{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"themes/landscape-plus/source/css/bdshare.styl","path":"css/bdshare.styl","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/img/scrollup.png","path":"img/scrollup.png","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"65055994f1a97aa5b66057151f13dadf628df63b","modified":1588264808000},{"_id":"source/favicon.ico","hash":"de3ec1762622ca41cf39d17af6e03a49529b069b","modified":1493631540000},{"_id":"source/manifest.json","hash":"66eba3b1b199e9cf57dfffe6ddf0e241a638713d","modified":1588262158000},{"_id":"source/sw.js","hash":"4eea73e1c7278fc272ac54e9f0611add2c9c2279","modified":1588262204000},{"_id":"themes/landscape-plus/.gitattributes","hash":"082442a106c29adb09669f321f984c1bf606f780","modified":1493204668000},{"_id":"themes/landscape-plus/.gitignore","hash":"b64fca798c2e9164bd1c9d8d641c4b2b22334da5","modified":1493204668000},{"_id":"themes/landscape-plus/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1493204668000},{"_id":"themes/landscape-plus/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1493204668000},{"_id":"themes/landscape-plus/README.md","hash":"3b370d9fc7e2c86d3e3e79d1b0eeeb2af461815f","modified":1493204668000},{"_id":"themes/landscape-plus/_config.yml","hash":"5c9a2feaccb148f18a88f9e97813aa9ca9fb15c7","modified":1639363623411},{"_id":"themes/landscape-plus/package.json","hash":"5deaa023c44f9f59f3df6e2a033a5fc2586797e6","modified":1493204668000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1595736140000},{"_id":"source/_posts/Angular的依赖注入.md","hash":"26067b526d9234aa5505d3f2a1451c32509e29af","modified":1493544666000},{"_id":"source/_posts/Canvas制作-撞球游戏-简单易学.md","hash":"c94e1baa2b3e314564c056dac389b75467931d85","modified":1554223956000},{"_id":"source/_posts/Canvas制作点赞送心动画.md","hash":"ef64e4f58f6195bc54de66da8668a1f7ef55666a","modified":1588263008000},{"_id":"source/_posts/Chrome插件之七牛云存储图片上传插件.md","hash":"572a5bf9776e14c290d2c12d7d93894338f729bc","modified":1554223946000},{"_id":"source/_posts/H5实现屏幕手势解锁.md","hash":"eec300c35203ba3e2b18939a74a9a55929c60c09","modified":1493349148000},{"_id":"source/_posts/H5视频直播扫盲.md","hash":"d3963c405cd72d504b95dfa5ad1b36f9700b08b0","modified":1554223800000},{"_id":"source/_posts/HTML5离线存储之Application-Cache.md","hash":"c5966bd618859faf099a44793377b80c4fcc8750","modified":1554223944000},{"_id":"source/_posts/HTTP-HTTP2-0-SPDY-HTTPS看这篇就够了.md","hash":"5af6eb28ed6807ffbf4055b60c05b1bf7e7d9e71","modified":1554223942000},{"_id":"source/_posts/HTTP2-Server-Push-研究.md","hash":"4fcbaeee7305d84feb49a543c3e5dc39aad2cd82","modified":1554223800000},{"_id":"source/_posts/HTTP2.0关于多路复用的研究.md","hash":"eac27f97927e31bdf555964696090e733a2415fa","modified":1554223798000},{"_id":"source/_posts/Javascript基本概念梳理.md","hash":"8a2caaac18cc69cd2a87d472a9a600354713d905","modified":1521532868000},{"_id":"source/_posts/PWA技术理论+实战.md","hash":"15852069418f9507c13f8f8daab5301bc8266491","modified":1595776270000},{"_id":"source/_posts/Proxy API--Vue3响应式对象reactive初探.md","hash":"905835d09ece433cacf7e3f822c7d541f49414ff","modified":1639150226000},{"_id":"source/_posts/React 16升级指南.md","hash":"5abd0b670e59fdb1d07022251342ff20ad923c92","modified":1554223796000},{"_id":"source/_posts/React Native IOS集成与原理简析.md","hash":"c58e1d55043e405186b28f162a550dc0d27439fb","modified":1554223792000},{"_id":"source/_posts/React Native Android 踩坑之旅.md","hash":"302676886a72141cd4dd9201bf201b84ba6f5e70","modified":1554223794000},{"_id":"source/_posts/React-Native下拉刷新组件react-native-pullRefreshScrollView.md","hash":"8e63e3f78112656a850c85dbf1d1c41656848050","modified":1493298756000},{"_id":"source/_posts/Tabs-Store保存你所有标签页的Chrome插件.md","hash":"73d94eea9307033849ccd8dbb87c3c57731d5951","modified":1554223940000},{"_id":"source/_posts/Vite与Vue Cli.md","hash":"9b34f3341d39eef10a78dd9b9f16e634f05e958d","modified":1639359148250},{"_id":"source/_posts/Vue.js Composition API.md","hash":"64d0a0519035e2c309d97032b88ddfcf1f67786d","modified":1639359143843},{"_id":"source/_posts/Vue3.0--Vue Composition API使用体验.md","hash":"ed6fb1ca969fdd4835691e1a137bc5c0cd6cf6f8","modified":1595736932000},{"_id":"source/_posts/Vue3源码解析--响应式原理.md","hash":"bb2e34e5f5cffb7b8ef13a9006de7d49b890b4f2","modified":1639359123778},{"_id":"source/_posts/Vue3源码解析--目录结构.md","hash":"909ebc4c2f2ec6764893e34a00838c134fda7eb5","modified":1639359127398},{"_id":"source/_posts/Vue3源码解析--虚拟DOM.md","hash":"2123db1e14366c8465c6326861dca3c75147d437","modified":1639359130692},{"_id":"source/_posts/Vue开发B端系统常见性能优化技巧.md","hash":"9abde59b2affb724ac3c7cd03db28a9ae65679f1","modified":1639152792000},{"_id":"source/_posts/Webpack1升级Webpack2整理总结.md","hash":"2efd4ff485fd2f75eecd17980c8ee8645de76fcd","modified":1588263024000},{"_id":"source/_posts/Web程序员学习iOS开发知识记录.md","hash":"78862fc89f4326441179beabd6d73b2cb5f91f95","modified":1493300108000},{"_id":"source/_posts/requireJS实现原理研究1.md","hash":"de87987e962c8c9503feac94c6e2a10ef2df10ff","modified":1493549212000},{"_id":"source/_posts/requireJS实现原理研究2.md","hash":"5658a1c7ac92a578983e99168285ab375ad7f7fd","modified":1493548712000},{"_id":"source/_posts/web前端性能优化之Html-Css-Javascript.md","hash":"36d0cec2d09679c1d1fb6f494c9619e7322918e3","modified":1493544308000},{"_id":"source/_posts/全屏滚动效果H5FullscreenPage-js测试版给力上线.md","hash":"0f608dc5847c6ded3ea1a81895c5a7ef815cb16b","modified":1639152468000},{"_id":"source/_posts/关于浏览器的工作原理.md","hash":"2f856becc7c08ef9f305c9ab0637ba6f59c7f4b6","modified":1554223938000},{"_id":"source/_posts/前端开发与架构师.md","hash":"709902e9f9a14339bdd662babdb97bc4ea85278c","modified":1595736962000},{"_id":"source/_posts/前端算法--二叉树遍历.md","hash":"e3d208877bb3bf674716d387c6e4c41941db2e96","modified":1639152752000},{"_id":"source/_posts/前端算法--回文串.md","hash":"3d35a9191a5d1662a968fee48666af49d3a62f7f","modified":1639152758000},{"_id":"source/_posts/前端算法--滑动窗口.md","hash":"91b5ec3d5fdefc9faa0feb1fc3fa7a691daf8ede","modified":1639152762000},{"_id":"source/_posts/前端算法--背包问题.md","hash":"95a3b27f00f073790fd7400d325314bf18ef82bd","modified":1639152764000},{"_id":"source/_posts/前端算法--迷宫问题.md","hash":"9ce6cc053e2ebebe13b57cfd98d49225a5bb9cda","modified":1639152774000},{"_id":"source/_posts/博客内容转移至慕课网手记,掘金,知乎专栏告知.md","hash":"7ab858cb23239e27084a9c3b7aa7c2d2f0d5ac8d","modified":1639362938660},{"_id":"source/_posts/号外！本博客已经全面升级HTTPS啦.md","hash":"d994b38ae87554e67ad0835ccc3cc0bca86c0b43","modified":1554223780000},{"_id":"source/_posts/吕小鸣博客搬家记.md","hash":"4d20db09879aab9a2d4f6097733ca28e4703a913","modified":1554223778000},{"_id":"source/_posts/微前端-最容易看懂的微前端知识.md","hash":"8604e1fb8792c806ad550f1d6d667b2888c958c6","modified":1639362930198},{"_id":"source/_posts/数据结构温习-排序算法.md","hash":"de4c89b6902e1769eced092621a5b00fa359e762","modified":1493552452000},{"_id":"source/_posts/最新React全家桶实战使用配置指南.md","hash":"613e00a632a50808b800a22d88c0c4476d4ba494","modified":1554223776000},{"_id":"source/_posts/百度分享HTTPS折腾记.md","hash":"7d25c28cd0881d599b051747a06c882199c52d72","modified":1554223774000},{"_id":"source/_posts/移动web之滚动篇.md","hash":"5b6a24102857d31c745114eec6e6100183be7a9b","modified":1554223772000},{"_id":"source/_posts/移动web开发实战课程.md","hash":"6e5b7492907e1fe5d2891e3ccedc599eaf5bfee3","modified":1554223768000},{"_id":"source/_posts/移动web日志查看工具.md","hash":"7cb21b4df0878bfabf66cc3ea48bf46a9be80036","modified":1554223950000},{"_id":"source/_posts/移动web性能优化从入门到进阶.md","hash":"6e96215032de7bd99498de02272176c8671bc4cf","modified":1551621236000},{"_id":"source/_posts/移动web适配之--vh,vw,vmin,vmax.md","hash":"8318ab7cabf421c0760aeceb4f4d6cec6d807d33","modified":1554223764000},{"_id":"source/_posts/移动web适配之rem.md","hash":"f55a7964683ea3406509f176ced5ca01322e043c","modified":1493299304000},{"_id":"source/_posts/移动web问题小结.md","hash":"343bcd577bed31fd2514f3d4b87f9d104b8e9186","modified":1639152494000},{"_id":"source/_posts/线条之美，玩转SVG线条动画.md","hash":"150785713eaa90240636b35debc69788c1e1971e","modified":1554223762000},{"_id":"source/about/index.md","hash":"c08f6b1c422dbd9298b24b30d1435ba543af7827","modified":1543329684000},{"_id":"source/exercise/index.md","hash":"d7a15070fdb2a33d12257e29bb49aec0da0c17e1","modified":1494145828000},{"_id":"themes/landscape-plus/languages/default.yml","hash":"0270b76db4c94f8905d4c0dc2303da5d5e756a19","modified":1493204668000},{"_id":"themes/landscape-plus/languages/zh-CN.yml","hash":"bab536eff019db1c8615a83e24e142105f397398","modified":1493204668000},{"_id":"themes/landscape-plus/languages/zh-TW.yml","hash":"1187826de31c687542e882835fc8062c2bc7a551","modified":1493204668000},{"_id":"themes/landscape-plus/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1493204668000},{"_id":"themes/landscape-plus/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1493204668000},{"_id":"themes/landscape-plus/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1493204668000},{"_id":"themes/landscape-plus/layout/layout.ejs","hash":"3626a74826657529bea744fb014dd9607e9834d0","modified":1493204668000},{"_id":"themes/landscape-plus/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1493204668000},{"_id":"themes/landscape-plus/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1493204668000},{"_id":"themes/landscape-plus/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1493204668000},{"_id":"themes/landscape-plus/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1493204668000},{"_id":"themes/landscape-plus/source/css/bdshare.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1493204668000},{"_id":"themes/landscape-plus/layout/_partial/after-footer.ejs","hash":"b628cdd7bd65755f1d228301cc3333e5aec77924","modified":1639364101154},{"_id":"themes/landscape-plus/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1493204668000},{"_id":"themes/landscape-plus/layout/_partial/archive.ejs","hash":"ff1e925ab5f512a89a7adb2c337f4bd021982154","modified":1493204668000},{"_id":"themes/landscape-plus/layout/_partial/article.ejs","hash":"34f878172d085050f5d30595d75e3af1acaf0ecd","modified":1639363407522},{"_id":"themes/landscape-plus/layout/_partial/footer.ejs","hash":"b0aec3fe694632dca7b6da32022b8d8218833ce7","modified":1588262414000},{"_id":"themes/landscape-plus/layout/_partial/google-analytics.ejs","hash":"78823298e9e47d8e6556fc2bb4598fc2814f2d52","modified":1493204668000},{"_id":"themes/landscape-plus/layout/_partial/head.ejs","hash":"d2716dcfac1f13d52aa3f68f6f6109b575c5c284","modified":1600528262000},{"_id":"themes/landscape-plus/layout/_partial/header.ejs","hash":"e9bd1af5969f641611251076b13d07002065b2aa","modified":1493204668000},{"_id":"themes/landscape-plus/layout/_partial/mathjax.ejs","hash":"204ed307e7b7cedb6d598b9ee14769b8d41180ca","modified":1493204668000},{"_id":"themes/landscape-plus/layout/_partial/mobile-nav.ejs","hash":"58648dc5920691a9cbc0d0a1b3b336f17480c9e8","modified":1493349294000},{"_id":"themes/landscape-plus/layout/_partial/sidebar.ejs","hash":"b90c252c1ac6c11630ae6dbdfe50381cedaf092e","modified":1600528648000},{"_id":"themes/landscape-plus/layout/_partial/totop.ejs","hash":"aa3a3eadf31d9b3e4d3081cd3ca61860e55ef553","modified":1493204668000},{"_id":"themes/landscape-plus/layout/_widget/archive.ejs","hash":"91d893dd184d3aa0e0c33025b76ac35e101b284b","modified":1493214950000},{"_id":"themes/landscape-plus/layout/_widget/category.ejs","hash":"4f6380fcc87a7ecb61829a0088a80ddd46e3d21e","modified":1493215182000},{"_id":"themes/landscape-plus/layout/_widget/links.ejs","hash":"ee400b1cd10946ca439b73a1e17bd14c18e512a9","modified":1493261086000},{"_id":"themes/landscape-plus/layout/_widget/recent_posts.ejs","hash":"e48be9faaed4cd85aec23fd1172b95781c5e7b29","modified":1493295592000},{"_id":"themes/landscape-plus/layout/_widget/tag.ejs","hash":"8ecaa9b2b9bb51f7b395e0a1c3636aa2da1b0334","modified":1493214978000},{"_id":"themes/landscape-plus/layout/_widget/tagcloud.ejs","hash":"36dfa6281421e60958cf1370521d271a511c3e57","modified":1493214994000},{"_id":"themes/landscape-plus/source/css/_extend.styl","hash":"3f8a9e4e63b7249408ac54559a5f9633d703e132","modified":1493204668000},{"_id":"themes/landscape-plus/source/css/_variables.styl","hash":"160cac8c46caba2525cae79286fd6e60110fbaed","modified":1493260530000},{"_id":"themes/landscape-plus/source/css/style.styl","hash":"1d60da58c7eb0b345bad37234497f5f9eba1ec03","modified":1639364205667},{"_id":"themes/landscape-plus/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1493204668000},{"_id":"themes/landscape-plus/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1493204668000},{"_id":"themes/landscape-plus/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1493204668000},{"_id":"themes/landscape-plus/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1493204668000},{"_id":"themes/landscape-plus/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1493204668000},{"_id":"themes/landscape-plus/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1493204668000},{"_id":"themes/landscape-plus/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1493204668000},{"_id":"themes/landscape-plus/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1493204668000},{"_id":"themes/landscape-plus/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1493204668000},{"_id":"themes/landscape-plus/source/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1493204668000},{"_id":"themes/landscape-plus/source/js/script.js","hash":"306d80a95aa441b567b7cc5b64c38defc8ef3597","modified":1498475602000},{"_id":"themes/landscape-plus/layout/_partial/post/nav.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1493264632000},{"_id":"themes/landscape-plus/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1493204668000},{"_id":"themes/landscape-plus/layout/_partial/post/category.ejs","hash":"be77c1c2a2836d079377da9dde2a6cf45c192cba","modified":1493206084000},{"_id":"themes/landscape-plus/layout/_partial/post/gallery.ejs","hash":"74ac818d2c6ed87994d343a907ddddc37c0e0249","modified":1493262368000},{"_id":"themes/landscape-plus/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1493204668000},{"_id":"themes/landscape-plus/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1493204668000},{"_id":"themes/landscape-plus/source/css/_partial/archive.styl","hash":"19b5af4e0969d93fb757577bd6ff380ef2224eb9","modified":1493204668000},{"_id":"themes/landscape-plus/source/css/_partial/article.styl","hash":"56b5d1c6efaebd4b1dbcf6e674d05eef7bb0b043","modified":1493729428000},{"_id":"themes/landscape-plus/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1493204668000},{"_id":"themes/landscape-plus/source/css/_partial/header.styl","hash":"d56dedcb668aceec7fe153fce46d741e406843f2","modified":1493640160000},{"_id":"themes/landscape-plus/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1493204668000},{"_id":"themes/landscape-plus/source/css/_partial/highlight.styl","hash":"d80b60045847867c6283f8339a426dd1eeac74e8","modified":1493574162000},{"_id":"themes/landscape-plus/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1493204668000},{"_id":"themes/landscape-plus/source/css/_partial/sidebar-aside.styl","hash":"77eade640d22eff33618c248f0b9d9a668a648bc","modified":1494910916000},{"_id":"themes/landscape-plus/source/css/_partial/sidebar.styl","hash":"50b5669098264b63a4f3a001c249eb398839135b","modified":1493628514000},{"_id":"themes/landscape-plus/source/css/_partial/sidebar-bottom.styl","hash":"bc5487b9a0bfe5f745423331824d3f3637ccd430","modified":1493215120000},{"_id":"themes/landscape-plus/source/css/_partial/totop.styl","hash":"817f36dd591d6beef9d41011ae8490d31d5e2e50","modified":1493204668000},{"_id":"themes/landscape-plus/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1493204668000},{"_id":"themes/landscape-plus/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1493204668000},{"_id":"themes/landscape-plus/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1493204668000},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1493204668000},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1493204668000},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1493204668000},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1493204668000},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1493204668000},{"_id":"themes/landscape-plus/source/css/fonts/FontAwesome.otf","hash":"6270a4a561a69fef5f5cc18cdf9efc256ec2ccbe","modified":1493204668000},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.eot","hash":"0183979056f0b87616cd99d5c54a48f3b771eee6","modified":1493204668000},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.woff","hash":"7d65e0227d0d7cdc1718119cd2a7dce0638f151c","modified":1493204668000},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.ttf","hash":"6225ccc4ec94d060f19efab97ca42d842845b949","modified":1493204668000},{"_id":"themes/landscape-plus/source/css/images/banner.jpg","hash":"843d9d47bf2b7b75495db11b3d765efaaae442a9","modified":1493204668000},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.svg","hash":"cd980eab6db5fa57db670cb2e4278e67e1a4d6c9","modified":1493204668000},{"_id":"public/manifest.json","hash":"66eba3b1b199e9cf57dfffe6ddf0e241a638713d","modified":1639364225671},{"_id":"public/sw.js","hash":"0df3b9adb07d77fb9dc1cd215317519eb06b9217","modified":1639364226307},{"_id":"public/about/index.html","hash":"81a6316985d124216dc49cb386c834d52ba9e381","modified":1639364226383},{"_id":"public/exercise/index.html","hash":"e4c144569b88b6ddab83bbc39c5a2cc91fe2c9fe","modified":1639364226383},{"_id":"public/index.php/archives/913/index.html","hash":"0cee9b547e224402c5c8431ecee215e9308b7192","modified":1639364226384},{"_id":"public/index.php/archives/1914/index.html","hash":"9c00ab0dbdbb67e852c1333151d32a6bc8152eb9","modified":1639364226384},{"_id":"public/index.php/archives/1201/index.html","hash":"f676267d675bbcc8fe15641102cf9c10b317f5c5","modified":1639364226384},{"_id":"public/index.php/archives/916/index.html","hash":"c5c3e24efa0b42e641fa9078eb4eb8567f434744","modified":1639364226384},{"_id":"public/index.php/archives/914/index.html","hash":"a86aeaaf88b66a5f5061232c4f8ecbb5a55b4872","modified":1639364226384},{"_id":"public/index.php/archives/12093/index.html","hash":"d1451bd67589c8ff15f5d7042f3de79366e80da5","modified":1639364226384},{"_id":"public/index.php/archives/12095/index.html","hash":"348870fbf7e050e126417682ad01050384601584","modified":1639364226384},{"_id":"public/index.php/archives/12097/index.html","hash":"c3761fd725d32b8f01371803fb1082a0e2cd930f","modified":1639364226384},{"_id":"public/index.php/archives/12091/index.html","hash":"6599032a41566e88b499fdd4ce9fe47a5c6f40f8","modified":1639364226384},{"_id":"public/index.php/archives/919/index.html","hash":"d80b6bc1ddc9783e21ff3f87e1e658f102d08247","modified":1639364226384},{"_id":"public/index.php/archives/12092/index.html","hash":"d08a7a5323e983cde3fc2d17fea24d5399146bd6","modified":1639364226384},{"_id":"public/index.php/archives/1120/index.html","hash":"175c22864898af271adca25932fffdf035565d60","modified":1639364226384},{"_id":"public/index.php/archives/1209/index.html","hash":"690f70d76d6e214e736b8b4e1b79c5c2d572c362","modified":1639364226385},{"_id":"public/index.php/archives/1210/index.html","hash":"910efcfdf5477ad71138564d1184f993ff7c587d","modified":1639364226385},{"_id":"public/index.php/archives/1110/index.html","hash":"54c56e32067cd8d010f8bb4914a119564461143b","modified":1639364226385},{"_id":"public/index.php/archives/1100/index.html","hash":"c377ecf7c144a00b8410590cc32683e1ac78a94a","modified":1639364226385},{"_id":"public/index.php/archives/795/index.html","hash":"ffe28b21ec5363d1bc8e8e5191ded7fe469a7ec5","modified":1639364226385},{"_id":"public/index.php/archives/1111/index.html","hash":"6f0be857a4c50359efe96c6ddcce1f2a46fdeca5","modified":1639364226385},{"_id":"public/index.php/archives/793/index.html","hash":"dee800632080af7ae10ce6f7f6b41ecf101c3b85","modified":1639364226385},{"_id":"public/index.php/archives/888/index.html","hash":"50cc05429490be234830fe7791bd9a4280282a3d","modified":1639364226385},{"_id":"public/index.php/archives/802/index.html","hash":"ae338bcdfd005fed38877088f90cd188ea76e362","modified":1639364226385},{"_id":"public/index.php/archives/788/index.html","hash":"01dd4e1188b0069f3e852e2ca58f99758dc033e0","modified":1639364226385},{"_id":"public/index.php/archives/703/index.html","hash":"b5724888b36ca9d4a367832d7bcb6b1fe628e085","modified":1639364226385},{"_id":"public/index.php/archives/702/index.html","hash":"8b07218390da2a21f12a077d0643203c48c9ba24","modified":1639364226385},{"_id":"public/index.php/archives/701/index.html","hash":"5184bd7e8946b00a19c4a50dc7cec7fe1148e84b","modified":1639364226386},{"_id":"public/index.php/archives/700/index.html","hash":"ba9c3ee9f5b7b5ce907df769ce3ce6037b6fb1e5","modified":1639364226386},{"_id":"public/index.php/archives/698/index.html","hash":"3de12b9c1d85bd756f4eff0b159951a5ae3ffcce","modified":1639364226386},{"_id":"public/index.php/archives/690/index.html","hash":"a5e50721f17358b653ccae346a19e23472391251","modified":1639364226386},{"_id":"public/index.php/archives/667/index.html","hash":"a6d06c256ee36baf1fd8517562b4c5923c27fcf1","modified":1639364226386},{"_id":"public/index.php/archives/651/index.html","hash":"ee18912145fe6145ffa2aa51de0d1bee83334563","modified":1639364226386},{"_id":"public/index.php/archives/646/index.html","hash":"c2fe87796dd7ae9aabd13109c08feafa59720446","modified":1639364226386},{"_id":"public/index.php/archives/630/index.html","hash":"610ac9cf74e341a45c0c8f08e0429e61146ef1d8","modified":1639364226386},{"_id":"public/index.php/archives/615/index.html","hash":"b2dff3a3d1e1e35692954c38acf3695fbdb9ef68","modified":1639364226386},{"_id":"public/index.php/archives/610/index.html","hash":"7f105c10b17642b7cba42d05638a13788c1de8ac","modified":1639364226386},{"_id":"public/index.php/archives/593/index.html","hash":"e546abf4641319a60958f13f10186b55cc6cb34d","modified":1639364226386},{"_id":"public/index.php/archives/578/index.html","hash":"2b6d896ff795ef27150633d61e24334c87ea68e6","modified":1639364226386},{"_id":"public/index.php/archives/568/index.html","hash":"a66e40812a0adc53dd7efe21fbb1491a2951f4ce","modified":1639364226387},{"_id":"public/index.php/archives/560/index.html","hash":"2eff4e2ff2f2d5a399a09f9952cc6abbd1d0c532","modified":1639364226387},{"_id":"public/index.php/archives/550/index.html","hash":"6fa1e9cb7de6cd541c200d102a452525336ad774","modified":1639364226387},{"_id":"public/index.php/archives/537/index.html","hash":"9630c21d22e1d02b10f2f759ceaf81248ea524c4","modified":1639364226387},{"_id":"public/index.php/archives/530/index.html","hash":"ee2f045f73cde32e6a1b9b8ddb4538b0b0712348","modified":1639364226387},{"_id":"public/index.php/archives/455/index.html","hash":"eeaabe17a34621c260b65a987750a79e87716a8f","modified":1639364226387},{"_id":"public/index.php/archives/447/index.html","hash":"ad2c315dc593f89c8852beb685452e60f9701332","modified":1639364226387},{"_id":"public/index.php/archives/425/index.html","hash":"7411035489da208e6e35dd7a6698e4a7620f8b71","modified":1639364226387},{"_id":"public/index.php/archives/422/index.html","hash":"9f39d68441ea259be06daafd9767d405f11c8e92","modified":1639364226387},{"_id":"public/index.php/archives/381/index.html","hash":"60ca952e909f37cf8b9a42cd59ab901b8db452d8","modified":1639364226387},{"_id":"public/index.php/archives/390/index.html","hash":"25ba74bdf4e77955688d8a29e7a0d00795a79c4c","modified":1639364226387},{"_id":"public/index.php/archives/341/index.html","hash":"797a01647a5391906cfbca2e7bb65946d0e53682","modified":1639364226388},{"_id":"public/index.php/archives/326/index.html","hash":"1b049d2d8aca90d086304267e91ba74823b0f2a1","modified":1639364226388},{"_id":"public/index.php/archives/322/index.html","hash":"1baa41e9f432ce9c527f609466cc468df8aea060","modified":1639364226388},{"_id":"public/index.php/archives/149/index.html","hash":"1cfa7a9300630e8fe353dcdac106abdede7a4240","modified":1639364226388},{"_id":"public/index.php/archives/126/index.html","hash":"c879d1f467d79f5836e49963c7c0c888625b11ba","modified":1639364226388},{"_id":"public/index.php/archives/115/index.html","hash":"7d5a871072ba9d01dde3aacf177e43c234953fa7","modified":1639364226388},{"_id":"public/categories/341/index.html","hash":"e99a93134913ff630b70797b87c8992b1c640677","modified":1639364226388},{"_id":"public/categories/115/index.html","hash":"5f29ed55ed8c0246a01f959173126351b3e9b5d8","modified":1639364226388},{"_id":"public/categories/802/index.html","hash":"699a2f882c13f8bc9e886cfe73e17b0648680e96","modified":1639364226388},{"_id":"public/categories/422/index.html","hash":"35407ae64c6f2e2ce34be2ddf7b7dcc999593263","modified":1639364226388},{"_id":"public/categories/537/index.html","hash":"11ff2b12412358eeb054e00523ee4f3c5eecfcbe","modified":1639364226388},{"_id":"public/categories/615/index.html","hash":"1e5b4e5cd464c5135036a7b583ecd55e286c6ede","modified":1639364226388},{"_id":"public/categories/425/index.html","hash":"6d555d1fb34e1bf49069ca0ca12041b956d39a7e","modified":1639364226388},{"_id":"public/categories/630/index.html","hash":"26285e1e9f52140ec2298649203b4e6e90eec820","modified":1639364226388},{"_id":"public/categories/651/index.html","hash":"0c982794d3c10c9cea250f7fc22e3b50c678818b","modified":1639364226388},{"_id":"public/categories/698/index.html","hash":"161fb36d800e0d95d37d36f5781d331f2ecc46dc","modified":1639364226389},{"_id":"public/categories/149/index.html","hash":"e227bd594481c81faad29ef6113abedc150ce59f","modified":1639364226389},{"_id":"public/categories/1120/index.html","hash":"4c715afa3626cfa0811562df8715e029ded0bafd","modified":1639364226389},{"_id":"public/categories/1209/index.html","hash":"24c59221c2951eb4ee84e110a256fd2414e2f94d","modified":1639364226389},{"_id":"public/categories/703/index.html","hash":"7033fbcd755802f934d11a4fac403b03a8b84ca1","modified":1639364226389},{"_id":"public/categories/550/index.html","hash":"493b23ae271f241422de6500bf991dcd554d07a1","modified":1639364226389},{"_id":"public/categories/560/index.html","hash":"e1925eaa0e9f82e1de0056fbace6ee23c45b45b1","modified":1639364226389},{"_id":"public/categories/610/index.html","hash":"fa5e371ade94cb8ab9f05a6f9a189fce5e23cc0a","modified":1639364226389},{"_id":"public/categories/326/index.html","hash":"3984c107c43454aa89c9f92151a9d68bc9a67ff2","modified":1639364226389},{"_id":"public/categories/1914/index.html","hash":"35192cb06c028dab2314d12eac4bb66fd28b0d05","modified":1639364226389},{"_id":"public/categories/1201/index.html","hash":"ff37c85a8178f5e8a09533ff8ebf634d3a8cba3f","modified":1639364226389},{"_id":"public/categories/1210/index.html","hash":"f483a166e4a4c3d1e16f15be9fbeab7866c4e1de","modified":1639364226389},{"_id":"public/categories/914/index.html","hash":"7bc924d9a4cacd7ee7188f9d767b1e72d94701de","modified":1639364226389},{"_id":"public/categories/913/index.html","hash":"0f2b53ca79e3e0cca3177445d41a7163e02ec074","modified":1639364226389},{"_id":"public/categories/916/index.html","hash":"486076bc6f1dc59ae289d341115f790584ceb39f","modified":1639364226389},{"_id":"public/categories/919/index.html","hash":"b9ec2ef9eca54e7fe6cc2069abde2600261e2483","modified":1639364226390},{"_id":"public/categories/702/index.html","hash":"4f305ba5cf1d30c5d3975df8a53746c4cd32f1f7","modified":1639364226390},{"_id":"public/categories/578/index.html","hash":"6954fb8b45f77533fc42b6727c0c83ac2b67bf1c","modified":1639364226390},{"_id":"public/categories/381/index.html","hash":"2e84737a1ce100c28039982bd05fc6f0e8da44ae","modified":1639364226390},{"_id":"public/categories/390/index.html","hash":"a8f23aa582dd5863dcd3eff26f6b248e215350d2","modified":1639364226390},{"_id":"public/categories/447/index.html","hash":"dd62fdc92c8d104026ec2c16fd68494ca77a65b3","modified":1639364226390},{"_id":"public/categories/530/index.html","hash":"0b9b1b2ed9d4b0080222e583d66c3c2f9451de75","modified":1639364226390},{"_id":"public/categories/322/index.html","hash":"5a5ca559f399cead976d1e4b1484479f6408aea0","modified":1639364226390},{"_id":"public/categories/1110/index.html","hash":"b3bc59fffb9893410b8cddd07454dce11516dd85","modified":1639364226390},{"_id":"public/categories/12092/index.html","hash":"ae44a808df3dcdc5d64aef8fdccb24927cba19b0","modified":1639364226390},{"_id":"public/categories/12091/index.html","hash":"307b97e4cbb8a53e95a50904cdd8c29d5b1575ae","modified":1639364226391},{"_id":"public/categories/12093/index.html","hash":"e3006d690e069dec2cbf8f182e25b40dd377a527","modified":1639364226391},{"_id":"public/categories/12095/index.html","hash":"14f7aff9844306978960267a30bb369fd8eb3532","modified":1639364226391},{"_id":"public/categories/12097/index.html","hash":"8821701c51b1f90e6c3060902ce026101815dd6a","modified":1639364226391},{"_id":"public/categories/1111/index.html","hash":"e422d20c7f79fa15710e5ca84d8e6bf8fa245bce","modified":1639364226391},{"_id":"public/categories/646/index.html","hash":"01b471ec59e3e229c0180a9507d93decc1770cf1","modified":1639364226391},{"_id":"public/categories/700/index.html","hash":"0110052748d36cd0bce84a6a3ff6857cb28490d9","modified":1639364226391},{"_id":"public/categories/1100/index.html","hash":"f95431913d40e7611a0f8fb671ca43b55ebaeb1d","modified":1639364226391},{"_id":"public/categories/126/index.html","hash":"9d8dbb8e57cd4fab1336a415c1ea765baed29cdf","modified":1639364226391},{"_id":"public/categories/701/index.html","hash":"8c4ec650260cfc9080c8ba692f431183d9c0934d","modified":1639364226391},{"_id":"public/categories/793/index.html","hash":"c7a4b53d9024c240ce8eceabbee946d6ffc75a66","modified":1639364226391},{"_id":"public/categories/690/index.html","hash":"68c2a5e5ccc38ced97417dd70a41fabbfea2c999","modified":1639364226391},{"_id":"public/categories/888/index.html","hash":"87f00991bcb992cca02e46a5f1b679c372e6aa04","modified":1639364226391},{"_id":"public/categories/568/index.html","hash":"744ddb48be459ded583c08aff818f482573eacf5","modified":1639364226391},{"_id":"public/categories/788/index.html","hash":"b0a14335c91ec274d4a05fc3dc81838da5d54902","modified":1639364226391},{"_id":"public/categories/593/index.html","hash":"6730483e916ca39b41d51c008d09a0cf784b5e97","modified":1639364226391},{"_id":"public/categories/455/index.html","hash":"7440e1c3225828562cb6bddad4d24fc29b9f59d0","modified":1639364226392},{"_id":"public/categories/795/index.html","hash":"ad9a7906dc3e2381017fa7c6940e6901da71efca","modified":1639364226392},{"_id":"public/categories/667/index.html","hash":"d26b532a3bd90f5616cadc4688a76f64799768e5","modified":1639364226392},{"_id":"public/index.html","hash":"e666da79ea8a1d3e3bb111a582ef4071b9e192a8","modified":1639364226392},{"_id":"public/page/2/index.html","hash":"2a71c6ec90a0cf4236833cc246544936128824f1","modified":1639364226392},{"_id":"public/page/3/index.html","hash":"ab78e81d1d54ddee8c8b2dd7bb527322792fdf78","modified":1639364226392},{"_id":"public/page/4/index.html","hash":"a37a8a68568faaae829ac2b04d50911c1706f0ab","modified":1639364226392},{"_id":"public/page/5/index.html","hash":"b1d0fd3deb8163e06a14d1f4a5efbea4bfc72201","modified":1639364226392},{"_id":"public/page/6/index.html","hash":"3cf942a14721a973b3ffcc92a5ad35689ee2cc0b","modified":1639364226392},{"_id":"public/archives/index.html","hash":"7778d2b4793b6d6780c1092753dd2f295b9d72d7","modified":1639364226392},{"_id":"public/archives/page/2/index.html","hash":"e0f35cb1ccbd9d1d35e91f27d8229da5e63b1238","modified":1639364226393},{"_id":"public/archives/page/3/index.html","hash":"4a29bc87497b0df5e393d670f006f75525a3b10f","modified":1639364226393},{"_id":"public/archives/page/4/index.html","hash":"a10706032fe81c71cb3376a42f8511c66620149f","modified":1639364226393},{"_id":"public/archives/page/5/index.html","hash":"2ac9b87d948058e252332ea44dd8b1023d03bbe1","modified":1639364226393},{"_id":"public/archives/page/6/index.html","hash":"428151aa507953d897a41a03d5b95f366bb79f2f","modified":1639364226393},{"_id":"public/archives/2014/index.html","hash":"a0d949225dc638858c2f3972b2e678bad0adb1d1","modified":1639364226393},{"_id":"public/archives/2014/page/2/index.html","hash":"652d4b879d5dd4dcb1aa6c67c555c533e34646b9","modified":1639364226393},{"_id":"public/archives/2014/06/index.html","hash":"c33fa556ba4dfe8ae7c22103f75a204ce061b7a7","modified":1639364226393},{"_id":"public/archives/2014/07/index.html","hash":"3be10b19dab1bd3570db777448e960387a4a4994","modified":1639364226393},{"_id":"public/archives/2014/08/index.html","hash":"c93536a307c537e9c4db1d056240bb7ebddd45ce","modified":1639364226393},{"_id":"public/archives/2014/09/index.html","hash":"6c82cdf00d0d92a1797f6e28b84ea5c403aeb1f3","modified":1639364226393},{"_id":"public/archives/2014/10/index.html","hash":"7f03ea9329b7e11f35f67dad1c6492c4e8eb7a32","modified":1639364226393},{"_id":"public/archives/2015/index.html","hash":"e8169bbfcb92c3ecef6ef1855f354bee0167d823","modified":1639364226393},{"_id":"public/archives/2015/05/index.html","hash":"bec643da6ce3c7579ecd07ba0c72618a77e7a207","modified":1639364226393},{"_id":"public/archives/2015/07/index.html","hash":"4d80256b88f21f7f3abe26316678d129bffe33f8","modified":1639364226394},{"_id":"public/archives/2015/10/index.html","hash":"dde862774700edb1ed4ed40dc4b46e572e5585ab","modified":1639364226394},{"_id":"public/archives/2015/12/index.html","hash":"17af94c28bc9ca5b8ac112b303c4234a6b26c87d","modified":1639364226395},{"_id":"public/archives/2016/index.html","hash":"f7c06af21acaf76d587c324ffc55d4fb7319484b","modified":1639364226395},{"_id":"public/archives/2016/01/index.html","hash":"97c656c86ae8218c0388bd6bf862918c42182ede","modified":1639364226395},{"_id":"public/archives/2016/03/index.html","hash":"47e50dd62aba4a87c630dbdd3ce891ab8075f835","modified":1639364226395},{"_id":"public/archives/2016/05/index.html","hash":"64f651a1ce81494d8c0e75d449e0d29ee945b9b7","modified":1639364226395},{"_id":"public/archives/2016/07/index.html","hash":"f35c5678f52bc50e7501a17d4b0b364e4d7b567f","modified":1639364226395},{"_id":"public/archives/2016/11/index.html","hash":"dcaf7efe6431082634d60b4bbd031e46cb1a913b","modified":1639364226395},{"_id":"public/archives/2017/index.html","hash":"4ea90503e44b8462c1b07cf428fe11692ba1c208","modified":1639364226395},{"_id":"public/archives/2017/02/index.html","hash":"21085ed5c45b7efaf927e9c2261e218c06ad4282","modified":1639364226395},{"_id":"public/archives/2017/04/index.html","hash":"f1271e8ddf46c1eed3710a1a766bc84db207c806","modified":1639364226395},{"_id":"public/archives/2017/05/index.html","hash":"848dc36da882a8db754f16bf2f3fadd7038cb915","modified":1639364226397},{"_id":"public/archives/2017/06/index.html","hash":"15d60a0a7bef88edb3940bd45c09c452ad859ff5","modified":1639364226397},{"_id":"public/archives/2017/07/index.html","hash":"1f77c9b0bac64988d43d74e94992d107488dbe16","modified":1639364226397},{"_id":"public/archives/2018/index.html","hash":"5ddec47cf94a1926bbd66dd27f2c0b8491901c93","modified":1639364226397},{"_id":"public/archives/2018/01/index.html","hash":"f38d9b737f21650eae28be7ea20574d76a839df5","modified":1639364226397},{"_id":"public/archives/2018/04/index.html","hash":"90b242add9d9944cee4a51b932bf89a6e1e24029","modified":1639364226397},{"_id":"public/archives/2018/06/index.html","hash":"4c6407736b9b36949620a4880933076595ec9090","modified":1639364226397},{"_id":"public/archives/2018/07/index.html","hash":"ecff95dfa69da9e38b87b24ff8858b5dcf4e4a40","modified":1639364226397},{"_id":"public/archives/2018/10/index.html","hash":"a5ed70da3828428cde6c1510c657804081dd7e08","modified":1639364226397},{"_id":"public/archives/2019/index.html","hash":"f333f63aafe8cb8291f4133b5f05682ef49c6288","modified":1639364226398},{"_id":"public/archives/2019/03/index.html","hash":"e149ab515e055e5c685ea90c9f3c7ef3020e3d6f","modified":1639364226398},{"_id":"public/archives/2020/index.html","hash":"b125073eb9c18c8cb61624ed3b4ba6538ab12b5e","modified":1639364226398},{"_id":"public/archives/2020/03/index.html","hash":"dd850c9bf6d965513ed8dfaa3914aec6d978c123","modified":1639364226398},{"_id":"public/archives/2020/05/index.html","hash":"e43c6cffa35ac35ec022550c20f3b10582d0e549","modified":1639364226398},{"_id":"public/archives/2021/index.html","hash":"956ab04acc6f962b87c40e9ced3fb953f879e3a2","modified":1639364226398},{"_id":"public/archives/2021/page/2/index.html","hash":"471e7044a8ea6e1b2e2667da027b46187958fd11","modified":1639364226398},{"_id":"public/archives/2021/02/index.html","hash":"c2a9a54e991d59de982829f4587da408b6b12bfb","modified":1639364226398},{"_id":"public/archives/2021/04/index.html","hash":"19579b66c716884639678512d9f9042ea4d35779","modified":1639364226398},{"_id":"public/archives/2021/05/index.html","hash":"8a826a6e0c38c4e69ea11cba4fd402df6861407e","modified":1639364226398},{"_id":"public/archives/2021/07/index.html","hash":"6b36a2f432c9d65296e19b90ec95f94d144e3504","modified":1639364226398},{"_id":"public/archives/2021/08/index.html","hash":"5e260e0d74561c0cb5533673f722fa607c18cb33","modified":1639364226398},{"_id":"public/archives/2021/09/index.html","hash":"20a5a44299565ab3605e8aed1af681a9ebb1b21b","modified":1639364226398},{"_id":"public/archives/2021/11/index.html","hash":"bb1e235efbc1c59fc2f9b327330128ee9594255e","modified":1639364226398},{"_id":"public/archives/2021/12/index.html","hash":"a197c22260071690ac14567979a0f570950e2541","modified":1639364226398},{"_id":"public/tags/Angular/index.html","hash":"5c568b3e9e61f5e59534fdec714aadfa0c5b8c7c","modified":1639364226398},{"_id":"public/tags/HTML5游戏/index.html","hash":"72fc590429af6e82a1a772276d95e672725e7596","modified":1639364226398},{"_id":"public/tags/canvas/index.html","hash":"d9742ee7eca927d276868dbd5d36bd649d282392","modified":1639364226398},{"_id":"public/tags/点赞/index.html","hash":"ffe2774572c09dd1e4f1741777e6236ee6359138","modified":1639364226398},{"_id":"public/tags/chrome插件/index.html","hash":"85498245b504981ccf2120381f108ee1d5e56145","modified":1639364226399},{"_id":"public/tags/手势解锁/index.html","hash":"ee26471848aa1770ef7653d237c6f61fabb1848e","modified":1639364226399},{"_id":"public/tags/HTML5/index.html","hash":"b71feecc8ad06ef51db735c8cc4d887b6d458563","modified":1639364226399},{"_id":"public/tags/视频直播/index.html","hash":"61277006d2774fd2293d2510a9581218090b452e","modified":1639364226399},{"_id":"public/tags/离线存储/index.html","hash":"9f10de30a0b8c4f721f30336e9e25163a79a0adb","modified":1639364226399},{"_id":"public/tags/http2/index.html","hash":"8f5d680c500a166e39de5b95d5de6a27b9a54b22","modified":1639364226399},{"_id":"public/tags/https/index.html","hash":"b39dd30673fddc868586f215880ae9276f1ddf84","modified":1639364226399},{"_id":"public/tags/javascript/index.html","hash":"b25f31ff6900608ec001466ac2329da7596e35ca","modified":1639364226399},{"_id":"public/tags/面试/index.html","hash":"3938bbaa099a66e0f0caf0ce6aa94c46650e7158","modified":1639364226399},{"_id":"public/tags/PWA/index.html","hash":"60a71d323d95fb699491496c8035a2c91a9bad96","modified":1639364226399},{"_id":"public/tags/前端/index.html","hash":"e7d62c0fd118bb9dd0148b5bbc448ee02d7ebe54","modified":1639364226399},{"_id":"public/tags/Vue3/index.html","hash":"fe14f89149bf2938196d8df656a492e824881801","modified":1639364226399},{"_id":"public/tags/Vue-js/index.html","hash":"4b909ad1a223f98b28f1fe38c2e64aac087f2c97","modified":1639364226399},{"_id":"public/tags/react16-升级/index.html","hash":"065eb56667cd3bc5519f510eb37022a9b42da428","modified":1639364226399},{"_id":"public/tags/React-Native/index.html","hash":"31ab613e3ebd3af3b7f1f81df4c3ddcb3003aa43","modified":1639364226399},{"_id":"public/tags/android/index.html","hash":"231f7209d6b9961dcddbaa8dc755791834dd5e46","modified":1639364226399},{"_id":"public/tags/下拉刷新/index.html","hash":"c676a1e6133c8b88e9a3b85695316f3eace69fab","modified":1639364226399},{"_id":"public/tags/vue3/index.html","hash":"097b4617a17f165148c7e84de5dc281bc730acfc","modified":1639364226400},{"_id":"public/tags/Composition-API/index.html","hash":"9d497b8118dde2b206e1df7af855d45725f536a2","modified":1639364226400},{"_id":"public/tags/Vite/index.html","hash":"12b7173c1bce1bd868064d88886ac14e7671debc","modified":1639364226400},{"_id":"public/tags/Vue-Cli/index.html","hash":"1fdd523dc26090c7db3fb69c56a0a8696dd1e337","modified":1639364226400},{"_id":"public/tags/源码解析/index.html","hash":"0eaff52363925a4428a1a7135fc9f24eb33075ce","modified":1639364226400},{"_id":"public/tags/Vue/index.html","hash":"0e175df34fa38326edba3d09af382c8148db0e63","modified":1639364226400},{"_id":"public/tags/B端系统/index.html","hash":"a34acec6c799f48d61c41f1e2f454ba75c19f06d","modified":1639364226400},{"_id":"public/tags/webpack2/index.html","hash":"afe20a73149673b6c4cef505a9978557bbd6312e","modified":1639364226400},{"_id":"public/tags/升级/index.html","hash":"238f4eb0cbd33797c63f8ba2d06e4d512c70a55f","modified":1639364226400},{"_id":"public/tags/ios/index.html","hash":"78529367655075211cc5ab48bf20d6adff362412","modified":1639364226400},{"_id":"public/tags/requirejs/index.html","hash":"49870f5dd10b93be5a6836b8fa84d0f87bd69531","modified":1639364226400},{"_id":"public/tags/css动画/index.html","hash":"01cce46326879bb56bb3fca3e47d3457afa38a31","modified":1639364226400},{"_id":"public/tags/全屏滚动/index.html","hash":"c5d7b137299b0b1f14490ee3b569c52e73c3b9d7","modified":1639364226400},{"_id":"public/tags/移动web/index.html","hash":"a54340f414f3c1547c81dba6d80be49fcac6ec1b","modified":1639364226400},{"_id":"public/tags/性能优化/index.html","hash":"65bb8dc5e7cbe7845380901efe9b910535941cd9","modified":1639364226400},{"_id":"public/tags/浏览器/index.html","hash":"6e656b17857326f011b26419a0157c2f57032d6e","modified":1639364226400},{"_id":"public/tags/架构师/index.html","hash":"de2d55f3d93adb5d024d59d5d7d089636bb9d477","modified":1639364226400},{"_id":"public/tags/算法/index.html","hash":"e157c57a4c88482559e6be88ade7c7dce6bf9afb","modified":1639364226400},{"_id":"public/tags/二叉树遍历/index.html","hash":"a43f28de58edd8d2bdcd82060fcc976ee8d7bfa8","modified":1639364226401},{"_id":"public/tags/回文串/index.html","hash":"aa978cc2c619523212fafc02d7418b5911de7233","modified":1639364226401},{"_id":"public/tags/滑动窗口/index.html","hash":"3acad9e6c90afaead24b938c661d48563e1e0ff8","modified":1639364226401},{"_id":"public/tags/背包问题/index.html","hash":"4e3b8480b05af1b55495de37a469f443a5a3a9ec","modified":1639364226401},{"_id":"public/tags/迷宫问题/index.html","hash":"baaa08a1c49b0c317e1aa9199530d90e34f4e6c0","modified":1639364226401},{"_id":"public/tags/专栏/index.html","hash":"2c55ade2fc550846cade2b24511a39c4708df8ab","modified":1639364226401},{"_id":"public/tags/博客搬家/index.html","hash":"cfffcf0e2a56d806d05a9a0948a4fd9111809ab2","modified":1639364226401},{"_id":"public/tags/hexo/index.html","hash":"a0630a33bbbe5d8c043f1836fde9d96e16f6e500","modified":1639364226401},{"_id":"public/tags/wordpress/index.html","hash":"df910f554f20eda7f5d1b7f48be0928479a92a87","modified":1639364226401},{"_id":"public/tags/微前端/index.html","hash":"4e424d706f623e9ce0be10a281b511eef66aef33","modified":1639364226401},{"_id":"public/tags/数据结构/index.html","hash":"e2e9dfdf1bc60a7d32bc3e3b2fad4c1c2c9dfae4","modified":1639364226401},{"_id":"public/tags/bdshare/index.html","hash":"450ae82d46f320c74a84b6a4ecce65aa1d2efd56","modified":1639364226401},{"_id":"public/tags/react/index.html","hash":"ef924d008328ec3cd5b0179aed5a7f984c345225","modified":1639364226401},{"_id":"public/tags/react全家桶/index.html","hash":"f739d9ff39e6930bd0529ea67685e2177802a1d3","modified":1639364226401},{"_id":"public/tags/配置指南/index.html","hash":"fb35c78f84a0876ece923862f893002f39744a10","modified":1639364226401},{"_id":"public/tags/滚动/index.html","hash":"f2b79826f15a148b96dc6af586094297354054bf","modified":1639364226401},{"_id":"public/tags/React全家桶/index.html","hash":"8fae51e53ef6300a20d5413d583eaed2f0d32c5a","modified":1639364226401},{"_id":"public/tags/工具/index.html","hash":"8c54ab22f372ff2fbbc2f02e80a17973d4457da1","modified":1639364226401},{"_id":"public/tags/移动web适配/index.html","hash":"a3f369bef8cf2620beb88cafa50299ccdbc1b309","modified":1639364226402},{"_id":"public/tags/vmin/index.html","hash":"09a15e6b604c2bf292775dd6969437139b63c174","modified":1639364226402},{"_id":"public/tags/rem/index.html","hash":"b587dcf0d7007b0f91c79d44d2b936ecaa8c5081","modified":1639364226402},{"_id":"public/tags/svg/index.html","hash":"786a6727300aaf4f18178ea8989da059b3b25691","modified":1639364226402},{"_id":"public/favicon.ico","hash":"de3ec1762622ca41cf39d17af6e03a49529b069b","modified":1639364226419},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1639364226419},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1639364226419},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1639364226419},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1639364226419},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1639364226419},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1639364226419},{"_id":"public/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1639364226419},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1639364226419},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"0183979056f0b87616cd99d5c54a48f3b771eee6","modified":1639364226419},{"_id":"public/css/fonts/FontAwesome.otf","hash":"6270a4a561a69fef5f5cc18cdf9efc256ec2ccbe","modified":1639364226922},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"7d65e0227d0d7cdc1718119cd2a7dce0638f151c","modified":1639364226924},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"6225ccc4ec94d060f19efab97ca42d842845b949","modified":1639364226924},{"_id":"public/css/bdshare.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1639364226932},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1639364226932},{"_id":"public/js/script.js","hash":"306d80a95aa441b567b7cc5b64c38defc8ef3597","modified":1639364226932},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1639364226933},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1639364226933},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1639364226933},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1639364226933},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1639364226933},{"_id":"public/css/style.css","hash":"ba19e3a9b0e0aa7eb2d22a2889e25ae155e32a88","modified":1639364226933},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1639364226933},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1639364226933},{"_id":"public/css/images/banner.jpg","hash":"843d9d47bf2b7b75495db11b3d765efaaae442a9","modified":1639364228345},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"cd980eab6db5fa57db670cb2e4278e67e1a4d6c9","modified":1639364228345}],"Category":[{"name":"341","_id":"ckx434pzc00062wvjq78xnvxh"},{"name":"115","_id":"ckx434pzk000b2wvjnviir5qh"},{"name":"802","_id":"ckx434pzq000h2wvjeahh6g6j"},{"name":"422","_id":"ckx434pzu000n2wvjduf44mor"},{"name":"537","_id":"ckx434pzy000s2wvjgcu8usje"},{"name":"615","_id":"ckx434q0200102wvjh1uuywhy"},{"name":"425","_id":"ckx434q0500162wvjpiic6vfz"},{"name":"630","_id":"ckx434q08001b2wvj7q7ygyje"},{"name":"651","_id":"ckx434q0b001i2wvj2fetaoz0"},{"name":"698","_id":"ckx434q0h001q2wvjfjxc685o"},{"name":"149","_id":"ckx434q0l001x2wvj0zwhy0hj"},{"name":"1120","_id":"ckx434q0n00222wvj5p2suucp"},{"name":"1209","_id":"ckx434q0q00292wvjktyfkdon"},{"name":"703","_id":"ckx434q0v002f2wvj15rodmh4"},{"name":"550","_id":"ckx434q0y002m2wvjw2dc3um3"},{"name":"560","_id":"ckx434q11002t2wvjleg1f5z3"},{"name":"610","_id":"ckx434q14002y2wvjv9kv9iec"},{"name":"326","_id":"ckx434q1800352wvjh65vp6bh"},{"name":"1914","_id":"ckx434q1d003c2wvja2xhuhyf"},{"name":"1201","_id":"ckx434q1g003i2wvj4ywoxett"},{"name":"1210","_id":"ckx434q1j003o2wvjbnsm797o"},{"name":"914","_id":"ckx434q1p003v2wvj4b4puxzc"},{"name":"913","_id":"ckx434q1w00422wvjku664b2f"},{"name":"916","_id":"ckx434q1y00462wvjjx0wek6c"},{"name":"919","_id":"ckx434q1z004a2wvjez72xxip"},{"name":"702","_id":"ckx434q20004f2wvjgtr0omq3"},{"name":"578","_id":"ckx434q21004i2wvjw4wcc11c"},{"name":"381","_id":"ckx434q22004m2wvjeolw2k8g"},{"name":"390","_id":"ckx434q23004q2wvjj7ak79pt"},{"name":"447","_id":"ckx434q24004u2wvjo5nbd4mv"},{"name":"530","_id":"ckx434q26004y2wvj7fvii35i"},{"name":"322","_id":"ckx434q2800522wvjnbm67y52"},{"name":"1110","_id":"ckx434q2a00562wvj8pl5dbit"},{"name":"12092","_id":"ckx434q2c005b2wvji2pcl5ol"},{"name":"12091","_id":"ckx434q2d005e2wvjsl0pdrzg"},{"name":"12093","_id":"ckx434q2g005k2wvj0ze97qwq"},{"name":"12095","_id":"ckx434q2l005n2wvjb8twq255"},{"name":"12097","_id":"ckx434q2p005s2wvjar6vbrbx"},{"name":"1111","_id":"ckx434q2q005w2wvj4078ah5q"},{"name":"646","_id":"ckx434q2r00602wvjzel7uuti"},{"name":"700","_id":"ckx434q2s00642wvj5dn41ltw"},{"name":"1100","_id":"ckx434q2t00682wvj0hlkxwo3"},{"name":"126","_id":"ckx434q2u006c2wvjq93jf5p2"},{"name":"701","_id":"ckx434q2v006h2wvj0f7c4495"},{"name":"793","_id":"ckx434q2w006l2wvjkooa9ozl"},{"name":"690","_id":"ckx434q2x006p2wvjgxt18mt9"},{"name":"888","_id":"ckx434q2y006s2wvjlnx8eqaq"},{"name":"568","_id":"ckx434q2z006w2wvjutq86kzi"},{"name":"788","_id":"ckx434q3000702wvjj10ljb6w"},{"name":"593","_id":"ckx434q3100742wvjptd9obpm"},{"name":"455","_id":"ckx434q3200792wvj8re9kohm"},{"name":"795","_id":"ckx434q32007c2wvjp6me0zi3"},{"name":"667","_id":"ckx434q33007g2wvj5rwlm02j"}],"Data":[],"Page":[{"_content":"{\"name\":\"吕小鸣\",\"short_name\":\"吕小鸣\",\"icons\":[{\"src\":\"https://avatars2.githubusercontent.com/u/7931760?s=192&v=4\",\"type\":\"image/png\",\"sizes\":\"192x192\"}],\"start_url\":\"/\",\"scope\":\"/\",\"display\":\"standalone\",\"background_color\":\"#181818\",\"theme_color\":\"#181818\"}","source":"manifest.json","raw":"{\"name\":\"吕小鸣\",\"short_name\":\"吕小鸣\",\"icons\":[{\"src\":\"https://avatars2.githubusercontent.com/u/7931760?s=192&v=4\",\"type\":\"image/png\",\"sizes\":\"192x192\"}],\"start_url\":\"/\",\"scope\":\"/\",\"display\":\"standalone\",\"background_color\":\"#181818\",\"theme_color\":\"#181818\"}","date":"2021-12-13T01:10:25.624Z","updated":"2020-04-30T15:55:58.000Z","path":"manifest.json","layout":"false","title":"","comments":1,"_id":"ckx434pxu00002wvj6251efyt","content":"{\"name\":\"吕小鸣\",\"short_name\":\"吕小鸣\",\"icons\":[{\"src\":\"https://avatars2.githubusercontent.com/u/7931760?s=192&v=4\",\"type\":\"image/png\",\"sizes\":\"192x192\"}],\"start_url\":\"/\",\"scope\":\"/\",\"display\":\"standalone\",\"background_color\":\"#181818\",\"theme_color\":\"#181818\"}","site":{"data":{}},"excerpt":"","more":"{\"name\":\"吕小鸣\",\"short_name\":\"吕小鸣\",\"icons\":[{\"src\":\"https://avatars2.githubusercontent.com/u/7931760?s=192&v=4\",\"type\":\"image/png\",\"sizes\":\"192x192\"}],\"start_url\":\"/\",\"scope\":\"/\",\"display\":\"standalone\",\"background_color\":\"#181818\",\"theme_color\":\"#181818\"}"},{"_content":"/**\n * service worker\n */\n\n\nself.addEventListener('fetch', function (e) {\n\n    console.log('现在正在请求：' + e.request.url);\n\n\n});\n\n","source":"sw.js","raw":"/**\n * service worker\n */\n\n\nself.addEventListener('fetch', function (e) {\n\n    console.log('现在正在请求：' + e.request.url);\n\n\n});\n\n","date":"2021-12-13T01:10:25.625Z","updated":"2020-04-30T15:56:44.000Z","path":"sw.js","layout":"false","title":"","comments":1,"_id":"ckx434pxv00012wvj6dvyknfk","content":"/**\n * service worker\n */\n\n\nself.addEventListener('fetch', function (e) {\n\n    console.log('现在正在请求：' + e.request.url);\n\n\n});\n\n","site":{"data":{}},"excerpt":"","more":"/**\n * service worker\n */\n\n\nself.addEventListener('fetch', function (e) {\n\n    console.log('现在正在请求：' + e.request.url);\n\n\n});\n\n"},{"title":"关于本站","date":"2017-05-01T05:50:19.000Z","_content":"> ### 博主是一个很内敛的人。\n\n### 联系\n\n* GitHub：[@lvming6816077](https://github.com/lvming6816077)\n\n* WeiBo：[@吕小鸣javascript](http://weibo.com/lvming6816077/)\n\n* QQ：[@ty吕小鸣](http://wpa.qq.com/msgrd?v=3&uin=441403517&site=qq&menu=yes)\n\n* 网易云音乐：[@吕小小鸣](http://music.163.com/)\n\n### 经历\n\n* 2012年6月，从还没毕业，就来到了上海实习，当时真的是满心期待，事后证明，的确值得期待，来到张江，开始了程序员生涯。\n\n* 2013年6月，实习满一年，回学校毕业，说实话，这一年确实学到了很多东西，但是也很后悔的，因为和别人比，我的大学少了一年！\n\n* 2013年8月，开始接触前端，从最开始的Html，Css，Javascript到一些框架性的Jquery，bootstrap，angularjs，还有犀牛书给了我很大的帮助。\n\n* 2014年6月，做了快一年的前端，期间也做过PHP，开始接触wordpress，从而开始了自己的博客之旅。\n\n* 2014年9月，来到了深圳，加入了BAT的行列，来到了鹅厂成为了一名前端工程师。\n\n* 2017年3月，wordpress已经不在流行了，改投hexo的怀抱，便有了本站。\n\n* 2018年8月，回到郑州，开始新的生活。\n\n### 博客\n\n* 本博客使用的主题是在 [Landscape-plus](https://github.com/xiangming/landscape-plus)的基础上修改的。\n* 本博客使用的插件 \n\t* [网易云跟帖](https://gentie.163.com/info.html)。\n\t* [busuanzi计数](http://busuanzi.ibruce.info/)。\n\t* [LearnCloud数据存储](https://leancloud.cn/)。\n\t* [七牛云图床](https://portal.qiniu.com/bucket/tenny/resource)。\n\n","source":"about/index.md","raw":"---\ntitle: 关于本站\ndate: 2017-05-01 13:50:19\n---\n> ### 博主是一个很内敛的人。\n\n### 联系\n\n* GitHub：[@lvming6816077](https://github.com/lvming6816077)\n\n* WeiBo：[@吕小鸣javascript](http://weibo.com/lvming6816077/)\n\n* QQ：[@ty吕小鸣](http://wpa.qq.com/msgrd?v=3&uin=441403517&site=qq&menu=yes)\n\n* 网易云音乐：[@吕小小鸣](http://music.163.com/)\n\n### 经历\n\n* 2012年6月，从还没毕业，就来到了上海实习，当时真的是满心期待，事后证明，的确值得期待，来到张江，开始了程序员生涯。\n\n* 2013年6月，实习满一年，回学校毕业，说实话，这一年确实学到了很多东西，但是也很后悔的，因为和别人比，我的大学少了一年！\n\n* 2013年8月，开始接触前端，从最开始的Html，Css，Javascript到一些框架性的Jquery，bootstrap，angularjs，还有犀牛书给了我很大的帮助。\n\n* 2014年6月，做了快一年的前端，期间也做过PHP，开始接触wordpress，从而开始了自己的博客之旅。\n\n* 2014年9月，来到了深圳，加入了BAT的行列，来到了鹅厂成为了一名前端工程师。\n\n* 2017年3月，wordpress已经不在流行了，改投hexo的怀抱，便有了本站。\n\n* 2018年8月，回到郑州，开始新的生活。\n\n### 博客\n\n* 本博客使用的主题是在 [Landscape-plus](https://github.com/xiangming/landscape-plus)的基础上修改的。\n* 本博客使用的插件 \n\t* [网易云跟帖](https://gentie.163.com/info.html)。\n\t* [busuanzi计数](http://busuanzi.ibruce.info/)。\n\t* [LearnCloud数据存储](https://leancloud.cn/)。\n\t* [七牛云图床](https://portal.qiniu.com/bucket/tenny/resource)。\n\n","updated":"2018-11-27T14:41:24.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckx434pz900032wvjm7g94wdn","content":"<blockquote>\n<h3><span id=\"博主是一个很内敛的人\">博主是一个很内敛的人。</span></h3></blockquote>\n<h3><span id=\"联系\">联系</span></h3><ul>\n<li><p>GitHub：<a href=\"https://github.com/lvming6816077\" target=\"_blank\" rel=\"noopener\">@lvming6816077</a></p>\n</li>\n<li><p>WeiBo：<a href=\"http://weibo.com/lvming6816077/\" target=\"_blank\" rel=\"noopener\">@吕小鸣javascript</a></p>\n</li>\n<li><p>QQ：<a href=\"http://wpa.qq.com/msgrd?v=3&amp;uin=441403517&amp;site=qq&amp;menu=yes\" target=\"_blank\" rel=\"noopener\">@ty吕小鸣</a></p>\n</li>\n<li><p>网易云音乐：<a href=\"http://music.163.com/\" target=\"_blank\" rel=\"noopener\">@吕小小鸣</a></p>\n</li>\n</ul>\n<h3><span id=\"经历\">经历</span></h3><ul>\n<li><p>2012年6月，从还没毕业，就来到了上海实习，当时真的是满心期待，事后证明，的确值得期待，来到张江，开始了程序员生涯。</p>\n</li>\n<li><p>2013年6月，实习满一年，回学校毕业，说实话，这一年确实学到了很多东西，但是也很后悔的，因为和别人比，我的大学少了一年！</p>\n</li>\n<li><p>2013年8月，开始接触前端，从最开始的Html，Css，Javascript到一些框架性的Jquery，bootstrap，angularjs，还有犀牛书给了我很大的帮助。</p>\n</li>\n<li><p>2014年6月，做了快一年的前端，期间也做过PHP，开始接触wordpress，从而开始了自己的博客之旅。</p>\n</li>\n<li><p>2014年9月，来到了深圳，加入了BAT的行列，来到了鹅厂成为了一名前端工程师。</p>\n</li>\n<li><p>2017年3月，wordpress已经不在流行了，改投hexo的怀抱，便有了本站。</p>\n</li>\n<li><p>2018年8月，回到郑州，开始新的生活。</p>\n</li>\n</ul>\n<h3><span id=\"博客\">博客</span></h3><ul>\n<li>本博客使用的主题是在 <a href=\"https://github.com/xiangming/landscape-plus\" target=\"_blank\" rel=\"noopener\">Landscape-plus</a>的基础上修改的。</li>\n<li>本博客使用的插件 <ul>\n<li><a href=\"https://gentie.163.com/info.html\" target=\"_blank\" rel=\"noopener\">网易云跟帖</a>。</li>\n<li><a href=\"http://busuanzi.ibruce.info/\" target=\"_blank\" rel=\"noopener\">busuanzi计数</a>。</li>\n<li><a href=\"https://leancloud.cn/\" target=\"_blank\" rel=\"noopener\">LearnCloud数据存储</a>。</li>\n<li><a href=\"https://portal.qiniu.com/bucket/tenny/resource\" target=\"_blank\" rel=\"noopener\">七牛云图床</a>。</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<h3 id=\"博主是一个很内敛的人。\"><a href=\"#博主是一个很内敛的人。\" class=\"headerlink\" title=\"博主是一个很内敛的人。\"></a>博主是一个很内敛的人。</h3></blockquote>\n<h3 id=\"联系\"><a href=\"#联系\" class=\"headerlink\" title=\"联系\"></a>联系</h3><ul>\n<li><p>GitHub：<a href=\"https://github.com/lvming6816077\" target=\"_blank\" rel=\"noopener\">@lvming6816077</a></p>\n</li>\n<li><p>WeiBo：<a href=\"http://weibo.com/lvming6816077/\" target=\"_blank\" rel=\"noopener\">@吕小鸣javascript</a></p>\n</li>\n<li><p>QQ：<a href=\"http://wpa.qq.com/msgrd?v=3&amp;uin=441403517&amp;site=qq&amp;menu=yes\" target=\"_blank\" rel=\"noopener\">@ty吕小鸣</a></p>\n</li>\n<li><p>网易云音乐：<a href=\"http://music.163.com/\" target=\"_blank\" rel=\"noopener\">@吕小小鸣</a></p>\n</li>\n</ul>\n<h3 id=\"经历\"><a href=\"#经历\" class=\"headerlink\" title=\"经历\"></a>经历</h3><ul>\n<li><p>2012年6月，从还没毕业，就来到了上海实习，当时真的是满心期待，事后证明，的确值得期待，来到张江，开始了程序员生涯。</p>\n</li>\n<li><p>2013年6月，实习满一年，回学校毕业，说实话，这一年确实学到了很多东西，但是也很后悔的，因为和别人比，我的大学少了一年！</p>\n</li>\n<li><p>2013年8月，开始接触前端，从最开始的Html，Css，Javascript到一些框架性的Jquery，bootstrap，angularjs，还有犀牛书给了我很大的帮助。</p>\n</li>\n<li><p>2014年6月，做了快一年的前端，期间也做过PHP，开始接触wordpress，从而开始了自己的博客之旅。</p>\n</li>\n<li><p>2014年9月，来到了深圳，加入了BAT的行列，来到了鹅厂成为了一名前端工程师。</p>\n</li>\n<li><p>2017年3月，wordpress已经不在流行了，改投hexo的怀抱，便有了本站。</p>\n</li>\n<li><p>2018年8月，回到郑州，开始新的生活。</p>\n</li>\n</ul>\n<h3 id=\"博客\"><a href=\"#博客\" class=\"headerlink\" title=\"博客\"></a>博客</h3><ul>\n<li>本博客使用的主题是在 <a href=\"https://github.com/xiangming/landscape-plus\" target=\"_blank\" rel=\"noopener\">Landscape-plus</a>的基础上修改的。</li>\n<li>本博客使用的插件 <ul>\n<li><a href=\"https://gentie.163.com/info.html\" target=\"_blank\" rel=\"noopener\">网易云跟帖</a>。</li>\n<li><a href=\"http://busuanzi.ibruce.info/\" target=\"_blank\" rel=\"noopener\">busuanzi计数</a>。</li>\n<li><a href=\"https://leancloud.cn/\" target=\"_blank\" rel=\"noopener\">LearnCloud数据存储</a>。</li>\n<li><a href=\"https://portal.qiniu.com/bucket/tenny/resource\" target=\"_blank\" rel=\"noopener\">七牛云图床</a>。</li>\n</ul>\n</li>\n</ul>\n"},{"title":"练习作品","date":"2017-05-07T07:49:41.000Z","_content":"Github:[https://github.com/lvming6816077](lvming6816077)\n\n\n\n\n* *一个单页面的网页，主要调侃了一个爱情故事，点进去看啊！具体做法会在以后博客里面说明。*\n\n[http://www.nihaoshijie.com.cn/mypro/app](http://www.nihaoshijie.com.cn/mypro/app)\n\n***\n\n* *Javacript写的俄罗斯方块，用到了之前提到的PhaserHtml5游戏引擎，已经放在小米应用商店，喜欢的可以下载来玩下！*\n\n下载地址：http://app.mi.com/detail/59367\n\n[http://www.nihaoshijie.com.cn/mypro/tetris](http://www.nihaoshijie.com.cn/mypro/tetris)\n\n\n\n***\n\n* *个人简介，还在制作中。。。*\n\n[http://www.nihaoshijie.com.cn/mypro/resume](http://www.nihaoshijie.com.cn/mypro/resume)\n\n\n***\n\n* *一个chrome插件，用来存储你当前的tabs*\n\n[http://www.nihaoshijie.com.cn/index.php/archives/326](http://www.nihaoshijie.com.cn/index.php/archives/326)\n\n\n\n***\n\n* *ios采集音视频数据并通过rtmp上传到nginx*\n\n[https://github.com/lvming6816077/LMVideoTest](https://github.com/lvming6816077/LMVideoTest)\n\n\n***\n\n* *H5手势解锁*\n\n[https://github.com/lvming6816077/H5lock](https://github.com/lvming6816077/H5lock)\n\n\n***\n\n* *创业项目：直播贴类型app*\n\n[https://github.com/lvming6816077/zhiboapp](https://github.com/lvming6816077/zhiboapp)\n\n\n\n\n\n","source":"exercise/index.md","raw":"---\ntitle: 练习作品\ndate: 2017-05-07 15:49:41\n---\nGithub:[https://github.com/lvming6816077](lvming6816077)\n\n\n\n\n* *一个单页面的网页，主要调侃了一个爱情故事，点进去看啊！具体做法会在以后博客里面说明。*\n\n[http://www.nihaoshijie.com.cn/mypro/app](http://www.nihaoshijie.com.cn/mypro/app)\n\n***\n\n* *Javacript写的俄罗斯方块，用到了之前提到的PhaserHtml5游戏引擎，已经放在小米应用商店，喜欢的可以下载来玩下！*\n\n下载地址：http://app.mi.com/detail/59367\n\n[http://www.nihaoshijie.com.cn/mypro/tetris](http://www.nihaoshijie.com.cn/mypro/tetris)\n\n\n\n***\n\n* *个人简介，还在制作中。。。*\n\n[http://www.nihaoshijie.com.cn/mypro/resume](http://www.nihaoshijie.com.cn/mypro/resume)\n\n\n***\n\n* *一个chrome插件，用来存储你当前的tabs*\n\n[http://www.nihaoshijie.com.cn/index.php/archives/326](http://www.nihaoshijie.com.cn/index.php/archives/326)\n\n\n\n***\n\n* *ios采集音视频数据并通过rtmp上传到nginx*\n\n[https://github.com/lvming6816077/LMVideoTest](https://github.com/lvming6816077/LMVideoTest)\n\n\n***\n\n* *H5手势解锁*\n\n[https://github.com/lvming6816077/H5lock](https://github.com/lvming6816077/H5lock)\n\n\n***\n\n* *创业项目：直播贴类型app*\n\n[https://github.com/lvming6816077/zhiboapp](https://github.com/lvming6816077/zhiboapp)\n\n\n\n\n\n","updated":"2017-05-07T08:30:28.000Z","path":"exercise/index.html","comments":1,"layout":"page","_id":"ckx434pzb00052wvjc49kilji","content":"<p>Github:<a href=\"lvming6816077\">https://github.com/lvming6816077</a></p>\n<ul>\n<li><em>一个单页面的网页，主要调侃了一个爱情故事，点进去看啊！具体做法会在以后博客里面说明。</em></li>\n</ul>\n<p><a href=\"http://www.nihaoshijie.com.cn/mypro/app\">http://www.nihaoshijie.com.cn/mypro/app</a></p>\n<hr>\n<ul>\n<li><em>Javacript写的俄罗斯方块，用到了之前提到的PhaserHtml5游戏引擎，已经放在小米应用商店，喜欢的可以下载来玩下！</em></li>\n</ul>\n<p>下载地址：<a href=\"http://app.mi.com/detail/59367\" target=\"_blank\" rel=\"noopener\">http://app.mi.com/detail/59367</a></p>\n<p><a href=\"http://www.nihaoshijie.com.cn/mypro/tetris\">http://www.nihaoshijie.com.cn/mypro/tetris</a></p>\n<hr>\n<ul>\n<li><em>个人简介，还在制作中。。。</em></li>\n</ul>\n<p><a href=\"http://www.nihaoshijie.com.cn/mypro/resume\">http://www.nihaoshijie.com.cn/mypro/resume</a></p>\n<hr>\n<ul>\n<li><em>一个chrome插件，用来存储你当前的tabs</em></li>\n</ul>\n<p><a href=\"http://www.nihaoshijie.com.cn/index.php/archives/326\">http://www.nihaoshijie.com.cn/index.php/archives/326</a></p>\n<hr>\n<ul>\n<li><em>ios采集音视频数据并通过rtmp上传到nginx</em></li>\n</ul>\n<p><a href=\"https://github.com/lvming6816077/LMVideoTest\" target=\"_blank\" rel=\"noopener\">https://github.com/lvming6816077/LMVideoTest</a></p>\n<hr>\n<ul>\n<li><em>H5手势解锁</em></li>\n</ul>\n<p><a href=\"https://github.com/lvming6816077/H5lock\" target=\"_blank\" rel=\"noopener\">https://github.com/lvming6816077/H5lock</a></p>\n<hr>\n<ul>\n<li><em>创业项目：直播贴类型app</em></li>\n</ul>\n<p><a href=\"https://github.com/lvming6816077/zhiboapp\" target=\"_blank\" rel=\"noopener\">https://github.com/lvming6816077/zhiboapp</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Github:<a href=\"lvming6816077\">https://github.com/lvming6816077</a></p>\n<ul>\n<li><em>一个单页面的网页，主要调侃了一个爱情故事，点进去看啊！具体做法会在以后博客里面说明。</em></li>\n</ul>\n<p><a href=\"http://www.nihaoshijie.com.cn/mypro/app\">http://www.nihaoshijie.com.cn/mypro/app</a></p>\n<hr>\n<ul>\n<li><em>Javacript写的俄罗斯方块，用到了之前提到的PhaserHtml5游戏引擎，已经放在小米应用商店，喜欢的可以下载来玩下！</em></li>\n</ul>\n<p>下载地址：<a href=\"http://app.mi.com/detail/59367\" target=\"_blank\" rel=\"noopener\">http://app.mi.com/detail/59367</a></p>\n<p><a href=\"http://www.nihaoshijie.com.cn/mypro/tetris\">http://www.nihaoshijie.com.cn/mypro/tetris</a></p>\n<hr>\n<ul>\n<li><em>个人简介，还在制作中。。。</em></li>\n</ul>\n<p><a href=\"http://www.nihaoshijie.com.cn/mypro/resume\">http://www.nihaoshijie.com.cn/mypro/resume</a></p>\n<hr>\n<ul>\n<li><em>一个chrome插件，用来存储你当前的tabs</em></li>\n</ul>\n<p><a href=\"http://www.nihaoshijie.com.cn/index.php/archives/326\">http://www.nihaoshijie.com.cn/index.php/archives/326</a></p>\n<hr>\n<ul>\n<li><em>ios采集音视频数据并通过rtmp上传到nginx</em></li>\n</ul>\n<p><a href=\"https://github.com/lvming6816077/LMVideoTest\" target=\"_blank\" rel=\"noopener\">https://github.com/lvming6816077/LMVideoTest</a></p>\n<hr>\n<ul>\n<li><em>H5手势解锁</em></li>\n</ul>\n<p><a href=\"https://github.com/lvming6816077/H5lock\" target=\"_blank\" rel=\"noopener\">https://github.com/lvming6816077/H5lock</a></p>\n<hr>\n<ul>\n<li><em>创业项目：直播贴类型app</em></li>\n</ul>\n<p><a href=\"https://github.com/lvming6816077/zhiboapp\" target=\"_blank\" rel=\"noopener\">https://github.com/lvming6816077/zhiboapp</a></p>\n"}],"Post":[{"title":"Angular的依赖注入","date":"2014-07-31T09:26:17.000Z","_content":"在众多的javascript框架中，多多少少都会使用一些思想，设计模式等等，下面就来说说其中的某些：\n<h3>依赖注入：</h3>\n什么是依赖注入呢，我的理解，简单点就是说我的东西我自己并不像来拿着，我想要我依赖的那个人来帮我拿着，当我需要的时候，他给我就行了。当然这只是简单的理解，还是用代码解释比较清楚一些。\n<!--more-->\n这里有一个function，很简单。\n```javascript\nvar a = function(name){\nconsole.log(name);\n}```\n\n我们调用它：\n```javascript\na('abc')；//abc\n```\n那么，就像我上面说的，我能不能自己不传参数呢，例如：\n```javascript\na();//undefined\n```\n如何才能实现让别人帮我们注入这个参数呢：\n```javascript\nvar inject = function(name,callback){\n  return function(){\n     callback(name);\n  }\n}```\n想这样，我们在定义参数的时候这样传：\n```javascript\na = inject('abc',a)```\n我们再调用a方法：\n```javascript\na()；//abc```\n这其实就是最简单的依赖注入了，当然这么简单是不行的，其实这是很无意义的，下面我们来看一下高深的angularjs：\n```javascript\nvar MyController = function($scope){\n        $scope.test = 1;\n}```\n上面这段代码定义了angularjs的controller里面用到了scope，这样还看不出问题，在看下面：\n```javascript\nvar MyController = function($scope,$http){\n        $scope.test = 1;\n        $http.get('');\n}```\n上面这段代码在原来的基础上增加了http,那么问题就来了，angular在调用controller的时候怎么知道我需要scope还是http还是两个都需要呢，这就牵着到了angular里的依赖注入，那么我们来模拟一下。\n\n假设没有angular的情况下，我们：\n```javascript\nvar MyController = function($scope,$http){\n        $scope.test = 1;\n        $http.get('');\n}\nMyController();//<span style=\"color: #808080;\">undefined</span>```\n肯定会报错的，然后我们来修改下我们的inject：\n```javascript\nvar inject = {\n            dependencies: {},\n            register: function(key, value) {\n                this.dependencies[key] = value;\n            },\n            resolve: function(deps, func, scope) {\n                var arr = [];\n                for (var i = 0 ; i &lt; deps.length ; i++) {\n                    if (this.dependencies.hasOwnProperty(deps[i])) {\n                       arr.push(this.dependencies[deps[i]])\n                    }\n                }\n                console.log(arr);\n                return function(){\n                    func.apply(scope || {}, arr);\n                }\n\n            }\n        }```\n然后我们模仿angular来预先注册几个模块：\n<pre class=\"lang:default decode:true \">inject.register('$http', {'get':function(){console.log('get')}});\ninject.register('$scope', {'test':''});\ninject.register('$location', {'hash':function(){console.log('hash')}});```\n然后我们就可以注入了：\n```javascript\nMyController = inject.resolve(['$http','$scope'],MyController)；\nMyController();```\n我们只需要http和scope，所以我们只穿了两个，虽然这样看似解决了依赖注入，但是还有很多问题，比如我要交换两个参数的位置就不行了。\n\n于是翻看了angularjs的源码，找到了：\n```javascript\nvar FN_ARGS = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n.....\nfunction annotate(fn) {\n  .....\n  fnText = fn.toString().replace(STRIP_COMMENTS, '');\n  argDecl = fnText.match(FN_ARGS);\n  .....\n}```\n我们忽略掉一些细节代码，只看我们需要的。annotate方法和我们的resolve方法很像。它转换传递过去的func为字符串，删除掉注释代码，然后抽取其中的参数。让我们看下它的执行结果，修改一下resolve方法：\n```javascript\nresolve: function(deps, func, scope) {\n                \n                var FN_ARGS = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;\n                var STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n                var fnText = func.toString().replace(STRIP_COMMENTS, '');\n                var argDecl = fnText.match(FN_ARGS);\n                console.log(argDecl);\n                \n\n            }```\n打印出argDecl：\n```javascript\n[\"function ($scope,$http)\", \"$scope,$http\", index: 0, input: \"function ($scope,$http){\n\n$scope.test = 1;\n$http.get('');\n}\"]```\n\n可以看到，这个数组拿到了func的参数，argDecl［1］ = \"$scope,$http\";\n\n根据这个，我们来修改resolve：\n```javascript\nresolve: function(func, scope) {\n                \n                var FN_ARGS = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;\n                var STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n                var fnText = func.toString().replace(STRIP_COMMENTS, '');\n                var argDecl = fnText.match(FN_ARGS);\n                console.log(argDecl);\n                var deps = argDecl[1].split(',');\n                var arr = [];\n                for (var i = 0 ; i &lt; deps.length ; i++) {\n                    if (this.dependencies.hasOwnProperty(deps[i])) {\n                       arr.push(this.dependencies[deps[i]])\n                    }\n                }\n                return function(){\n                    func.apply(scope || {}, arr);\n                }\n\n            }```\nOK，这次我们不用在意参数的顺序了，但是angular远比我们要想的多，大多数情况下，我们的js都是要压缩的，所以function的实参会被替换，如果是那样的话，我们这个方法的argDecl［1］ = \"$scope,$http\";就会是argDecl［1］ = \"r,t\";类似这样的变量，那么又该怎么解决呢？\n\nangular官方有这样的解释：\n\n为了克服压缩引起的问题，只要在控制器函数里面给$inject属性赋值一个依赖服务标识符的数组，就像：\n```javascript\nvar MyController = ['$scope', '$http', function($scope, $http) { /* constructor body */ }];```\n那么，用到我们这个方法里面又该怎么实现呢？那我们在看看angular的源码吧：\n```javascript\n....\n} else if (isArray(fn)) {\n    last = fn.length - 1;\n    assertArgFn(fn[last], 'fn')\n    $inject = fn.slice(0, last);\n  } else {\n....```\n看到了吧，之所以用到数组也是有原因的，把需要的依赖写在方法的前面，于是，应用到我们的reslove方法：\n```javascript\nresolve: function(func, scope) {\n                isArray(func) {\n                    var last = func.length - 1;\n                    var deps = func.slice(0, last);\n                    func = func[last]\n                } else {\n                    var FN_ARGS = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;\n                    var STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n                    var fnText = func.toString().replace(STRIP_COMMENTS, '');\n                    var argDecl = fnText.match(FN_ARGS);\n                    var deps = argDecl[1].split(',');\n                }\n                \n                var arr = [];\n                for (var i = 0 ; i &lt; deps.length ; i++) {\n                    if (this.dependencies.hasOwnProperty(deps[i])) {\n                       arr.push(this.dependencies[deps[i]])\n                    }\n                }\n                return function(){\n                    func.apply(scope || {}, arr);\n                }\n\n            }```\nOK，到这里，便可以用我们的inject来模拟angular的依赖注入了，当然，真正angular的依赖注入还有很多东西，这里就不在详细描述了。\n\n以上观点都是我的个人见解，如有错误欢迎指正！\n\n&nbsp;\n\n完！\n\n&nbsp;\n\n参考资料：<a href=\"http://www.2cto.com/kf/201401/275236.html\" target=\"_blank\">http://www.2cto.com/kf/201401/275236.html</a>\n\n&nbsp;","source":"_posts/Angular的依赖注入.md","raw":"---\ntitle: Angular的依赖注入\ndate: 2014-07-31 17:26:17\ntags:\n- Angular\ncategories:\n- 341\n---\n在众多的javascript框架中，多多少少都会使用一些思想，设计模式等等，下面就来说说其中的某些：\n<h3>依赖注入：</h3>\n什么是依赖注入呢，我的理解，简单点就是说我的东西我自己并不像来拿着，我想要我依赖的那个人来帮我拿着，当我需要的时候，他给我就行了。当然这只是简单的理解，还是用代码解释比较清楚一些。\n<!--more-->\n这里有一个function，很简单。\n```javascript\nvar a = function(name){\nconsole.log(name);\n}```\n\n我们调用它：\n```javascript\na('abc')；//abc\n```\n那么，就像我上面说的，我能不能自己不传参数呢，例如：\n```javascript\na();//undefined\n```\n如何才能实现让别人帮我们注入这个参数呢：\n```javascript\nvar inject = function(name,callback){\n  return function(){\n     callback(name);\n  }\n}```\n想这样，我们在定义参数的时候这样传：\n```javascript\na = inject('abc',a)```\n我们再调用a方法：\n```javascript\na()；//abc```\n这其实就是最简单的依赖注入了，当然这么简单是不行的，其实这是很无意义的，下面我们来看一下高深的angularjs：\n```javascript\nvar MyController = function($scope){\n        $scope.test = 1;\n}```\n上面这段代码定义了angularjs的controller里面用到了scope，这样还看不出问题，在看下面：\n```javascript\nvar MyController = function($scope,$http){\n        $scope.test = 1;\n        $http.get('');\n}```\n上面这段代码在原来的基础上增加了http,那么问题就来了，angular在调用controller的时候怎么知道我需要scope还是http还是两个都需要呢，这就牵着到了angular里的依赖注入，那么我们来模拟一下。\n\n假设没有angular的情况下，我们：\n```javascript\nvar MyController = function($scope,$http){\n        $scope.test = 1;\n        $http.get('');\n}\nMyController();//<span style=\"color: #808080;\">undefined</span>```\n肯定会报错的，然后我们来修改下我们的inject：\n```javascript\nvar inject = {\n            dependencies: {},\n            register: function(key, value) {\n                this.dependencies[key] = value;\n            },\n            resolve: function(deps, func, scope) {\n                var arr = [];\n                for (var i = 0 ; i &lt; deps.length ; i++) {\n                    if (this.dependencies.hasOwnProperty(deps[i])) {\n                       arr.push(this.dependencies[deps[i]])\n                    }\n                }\n                console.log(arr);\n                return function(){\n                    func.apply(scope || {}, arr);\n                }\n\n            }\n        }```\n然后我们模仿angular来预先注册几个模块：\n<pre class=\"lang:default decode:true \">inject.register('$http', {'get':function(){console.log('get')}});\ninject.register('$scope', {'test':''});\ninject.register('$location', {'hash':function(){console.log('hash')}});```\n然后我们就可以注入了：\n```javascript\nMyController = inject.resolve(['$http','$scope'],MyController)；\nMyController();```\n我们只需要http和scope，所以我们只穿了两个，虽然这样看似解决了依赖注入，但是还有很多问题，比如我要交换两个参数的位置就不行了。\n\n于是翻看了angularjs的源码，找到了：\n```javascript\nvar FN_ARGS = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n.....\nfunction annotate(fn) {\n  .....\n  fnText = fn.toString().replace(STRIP_COMMENTS, '');\n  argDecl = fnText.match(FN_ARGS);\n  .....\n}```\n我们忽略掉一些细节代码，只看我们需要的。annotate方法和我们的resolve方法很像。它转换传递过去的func为字符串，删除掉注释代码，然后抽取其中的参数。让我们看下它的执行结果，修改一下resolve方法：\n```javascript\nresolve: function(deps, func, scope) {\n                \n                var FN_ARGS = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;\n                var STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n                var fnText = func.toString().replace(STRIP_COMMENTS, '');\n                var argDecl = fnText.match(FN_ARGS);\n                console.log(argDecl);\n                \n\n            }```\n打印出argDecl：\n```javascript\n[\"function ($scope,$http)\", \"$scope,$http\", index: 0, input: \"function ($scope,$http){\n\n$scope.test = 1;\n$http.get('');\n}\"]```\n\n可以看到，这个数组拿到了func的参数，argDecl［1］ = \"$scope,$http\";\n\n根据这个，我们来修改resolve：\n```javascript\nresolve: function(func, scope) {\n                \n                var FN_ARGS = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;\n                var STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n                var fnText = func.toString().replace(STRIP_COMMENTS, '');\n                var argDecl = fnText.match(FN_ARGS);\n                console.log(argDecl);\n                var deps = argDecl[1].split(',');\n                var arr = [];\n                for (var i = 0 ; i &lt; deps.length ; i++) {\n                    if (this.dependencies.hasOwnProperty(deps[i])) {\n                       arr.push(this.dependencies[deps[i]])\n                    }\n                }\n                return function(){\n                    func.apply(scope || {}, arr);\n                }\n\n            }```\nOK，这次我们不用在意参数的顺序了，但是angular远比我们要想的多，大多数情况下，我们的js都是要压缩的，所以function的实参会被替换，如果是那样的话，我们这个方法的argDecl［1］ = \"$scope,$http\";就会是argDecl［1］ = \"r,t\";类似这样的变量，那么又该怎么解决呢？\n\nangular官方有这样的解释：\n\n为了克服压缩引起的问题，只要在控制器函数里面给$inject属性赋值一个依赖服务标识符的数组，就像：\n```javascript\nvar MyController = ['$scope', '$http', function($scope, $http) { /* constructor body */ }];```\n那么，用到我们这个方法里面又该怎么实现呢？那我们在看看angular的源码吧：\n```javascript\n....\n} else if (isArray(fn)) {\n    last = fn.length - 1;\n    assertArgFn(fn[last], 'fn')\n    $inject = fn.slice(0, last);\n  } else {\n....```\n看到了吧，之所以用到数组也是有原因的，把需要的依赖写在方法的前面，于是，应用到我们的reslove方法：\n```javascript\nresolve: function(func, scope) {\n                isArray(func) {\n                    var last = func.length - 1;\n                    var deps = func.slice(0, last);\n                    func = func[last]\n                } else {\n                    var FN_ARGS = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;\n                    var STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n                    var fnText = func.toString().replace(STRIP_COMMENTS, '');\n                    var argDecl = fnText.match(FN_ARGS);\n                    var deps = argDecl[1].split(',');\n                }\n                \n                var arr = [];\n                for (var i = 0 ; i &lt; deps.length ; i++) {\n                    if (this.dependencies.hasOwnProperty(deps[i])) {\n                       arr.push(this.dependencies[deps[i]])\n                    }\n                }\n                return function(){\n                    func.apply(scope || {}, arr);\n                }\n\n            }```\nOK，到这里，便可以用我们的inject来模拟angular的依赖注入了，当然，真正angular的依赖注入还有很多东西，这里就不在详细描述了。\n\n以上观点都是我的个人见解，如有错误欢迎指正！\n\n&nbsp;\n\n完！\n\n&nbsp;\n\n参考资料：<a href=\"http://www.2cto.com/kf/201401/275236.html\" target=\"_blank\">http://www.2cto.com/kf/201401/275236.html</a>\n\n&nbsp;","slug":"Angular的依赖注入","published":1,"updated":"2017-04-30T09:31:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434pz300022wvjgpkjc70l","content":"<p>在众多的javascript框架中，多多少少都会使用一些思想，设计模式等等，下面就来说说其中的某些：</p>\n<p></p><h3><span id=\"依赖注入\">依赖注入：</span></h3><br>什么是依赖注入呢，我的理解，简单点就是说我的东西我自己并不像来拿着，我想要我依赖的那个人来帮我拿着，当我需要的时候，他给我就行了。当然这只是简单的理解，还是用代码解释比较清楚一些。<br><a id=\"more\"></a><br>这里有一个function，很简单。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p>\n<p>我们调用它：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a(<span class=\"string\">'abc'</span>)；<span class=\"comment\">//abc</span></span><br></pre></td></tr></table></figure></p>\n<p>那么，就像我上面说的，我能不能自己不传参数呢，例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a();<span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure></p>\n<p>如何才能实现让别人帮我们注入这个参数呢：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> inject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name,callback</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">     callback(name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>想这样，我们在定义参数的时候这样传：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = inject(<span class=\"string\">'abc'</span>,a)</span><br></pre></td></tr></table></figure></p>\n<p>我们再调用a方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a()；<span class=\"comment\">//abc</span></span><br></pre></td></tr></table></figure></p>\n<p>这其实就是最简单的依赖注入了，当然这么简单是不行的，其实这是很无意义的，下面我们来看一下高深的angularjs：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyController = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$scope</span>)</span>&#123;</span><br><span class=\"line\">        $scope.test = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面这段代码定义了angularjs的controller里面用到了scope，这样还看不出问题，在看下面：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyController = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$scope,$http</span>)</span>&#123;</span><br><span class=\"line\">        $scope.test = <span class=\"number\">1</span>;</span><br><span class=\"line\">        $http.get(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面这段代码在原来的基础上增加了http,那么问题就来了，angular在调用controller的时候怎么知道我需要scope还是http还是两个都需要呢，这就牵着到了angular里的依赖注入，那么我们来模拟一下。</p>\n<p>假设没有angular的情况下，我们：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyController = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$scope,$http</span>)</span>&#123;</span><br><span class=\"line\">        $scope.test = <span class=\"number\">1</span>;</span><br><span class=\"line\">        $http.get(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">MyController();<span class=\"comment\">//&lt;span style=\"color: #808080;\"&gt;undefined&lt;/span&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>肯定会报错的，然后我们来修改下我们的inject：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> inject = &#123;</span><br><span class=\"line\">            dependencies: &#123;&#125;,</span><br><span class=\"line\">            register: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key, value</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.dependencies[key] = value;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            resolve: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">deps, func, scope</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> arr = [];</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i &amp;lt; deps.length ; i++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.dependencies.hasOwnProperty(deps[i])) &#123;</span><br><span class=\"line\">                       arr.push(<span class=\"keyword\">this</span>.dependencies[deps[i]])</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(arr);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">                    func.apply(scope || &#123;&#125;, arr);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后我们模仿angular来预先注册几个模块：</p>\n<p><pre class=\"lang:default decode:true \">inject.register(‘$http’, {‘get’:function(){console.log(‘get’)}});<br>inject.register(‘$scope’, {‘test’:’’});<br>inject.register(‘$location’, {‘hash’:function(){console.log(‘hash’)}});<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">然后我们就可以注入了：</span><br><span class=\"line\">```javascript</span><br><span class=\"line\">MyController = inject.resolve([&apos;$http&apos;,&apos;$scope&apos;],MyController)；</span><br><span class=\"line\">MyController();</span><br></pre></td></tr></table></figure></pre></p>\n<p>我们只需要http和scope，所以我们只穿了两个，虽然这样看似解决了依赖注入，但是还有很多问题，比如我要交换两个参数的位置就不行了。</p>\n<p>于是翻看了angularjs的源码，找到了：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> FN_ARGS = <span class=\"regexp\">/^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> STRIP_COMMENTS = <span class=\"regexp\">/((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg</span>;</span><br><span class=\"line\">.....</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">annotate</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  .....</span><br><span class=\"line\">  fnText = fn.toString().replace(STRIP_COMMENTS, <span class=\"string\">''</span>);</span><br><span class=\"line\">  argDecl = fnText.match(FN_ARGS);</span><br><span class=\"line\">  .....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们忽略掉一些细节代码，只看我们需要的。annotate方法和我们的resolve方法很像。它转换传递过去的func为字符串，删除掉注释代码，然后抽取其中的参数。让我们看下它的执行结果，修改一下resolve方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resolve: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">deps, func, scope</span>) </span>&#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">var</span> FN_ARGS = <span class=\"regexp\">/^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m</span>;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> STRIP_COMMENTS = <span class=\"regexp\">/((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg</span>;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> fnText = func.toString().replace(STRIP_COMMENTS, <span class=\"string\">''</span>);</span><br><span class=\"line\">                <span class=\"keyword\">var</span> argDecl = fnText.match(FN_ARGS);</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(argDecl);</span><br><span class=\"line\">                </span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure></p>\n<p>打印出argDecl：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">\"function ($scope,$http)\"</span>, <span class=\"string\">\"$scope,$http\"</span>, <span class=\"attr\">index</span>: <span class=\"number\">0</span>, <span class=\"attr\">input</span>: <span class=\"string\">\"function ($scope,$http)&#123;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">$scope.test = 1;</span></span><br><span class=\"line\"><span class=\"string\">$http.get('');</span></span><br><span class=\"line\"><span class=\"string\">&#125;\"</span>]</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，这个数组拿到了func的参数，argDecl［1］ = “$scope,$http”;</p>\n<p>根据这个，我们来修改resolve：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resolve: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, scope</span>) </span>&#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">var</span> FN_ARGS = <span class=\"regexp\">/^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m</span>;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> STRIP_COMMENTS = <span class=\"regexp\">/((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg</span>;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> fnText = func.toString().replace(STRIP_COMMENTS, <span class=\"string\">''</span>);</span><br><span class=\"line\">                <span class=\"keyword\">var</span> argDecl = fnText.match(FN_ARGS);</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(argDecl);</span><br><span class=\"line\">                <span class=\"keyword\">var</span> deps = argDecl[<span class=\"number\">1</span>].split(<span class=\"string\">','</span>);</span><br><span class=\"line\">                <span class=\"keyword\">var</span> arr = [];</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i &amp;lt; deps.length ; i++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.dependencies.hasOwnProperty(deps[i])) &#123;</span><br><span class=\"line\">                       arr.push(<span class=\"keyword\">this</span>.dependencies[deps[i]])</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">                    func.apply(scope || &#123;&#125;, arr);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure></p>\n<p>OK，这次我们不用在意参数的顺序了，但是angular远比我们要想的多，大多数情况下，我们的js都是要压缩的，所以function的实参会被替换，如果是那样的话，我们这个方法的argDecl［1］ = “$scope,$http”;就会是argDecl［1］ = “r,t”;类似这样的变量，那么又该怎么解决呢？</p>\n<p>angular官方有这样的解释：</p>\n<p>为了克服压缩引起的问题，只要在控制器函数里面给$inject属性赋值一个依赖服务标识符的数组，就像：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyController = [<span class=\"string\">'$scope'</span>, <span class=\"string\">'$http'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$scope, $http</span>) </span>&#123; <span class=\"comment\">/* constructor body */</span> &#125;];</span><br></pre></td></tr></table></figure></p>\n<p>那么，用到我们这个方法里面又该怎么实现呢？那我们在看看angular的源码吧：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">....</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isArray(fn)) &#123;</span><br><span class=\"line\">    last = fn.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    assertArgFn(fn[last], <span class=\"string\">'fn'</span>)</span><br><span class=\"line\">    $inject = fn.slice(<span class=\"number\">0</span>, last);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">....</span><br></pre></td></tr></table></figure></p>\n<p>看到了吧，之所以用到数组也是有原因的，把需要的依赖写在方法的前面，于是，应用到我们的reslove方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resolve: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, scope</span>) </span>&#123;</span><br><span class=\"line\">                isArray(func) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> last = func.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> deps = func.slice(<span class=\"number\">0</span>, last);</span><br><span class=\"line\">                    func = func[last]</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> FN_ARGS = <span class=\"regexp\">/^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> STRIP_COMMENTS = <span class=\"regexp\">/((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> fnText = func.toString().replace(STRIP_COMMENTS, <span class=\"string\">''</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> argDecl = fnText.match(FN_ARGS);</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> deps = argDecl[<span class=\"number\">1</span>].split(<span class=\"string\">','</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">var</span> arr = [];</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i &amp;lt; deps.length ; i++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.dependencies.hasOwnProperty(deps[i])) &#123;</span><br><span class=\"line\">                       arr.push(<span class=\"keyword\">this</span>.dependencies[deps[i]])</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">                    func.apply(scope || &#123;&#125;, arr);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure></p>\n<p>OK，到这里，便可以用我们的inject来模拟angular的依赖注入了，当然，真正angular的依赖注入还有很多东西，这里就不在详细描述了。</p>\n<p>以上观点都是我的个人见解，如有错误欢迎指正！</p>\n<p>&nbsp;</p>\n<p>完！</p>\n<p>&nbsp;</p>\n<p>参考资料：<a href=\"http://www.2cto.com/kf/201401/275236.html\" target=\"_blank\">http://www.2cto.com/kf/201401/275236.html</a></p>\n<p>&nbsp;</p>\n","site":{"data":{}},"excerpt":"<p>在众多的javascript框架中，多多少少都会使用一些思想，设计模式等等，下面就来说说其中的某些：</p>\n<p></p><h3>依赖注入：</h3><br>什么是依赖注入呢，我的理解，简单点就是说我的东西我自己并不像来拿着，我想要我依赖的那个人来帮我拿着，当我需要的时候，他给我就行了。当然这只是简单的理解，还是用代码解释比较清楚一些。<br>","more":"<br>这里有一个function，很简单。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p>\n<p>我们调用它：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a(<span class=\"string\">'abc'</span>)；<span class=\"comment\">//abc</span></span><br></pre></td></tr></table></figure></p>\n<p>那么，就像我上面说的，我能不能自己不传参数呢，例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a();<span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure></p>\n<p>如何才能实现让别人帮我们注入这个参数呢：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> inject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name,callback</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">     callback(name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>想这样，我们在定义参数的时候这样传：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = inject(<span class=\"string\">'abc'</span>,a)</span><br></pre></td></tr></table></figure></p>\n<p>我们再调用a方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a()；<span class=\"comment\">//abc</span></span><br></pre></td></tr></table></figure></p>\n<p>这其实就是最简单的依赖注入了，当然这么简单是不行的，其实这是很无意义的，下面我们来看一下高深的angularjs：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyController = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$scope</span>)</span>&#123;</span><br><span class=\"line\">        $scope.test = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面这段代码定义了angularjs的controller里面用到了scope，这样还看不出问题，在看下面：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyController = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$scope,$http</span>)</span>&#123;</span><br><span class=\"line\">        $scope.test = <span class=\"number\">1</span>;</span><br><span class=\"line\">        $http.get(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面这段代码在原来的基础上增加了http,那么问题就来了，angular在调用controller的时候怎么知道我需要scope还是http还是两个都需要呢，这就牵着到了angular里的依赖注入，那么我们来模拟一下。</p>\n<p>假设没有angular的情况下，我们：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyController = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$scope,$http</span>)</span>&#123;</span><br><span class=\"line\">        $scope.test = <span class=\"number\">1</span>;</span><br><span class=\"line\">        $http.get(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">MyController();<span class=\"comment\">//&lt;span style=\"color: #808080;\"&gt;undefined&lt;/span&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>肯定会报错的，然后我们来修改下我们的inject：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> inject = &#123;</span><br><span class=\"line\">            dependencies: &#123;&#125;,</span><br><span class=\"line\">            register: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key, value</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.dependencies[key] = value;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            resolve: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">deps, func, scope</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> arr = [];</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i &amp;lt; deps.length ; i++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.dependencies.hasOwnProperty(deps[i])) &#123;</span><br><span class=\"line\">                       arr.push(<span class=\"keyword\">this</span>.dependencies[deps[i]])</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(arr);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">                    func.apply(scope || &#123;&#125;, arr);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后我们模仿angular来预先注册几个模块：</p>\n<p><pre class=\"lang:default decode:true \">inject.register(‘$http’, {‘get’:function(){console.log(‘get’)}});<br>inject.register(‘$scope’, {‘test’:’’});<br>inject.register(‘$location’, {‘hash’:function(){console.log(‘hash’)}});<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">然后我们就可以注入了：</span><br><span class=\"line\">```javascript</span><br><span class=\"line\">MyController = inject.resolve([&apos;$http&apos;,&apos;$scope&apos;],MyController)；</span><br><span class=\"line\">MyController();</span><br></pre></td></tr></table></figure></pre></p>\n<p>我们只需要http和scope，所以我们只穿了两个，虽然这样看似解决了依赖注入，但是还有很多问题，比如我要交换两个参数的位置就不行了。</p>\n<p>于是翻看了angularjs的源码，找到了：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> FN_ARGS = <span class=\"regexp\">/^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> STRIP_COMMENTS = <span class=\"regexp\">/((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg</span>;</span><br><span class=\"line\">.....</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">annotate</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  .....</span><br><span class=\"line\">  fnText = fn.toString().replace(STRIP_COMMENTS, <span class=\"string\">''</span>);</span><br><span class=\"line\">  argDecl = fnText.match(FN_ARGS);</span><br><span class=\"line\">  .....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们忽略掉一些细节代码，只看我们需要的。annotate方法和我们的resolve方法很像。它转换传递过去的func为字符串，删除掉注释代码，然后抽取其中的参数。让我们看下它的执行结果，修改一下resolve方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resolve: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">deps, func, scope</span>) </span>&#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">var</span> FN_ARGS = <span class=\"regexp\">/^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m</span>;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> STRIP_COMMENTS = <span class=\"regexp\">/((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg</span>;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> fnText = func.toString().replace(STRIP_COMMENTS, <span class=\"string\">''</span>);</span><br><span class=\"line\">                <span class=\"keyword\">var</span> argDecl = fnText.match(FN_ARGS);</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(argDecl);</span><br><span class=\"line\">                </span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure></p>\n<p>打印出argDecl：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">\"function ($scope,$http)\"</span>, <span class=\"string\">\"$scope,$http\"</span>, <span class=\"attr\">index</span>: <span class=\"number\">0</span>, <span class=\"attr\">input</span>: <span class=\"string\">\"function ($scope,$http)&#123;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">$scope.test = 1;</span></span><br><span class=\"line\"><span class=\"string\">$http.get('');</span></span><br><span class=\"line\"><span class=\"string\">&#125;\"</span>]</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，这个数组拿到了func的参数，argDecl［1］ = “$scope,$http”;</p>\n<p>根据这个，我们来修改resolve：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resolve: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, scope</span>) </span>&#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">var</span> FN_ARGS = <span class=\"regexp\">/^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m</span>;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> STRIP_COMMENTS = <span class=\"regexp\">/((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg</span>;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> fnText = func.toString().replace(STRIP_COMMENTS, <span class=\"string\">''</span>);</span><br><span class=\"line\">                <span class=\"keyword\">var</span> argDecl = fnText.match(FN_ARGS);</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(argDecl);</span><br><span class=\"line\">                <span class=\"keyword\">var</span> deps = argDecl[<span class=\"number\">1</span>].split(<span class=\"string\">','</span>);</span><br><span class=\"line\">                <span class=\"keyword\">var</span> arr = [];</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i &amp;lt; deps.length ; i++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.dependencies.hasOwnProperty(deps[i])) &#123;</span><br><span class=\"line\">                       arr.push(<span class=\"keyword\">this</span>.dependencies[deps[i]])</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">                    func.apply(scope || &#123;&#125;, arr);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure></p>\n<p>OK，这次我们不用在意参数的顺序了，但是angular远比我们要想的多，大多数情况下，我们的js都是要压缩的，所以function的实参会被替换，如果是那样的话，我们这个方法的argDecl［1］ = “$scope,$http”;就会是argDecl［1］ = “r,t”;类似这样的变量，那么又该怎么解决呢？</p>\n<p>angular官方有这样的解释：</p>\n<p>为了克服压缩引起的问题，只要在控制器函数里面给$inject属性赋值一个依赖服务标识符的数组，就像：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyController = [<span class=\"string\">'$scope'</span>, <span class=\"string\">'$http'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$scope, $http</span>) </span>&#123; <span class=\"comment\">/* constructor body */</span> &#125;];</span><br></pre></td></tr></table></figure></p>\n<p>那么，用到我们这个方法里面又该怎么实现呢？那我们在看看angular的源码吧：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">....</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isArray(fn)) &#123;</span><br><span class=\"line\">    last = fn.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    assertArgFn(fn[last], <span class=\"string\">'fn'</span>)</span><br><span class=\"line\">    $inject = fn.slice(<span class=\"number\">0</span>, last);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">....</span><br></pre></td></tr></table></figure></p>\n<p>看到了吧，之所以用到数组也是有原因的，把需要的依赖写在方法的前面，于是，应用到我们的reslove方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resolve: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, scope</span>) </span>&#123;</span><br><span class=\"line\">                isArray(func) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> last = func.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> deps = func.slice(<span class=\"number\">0</span>, last);</span><br><span class=\"line\">                    func = func[last]</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> FN_ARGS = <span class=\"regexp\">/^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> STRIP_COMMENTS = <span class=\"regexp\">/((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> fnText = func.toString().replace(STRIP_COMMENTS, <span class=\"string\">''</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> argDecl = fnText.match(FN_ARGS);</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> deps = argDecl[<span class=\"number\">1</span>].split(<span class=\"string\">','</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">var</span> arr = [];</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i &amp;lt; deps.length ; i++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.dependencies.hasOwnProperty(deps[i])) &#123;</span><br><span class=\"line\">                       arr.push(<span class=\"keyword\">this</span>.dependencies[deps[i]])</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">                    func.apply(scope || &#123;&#125;, arr);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure></p>\n<p>OK，到这里，便可以用我们的inject来模拟angular的依赖注入了，当然，真正angular的依赖注入还有很多东西，这里就不在详细描述了。</p>\n<p>以上观点都是我的个人见解，如有错误欢迎指正！</p>\n<p>&nbsp;</p>\n<p>完！</p>\n<p>&nbsp;</p>\n<p>参考资料：<a href=\"http://www.2cto.com/kf/201401/275236.html\" target=\"_blank\">http://www.2cto.com/kf/201401/275236.html</a></p>\n<p>&nbsp;</p>"},{"title":"Canvas制作 撞球游戏 简单易学","date":"2014-06-12T10:54:33.000Z","_content":"演示地址：<iframe width=\"100%\" height=\"400\" src=\"http://jsfiddle.net/DkNb4/embedded/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n<!--more-->\n<span style=\"color: #362e2b;\">首先基本的canvas api 要掌握</span>\n\n核心代码：\n```javascript\nvar canvas = document.getElementById('canvas');  \nvar x = 50;  \nvar y = 50;  \nvar dx = 2;  \nvar dy = 4;  \nvar WIDTH;  \nvar HEIGHT;  \nvar ctx;  \nvar paddlex;  \nvar paddleh;  \nvar paddlew;  \nvar a;  \n  \nvar rectee = {w:60,h:10,data:[{  \n    x:10,  \n    y:10  \n},{  \n    x:80,  \n    y:10  \n},{  \n    x:150,  \n    y:10  \n},{  \n    x:220,  \n    y:10  \n},{  \n    x:10,  \n    y:30  \n},{  \n    x:80,  \n    y:30  \n},{  \n    x:150,  \n    y:30  \n},{  \n    x:220,  \n    y:30  \n}]};  \nfunction init_paddle() {  \n  paddlex = WIDTH / 2;  \n  paddleh = 10;  \n  paddlew = 75;  \n}  \nfunction init() {  \n  ctx = canvas.getContext(\"2d\");  \n  WIDTH = 300;  \n  HEIGHT = 300;  \n  canvas.addEventListener(\"mousemove\",mouseMove)  \n  a = setInterval(draw, 10);  \n}  \nfunction mouseMove (e) {  \n    var rect = e.currentTarget.getBoundingClientRect();  \n    var gravityPoint = {  \n            x: e.clientX - rect.left,  \n            y: e.clientY - rect.top  \n          };  \n    paddlex = gravityPoint.x - 30;  \n}  \nfunction circle(x,y,r) {  \n  ctx.beginPath();  \n  ctx.arc(x, y, r, 0, Math.PI*2, true);  \n  ctx.closePath();  \n  ctx.fill();  \n}  \n   \nfunction rect(x,y,w,h) {  \n  ctx.beginPath();  \n  ctx.rect(x,y,w,h);  \n  ctx.closePath();  \n  ctx.fill();  \n}  \n   \nfunction clear() {  \n  ctx.clearRect(0, 0, WIDTH, HEIGHT);  \n}  \n   \nfunction checkCollide(){  \n    for (var i = 0; i < rectee.data.length ; i++) {  \n        if (x <= (rectee.data[i].x + 60) && x >= (rectee.data[i].x) && rectee.data[i].y <= y && y <= (rectee.data[i].y + 10)) {  \n            rectee.data.splice(i,1);  \n            dy = -dy;  \n        }  \n      }  \n      \n}  \nfunction draw() {  \n  clear();  \n  circle(x, y, 10);  \n  rect(paddlex, 290, paddlew, paddleh);  \n  for (var i = 0; i < rectee.data.length ; i++) {  \n      rect(rectee.data[i].x, rectee.data[i].y, rectee.w, rectee.h);  \n  }  \n  if (rectee.data.length == 0) {  \n      clearInterval(a);  \n      alert(\"success!\");  \n  }  \n  checkCollide();  \n  if ((x + dx) > WIDTH || (x + dx) < 0 ) {  \n      dx = -dx;  \n  }  \n  if ((y + dy) < 0) {  \n      dy = -dy;  \n  } else if ((y + dy) >= 290) {  \n      if ((x + dx) >= paddlex && (x + dx) <= (paddlex + paddlew)) {  \n          dy = -dy;  \n      } else {  \n          clearInterval(a);  \n          alert(\"error!\");  \n      }  \n  }  \n    \n  x += dx;  \n  y += dy;  \n    \n}  \n  \ninit();  \ninit_paddle();\n```\n<span style=\"color: #362e2b;\">rectee定义并且存储了一组画被撞方块的位置和大小信息。</span>\n<p style=\"color: #362e2b;\">每一项的初始值必须定义在外部，这样可以实时修改他们的信息。</p>\n<p style=\"color: #362e2b;\">首先 画一个圆</p>\n\n```javascript\nfunction circle(x,y,r) {  \n  ctx.beginPath();  \n  ctx.arc(x, y, r, 0, Math.PI*2, true);  \n  ctx.closePath();  \n  ctx.fill();  \n}\n```\n<span style=\"color: #362e2b;\">很简单，直接调用这个方法。</span>\n<p style=\"color: #362e2b;\">然后画托板</p>\n\n```javascript\nfunction rect(x,y,w,h) {  \n  ctx.beginPath();  \n  ctx.rect(x,y,w,h);  \n  ctx.closePath();  \n  ctx.fill();  \n}\n```\n<span style=\"color: #362e2b;\">注意的是这个托板只能在canvas底部移动，所以传的Y值要固定，为canvas的高度减去托板的高度，很好理解。</span>\n<p style=\"color: #362e2b;\">然后让小球，也就是刚才画的圆形，不断移动。</p>\n<p style=\"color: #362e2b;\">思路就是setInterval方法每次画出小球的位置，然后调用clearRect来清除上一次的内容。</p>\n<p style=\"color: #362e2b;\">再次期间每次改变小球的位置，x y 的值就可以了。</p>\n<p style=\"color: #362e2b;\">然后判断当x 或者 y在临界边缘时，反弹，也就是代码里的 dx 和 dy取反就OK了。</p>\n\n```javascript\nif ((x + dx) > WIDTH || (x + dx) < 0 ) {  \n      dx = -dx;  \n  }  \n  if ((y + dy) < 0) {  \n      dy = -dy;  \n  } else if ((y + dy) >= 290) {  \n      if ((x + dx) >= paddlex && (x + dx) <= (paddlex + paddlew)) {  \n          dy = -dy;  \n      } else {  \n          clearInterval(a);  \n          alert(\"error!\");  \n      }  \n  }  \n    \n  x += dx;  \n  y += dy;</pre>\n\n```\n<span style=\"color: #362e2b;\">然后，绑定mousemove事件给canvas，由于canvas内部的元素不支持绑定事件，所以只能通过给canvas绑定，然后判断canvas内元素的位置来决定是否触发事件。许多canvas的事件绑定就是根据这个原理来的。</span>\n\n\n```javascriptfunction mouseMove (e) {  \n    var rect = e.currentTarget.getBoundingClientRect();  \n    var gravityPoint = {  \n            x: e.clientX - rect.left,  \n            y: e.clientY - rect.top  \n          };  \n    paddlex = gravityPoint.x - 30;  \n}\n```\n\n\n<span style=\"color: #362e2b;\">其中getBoundingClientRect为常用的判断canvas元素相对于body位置坐标的方法，直接用即可！</span>\n<p style=\"color: #362e2b;\">ok接下啦就是让被撞的方块消失。</p>\n\n```javascript\nfunction checkCollide(){  \n    for (var i = 0; i < rectee.data.length ; i++) {  \n        if (x <= (rectee.data[i].x + 60) && x >= (rectee.data[i].x) && rectee.data[i].y <= y && y <= (rectee.data[i].y + 10)) {  \n            rectee.data.splice(i,1);  \n            dy = -dy;  \n        }  \n      }  \n      \n}\n```\n<span style=\"color: #362e2b;\">同理，先遍历方块，然后通过坐标来判断，OK!</span>\n<p style=\"color: #362e2b;\">很简单吧！</p>\n<p style=\"color: #362e2b;\">完！</p>","source":"_posts/Canvas制作-撞球游戏-简单易学.md","raw":"---\ntitle: Canvas制作 撞球游戏 简单易学\ndate: 2014-06-12 18:54:33\ntags:\n- HTML5游戏\ncategories:\n- 115\n---\n演示地址：<iframe width=\"100%\" height=\"400\" src=\"http://jsfiddle.net/DkNb4/embedded/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n<!--more-->\n<span style=\"color: #362e2b;\">首先基本的canvas api 要掌握</span>\n\n核心代码：\n```javascript\nvar canvas = document.getElementById('canvas');  \nvar x = 50;  \nvar y = 50;  \nvar dx = 2;  \nvar dy = 4;  \nvar WIDTH;  \nvar HEIGHT;  \nvar ctx;  \nvar paddlex;  \nvar paddleh;  \nvar paddlew;  \nvar a;  \n  \nvar rectee = {w:60,h:10,data:[{  \n    x:10,  \n    y:10  \n},{  \n    x:80,  \n    y:10  \n},{  \n    x:150,  \n    y:10  \n},{  \n    x:220,  \n    y:10  \n},{  \n    x:10,  \n    y:30  \n},{  \n    x:80,  \n    y:30  \n},{  \n    x:150,  \n    y:30  \n},{  \n    x:220,  \n    y:30  \n}]};  \nfunction init_paddle() {  \n  paddlex = WIDTH / 2;  \n  paddleh = 10;  \n  paddlew = 75;  \n}  \nfunction init() {  \n  ctx = canvas.getContext(\"2d\");  \n  WIDTH = 300;  \n  HEIGHT = 300;  \n  canvas.addEventListener(\"mousemove\",mouseMove)  \n  a = setInterval(draw, 10);  \n}  \nfunction mouseMove (e) {  \n    var rect = e.currentTarget.getBoundingClientRect();  \n    var gravityPoint = {  \n            x: e.clientX - rect.left,  \n            y: e.clientY - rect.top  \n          };  \n    paddlex = gravityPoint.x - 30;  \n}  \nfunction circle(x,y,r) {  \n  ctx.beginPath();  \n  ctx.arc(x, y, r, 0, Math.PI*2, true);  \n  ctx.closePath();  \n  ctx.fill();  \n}  \n   \nfunction rect(x,y,w,h) {  \n  ctx.beginPath();  \n  ctx.rect(x,y,w,h);  \n  ctx.closePath();  \n  ctx.fill();  \n}  \n   \nfunction clear() {  \n  ctx.clearRect(0, 0, WIDTH, HEIGHT);  \n}  \n   \nfunction checkCollide(){  \n    for (var i = 0; i < rectee.data.length ; i++) {  \n        if (x <= (rectee.data[i].x + 60) && x >= (rectee.data[i].x) && rectee.data[i].y <= y && y <= (rectee.data[i].y + 10)) {  \n            rectee.data.splice(i,1);  \n            dy = -dy;  \n        }  \n      }  \n      \n}  \nfunction draw() {  \n  clear();  \n  circle(x, y, 10);  \n  rect(paddlex, 290, paddlew, paddleh);  \n  for (var i = 0; i < rectee.data.length ; i++) {  \n      rect(rectee.data[i].x, rectee.data[i].y, rectee.w, rectee.h);  \n  }  \n  if (rectee.data.length == 0) {  \n      clearInterval(a);  \n      alert(\"success!\");  \n  }  \n  checkCollide();  \n  if ((x + dx) > WIDTH || (x + dx) < 0 ) {  \n      dx = -dx;  \n  }  \n  if ((y + dy) < 0) {  \n      dy = -dy;  \n  } else if ((y + dy) >= 290) {  \n      if ((x + dx) >= paddlex && (x + dx) <= (paddlex + paddlew)) {  \n          dy = -dy;  \n      } else {  \n          clearInterval(a);  \n          alert(\"error!\");  \n      }  \n  }  \n    \n  x += dx;  \n  y += dy;  \n    \n}  \n  \ninit();  \ninit_paddle();\n```\n<span style=\"color: #362e2b;\">rectee定义并且存储了一组画被撞方块的位置和大小信息。</span>\n<p style=\"color: #362e2b;\">每一项的初始值必须定义在外部，这样可以实时修改他们的信息。</p>\n<p style=\"color: #362e2b;\">首先 画一个圆</p>\n\n```javascript\nfunction circle(x,y,r) {  \n  ctx.beginPath();  \n  ctx.arc(x, y, r, 0, Math.PI*2, true);  \n  ctx.closePath();  \n  ctx.fill();  \n}\n```\n<span style=\"color: #362e2b;\">很简单，直接调用这个方法。</span>\n<p style=\"color: #362e2b;\">然后画托板</p>\n\n```javascript\nfunction rect(x,y,w,h) {  \n  ctx.beginPath();  \n  ctx.rect(x,y,w,h);  \n  ctx.closePath();  \n  ctx.fill();  \n}\n```\n<span style=\"color: #362e2b;\">注意的是这个托板只能在canvas底部移动，所以传的Y值要固定，为canvas的高度减去托板的高度，很好理解。</span>\n<p style=\"color: #362e2b;\">然后让小球，也就是刚才画的圆形，不断移动。</p>\n<p style=\"color: #362e2b;\">思路就是setInterval方法每次画出小球的位置，然后调用clearRect来清除上一次的内容。</p>\n<p style=\"color: #362e2b;\">再次期间每次改变小球的位置，x y 的值就可以了。</p>\n<p style=\"color: #362e2b;\">然后判断当x 或者 y在临界边缘时，反弹，也就是代码里的 dx 和 dy取反就OK了。</p>\n\n```javascript\nif ((x + dx) > WIDTH || (x + dx) < 0 ) {  \n      dx = -dx;  \n  }  \n  if ((y + dy) < 0) {  \n      dy = -dy;  \n  } else if ((y + dy) >= 290) {  \n      if ((x + dx) >= paddlex && (x + dx) <= (paddlex + paddlew)) {  \n          dy = -dy;  \n      } else {  \n          clearInterval(a);  \n          alert(\"error!\");  \n      }  \n  }  \n    \n  x += dx;  \n  y += dy;</pre>\n\n```\n<span style=\"color: #362e2b;\">然后，绑定mousemove事件给canvas，由于canvas内部的元素不支持绑定事件，所以只能通过给canvas绑定，然后判断canvas内元素的位置来决定是否触发事件。许多canvas的事件绑定就是根据这个原理来的。</span>\n\n\n```javascriptfunction mouseMove (e) {  \n    var rect = e.currentTarget.getBoundingClientRect();  \n    var gravityPoint = {  \n            x: e.clientX - rect.left,  \n            y: e.clientY - rect.top  \n          };  \n    paddlex = gravityPoint.x - 30;  \n}\n```\n\n\n<span style=\"color: #362e2b;\">其中getBoundingClientRect为常用的判断canvas元素相对于body位置坐标的方法，直接用即可！</span>\n<p style=\"color: #362e2b;\">ok接下啦就是让被撞的方块消失。</p>\n\n```javascript\nfunction checkCollide(){  \n    for (var i = 0; i < rectee.data.length ; i++) {  \n        if (x <= (rectee.data[i].x + 60) && x >= (rectee.data[i].x) && rectee.data[i].y <= y && y <= (rectee.data[i].y + 10)) {  \n            rectee.data.splice(i,1);  \n            dy = -dy;  \n        }  \n      }  \n      \n}\n```\n<span style=\"color: #362e2b;\">同理，先遍历方块，然后通过坐标来判断，OK!</span>\n<p style=\"color: #362e2b;\">很简单吧！</p>\n<p style=\"color: #362e2b;\">完！</p>","slug":"Canvas制作-撞球游戏-简单易学","published":1,"updated":"2019-04-02T16:52:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434pza00042wvjmjyg4krh","content":"<p>演示地址：<iframe width=\"100%\" height=\"400\" src=\"http://jsfiddle.net/DkNb4/embedded/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe></p>\n<a id=\"more\"></a>\n<p><span style=\"color: #362e2b;\">首先基本的canvas api 要掌握</span></p>\n<p>核心代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'canvas'</span>);  </span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">50</span>;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> y = <span class=\"number\">50</span>;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> dx = <span class=\"number\">2</span>;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> dy = <span class=\"number\">4</span>;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> WIDTH;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> HEIGHT;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> ctx;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> paddlex;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> paddleh;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> paddlew;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> a;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> rectee = &#123;<span class=\"attr\">w</span>:<span class=\"number\">60</span>,<span class=\"attr\">h</span>:<span class=\"number\">10</span>,<span class=\"attr\">data</span>:[&#123;  </span><br><span class=\"line\">    x:<span class=\"number\">10</span>,  </span><br><span class=\"line\">    y:<span class=\"number\">10</span>  </span><br><span class=\"line\">&#125;,&#123;  </span><br><span class=\"line\">    x:<span class=\"number\">80</span>,  </span><br><span class=\"line\">    y:<span class=\"number\">10</span>  </span><br><span class=\"line\">&#125;,&#123;  </span><br><span class=\"line\">    x:<span class=\"number\">150</span>,  </span><br><span class=\"line\">    y:<span class=\"number\">10</span>  </span><br><span class=\"line\">&#125;,&#123;  </span><br><span class=\"line\">    x:<span class=\"number\">220</span>,  </span><br><span class=\"line\">    y:<span class=\"number\">10</span>  </span><br><span class=\"line\">&#125;,&#123;  </span><br><span class=\"line\">    x:<span class=\"number\">10</span>,  </span><br><span class=\"line\">    y:<span class=\"number\">30</span>  </span><br><span class=\"line\">&#125;,&#123;  </span><br><span class=\"line\">    x:<span class=\"number\">80</span>,  </span><br><span class=\"line\">    y:<span class=\"number\">30</span>  </span><br><span class=\"line\">&#125;,&#123;  </span><br><span class=\"line\">    x:<span class=\"number\">150</span>,  </span><br><span class=\"line\">    y:<span class=\"number\">30</span>  </span><br><span class=\"line\">&#125;,&#123;  </span><br><span class=\"line\">    x:<span class=\"number\">220</span>,  </span><br><span class=\"line\">    y:<span class=\"number\">30</span>  </span><br><span class=\"line\">&#125;]&#125;;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">init_paddle</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\">  paddlex = WIDTH / <span class=\"number\">2</span>;  </span><br><span class=\"line\">  paddleh = <span class=\"number\">10</span>;  </span><br><span class=\"line\">  paddlew = <span class=\"number\">75</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">init</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\">  ctx = canvas.getContext(<span class=\"string\">\"2d\"</span>);  </span><br><span class=\"line\">  WIDTH = <span class=\"number\">300</span>;  </span><br><span class=\"line\">  HEIGHT = <span class=\"number\">300</span>;  </span><br><span class=\"line\">  canvas.addEventListener(<span class=\"string\">\"mousemove\"</span>,mouseMove)  </span><br><span class=\"line\">  a = setInterval(draw, <span class=\"number\">10</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mouseMove</span> (<span class=\"params\">e</span>) </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">var</span> rect = e.currentTarget.getBoundingClientRect();  </span><br><span class=\"line\">    <span class=\"keyword\">var</span> gravityPoint = &#123;  </span><br><span class=\"line\">            x: e.clientX - rect.left,  </span><br><span class=\"line\">            y: e.clientY - rect.top  </span><br><span class=\"line\">          &#125;;  </span><br><span class=\"line\">    paddlex = gravityPoint.x - <span class=\"number\">30</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">circle</span>(<span class=\"params\">x,y,r</span>) </span>&#123;  </span><br><span class=\"line\">  ctx.beginPath();  </span><br><span class=\"line\">  ctx.arc(x, y, r, <span class=\"number\">0</span>, <span class=\"built_in\">Math</span>.PI*<span class=\"number\">2</span>, <span class=\"literal\">true</span>);  </span><br><span class=\"line\">  ctx.closePath();  </span><br><span class=\"line\">  ctx.fill();  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rect</span>(<span class=\"params\">x,y,w,h</span>) </span>&#123;  </span><br><span class=\"line\">  ctx.beginPath();  </span><br><span class=\"line\">  ctx.rect(x,y,w,h);  </span><br><span class=\"line\">  ctx.closePath();  </span><br><span class=\"line\">  ctx.fill();  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clear</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\">  ctx.clearRect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, WIDTH, HEIGHT);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkCollide</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; rectee.data.length ; i++) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &lt;= (rectee.data[i].x + <span class=\"number\">60</span>) &amp;&amp; x &gt;= (rectee.data[i].x) &amp;&amp; rectee.data[i].y &lt;= y &amp;&amp; y &lt;= (rectee.data[i].y + <span class=\"number\">10</span>)) &#123;  </span><br><span class=\"line\">            rectee.data.splice(i,<span class=\"number\">1</span>);  </span><br><span class=\"line\">            dy = -dy;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">draw</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\">  clear();  </span><br><span class=\"line\">  circle(x, y, <span class=\"number\">10</span>);  </span><br><span class=\"line\">  rect(paddlex, <span class=\"number\">290</span>, paddlew, paddleh);  </span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; rectee.data.length ; i++) &#123;  </span><br><span class=\"line\">      rect(rectee.data[i].x, rectee.data[i].y, rectee.w, rectee.h);  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (rectee.data.length == <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">      clearInterval(a);  </span><br><span class=\"line\">      alert(<span class=\"string\">\"success!\"</span>);  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  checkCollide();  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((x + dx) &gt; WIDTH || (x + dx) &lt; <span class=\"number\">0</span> ) &#123;  </span><br><span class=\"line\">      dx = -dx;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((y + dy) &lt; <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">      dy = -dy;  </span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((y + dy) &gt;= <span class=\"number\">290</span>) &#123;  </span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((x + dx) &gt;= paddlex &amp;&amp; (x + dx) &lt;= (paddlex + paddlew)) &#123;  </span><br><span class=\"line\">          dy = -dy;  </span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">          clearInterval(a);  </span><br><span class=\"line\">          alert(<span class=\"string\">\"error!\"</span>);  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">  x += dx;  </span><br><span class=\"line\">  y += dy;  </span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">init();  </span><br><span class=\"line\">init_paddle();</span><br></pre></td></tr></table></figure></p>\n<p><span style=\"color: #362e2b;\">rectee定义并且存储了一组画被撞方块的位置和大小信息。</span></p>\n<p style=\"color: #362e2b;\">每一项的初始值必须定义在外部，这样可以实时修改他们的信息。</p><br><p style=\"color: #362e2b;\">首先 画一个圆</p>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">circle</span>(<span class=\"params\">x,y,r</span>) </span>&#123;  </span><br><span class=\"line\">  ctx.beginPath();  </span><br><span class=\"line\">  ctx.arc(x, y, r, <span class=\"number\">0</span>, <span class=\"built_in\">Math</span>.PI*<span class=\"number\">2</span>, <span class=\"literal\">true</span>);  </span><br><span class=\"line\">  ctx.closePath();  </span><br><span class=\"line\">  ctx.fill();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><span style=\"color: #362e2b;\">很简单，直接调用这个方法。</span></p>\n<p style=\"color: #362e2b;\">然后画托板</p>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rect</span>(<span class=\"params\">x,y,w,h</span>) </span>&#123;  </span><br><span class=\"line\">  ctx.beginPath();  </span><br><span class=\"line\">  ctx.rect(x,y,w,h);  </span><br><span class=\"line\">  ctx.closePath();  </span><br><span class=\"line\">  ctx.fill();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><span style=\"color: #362e2b;\">注意的是这个托板只能在canvas底部移动，所以传的Y值要固定，为canvas的高度减去托板的高度，很好理解。</span></p>\n<p style=\"color: #362e2b;\">然后让小球，也就是刚才画的圆形，不断移动。</p><br><p style=\"color: #362e2b;\">思路就是setInterval方法每次画出小球的位置，然后调用clearRect来清除上一次的内容。</p><br><p style=\"color: #362e2b;\">再次期间每次改变小球的位置，x y 的值就可以了。</p><br><p style=\"color: #362e2b;\">然后判断当x 或者 y在临界边缘时，反弹，也就是代码里的 dx 和 dy取反就OK了。</p>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((x + dx) &gt; WIDTH || (x + dx) &lt; <span class=\"number\">0</span> ) &#123;  </span><br><span class=\"line\">      dx = -dx;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((y + dy) &lt; <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">      dy = -dy;  </span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((y + dy) &gt;= <span class=\"number\">290</span>) &#123;  </span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((x + dx) &gt;= paddlex &amp;&amp; (x + dx) &lt;= (paddlex + paddlew)) &#123;  </span><br><span class=\"line\">          dy = -dy;  </span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">          clearInterval(a);  </span><br><span class=\"line\">          alert(<span class=\"string\">\"error!\"</span>);  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">  x += dx;  </span><br><span class=\"line\">  y += dy;&lt;/pre&gt;</span><br></pre></td></tr></table></figure>\n<p><span style=\"color: #362e2b;\">然后，绑定mousemove事件给canvas，由于canvas内部的元素不支持绑定事件，所以只能通过给canvas绑定，然后判断canvas内元素的位置来决定是否触发事件。许多canvas的事件绑定就是根据这个原理来的。</span></p>\n<figure class=\"highlight plain\"><figcaption><span>mouseMove (e) &#123;  </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    var rect = e.currentTarget.getBoundingClientRect();  </span><br><span class=\"line\">    var gravityPoint = &#123;  </span><br><span class=\"line\">            x: e.clientX - rect.left,  </span><br><span class=\"line\">            y: e.clientY - rect.top  </span><br><span class=\"line\">          &#125;;  </span><br><span class=\"line\">    paddlex = gravityPoint.x - 30;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><span style=\"color: #362e2b;\">其中getBoundingClientRect为常用的判断canvas元素相对于body位置坐标的方法，直接用即可！</span></p>\n<p style=\"color: #362e2b;\">ok接下啦就是让被撞的方块消失。</p>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkCollide</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; rectee.data.length ; i++) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &lt;= (rectee.data[i].x + <span class=\"number\">60</span>) &amp;&amp; x &gt;= (rectee.data[i].x) &amp;&amp; rectee.data[i].y &lt;= y &amp;&amp; y &lt;= (rectee.data[i].y + <span class=\"number\">10</span>)) &#123;  </span><br><span class=\"line\">            rectee.data.splice(i,<span class=\"number\">1</span>);  </span><br><span class=\"line\">            dy = -dy;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><span style=\"color: #362e2b;\">同理，先遍历方块，然后通过坐标来判断，OK!</span></p>\n<p style=\"color: #362e2b;\">很简单吧！</p><br><p style=\"color: #362e2b;\">完！</p>","site":{"data":{}},"excerpt":"<p>演示地址：<iframe width=\"100%\" height=\"400\" src=\"http://jsfiddle.net/DkNb4/embedded/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe></p>","more":"<p><span style=\"color: #362e2b;\">首先基本的canvas api 要掌握</span></p>\n<p>核心代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'canvas'</span>);  </span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">50</span>;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> y = <span class=\"number\">50</span>;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> dx = <span class=\"number\">2</span>;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> dy = <span class=\"number\">4</span>;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> WIDTH;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> HEIGHT;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> ctx;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> paddlex;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> paddleh;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> paddlew;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> a;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> rectee = &#123;<span class=\"attr\">w</span>:<span class=\"number\">60</span>,<span class=\"attr\">h</span>:<span class=\"number\">10</span>,<span class=\"attr\">data</span>:[&#123;  </span><br><span class=\"line\">    x:<span class=\"number\">10</span>,  </span><br><span class=\"line\">    y:<span class=\"number\">10</span>  </span><br><span class=\"line\">&#125;,&#123;  </span><br><span class=\"line\">    x:<span class=\"number\">80</span>,  </span><br><span class=\"line\">    y:<span class=\"number\">10</span>  </span><br><span class=\"line\">&#125;,&#123;  </span><br><span class=\"line\">    x:<span class=\"number\">150</span>,  </span><br><span class=\"line\">    y:<span class=\"number\">10</span>  </span><br><span class=\"line\">&#125;,&#123;  </span><br><span class=\"line\">    x:<span class=\"number\">220</span>,  </span><br><span class=\"line\">    y:<span class=\"number\">10</span>  </span><br><span class=\"line\">&#125;,&#123;  </span><br><span class=\"line\">    x:<span class=\"number\">10</span>,  </span><br><span class=\"line\">    y:<span class=\"number\">30</span>  </span><br><span class=\"line\">&#125;,&#123;  </span><br><span class=\"line\">    x:<span class=\"number\">80</span>,  </span><br><span class=\"line\">    y:<span class=\"number\">30</span>  </span><br><span class=\"line\">&#125;,&#123;  </span><br><span class=\"line\">    x:<span class=\"number\">150</span>,  </span><br><span class=\"line\">    y:<span class=\"number\">30</span>  </span><br><span class=\"line\">&#125;,&#123;  </span><br><span class=\"line\">    x:<span class=\"number\">220</span>,  </span><br><span class=\"line\">    y:<span class=\"number\">30</span>  </span><br><span class=\"line\">&#125;]&#125;;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">init_paddle</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\">  paddlex = WIDTH / <span class=\"number\">2</span>;  </span><br><span class=\"line\">  paddleh = <span class=\"number\">10</span>;  </span><br><span class=\"line\">  paddlew = <span class=\"number\">75</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">init</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\">  ctx = canvas.getContext(<span class=\"string\">\"2d\"</span>);  </span><br><span class=\"line\">  WIDTH = <span class=\"number\">300</span>;  </span><br><span class=\"line\">  HEIGHT = <span class=\"number\">300</span>;  </span><br><span class=\"line\">  canvas.addEventListener(<span class=\"string\">\"mousemove\"</span>,mouseMove)  </span><br><span class=\"line\">  a = setInterval(draw, <span class=\"number\">10</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mouseMove</span> (<span class=\"params\">e</span>) </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">var</span> rect = e.currentTarget.getBoundingClientRect();  </span><br><span class=\"line\">    <span class=\"keyword\">var</span> gravityPoint = &#123;  </span><br><span class=\"line\">            x: e.clientX - rect.left,  </span><br><span class=\"line\">            y: e.clientY - rect.top  </span><br><span class=\"line\">          &#125;;  </span><br><span class=\"line\">    paddlex = gravityPoint.x - <span class=\"number\">30</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">circle</span>(<span class=\"params\">x,y,r</span>) </span>&#123;  </span><br><span class=\"line\">  ctx.beginPath();  </span><br><span class=\"line\">  ctx.arc(x, y, r, <span class=\"number\">0</span>, <span class=\"built_in\">Math</span>.PI*<span class=\"number\">2</span>, <span class=\"literal\">true</span>);  </span><br><span class=\"line\">  ctx.closePath();  </span><br><span class=\"line\">  ctx.fill();  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rect</span>(<span class=\"params\">x,y,w,h</span>) </span>&#123;  </span><br><span class=\"line\">  ctx.beginPath();  </span><br><span class=\"line\">  ctx.rect(x,y,w,h);  </span><br><span class=\"line\">  ctx.closePath();  </span><br><span class=\"line\">  ctx.fill();  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clear</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\">  ctx.clearRect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, WIDTH, HEIGHT);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkCollide</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; rectee.data.length ; i++) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &lt;= (rectee.data[i].x + <span class=\"number\">60</span>) &amp;&amp; x &gt;= (rectee.data[i].x) &amp;&amp; rectee.data[i].y &lt;= y &amp;&amp; y &lt;= (rectee.data[i].y + <span class=\"number\">10</span>)) &#123;  </span><br><span class=\"line\">            rectee.data.splice(i,<span class=\"number\">1</span>);  </span><br><span class=\"line\">            dy = -dy;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">draw</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\">  clear();  </span><br><span class=\"line\">  circle(x, y, <span class=\"number\">10</span>);  </span><br><span class=\"line\">  rect(paddlex, <span class=\"number\">290</span>, paddlew, paddleh);  </span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; rectee.data.length ; i++) &#123;  </span><br><span class=\"line\">      rect(rectee.data[i].x, rectee.data[i].y, rectee.w, rectee.h);  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (rectee.data.length == <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">      clearInterval(a);  </span><br><span class=\"line\">      alert(<span class=\"string\">\"success!\"</span>);  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  checkCollide();  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((x + dx) &gt; WIDTH || (x + dx) &lt; <span class=\"number\">0</span> ) &#123;  </span><br><span class=\"line\">      dx = -dx;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((y + dy) &lt; <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">      dy = -dy;  </span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((y + dy) &gt;= <span class=\"number\">290</span>) &#123;  </span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((x + dx) &gt;= paddlex &amp;&amp; (x + dx) &lt;= (paddlex + paddlew)) &#123;  </span><br><span class=\"line\">          dy = -dy;  </span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">          clearInterval(a);  </span><br><span class=\"line\">          alert(<span class=\"string\">\"error!\"</span>);  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">  x += dx;  </span><br><span class=\"line\">  y += dy;  </span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">init();  </span><br><span class=\"line\">init_paddle();</span><br></pre></td></tr></table></figure></p>\n<p><span style=\"color: #362e2b;\">rectee定义并且存储了一组画被撞方块的位置和大小信息。</span></p>\n<p style=\"color: #362e2b;\">每一项的初始值必须定义在外部，这样可以实时修改他们的信息。</p><br><p style=\"color: #362e2b;\">首先 画一个圆</p>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">circle</span>(<span class=\"params\">x,y,r</span>) </span>&#123;  </span><br><span class=\"line\">  ctx.beginPath();  </span><br><span class=\"line\">  ctx.arc(x, y, r, <span class=\"number\">0</span>, <span class=\"built_in\">Math</span>.PI*<span class=\"number\">2</span>, <span class=\"literal\">true</span>);  </span><br><span class=\"line\">  ctx.closePath();  </span><br><span class=\"line\">  ctx.fill();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><span style=\"color: #362e2b;\">很简单，直接调用这个方法。</span></p>\n<p style=\"color: #362e2b;\">然后画托板</p>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rect</span>(<span class=\"params\">x,y,w,h</span>) </span>&#123;  </span><br><span class=\"line\">  ctx.beginPath();  </span><br><span class=\"line\">  ctx.rect(x,y,w,h);  </span><br><span class=\"line\">  ctx.closePath();  </span><br><span class=\"line\">  ctx.fill();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><span style=\"color: #362e2b;\">注意的是这个托板只能在canvas底部移动，所以传的Y值要固定，为canvas的高度减去托板的高度，很好理解。</span></p>\n<p style=\"color: #362e2b;\">然后让小球，也就是刚才画的圆形，不断移动。</p><br><p style=\"color: #362e2b;\">思路就是setInterval方法每次画出小球的位置，然后调用clearRect来清除上一次的内容。</p><br><p style=\"color: #362e2b;\">再次期间每次改变小球的位置，x y 的值就可以了。</p><br><p style=\"color: #362e2b;\">然后判断当x 或者 y在临界边缘时，反弹，也就是代码里的 dx 和 dy取反就OK了。</p>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((x + dx) &gt; WIDTH || (x + dx) &lt; <span class=\"number\">0</span> ) &#123;  </span><br><span class=\"line\">      dx = -dx;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((y + dy) &lt; <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">      dy = -dy;  </span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((y + dy) &gt;= <span class=\"number\">290</span>) &#123;  </span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((x + dx) &gt;= paddlex &amp;&amp; (x + dx) &lt;= (paddlex + paddlew)) &#123;  </span><br><span class=\"line\">          dy = -dy;  </span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">          clearInterval(a);  </span><br><span class=\"line\">          alert(<span class=\"string\">\"error!\"</span>);  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">  x += dx;  </span><br><span class=\"line\">  y += dy;&lt;/pre&gt;</span><br></pre></td></tr></table></figure>\n<p><span style=\"color: #362e2b;\">然后，绑定mousemove事件给canvas，由于canvas内部的元素不支持绑定事件，所以只能通过给canvas绑定，然后判断canvas内元素的位置来决定是否触发事件。许多canvas的事件绑定就是根据这个原理来的。</span></p>\n<figure class=\"highlight plain\"><figcaption><span>mouseMove (e) &#123;  </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    var rect = e.currentTarget.getBoundingClientRect();  </span><br><span class=\"line\">    var gravityPoint = &#123;  </span><br><span class=\"line\">            x: e.clientX - rect.left,  </span><br><span class=\"line\">            y: e.clientY - rect.top  </span><br><span class=\"line\">          &#125;;  </span><br><span class=\"line\">    paddlex = gravityPoint.x - 30;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><span style=\"color: #362e2b;\">其中getBoundingClientRect为常用的判断canvas元素相对于body位置坐标的方法，直接用即可！</span></p>\n<p style=\"color: #362e2b;\">ok接下啦就是让被撞的方块消失。</p>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkCollide</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; rectee.data.length ; i++) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &lt;= (rectee.data[i].x + <span class=\"number\">60</span>) &amp;&amp; x &gt;= (rectee.data[i].x) &amp;&amp; rectee.data[i].y &lt;= y &amp;&amp; y &lt;= (rectee.data[i].y + <span class=\"number\">10</span>)) &#123;  </span><br><span class=\"line\">            rectee.data.splice(i,<span class=\"number\">1</span>);  </span><br><span class=\"line\">            dy = -dy;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><span style=\"color: #362e2b;\">同理，先遍历方块，然后通过坐标来判断，OK!</span></p>\n<p style=\"color: #362e2b;\">很简单吧！</p><br><p style=\"color: #362e2b;\">完！</p>"},{"title":"Canvas制作点赞送心动画","date":"2018-06-01T15:00:13.000Z","photos":["https://qiniu.nihaoshijie.com.cn/h52015031913.png"],"_content":"\n### 先看看效果\n\n![](https://qiniu.nihaoshijie.com.cn/1527477112_60_w305_h232.gif)\n<!--more-->\n![](https://qiniu.nihaoshijie.com.cn/1527476652_7_w380_h433.gif)\n### 实现原理\n\n1.动画中每颗心都有自己的透明度，位移，角度，缩放的变化动画，针对这些动画，可以分别调用canvas的相关API：\n\n```javascript\n\nctx.translate(this.x, this.y);\nctx.rotate(this.angle);\nctx.scale(this.scale, this.scale);\nctx.globalAlpha = this.opacity;\n```\n\n2.在有大于1颗心的情况时，针对每颗心，在实现角度，缩放时必须要保存上一次canvas的状态，改变完成之后在恢复：\n\n```javascript\n\nctx.save();\nctx.translate(this.x, this.y);\nctx.rotate(this.angle);\nctx.scale(this.scale, this.scale);\nctx.globalAlpha = this.opacity;\nctx.restore();\n```\n\n3.计算心位移路径(3次被塞尔曲线)\n公式：![](https://qiniu.nihaoshijie.com.cn/images/1527478364_96_w1098_h68.png)\n转换成js代码计算心的x,y方向上的位移：\n\n```javascript\n\n    /**\n     * 获得贝塞尔曲线路径\n     * 一共4个点\n     */\n     function getBezierLine(heart){\n         var obj = heart.bezierPoint;\n         var p0 = obj.p0;\n         var p1 = obj.p1;\n         var p2 = obj.p2;\n         var p3 = obj.p3;\n         var t = heart.bezierDis;\n         var cx = 3 * (p1.x - p0.x),\n         bx = 3 * (p2.x - p1.x) - cx,\n         ax = p3.x - p0.x - cx - bx,\n\n    cy = 3 * (p1.y - p0.y),\n    by = 3 * (p2.y - p1.y) - cy,\n    ay = p3.y - p0.y - cy - by,\n\n    xt = ax * (t * t * t) + bx * (t * t) + cx * t + p0.x,\n    yt = ay * (t * t * t) + by * (t * t) + cy * t + p0.y;\n\n    heart.bezierDis += heart.speed;\n\n    return {\n    xt: xt,\n    yt: yt\n    }\n}\n\n```\n\n路径如图所示：\n![](https://qiniu.nihaoshijie.com.cn/1527478501_6_w166_h306.png)\n\n根据曲线路径方法可以实现心的运动轨迹：\n![](https://qiniu.nihaoshijie.com.cn/1527479519_2_w305_h232.gif)\n\n4.针对每一帧需要动态修改，心的位移，角度，和缩放：\n\n```javascript\n\n/**\n* 计算缩放角度的方法\n*/\nfunction getFScale(heart){\n    let _scale = heart.scale;\n\n    // 随着距离起始点的距离增加，scale不断变大\n    let dis = heart.orignY - heart.y;\n    _scale = (dis / heart.scaleDis);\n\n    // 当大于设置的阈值时变成1\n    if (dis >= heart.scaleDis) {\n        _scale = 1;\n    }\n\n    return _scale;\n}\n```\n\n5.计算心角度变化\n\n```javascript\n\n/**\n* 计算心左右摇摆的方法\n*/\nfunction rangeAngle(heart) {\n    let _angle = heart.angle;\n    // 心介于[start, end]之间不断变化角度\n    if(_angle >= heart.angelEnd) {\n    // 角度不断变小，向左摇摆\n    heart.angleLeft = false;\n    } else if (_angle <= heart.angelBegin){\n    // 角度不断变大，向又摇摆\n    heart.angleLeft = true;\n    }\n    // 动态改变角度\n    if (heart.angleLeft) {\n    _angle = _angle + 1;\n    } else {\n    _angle = _angle - 1;\n    }\n    return _angle;\n}\n\n```\n\n\n\n### 组件化\n整个组件代码不超过200行，相较于使用css3实现更加轻便，dom少，性能更好。\n组件地址：https://github.com/lvming6816077/like-heart\n","source":"_posts/Canvas制作点赞送心动画.md","raw":"---\ntitle: Canvas制作点赞送心动画\ndate: 2018-06-01 23:00:13\ntags:\n- canvas\n- 点赞\ncategories:\n- 802\nphotos: https://qiniu.nihaoshijie.com.cn/h52015031913.png\n---\n\n### 先看看效果\n\n![](https://qiniu.nihaoshijie.com.cn/1527477112_60_w305_h232.gif)\n<!--more-->\n![](https://qiniu.nihaoshijie.com.cn/1527476652_7_w380_h433.gif)\n### 实现原理\n\n1.动画中每颗心都有自己的透明度，位移，角度，缩放的变化动画，针对这些动画，可以分别调用canvas的相关API：\n\n```javascript\n\nctx.translate(this.x, this.y);\nctx.rotate(this.angle);\nctx.scale(this.scale, this.scale);\nctx.globalAlpha = this.opacity;\n```\n\n2.在有大于1颗心的情况时，针对每颗心，在实现角度，缩放时必须要保存上一次canvas的状态，改变完成之后在恢复：\n\n```javascript\n\nctx.save();\nctx.translate(this.x, this.y);\nctx.rotate(this.angle);\nctx.scale(this.scale, this.scale);\nctx.globalAlpha = this.opacity;\nctx.restore();\n```\n\n3.计算心位移路径(3次被塞尔曲线)\n公式：![](https://qiniu.nihaoshijie.com.cn/images/1527478364_96_w1098_h68.png)\n转换成js代码计算心的x,y方向上的位移：\n\n```javascript\n\n    /**\n     * 获得贝塞尔曲线路径\n     * 一共4个点\n     */\n     function getBezierLine(heart){\n         var obj = heart.bezierPoint;\n         var p0 = obj.p0;\n         var p1 = obj.p1;\n         var p2 = obj.p2;\n         var p3 = obj.p3;\n         var t = heart.bezierDis;\n         var cx = 3 * (p1.x - p0.x),\n         bx = 3 * (p2.x - p1.x) - cx,\n         ax = p3.x - p0.x - cx - bx,\n\n    cy = 3 * (p1.y - p0.y),\n    by = 3 * (p2.y - p1.y) - cy,\n    ay = p3.y - p0.y - cy - by,\n\n    xt = ax * (t * t * t) + bx * (t * t) + cx * t + p0.x,\n    yt = ay * (t * t * t) + by * (t * t) + cy * t + p0.y;\n\n    heart.bezierDis += heart.speed;\n\n    return {\n    xt: xt,\n    yt: yt\n    }\n}\n\n```\n\n路径如图所示：\n![](https://qiniu.nihaoshijie.com.cn/1527478501_6_w166_h306.png)\n\n根据曲线路径方法可以实现心的运动轨迹：\n![](https://qiniu.nihaoshijie.com.cn/1527479519_2_w305_h232.gif)\n\n4.针对每一帧需要动态修改，心的位移，角度，和缩放：\n\n```javascript\n\n/**\n* 计算缩放角度的方法\n*/\nfunction getFScale(heart){\n    let _scale = heart.scale;\n\n    // 随着距离起始点的距离增加，scale不断变大\n    let dis = heart.orignY - heart.y;\n    _scale = (dis / heart.scaleDis);\n\n    // 当大于设置的阈值时变成1\n    if (dis >= heart.scaleDis) {\n        _scale = 1;\n    }\n\n    return _scale;\n}\n```\n\n5.计算心角度变化\n\n```javascript\n\n/**\n* 计算心左右摇摆的方法\n*/\nfunction rangeAngle(heart) {\n    let _angle = heart.angle;\n    // 心介于[start, end]之间不断变化角度\n    if(_angle >= heart.angelEnd) {\n    // 角度不断变小，向左摇摆\n    heart.angleLeft = false;\n    } else if (_angle <= heart.angelBegin){\n    // 角度不断变大，向又摇摆\n    heart.angleLeft = true;\n    }\n    // 动态改变角度\n    if (heart.angleLeft) {\n    _angle = _angle + 1;\n    } else {\n    _angle = _angle - 1;\n    }\n    return _angle;\n}\n\n```\n\n\n\n### 组件化\n整个组件代码不超过200行，相较于使用css3实现更加轻便，dom少，性能更好。\n组件地址：https://github.com/lvming6816077/like-heart\n","slug":"Canvas制作点赞送心动画","published":1,"updated":"2020-04-30T16:10:08.000Z","comments":1,"layout":"post","link":"","_id":"ckx434pzf00082wvjen46uibo","content":"<h3><span id=\"先看看效果\">先看看效果</span></h3><p><img src=\"https://qiniu.nihaoshijie.com.cn/1527477112_60_w305_h232.gif\" alt><br><a id=\"more\"></a><br><img src=\"https://qiniu.nihaoshijie.com.cn/1527476652_7_w380_h433.gif\" alt></p>\n<h3><span id=\"实现原理\">实现原理</span></h3><p>1.动画中每颗心都有自己的透明度，位移，角度，缩放的变化动画，针对这些动画，可以分别调用canvas的相关API：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ctx.translate(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\">ctx.rotate(<span class=\"keyword\">this</span>.angle);</span><br><span class=\"line\">ctx.scale(<span class=\"keyword\">this</span>.scale, <span class=\"keyword\">this</span>.scale);</span><br><span class=\"line\">ctx.globalAlpha = <span class=\"keyword\">this</span>.opacity;</span><br></pre></td></tr></table></figure>\n<p>2.在有大于1颗心的情况时，针对每颗心，在实现角度，缩放时必须要保存上一次canvas的状态，改变完成之后在恢复：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ctx.save();</span><br><span class=\"line\">ctx.translate(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\">ctx.rotate(<span class=\"keyword\">this</span>.angle);</span><br><span class=\"line\">ctx.scale(<span class=\"keyword\">this</span>.scale, <span class=\"keyword\">this</span>.scale);</span><br><span class=\"line\">ctx.globalAlpha = <span class=\"keyword\">this</span>.opacity;</span><br><span class=\"line\">ctx.restore();</span><br></pre></td></tr></table></figure>\n<p>3.计算心位移路径(3次被塞尔曲线)<br>公式：<img src=\"https://qiniu.nihaoshijie.com.cn/images/1527478364_96_w1098_h68.png\" alt><br>转换成js代码计算心的x,y方向上的位移：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获得贝塞尔曲线路径</span></span><br><span class=\"line\"><span class=\"comment\">     * 一共4个点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getBezierLine</span>(<span class=\"params\">heart</span>)</span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> obj = heart.bezierPoint;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> p0 = obj.p0;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> p1 = obj.p1;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> p2 = obj.p2;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> p3 = obj.p3;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> t = heart.bezierDis;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> cx = <span class=\"number\">3</span> * (p1.x - p0.x),</span><br><span class=\"line\">         bx = <span class=\"number\">3</span> * (p2.x - p1.x) - cx,</span><br><span class=\"line\">         ax = p3.x - p0.x - cx - bx,</span><br><span class=\"line\"></span><br><span class=\"line\">    cy = <span class=\"number\">3</span> * (p1.y - p0.y),</span><br><span class=\"line\">    by = <span class=\"number\">3</span> * (p2.y - p1.y) - cy,</span><br><span class=\"line\">    ay = p3.y - p0.y - cy - by,</span><br><span class=\"line\"></span><br><span class=\"line\">    xt = ax * (t * t * t) + bx * (t * t) + cx * t + p0.x,</span><br><span class=\"line\">    yt = ay * (t * t * t) + by * (t * t) + cy * t + p0.y;</span><br><span class=\"line\"></span><br><span class=\"line\">    heart.bezierDis += heart.speed;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    xt: xt,</span><br><span class=\"line\">    yt: yt</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>路径如图所示：<br><img src=\"https://qiniu.nihaoshijie.com.cn/1527478501_6_w166_h306.png\" alt></p>\n<p>根据曲线路径方法可以实现心的运动轨迹：<br><img src=\"https://qiniu.nihaoshijie.com.cn/1527479519_2_w305_h232.gif\" alt></p>\n<p>4.针对每一帧需要动态修改，心的位移，角度，和缩放：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 计算缩放角度的方法</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getFScale</span>(<span class=\"params\">heart</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> _scale = heart.scale;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 随着距离起始点的距离增加，scale不断变大</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> dis = heart.orignY - heart.y;</span><br><span class=\"line\">    _scale = (dis / heart.scaleDis);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 当大于设置的阈值时变成1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dis &gt;= heart.scaleDis) &#123;</span><br><span class=\"line\">        _scale = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> _scale;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>5.计算心角度变化</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 计算心左右摇摆的方法</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rangeAngle</span>(<span class=\"params\">heart</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> _angle = heart.angle;</span><br><span class=\"line\">    <span class=\"comment\">// 心介于[start, end]之间不断变化角度</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(_angle &gt;= heart.angelEnd) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 角度不断变小，向左摇摆</span></span><br><span class=\"line\">    heart.angleLeft = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (_angle &lt;= heart.angelBegin)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 角度不断变大，向又摇摆</span></span><br><span class=\"line\">    heart.angleLeft = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 动态改变角度</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (heart.angleLeft) &#123;</span><br><span class=\"line\">    _angle = _angle + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    _angle = _angle - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _angle;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"组件化\">组件化</span></h3><p>整个组件代码不超过200行，相较于使用css3实现更加轻便，dom少，性能更好。<br>组件地址：<a href=\"https://github.com/lvming6816077/like-heart\" target=\"_blank\" rel=\"noopener\">https://github.com/lvming6816077/like-heart</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"先看看效果\"><a href=\"#先看看效果\" class=\"headerlink\" title=\"先看看效果\"></a>先看看效果</h3><p><img src=\"https://qiniu.nihaoshijie.com.cn/1527477112_60_w305_h232.gif\" alt=\"\"><br>","more":"<br><img src=\"https://qiniu.nihaoshijie.com.cn/1527476652_7_w380_h433.gif\" alt=\"\"></p>\n<h3 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h3><p>1.动画中每颗心都有自己的透明度，位移，角度，缩放的变化动画，针对这些动画，可以分别调用canvas的相关API：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ctx.translate(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\">ctx.rotate(<span class=\"keyword\">this</span>.angle);</span><br><span class=\"line\">ctx.scale(<span class=\"keyword\">this</span>.scale, <span class=\"keyword\">this</span>.scale);</span><br><span class=\"line\">ctx.globalAlpha = <span class=\"keyword\">this</span>.opacity;</span><br></pre></td></tr></table></figure>\n<p>2.在有大于1颗心的情况时，针对每颗心，在实现角度，缩放时必须要保存上一次canvas的状态，改变完成之后在恢复：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ctx.save();</span><br><span class=\"line\">ctx.translate(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\">ctx.rotate(<span class=\"keyword\">this</span>.angle);</span><br><span class=\"line\">ctx.scale(<span class=\"keyword\">this</span>.scale, <span class=\"keyword\">this</span>.scale);</span><br><span class=\"line\">ctx.globalAlpha = <span class=\"keyword\">this</span>.opacity;</span><br><span class=\"line\">ctx.restore();</span><br></pre></td></tr></table></figure>\n<p>3.计算心位移路径(3次被塞尔曲线)<br>公式：<img src=\"https://qiniu.nihaoshijie.com.cn/images/1527478364_96_w1098_h68.png\" alt=\"\"><br>转换成js代码计算心的x,y方向上的位移：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获得贝塞尔曲线路径</span></span><br><span class=\"line\"><span class=\"comment\">     * 一共4个点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getBezierLine</span>(<span class=\"params\">heart</span>)</span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> obj = heart.bezierPoint;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> p0 = obj.p0;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> p1 = obj.p1;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> p2 = obj.p2;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> p3 = obj.p3;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> t = heart.bezierDis;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> cx = <span class=\"number\">3</span> * (p1.x - p0.x),</span><br><span class=\"line\">         bx = <span class=\"number\">3</span> * (p2.x - p1.x) - cx,</span><br><span class=\"line\">         ax = p3.x - p0.x - cx - bx,</span><br><span class=\"line\"></span><br><span class=\"line\">    cy = <span class=\"number\">3</span> * (p1.y - p0.y),</span><br><span class=\"line\">    by = <span class=\"number\">3</span> * (p2.y - p1.y) - cy,</span><br><span class=\"line\">    ay = p3.y - p0.y - cy - by,</span><br><span class=\"line\"></span><br><span class=\"line\">    xt = ax * (t * t * t) + bx * (t * t) + cx * t + p0.x,</span><br><span class=\"line\">    yt = ay * (t * t * t) + by * (t * t) + cy * t + p0.y;</span><br><span class=\"line\"></span><br><span class=\"line\">    heart.bezierDis += heart.speed;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    xt: xt,</span><br><span class=\"line\">    yt: yt</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>路径如图所示：<br><img src=\"https://qiniu.nihaoshijie.com.cn/1527478501_6_w166_h306.png\" alt=\"\"></p>\n<p>根据曲线路径方法可以实现心的运动轨迹：<br><img src=\"https://qiniu.nihaoshijie.com.cn/1527479519_2_w305_h232.gif\" alt=\"\"></p>\n<p>4.针对每一帧需要动态修改，心的位移，角度，和缩放：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 计算缩放角度的方法</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getFScale</span>(<span class=\"params\">heart</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> _scale = heart.scale;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 随着距离起始点的距离增加，scale不断变大</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> dis = heart.orignY - heart.y;</span><br><span class=\"line\">    _scale = (dis / heart.scaleDis);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 当大于设置的阈值时变成1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dis &gt;= heart.scaleDis) &#123;</span><br><span class=\"line\">        _scale = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> _scale;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>5.计算心角度变化</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 计算心左右摇摆的方法</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rangeAngle</span>(<span class=\"params\">heart</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> _angle = heart.angle;</span><br><span class=\"line\">    <span class=\"comment\">// 心介于[start, end]之间不断变化角度</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(_angle &gt;= heart.angelEnd) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 角度不断变小，向左摇摆</span></span><br><span class=\"line\">    heart.angleLeft = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (_angle &lt;= heart.angelBegin)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 角度不断变大，向又摇摆</span></span><br><span class=\"line\">    heart.angleLeft = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 动态改变角度</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (heart.angleLeft) &#123;</span><br><span class=\"line\">    _angle = _angle + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    _angle = _angle - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _angle;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"组件化\"><a href=\"#组件化\" class=\"headerlink\" title=\"组件化\"></a>组件化</h3><p>整个组件代码不超过200行，相较于使用css3实现更加轻便，dom少，性能更好。<br>组件地址：<a href=\"https://github.com/lvming6816077/like-heart\" target=\"_blank\" rel=\"noopener\">https://github.com/lvming6816077/like-heart</a></p>"},{"title":"Chrome插件之七牛云存储图片上传插件","date":"2014-08-26T10:24:00.000Z","photos":["https://qiniu.nihaoshijie.com.cn/qiniuhuojiang.jpg"],"_content":"<h3>基本说明：</h3>\n本插件是为了参加七牛云存储<a href=\"https://portal.qiniu.com/contest/demo2014\" target=\"_blank\">demo</a>大赛而制作。\n\n项目代码托管在<a href=\"https://gitcafe.com/lvming6816077/qiniu-demo\" target=\"_blank\">gitcafe</a>上。\n<!--more-->\n项目后台代码部署在sina 的 <a href=\"http://1.lvming6816077.sinaapp.com/\" target=\"_blank\">SAE</a>上。\n<h3>项目源码：</h3>\n1. 关于后台代码，主要就是用了七牛的php sdk来获取远程图片，然后上传到七牛上。\n\n2. 关于前台代码，主要参考的chrome extension开发的api来实现的简单的插件。加上一些js逻辑和ui设计，构成了一个用于上传图片的插件。\n\n<h3>如何使用：</h3>\n下载地址：<a title=\"http://qiniu.nihaoshijie.com.cn/qiniu-demo1.1.zip\" href=\"http://qiniu.nihaoshijie.com.cn/qiniu-demo1.1.zip\" target=\"_blank\">http://qiniu.nihaoshijie.com.cn/qiniu-demo1.1.zip</a>\n\n\n\n后记：\n\n今天收到此的demo获奖的邮件，还是有些意外的，从提交到gitcafe之后就没怎么管过了，没想到还能获奖，希望下次继续努力！\n\n<img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/huojiang123\" alt=\"\" width=\"640\" height=\"1137\" />","source":"_posts/Chrome插件之七牛云存储图片上传插件.md","raw":"---\ntitle: Chrome插件之七牛云存储图片上传插件\ndate: 2014-08-26 18:24:00\ntags:\n- chrome插件\ncategories:\n- 422\nphotos: https://qiniu.nihaoshijie.com.cn/qiniuhuojiang.jpg\n---\n<h3>基本说明：</h3>\n本插件是为了参加七牛云存储<a href=\"https://portal.qiniu.com/contest/demo2014\" target=\"_blank\">demo</a>大赛而制作。\n\n项目代码托管在<a href=\"https://gitcafe.com/lvming6816077/qiniu-demo\" target=\"_blank\">gitcafe</a>上。\n<!--more-->\n项目后台代码部署在sina 的 <a href=\"http://1.lvming6816077.sinaapp.com/\" target=\"_blank\">SAE</a>上。\n<h3>项目源码：</h3>\n1. 关于后台代码，主要就是用了七牛的php sdk来获取远程图片，然后上传到七牛上。\n\n2. 关于前台代码，主要参考的chrome extension开发的api来实现的简单的插件。加上一些js逻辑和ui设计，构成了一个用于上传图片的插件。\n\n<h3>如何使用：</h3>\n下载地址：<a title=\"http://qiniu.nihaoshijie.com.cn/qiniu-demo1.1.zip\" href=\"http://qiniu.nihaoshijie.com.cn/qiniu-demo1.1.zip\" target=\"_blank\">http://qiniu.nihaoshijie.com.cn/qiniu-demo1.1.zip</a>\n\n\n\n后记：\n\n今天收到此的demo获奖的邮件，还是有些意外的，从提交到gitcafe之后就没怎么管过了，没想到还能获奖，希望下次继续努力！\n\n<img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/huojiang123\" alt=\"\" width=\"640\" height=\"1137\" />","slug":"Chrome插件之七牛云存储图片上传插件","published":1,"updated":"2019-04-02T16:52:26.000Z","comments":1,"layout":"post","link":"","_id":"ckx434pzh00092wvjwb4zfqdv","content":"<p></p><h3><span id=\"基本说明\">基本说明：</span></h3><br>本插件是为了参加七牛云存储<a href=\"https://portal.qiniu.com/contest/demo2014\" target=\"_blank\">demo</a>大赛而制作。<p></p>\n<p>项目代码托管在<a href=\"https://gitcafe.com/lvming6816077/qiniu-demo\" target=\"_blank\">gitcafe</a>上。<br><a id=\"more\"></a><br>项目后台代码部署在sina 的 <a href=\"http://1.lvming6816077.sinaapp.com/\" target=\"_blank\">SAE</a>上。</p>\n<p></p><h3><span id=\"项目源码\">项目源码：</span></h3><p></p>\n<ol>\n<li><p>关于后台代码，主要就是用了七牛的php sdk来获取远程图片，然后上传到七牛上。</p>\n</li>\n<li><p>关于前台代码，主要参考的chrome extension开发的api来实现的简单的插件。加上一些js逻辑和ui设计，构成了一个用于上传图片的插件。</p>\n</li>\n</ol>\n<p></p><h3><span id=\"如何使用\">如何使用：</span></h3><br>下载地址：<a title=\"http://qiniu.nihaoshijie.com.cn/qiniu-demo1.1.zip\" href=\"http://qiniu.nihaoshijie.com.cn/qiniu-demo1.1.zip\" target=\"_blank\">http://qiniu.nihaoshijie.com.cn/qiniu-demo1.1.zip</a><p></p>\n<p>后记：</p>\n<p>今天收到此的demo获奖的邮件，还是有些意外的，从提交到gitcafe之后就没怎么管过了，没想到还能获奖，希望下次继续努力！</p>\n<p><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/huojiang123\" alt width=\"640\" height=\"1137\"></p>\n","site":{"data":{}},"excerpt":"<p></p><h3>基本说明：</h3><br>本插件是为了参加七牛云存储<a href=\"https://portal.qiniu.com/contest/demo2014\" target=\"_blank\">demo</a>大赛而制作。<p></p>\n<p>项目代码托管在<a href=\"https://gitcafe.com/lvming6816077/qiniu-demo\" target=\"_blank\">gitcafe</a>上。<br>","more":"<br>项目后台代码部署在sina 的 <a href=\"http://1.lvming6816077.sinaapp.com/\" target=\"_blank\">SAE</a>上。</p>\n<p></p><h3>项目源码：</h3><p></p>\n<ol>\n<li><p>关于后台代码，主要就是用了七牛的php sdk来获取远程图片，然后上传到七牛上。</p>\n</li>\n<li><p>关于前台代码，主要参考的chrome extension开发的api来实现的简单的插件。加上一些js逻辑和ui设计，构成了一个用于上传图片的插件。</p>\n</li>\n</ol>\n<p></p><h3>如何使用：</h3><br>下载地址：<a title=\"http://qiniu.nihaoshijie.com.cn/qiniu-demo1.1.zip\" href=\"http://qiniu.nihaoshijie.com.cn/qiniu-demo1.1.zip\" target=\"_blank\">http://qiniu.nihaoshijie.com.cn/qiniu-demo1.1.zip</a><p></p>\n<p>后记：</p>\n<p>今天收到此的demo获奖的邮件，还是有些意外的，从提交到gitcafe之后就没怎么管过了，没想到还能获奖，希望下次继续努力！</p>\n<p><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/huojiang123\" alt=\"\" width=\"640\" height=\"1137\"></p>"},{"title":"H5实现屏幕手势解锁","date":"2015-07-08T03:07:37.000Z","_content":"<strong>效果展示</strong> <img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/testh5lock.gif\" alt=\"\" width=\"372\" height=\"471\" />\n\n<!--more-->\n\n&nbsp;\n\n<strong>实现原理</strong> 利用HTML5的canvas，将解锁的圈圈划出，利用touch事件解锁这些圈圈，直接看代码。\n```javascript\nfunction createCircle() {// 创建解锁点的坐标，根据canvas的大小来平均分配半径\n\n        var n = chooseType;// 画出n*n的矩阵 \n        lastPoint = [];\n        arr = [];\n        restPoint = [];\n        r = ctx.canvas.width / (2 + 4 * n);// 公式计算 半径和canvas的大小有关\n        for (var i = 0 ; i &lt; n ; i++) {\n            for (var j = 0 ; j &lt; n ; j++) {\n                arr.push({\n                    x: j * 4 * r + 3 * r,\n                    y: i * 4 * r + 3 * r\n                });\n                restPoint.push({\n                    x: j * 4 * r + 3 * r,\n                    y: i * 4 * r + 3 * r\n                });\n            }\n        }\n        //return arr;\n    }\n```\ncanvas里的圆圈画好之后可以进行事件绑定\n```javascript\nfunction bindEvent() {\n    can.addEventListener(\"touchstart\", function (e) {\n         var po = getPosition(e);\n         console.log(po);\n         for (var i = 0 ; i &lt; arr.length ; i++) {\n            if (Math.abs(po.x - arr[i].x) &lt; r &amp;&amp; Math.abs(po.y - arr[i].y) &lt; r) { // 用来判断起始点是否在圈圈内部\n\n                touchFlag = true;\n                drawPoint(arr[i].x,arr[i].y);\n                lastPoint.push(arr[i]);\n                restPoint.splice(i,1);\n                break;\n            }\n         }\n     }, false);\n     can.addEventListener(\"touchmove\", function (e) {\n        if (touchFlag) {\n            update(getPosition(e));\n        }\n     }, false);\n     can.addEventListener(\"touchend\", function (e) {\n         if (touchFlag) {\n             touchFlag = false;\n             storePass(lastPoint);\n             setTimeout(function(){\n\n                init();\n            }, 300);\n         }\n\n\n     }, false);\n}\n```\n接着到了最关键的步骤绘制解锁路径逻辑，通过touchmove事件的不断触发，调用canvas的moveTo方法和lineTo方法来画出折现，同时判断是否达到我们所画的圈圈里面，其中lastPoint保存正确的圈圈路径，restPoint保存全部圈圈去除正确路径之后剩余的。 Update方法：\n```javascript\nfunction update(po) {// 核心变换方法在touchmove时候调用\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n    for (var i = 0 ; i &lt; arr.length ; i++) { // 每帧先把面板画出来\n        drawCle(arr[i].x, arr[i].y);\n    }\n\n    drawPoint(lastPoint);// 每帧花轨迹\n    drawLine(po , lastPoint);// 每帧画圆心\n\n    for (var i = 0 ; i &lt; restPoint.length ; i++) {\n        if (Math.abs(po.x - restPoint[i].x) &lt; r &amp;&amp; Math.abs(po.y - restPoint[i].y) &lt; r) {\n            drawPoint(restPoint[i].x, restPoint[i].y);\n            lastPoint.push(restPoint[i]);\n            restPoint.splice(i, 1);\n            break;\n        }\n    }\n\n}\n```\n最后就是收尾工作，把路径里面的lastPoint保存的数组变成密码存在localstorage里面，之后就用来处理解锁验证逻辑了\n```javascript\nfunction storePass(psw) {// touchend结束之后对密码和状态的处理\n    if (pswObj.step == 1) {\n        if (checkPass(pswObj.fpassword, psw)) {\n            pswObj.step = 2;\n            pswObj.spassword = psw;\n            document.getElementById('title').innerHTML = '密码保存成功';\n            drawStatusPoint('#2CFF26');\n            window.localStorage.setItem('passwordx', JSON.stringify(pswObj.spassword));\n            window.localStorage.setItem('chooseType', chooseType);\n        } else {\n            document.getElementById('title').innerHTML = '两次不一致，重新输入';\n            drawStatusPoint('red');\n            delete pswObj.step;\n        }\n    } else if (pswObj.step == 2) {\n        if (checkPass(pswObj.spassword, psw)) {\n            document.getElementById('title').innerHTML = '解锁成功';\n            drawStatusPoint('#2CFF26');\n        } else {\n            drawStatusPoint('red');\n            document.getElementById('title').innerHTML = '解锁失败';\n        }\n    } else {\n        pswObj.step = 1;\n        pswObj.fpassword = psw;\n        document.getElementById('title').innerHTML = '再次输入';\n    }\n\n}\n```\n<strong>解锁组件</strong> 将这个HTML5解锁写成了一个组件，放在<a href=\"https://github.com/lvming6816077/H5lock\" target=\"_blank\">https://github.com/lvming6816077/H5lock</a> 二维码体验： <img class=\"alignnone\" src=\"https://camo.githubusercontent.com/7f4c6fe6bd74d440af5f03240c4c67a23dcd0f7a/687474703a2f2f6c766d696e67363831363037372e6769746875622e696f2f483546756c6c73637265656e506167652f48356c6f636b64656d6f2f313433363731333937352e706e67\" alt=\"\" width=\"280\" height=\"280\" /> 欢迎使用和建议！","source":"_posts/H5实现屏幕手势解锁.md","raw":"---\ntitle: H5实现屏幕手势解锁\ndate: 2015-07-08 11:07:37\ntags:\n- 手势解锁\n- HTML5\ncategories:\n- 537\n---\n<strong>效果展示</strong> <img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/testh5lock.gif\" alt=\"\" width=\"372\" height=\"471\" />\n\n<!--more-->\n\n&nbsp;\n\n<strong>实现原理</strong> 利用HTML5的canvas，将解锁的圈圈划出，利用touch事件解锁这些圈圈，直接看代码。\n```javascript\nfunction createCircle() {// 创建解锁点的坐标，根据canvas的大小来平均分配半径\n\n        var n = chooseType;// 画出n*n的矩阵 \n        lastPoint = [];\n        arr = [];\n        restPoint = [];\n        r = ctx.canvas.width / (2 + 4 * n);// 公式计算 半径和canvas的大小有关\n        for (var i = 0 ; i &lt; n ; i++) {\n            for (var j = 0 ; j &lt; n ; j++) {\n                arr.push({\n                    x: j * 4 * r + 3 * r,\n                    y: i * 4 * r + 3 * r\n                });\n                restPoint.push({\n                    x: j * 4 * r + 3 * r,\n                    y: i * 4 * r + 3 * r\n                });\n            }\n        }\n        //return arr;\n    }\n```\ncanvas里的圆圈画好之后可以进行事件绑定\n```javascript\nfunction bindEvent() {\n    can.addEventListener(\"touchstart\", function (e) {\n         var po = getPosition(e);\n         console.log(po);\n         for (var i = 0 ; i &lt; arr.length ; i++) {\n            if (Math.abs(po.x - arr[i].x) &lt; r &amp;&amp; Math.abs(po.y - arr[i].y) &lt; r) { // 用来判断起始点是否在圈圈内部\n\n                touchFlag = true;\n                drawPoint(arr[i].x,arr[i].y);\n                lastPoint.push(arr[i]);\n                restPoint.splice(i,1);\n                break;\n            }\n         }\n     }, false);\n     can.addEventListener(\"touchmove\", function (e) {\n        if (touchFlag) {\n            update(getPosition(e));\n        }\n     }, false);\n     can.addEventListener(\"touchend\", function (e) {\n         if (touchFlag) {\n             touchFlag = false;\n             storePass(lastPoint);\n             setTimeout(function(){\n\n                init();\n            }, 300);\n         }\n\n\n     }, false);\n}\n```\n接着到了最关键的步骤绘制解锁路径逻辑，通过touchmove事件的不断触发，调用canvas的moveTo方法和lineTo方法来画出折现，同时判断是否达到我们所画的圈圈里面，其中lastPoint保存正确的圈圈路径，restPoint保存全部圈圈去除正确路径之后剩余的。 Update方法：\n```javascript\nfunction update(po) {// 核心变换方法在touchmove时候调用\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n    for (var i = 0 ; i &lt; arr.length ; i++) { // 每帧先把面板画出来\n        drawCle(arr[i].x, arr[i].y);\n    }\n\n    drawPoint(lastPoint);// 每帧花轨迹\n    drawLine(po , lastPoint);// 每帧画圆心\n\n    for (var i = 0 ; i &lt; restPoint.length ; i++) {\n        if (Math.abs(po.x - restPoint[i].x) &lt; r &amp;&amp; Math.abs(po.y - restPoint[i].y) &lt; r) {\n            drawPoint(restPoint[i].x, restPoint[i].y);\n            lastPoint.push(restPoint[i]);\n            restPoint.splice(i, 1);\n            break;\n        }\n    }\n\n}\n```\n最后就是收尾工作，把路径里面的lastPoint保存的数组变成密码存在localstorage里面，之后就用来处理解锁验证逻辑了\n```javascript\nfunction storePass(psw) {// touchend结束之后对密码和状态的处理\n    if (pswObj.step == 1) {\n        if (checkPass(pswObj.fpassword, psw)) {\n            pswObj.step = 2;\n            pswObj.spassword = psw;\n            document.getElementById('title').innerHTML = '密码保存成功';\n            drawStatusPoint('#2CFF26');\n            window.localStorage.setItem('passwordx', JSON.stringify(pswObj.spassword));\n            window.localStorage.setItem('chooseType', chooseType);\n        } else {\n            document.getElementById('title').innerHTML = '两次不一致，重新输入';\n            drawStatusPoint('red');\n            delete pswObj.step;\n        }\n    } else if (pswObj.step == 2) {\n        if (checkPass(pswObj.spassword, psw)) {\n            document.getElementById('title').innerHTML = '解锁成功';\n            drawStatusPoint('#2CFF26');\n        } else {\n            drawStatusPoint('red');\n            document.getElementById('title').innerHTML = '解锁失败';\n        }\n    } else {\n        pswObj.step = 1;\n        pswObj.fpassword = psw;\n        document.getElementById('title').innerHTML = '再次输入';\n    }\n\n}\n```\n<strong>解锁组件</strong> 将这个HTML5解锁写成了一个组件，放在<a href=\"https://github.com/lvming6816077/H5lock\" target=\"_blank\">https://github.com/lvming6816077/H5lock</a> 二维码体验： <img class=\"alignnone\" src=\"https://camo.githubusercontent.com/7f4c6fe6bd74d440af5f03240c4c67a23dcd0f7a/687474703a2f2f6c766d696e67363831363037372e6769746875622e696f2f483546756c6c73637265656e506167652f48356c6f636b64656d6f2f313433363731333937352e706e67\" alt=\"\" width=\"280\" height=\"280\" /> 欢迎使用和建议！","slug":"H5实现屏幕手势解锁","published":1,"updated":"2017-04-28T03:12:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434pzj000a2wvjgybmp15v","content":"<p><strong>效果展示</strong> <img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/testh5lock.gif\" alt width=\"372\" height=\"471\"></p>\n<a id=\"more\"></a>\n<p>&nbsp;</p>\n<p><strong>实现原理</strong> 利用HTML5的canvas，将解锁的圈圈划出，利用touch事件解锁这些圈圈，直接看代码。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createCircle</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"comment\">// 创建解锁点的坐标，根据canvas的大小来平均分配半径</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> n = chooseType;<span class=\"comment\">// 画出n*n的矩阵 </span></span><br><span class=\"line\">        lastPoint = [];</span><br><span class=\"line\">        arr = [];</span><br><span class=\"line\">        restPoint = [];</span><br><span class=\"line\">        r = ctx.canvas.width / (<span class=\"number\">2</span> + <span class=\"number\">4</span> * n);<span class=\"comment\">// 公式计算 半径和canvas的大小有关</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i &amp;lt; n ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span> ; j &amp;lt; n ; j++) &#123;</span><br><span class=\"line\">                arr.push(&#123;</span><br><span class=\"line\">                    x: j * <span class=\"number\">4</span> * r + <span class=\"number\">3</span> * r,</span><br><span class=\"line\">                    y: i * <span class=\"number\">4</span> * r + <span class=\"number\">3</span> * r</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">                restPoint.push(&#123;</span><br><span class=\"line\">                    x: j * <span class=\"number\">4</span> * r + <span class=\"number\">3</span> * r,</span><br><span class=\"line\">                    y: i * <span class=\"number\">4</span> * r + <span class=\"number\">3</span> * r</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//return arr;</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>canvas里的圆圈画好之后可以进行事件绑定<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bindEvent</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    can.addEventListener(<span class=\"string\">\"touchstart\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> po = getPosition(e);</span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log(po);</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i &amp;lt; arr.length ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">Math</span>.abs(po.x - arr[i].x) &amp;lt; r &amp;amp;&amp;amp; <span class=\"built_in\">Math</span>.abs(po.y - arr[i].y) &amp;lt; r) &#123; <span class=\"comment\">// 用来判断起始点是否在圈圈内部</span></span><br><span class=\"line\"></span><br><span class=\"line\">                touchFlag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                drawPoint(arr[i].x,arr[i].y);</span><br><span class=\"line\">                lastPoint.push(arr[i]);</span><br><span class=\"line\">                restPoint.splice(i,<span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;, <span class=\"literal\">false</span>);</span><br><span class=\"line\">     can.addEventListener(<span class=\"string\">\"touchmove\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (touchFlag) &#123;</span><br><span class=\"line\">            update(getPosition(e));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     &#125;, <span class=\"literal\">false</span>);</span><br><span class=\"line\">     can.addEventListener(<span class=\"string\">\"touchend\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (touchFlag) &#123;</span><br><span class=\"line\">             touchFlag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">             storePass(lastPoint);</span><br><span class=\"line\">             setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                init();</span><br><span class=\"line\">            &#125;, <span class=\"number\">300</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">     &#125;, <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接着到了最关键的步骤绘制解锁路径逻辑，通过touchmove事件的不断触发，调用canvas的moveTo方法和lineTo方法来画出折现，同时判断是否达到我们所画的圈圈里面，其中lastPoint保存正确的圈圈路径，restPoint保存全部圈圈去除正确路径之后剩余的。 Update方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">update</span>(<span class=\"params\">po</span>) </span>&#123;<span class=\"comment\">// 核心变换方法在touchmove时候调用</span></span><br><span class=\"line\">    ctx.clearRect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, ctx.canvas.width, ctx.canvas.height);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i &amp;lt; arr.length ; i++) &#123; <span class=\"comment\">// 每帧先把面板画出来</span></span><br><span class=\"line\">        drawCle(arr[i].x, arr[i].y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    drawPoint(lastPoint);<span class=\"comment\">// 每帧花轨迹</span></span><br><span class=\"line\">    drawLine(po , lastPoint);<span class=\"comment\">// 每帧画圆心</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i &amp;lt; restPoint.length ; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">Math</span>.abs(po.x - restPoint[i].x) &amp;lt; r &amp;amp;&amp;amp; <span class=\"built_in\">Math</span>.abs(po.y - restPoint[i].y) &amp;lt; r) &#123;</span><br><span class=\"line\">            drawPoint(restPoint[i].x, restPoint[i].y);</span><br><span class=\"line\">            lastPoint.push(restPoint[i]);</span><br><span class=\"line\">            restPoint.splice(i, <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后就是收尾工作，把路径里面的lastPoint保存的数组变成密码存在localstorage里面，之后就用来处理解锁验证逻辑了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">storePass</span>(<span class=\"params\">psw</span>) </span>&#123;<span class=\"comment\">// touchend结束之后对密码和状态的处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pswObj.step == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (checkPass(pswObj.fpassword, psw)) &#123;</span><br><span class=\"line\">            pswObj.step = <span class=\"number\">2</span>;</span><br><span class=\"line\">            pswObj.spassword = psw;</span><br><span class=\"line\">            <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'title'</span>).innerHTML = <span class=\"string\">'密码保存成功'</span>;</span><br><span class=\"line\">            drawStatusPoint(<span class=\"string\">'#2CFF26'</span>);</span><br><span class=\"line\">            <span class=\"built_in\">window</span>.localStorage.setItem(<span class=\"string\">'passwordx'</span>, <span class=\"built_in\">JSON</span>.stringify(pswObj.spassword));</span><br><span class=\"line\">            <span class=\"built_in\">window</span>.localStorage.setItem(<span class=\"string\">'chooseType'</span>, chooseType);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'title'</span>).innerHTML = <span class=\"string\">'两次不一致，重新输入'</span>;</span><br><span class=\"line\">            drawStatusPoint(<span class=\"string\">'red'</span>);</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> pswObj.step;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pswObj.step == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (checkPass(pswObj.spassword, psw)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'title'</span>).innerHTML = <span class=\"string\">'解锁成功'</span>;</span><br><span class=\"line\">            drawStatusPoint(<span class=\"string\">'#2CFF26'</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            drawStatusPoint(<span class=\"string\">'red'</span>);</span><br><span class=\"line\">            <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'title'</span>).innerHTML = <span class=\"string\">'解锁失败'</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        pswObj.step = <span class=\"number\">1</span>;</span><br><span class=\"line\">        pswObj.fpassword = psw;</span><br><span class=\"line\">        <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'title'</span>).innerHTML = <span class=\"string\">'再次输入'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>解锁组件</strong> 将这个HTML5解锁写成了一个组件，放在<a href=\"https://github.com/lvming6816077/H5lock\" target=\"_blank\">https://github.com/lvming6816077/H5lock</a> 二维码体验： <img class=\"alignnone\" src=\"https://camo.githubusercontent.com/7f4c6fe6bd74d440af5f03240c4c67a23dcd0f7a/687474703a2f2f6c766d696e67363831363037372e6769746875622e696f2f483546756c6c73637265656e506167652f48356c6f636b64656d6f2f313433363731333937352e706e67\" alt width=\"280\" height=\"280\"> 欢迎使用和建议！</p>\n","site":{"data":{}},"excerpt":"<p><strong>效果展示</strong> <img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/testh5lock.gif\" alt=\"\" width=\"372\" height=\"471\"></p>","more":"<p>&nbsp;</p>\n<p><strong>实现原理</strong> 利用HTML5的canvas，将解锁的圈圈划出，利用touch事件解锁这些圈圈，直接看代码。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createCircle</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"comment\">// 创建解锁点的坐标，根据canvas的大小来平均分配半径</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> n = chooseType;<span class=\"comment\">// 画出n*n的矩阵 </span></span><br><span class=\"line\">        lastPoint = [];</span><br><span class=\"line\">        arr = [];</span><br><span class=\"line\">        restPoint = [];</span><br><span class=\"line\">        r = ctx.canvas.width / (<span class=\"number\">2</span> + <span class=\"number\">4</span> * n);<span class=\"comment\">// 公式计算 半径和canvas的大小有关</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i &amp;lt; n ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span> ; j &amp;lt; n ; j++) &#123;</span><br><span class=\"line\">                arr.push(&#123;</span><br><span class=\"line\">                    x: j * <span class=\"number\">4</span> * r + <span class=\"number\">3</span> * r,</span><br><span class=\"line\">                    y: i * <span class=\"number\">4</span> * r + <span class=\"number\">3</span> * r</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">                restPoint.push(&#123;</span><br><span class=\"line\">                    x: j * <span class=\"number\">4</span> * r + <span class=\"number\">3</span> * r,</span><br><span class=\"line\">                    y: i * <span class=\"number\">4</span> * r + <span class=\"number\">3</span> * r</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//return arr;</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>canvas里的圆圈画好之后可以进行事件绑定<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bindEvent</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    can.addEventListener(<span class=\"string\">\"touchstart\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> po = getPosition(e);</span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log(po);</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i &amp;lt; arr.length ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">Math</span>.abs(po.x - arr[i].x) &amp;lt; r &amp;amp;&amp;amp; <span class=\"built_in\">Math</span>.abs(po.y - arr[i].y) &amp;lt; r) &#123; <span class=\"comment\">// 用来判断起始点是否在圈圈内部</span></span><br><span class=\"line\"></span><br><span class=\"line\">                touchFlag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                drawPoint(arr[i].x,arr[i].y);</span><br><span class=\"line\">                lastPoint.push(arr[i]);</span><br><span class=\"line\">                restPoint.splice(i,<span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;, <span class=\"literal\">false</span>);</span><br><span class=\"line\">     can.addEventListener(<span class=\"string\">\"touchmove\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (touchFlag) &#123;</span><br><span class=\"line\">            update(getPosition(e));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     &#125;, <span class=\"literal\">false</span>);</span><br><span class=\"line\">     can.addEventListener(<span class=\"string\">\"touchend\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (touchFlag) &#123;</span><br><span class=\"line\">             touchFlag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">             storePass(lastPoint);</span><br><span class=\"line\">             setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                init();</span><br><span class=\"line\">            &#125;, <span class=\"number\">300</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">     &#125;, <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接着到了最关键的步骤绘制解锁路径逻辑，通过touchmove事件的不断触发，调用canvas的moveTo方法和lineTo方法来画出折现，同时判断是否达到我们所画的圈圈里面，其中lastPoint保存正确的圈圈路径，restPoint保存全部圈圈去除正确路径之后剩余的。 Update方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">update</span>(<span class=\"params\">po</span>) </span>&#123;<span class=\"comment\">// 核心变换方法在touchmove时候调用</span></span><br><span class=\"line\">    ctx.clearRect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, ctx.canvas.width, ctx.canvas.height);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i &amp;lt; arr.length ; i++) &#123; <span class=\"comment\">// 每帧先把面板画出来</span></span><br><span class=\"line\">        drawCle(arr[i].x, arr[i].y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    drawPoint(lastPoint);<span class=\"comment\">// 每帧花轨迹</span></span><br><span class=\"line\">    drawLine(po , lastPoint);<span class=\"comment\">// 每帧画圆心</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i &amp;lt; restPoint.length ; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">Math</span>.abs(po.x - restPoint[i].x) &amp;lt; r &amp;amp;&amp;amp; <span class=\"built_in\">Math</span>.abs(po.y - restPoint[i].y) &amp;lt; r) &#123;</span><br><span class=\"line\">            drawPoint(restPoint[i].x, restPoint[i].y);</span><br><span class=\"line\">            lastPoint.push(restPoint[i]);</span><br><span class=\"line\">            restPoint.splice(i, <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后就是收尾工作，把路径里面的lastPoint保存的数组变成密码存在localstorage里面，之后就用来处理解锁验证逻辑了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">storePass</span>(<span class=\"params\">psw</span>) </span>&#123;<span class=\"comment\">// touchend结束之后对密码和状态的处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pswObj.step == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (checkPass(pswObj.fpassword, psw)) &#123;</span><br><span class=\"line\">            pswObj.step = <span class=\"number\">2</span>;</span><br><span class=\"line\">            pswObj.spassword = psw;</span><br><span class=\"line\">            <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'title'</span>).innerHTML = <span class=\"string\">'密码保存成功'</span>;</span><br><span class=\"line\">            drawStatusPoint(<span class=\"string\">'#2CFF26'</span>);</span><br><span class=\"line\">            <span class=\"built_in\">window</span>.localStorage.setItem(<span class=\"string\">'passwordx'</span>, <span class=\"built_in\">JSON</span>.stringify(pswObj.spassword));</span><br><span class=\"line\">            <span class=\"built_in\">window</span>.localStorage.setItem(<span class=\"string\">'chooseType'</span>, chooseType);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'title'</span>).innerHTML = <span class=\"string\">'两次不一致，重新输入'</span>;</span><br><span class=\"line\">            drawStatusPoint(<span class=\"string\">'red'</span>);</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> pswObj.step;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pswObj.step == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (checkPass(pswObj.spassword, psw)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'title'</span>).innerHTML = <span class=\"string\">'解锁成功'</span>;</span><br><span class=\"line\">            drawStatusPoint(<span class=\"string\">'#2CFF26'</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            drawStatusPoint(<span class=\"string\">'red'</span>);</span><br><span class=\"line\">            <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'title'</span>).innerHTML = <span class=\"string\">'解锁失败'</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        pswObj.step = <span class=\"number\">1</span>;</span><br><span class=\"line\">        pswObj.fpassword = psw;</span><br><span class=\"line\">        <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'title'</span>).innerHTML = <span class=\"string\">'再次输入'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>解锁组件</strong> 将这个HTML5解锁写成了一个组件，放在<a href=\"https://github.com/lvming6816077/H5lock\" target=\"_blank\">https://github.com/lvming6816077/H5lock</a> 二维码体验： <img class=\"alignnone\" src=\"https://camo.githubusercontent.com/7f4c6fe6bd74d440af5f03240c4c67a23dcd0f7a/687474703a2f2f6c766d696e67363831363037372e6769746875622e696f2f483546756c6c73637265656e506167652f48356c6f636b64656d6f2f313433363731333937352e706e67\" alt=\"\" width=\"280\" height=\"280\"> 欢迎使用和建议！</p>"},{"title":"H5视频直播扫盲","date":"2016-05-25T13:04:19.000Z","photos":["https://qiniu.nihaoshijie.com.cn/1-1604251R0335K.jpg"],"_content":"视频直播这么火，再不学就out了。\n\n为了紧跟潮流，本文将向大家介绍一下视频直播中的基本流程和主要的技术点，包括但不限于前端技术。\n<h2><strong>1 H5到底能不能做视频直播？</strong></h2>\n当然可以， H5火了这么久，涵盖了各个方面的技术。\n<!--more-->\n对于视频录制，可以使用强大的<span style=\"color: #0000cd;\">webRTC</span>（Web Real-Time Communication）是一个支持网页浏览器进行实时语音对话或视频对话的技术，缺点是只在PC的chrome上支持较好，移动端支持不太理想。\n\n对于视频播放，可以使用<span style=\"color: #0000cd;\">HLS</span>(HTTP Live Streaming)协议播放直播流，ios和android都天然支持这种协议，配置简单，直接使用video标签即可。\n\nwebRTC兼容性：\n\n<img src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2010.24.48.png\" alt=\"\" data-cke-saved-src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2010.24.48.png\" />\n\nvideo标签播放hls协议视频：\n<pre class=\"lang:default decode:true\">&lt;video controls autoplay&gt;  \n    &lt;source src=\"http://10.66.69.77:8080/hls/mystream.m3u8\" type=\"application/vnd.apple.mpegurl\" /&gt;  \n    &lt;p class=\"warning\"&gt;Your browser does not support HTML5 video.&lt;/p&gt;  \n&lt;/video&gt;</pre>\n<h2><strong>2 到底什么是HLS协议？</strong></h2>\n当简单讲就是把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些，前面提到了用于H5播放直播视频时引入的一个<span style=\"color: #0000cd;\">.m3u8</span>的文件，这个文件就是基于HLS协议，存放视频流元数据的文件。\n\n每一个.m3u8文件，分别对应若干个ts文件，这些ts文件才是真正存放视频的数据，m3u8文件只是存放了一些ts文件的配置信息和相关路径，当视频播放时，.m3u8是动态改变的，video标签会解析这个文件，并找到对应的ts文件来播放，所以一般为了加快速度，.m3u8放在web服务器上，ts文件放在cdn上。\n\n.m3u8文件，其实就是以UTF-8编码的m3u文件，这个文件本身不能播放，只是存放了播放信息的文本文件：\n<pre>​#EXTM3U                     m3u文件头\n#EXT-X-MEDIA-SEQUENCE       第一个TS分片的序列号\n#EXT-X-TARGETDURATION       每个分片TS的最大的时长\n#EXT-X-ALLOW-CACHE          是否允许cache\n#EXT-X-ENDLIST              m3u8文件结束符\n#EXTINF                     指定每个媒体段(ts)的持续时间（秒），仅对其后面的URI有效\nmystream-12.ts</pre>\nts文件：\n\n<img src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2011.09.29.png\" alt=\"\" data-cke-saved-src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2011.09.29.png\" />\n\nHLS的请求流程是：\n<strong>1 http请求m3u8的url\n2 服务端返回一个m3u8的播放列表，这个播放列表是实时跟新的，一般一次给出3段数据的url\n3 客户端解析m3u8的播放列表，再按序请求每一段的url，获取ts数据流</strong>\n\n简单流程：\n\n<img src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2011.20.29.png\" alt=\"\" data-cke-saved-src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2011.20.29.png\" />\n<h2><strong>3 HLS直播延时</strong></h2>\n当我们知道hls协议是将直播流分成一段一段的小段视频去下载播放的，所以假设列表里面的包含5个TS文件，每个TS文件包含5秒的视频内容，那么整体的延迟就是25秒。因为当你看到这些视频时，主播已经将视频录制好上传上去了，所以时这样产生的延迟。当然可以缩短列表的长度和单个TS文件的大小来降低延迟，极致来说可以缩减列表长度为1，并且TS的时长为1s，但是这样会造成请求次数增加，增大服务器压力，当网速慢时回造成更多的缓冲，所以苹果官方推荐的ts时长时10s，所以这样就会大改有30s的延迟。参考资料：<a href=\"https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/FrequentlyAskedQuestions/FrequentlyAskedQuestions.html\" data-cke-saved-href=\"https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/FrequentlyAskedQuestions/FrequentlyAskedQuestions.html\">https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/FrequentlyAskedQuestions/FrequentlyAskedQuestions.html</a>\n<h2><strong>4 视频直播的整个流程是什么？</strong></h2>\n当视频直播可大致分为：\n\n<strong>1 视频录制端：一般是电脑上的音视频输入设备或者手机端的摄像头或者麦克风，目前已移动端的手机视频为主。</strong>\n\n<strong>2 视频播放端：可以是电脑上的播放器，手机端的native播放器，还有就是h5的video标签等，目前还是已手机端的native播放器为主。</strong>\n\n<strong>3 视频服务器端：一般是一台nginx服务器，用来接受视频录制端提供的视频源，同时提供给视频播放端流服务。</strong>\n\n简单流程：\n\n<img src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2011.33.20.png\" alt=\"\" data-cke-saved-src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2011.33.20.png\" />\n\n&nbsp;\n\n&nbsp;\n<h2><strong>5 怎样进行音视频采集？</strong></h2>\n当首先明确几个概念：\n\n<strong>视频编码：所谓视频编码就是指通过特定的压缩技术，将某个视频格式的文件转换成另一种视频格式文件的方式，我们使用的iphone录制的视频，必须要经过编码，上传，解码，才能真正的在用户端的播放器里播放。</strong>\n\n<strong>编解码标准：视频流传输中最为重要的编解码标准有国际电联的H.261、H.263、H.264，其中HLS协议支持<span style=\"color: #0000cd;\">H.264</span>格式的编码。\n音频编码：同视频编码类似，将原始的音频流按照一定的标准进行编码，上传，解码，同时在播放器里播放，当然音频也有许多编码标准，例如PCM编码，WMA编码，AAC编码等等，这里我们HLS协议支持的音频编码方式是<span style=\"color: #0000cd;\">AAC编码</span>。</strong>\n\n下面将利用ios上的摄像头，进行音视频的数据采集，主要分为以下几个步骤：\n\n&nbsp;\n\n<strong>1 音视频的采集，ios中，利用<span style=\"color: #0000cd;\">AVCaptureSession</span>和<span style=\"color: #0000cd;\">AVCaptureDevice</span>可以采集到原始的音视频数据流。\n2 对视频进行H264编码，对音频进行AAC编码，在ios中分别有已经封装好的编码库来实现对音视频的编码。\n3 对编码后的音、视频数据进行组装封包；\n4 建立<span style=\"color: #0000cd;\">RTMP</span>连接并上推到服务端。</strong>\n\n&nbsp;\n\nps：由于编码库大多使用c语言编写，需要自己使用时编译，对于ios，可以使用已经编译好的编码库。\n\nx264编码：<a href=\"https://github.com/kewlbear/x264-ios\" data-cke-saved-href=\"https://github.com/kewlbear/x264-ios\">https://github.com/kewlbear/x264-ios</a>\n\nfaac编码：<a href=\"https://github.com/fflydev/faac-ios-build\" data-cke-saved-href=\"https://github.com/fflydev/faac-ios-build\">https://github.com/fflydev/faac-ios-build</a>\n\nffmpeg编码：<a href=\"https://github.com/kewlbear/FFmpeg-iOS-build-script\" data-cke-saved-href=\"https://github.com/kewlbear/FFmpeg-iOS-build-script\">https://github.com/kewlbear/FFmpeg-iOS-build-script</a>\n\n关于如果想给视频增加一些特殊效果，例如增加滤镜等，一般在编码前给使用滤镜库，但是这样也会造成一些耗时，导致上传视频数据有一定延时。\n\n简单流程：\n\n<img src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2012.07.49.png\" alt=\"\" data-cke-saved-src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2012.07.49.png\" />\n<h2><strong>6 前面提到的ffmpeg是什么？</strong></h2>\n和之前的<span style=\"color: #0000cd;\">x264</span>一样，<span style=\"color: #0000cd;\">ffmpeg</span>其实也是一套编码库，类似的还有Xvid，Xvid是基于MPEG4协议的编解码器，x264是基于H.264协议的编码器，ffmpeg集合了各种音频，视频编解码协议，通过设置参数可以完成基于MPEG4,H.264等协议的编解码，demo这里使用的是x264编码库。\n<h2><strong>7 什么是RTMP？</strong></h2>\nReal Time Messaging Protocol（简称 RTMP）是 Macromedia 开发的一套视频直播协议，现在属于 Adobe。和HLS一样都可以应用于视频直播，区别是RTMP基于flash无法在ios的浏览器里播放，但是实时性比HLS要好。所以一般使用这种协议来上传视频流，也就是视频流推送到服务器。\n\n这里列举一下hls和rtmp对比：\n\n<img src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-25%2010.43.02.png\" alt=\"\" data-cke-saved-src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-25%2010.43.02.png\" />\n<h2><strong>8 推流</strong></h2>\n简所谓推流，就是将我们已经编码好的音视频数据发往视频流服务器中，一般常用的是使用rtmp推流，可以使用第三方库<strong><a href=\"https://github.com/ifactorylab/librtmp-iOS\" data-cke-saved-href=\"https://github.com/ifactorylab/librtmp-iOS\">librtmp-iOS</a></strong>进行推流，librtmp封装了一些核心的api供使用者调用，如果觉得麻烦，可以使用现成的ios视频推流sdk，也是基于rtmp的，<a href=\"https://github.com/runner365/LiveVideoCoreSDK\" data-cke-saved-href=\"https://github.com/runner365/LiveVideoCoreSDK\">https://github.com/runner365/LiveVideoCoreSDK</a>\n<h2><strong>9 推流服务器搭建</strong></h2>\n简简单的推流服务器搭建，由于我们上传的视频流都是基于rtmp协议的，所以服务器也必须要支持rtmp才行，大概需要以下几个步骤：\n\n<strong>1 安装一台nginx服务器。</strong>\n\n<strong>2 安装nginx的rtmp扩展，目前使用比较多的是<a href=\"https://github.com/arut/nginx-rtmp-module\" data-cke-saved-href=\"https://github.com/arut/nginx-rtmp-module\">https://github.com/arut/nginx-rtmp-module</a></strong>\n\n<strong>3 配置nginx的conf文件：</strong>\n<pre>rtmp {  \n  \n    server {  \n  \n        listen 1935;  #监听的端口\n  \n        chunk_size 4000;  \n        \n         \n        application hls {  #rtmp推流请求路径\n            live on;  \n            hls on;  \n            hls_path /usr/local/var/www/hls;  \n            hls_fragment 5s;  \n        }  \n    }  \n}</pre>\n<strong>4 重启nginx，将rtmp的推流地址写为rtmp://ip:1935/hls/mystream，其中hls_path表示生成的.m3u8和ts文件所存放的地址，hls_fragment表示切片时长，mysteam表示一个实例，即将来要生成的文件名可以先自己随便设置一个。更多配置可以参考：<a href=\"https://github.com/arut/nginx-rtmp-module/wiki/\" data-cke-saved-href=\"https://github.com/arut/nginx-rtmp-module/wiki/\">https://github.com/arut/nginx-rtmp-module/wiki/</a></strong>\n\n根据以上步骤基本上已经实现了一个支持rtmp的视频服务器了。\n<h2><strong>10 在html5页面进行播放直播视频？</strong></h2>\n简单来说，直接使用video标签即可播放hls协议的直播视频：\n<pre>&lt;video autoplay webkit-playsinline&gt;  \n    &lt;source src=\"http://10.66.69.77:8080/hls/mystream.m3u8\" type=\"application/vnd.apple.mpegurl\" /&gt;  \n    &lt;p class=\"warning\"&gt;Your browser does not support HTML5 video.&lt;/p&gt;  \n&lt;/video&gt;</pre>\n需要注意的是，给video标签增加webkit-playsinline属性，这个属性是为了让video视频在ios的uiwebview里面可以不全屏播放，默认ios会全屏播放视频，需要给uiwebview设置allowsInlineMediaPlayback＝YES。业界比较成熟的<a href=\"http://videojs.com/\" data-cke-saved-href=\"http://videojs.com/\">videojs</a>，可以根据不同平台选择不同的策略，例如ios使用video标签，pc使用flash等。\n<h2><strong>11 坑点总结</strong></h2>\n简根据以上步骤，笔者写了一个demo，从实现ios视频录制，采集，上传，nginx服务器下发直播流，h5页面播放直播视频者一整套流程，总结出以下几点比较坑的地方：\n\n1 在使用AVCaptureSession进行采集视频时，需要实现AVCaptureVideoDataOutputSampleBufferDelegate协议，同时在- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection捕获到视频流，要注意的是didOutputSampleBuffer这个方法不是didDropSampleBuffer方法，后者只会触发一次，当时开始写的是didDropSampleBuffer方法，差了半天才发现方法调用错了。\n\n2 在使用rtmp推流时，rmtp地址要以rtmp://开头，ip地址要写实际ip地址，不要写成localhost，同时要加上端口号，因为手机端上传时是无法识别localhost的。\n\n这里后续会补充上一些坑点，有的需要贴代码，这里先列这么多。\n<h2><strong>12 业界支持</strong></h2>\n目前，<a href=\"https://www.qcloud.com/solution/video.html\" data-cke-saved-href=\"https://www.qcloud.com/solution/video.html\">腾讯云</a>，百度云，阿里云都已经有了基于视频直播的解决方案，从视频录制到视频播放，推流，都有一系列的sdk可以使用，缺点就是需要收费，如果可以的话，自己实现一套也并不是难事哈。\n\n&nbsp;\n\ndemo地址：<a href=\"https://github.com/lvming6816077/LMVideoTest/\" data-cke-saved-href=\"http://blob/master/LMVideoTest/ViewController.m\">https://github.com/lvming6816077/LMVideoTest/</a>","source":"_posts/H5视频直播扫盲.md","raw":"---\ntitle: H5视频直播扫盲\ndate: 2016-05-25 21:04:19\ntags:\n- 视频直播\n- HTML5\ncategories:\n- 615\nphotos: https://qiniu.nihaoshijie.com.cn/1-1604251R0335K.jpg\n---\n视频直播这么火，再不学就out了。\n\n为了紧跟潮流，本文将向大家介绍一下视频直播中的基本流程和主要的技术点，包括但不限于前端技术。\n<h2><strong>1 H5到底能不能做视频直播？</strong></h2>\n当然可以， H5火了这么久，涵盖了各个方面的技术。\n<!--more-->\n对于视频录制，可以使用强大的<span style=\"color: #0000cd;\">webRTC</span>（Web Real-Time Communication）是一个支持网页浏览器进行实时语音对话或视频对话的技术，缺点是只在PC的chrome上支持较好，移动端支持不太理想。\n\n对于视频播放，可以使用<span style=\"color: #0000cd;\">HLS</span>(HTTP Live Streaming)协议播放直播流，ios和android都天然支持这种协议，配置简单，直接使用video标签即可。\n\nwebRTC兼容性：\n\n<img src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2010.24.48.png\" alt=\"\" data-cke-saved-src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2010.24.48.png\" />\n\nvideo标签播放hls协议视频：\n<pre class=\"lang:default decode:true\">&lt;video controls autoplay&gt;  \n    &lt;source src=\"http://10.66.69.77:8080/hls/mystream.m3u8\" type=\"application/vnd.apple.mpegurl\" /&gt;  \n    &lt;p class=\"warning\"&gt;Your browser does not support HTML5 video.&lt;/p&gt;  \n&lt;/video&gt;</pre>\n<h2><strong>2 到底什么是HLS协议？</strong></h2>\n当简单讲就是把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些，前面提到了用于H5播放直播视频时引入的一个<span style=\"color: #0000cd;\">.m3u8</span>的文件，这个文件就是基于HLS协议，存放视频流元数据的文件。\n\n每一个.m3u8文件，分别对应若干个ts文件，这些ts文件才是真正存放视频的数据，m3u8文件只是存放了一些ts文件的配置信息和相关路径，当视频播放时，.m3u8是动态改变的，video标签会解析这个文件，并找到对应的ts文件来播放，所以一般为了加快速度，.m3u8放在web服务器上，ts文件放在cdn上。\n\n.m3u8文件，其实就是以UTF-8编码的m3u文件，这个文件本身不能播放，只是存放了播放信息的文本文件：\n<pre>​#EXTM3U                     m3u文件头\n#EXT-X-MEDIA-SEQUENCE       第一个TS分片的序列号\n#EXT-X-TARGETDURATION       每个分片TS的最大的时长\n#EXT-X-ALLOW-CACHE          是否允许cache\n#EXT-X-ENDLIST              m3u8文件结束符\n#EXTINF                     指定每个媒体段(ts)的持续时间（秒），仅对其后面的URI有效\nmystream-12.ts</pre>\nts文件：\n\n<img src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2011.09.29.png\" alt=\"\" data-cke-saved-src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2011.09.29.png\" />\n\nHLS的请求流程是：\n<strong>1 http请求m3u8的url\n2 服务端返回一个m3u8的播放列表，这个播放列表是实时跟新的，一般一次给出3段数据的url\n3 客户端解析m3u8的播放列表，再按序请求每一段的url，获取ts数据流</strong>\n\n简单流程：\n\n<img src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2011.20.29.png\" alt=\"\" data-cke-saved-src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2011.20.29.png\" />\n<h2><strong>3 HLS直播延时</strong></h2>\n当我们知道hls协议是将直播流分成一段一段的小段视频去下载播放的，所以假设列表里面的包含5个TS文件，每个TS文件包含5秒的视频内容，那么整体的延迟就是25秒。因为当你看到这些视频时，主播已经将视频录制好上传上去了，所以时这样产生的延迟。当然可以缩短列表的长度和单个TS文件的大小来降低延迟，极致来说可以缩减列表长度为1，并且TS的时长为1s，但是这样会造成请求次数增加，增大服务器压力，当网速慢时回造成更多的缓冲，所以苹果官方推荐的ts时长时10s，所以这样就会大改有30s的延迟。参考资料：<a href=\"https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/FrequentlyAskedQuestions/FrequentlyAskedQuestions.html\" data-cke-saved-href=\"https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/FrequentlyAskedQuestions/FrequentlyAskedQuestions.html\">https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/FrequentlyAskedQuestions/FrequentlyAskedQuestions.html</a>\n<h2><strong>4 视频直播的整个流程是什么？</strong></h2>\n当视频直播可大致分为：\n\n<strong>1 视频录制端：一般是电脑上的音视频输入设备或者手机端的摄像头或者麦克风，目前已移动端的手机视频为主。</strong>\n\n<strong>2 视频播放端：可以是电脑上的播放器，手机端的native播放器，还有就是h5的video标签等，目前还是已手机端的native播放器为主。</strong>\n\n<strong>3 视频服务器端：一般是一台nginx服务器，用来接受视频录制端提供的视频源，同时提供给视频播放端流服务。</strong>\n\n简单流程：\n\n<img src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2011.33.20.png\" alt=\"\" data-cke-saved-src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2011.33.20.png\" />\n\n&nbsp;\n\n&nbsp;\n<h2><strong>5 怎样进行音视频采集？</strong></h2>\n当首先明确几个概念：\n\n<strong>视频编码：所谓视频编码就是指通过特定的压缩技术，将某个视频格式的文件转换成另一种视频格式文件的方式，我们使用的iphone录制的视频，必须要经过编码，上传，解码，才能真正的在用户端的播放器里播放。</strong>\n\n<strong>编解码标准：视频流传输中最为重要的编解码标准有国际电联的H.261、H.263、H.264，其中HLS协议支持<span style=\"color: #0000cd;\">H.264</span>格式的编码。\n音频编码：同视频编码类似，将原始的音频流按照一定的标准进行编码，上传，解码，同时在播放器里播放，当然音频也有许多编码标准，例如PCM编码，WMA编码，AAC编码等等，这里我们HLS协议支持的音频编码方式是<span style=\"color: #0000cd;\">AAC编码</span>。</strong>\n\n下面将利用ios上的摄像头，进行音视频的数据采集，主要分为以下几个步骤：\n\n&nbsp;\n\n<strong>1 音视频的采集，ios中，利用<span style=\"color: #0000cd;\">AVCaptureSession</span>和<span style=\"color: #0000cd;\">AVCaptureDevice</span>可以采集到原始的音视频数据流。\n2 对视频进行H264编码，对音频进行AAC编码，在ios中分别有已经封装好的编码库来实现对音视频的编码。\n3 对编码后的音、视频数据进行组装封包；\n4 建立<span style=\"color: #0000cd;\">RTMP</span>连接并上推到服务端。</strong>\n\n&nbsp;\n\nps：由于编码库大多使用c语言编写，需要自己使用时编译，对于ios，可以使用已经编译好的编码库。\n\nx264编码：<a href=\"https://github.com/kewlbear/x264-ios\" data-cke-saved-href=\"https://github.com/kewlbear/x264-ios\">https://github.com/kewlbear/x264-ios</a>\n\nfaac编码：<a href=\"https://github.com/fflydev/faac-ios-build\" data-cke-saved-href=\"https://github.com/fflydev/faac-ios-build\">https://github.com/fflydev/faac-ios-build</a>\n\nffmpeg编码：<a href=\"https://github.com/kewlbear/FFmpeg-iOS-build-script\" data-cke-saved-href=\"https://github.com/kewlbear/FFmpeg-iOS-build-script\">https://github.com/kewlbear/FFmpeg-iOS-build-script</a>\n\n关于如果想给视频增加一些特殊效果，例如增加滤镜等，一般在编码前给使用滤镜库，但是这样也会造成一些耗时，导致上传视频数据有一定延时。\n\n简单流程：\n\n<img src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2012.07.49.png\" alt=\"\" data-cke-saved-src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2012.07.49.png\" />\n<h2><strong>6 前面提到的ffmpeg是什么？</strong></h2>\n和之前的<span style=\"color: #0000cd;\">x264</span>一样，<span style=\"color: #0000cd;\">ffmpeg</span>其实也是一套编码库，类似的还有Xvid，Xvid是基于MPEG4协议的编解码器，x264是基于H.264协议的编码器，ffmpeg集合了各种音频，视频编解码协议，通过设置参数可以完成基于MPEG4,H.264等协议的编解码，demo这里使用的是x264编码库。\n<h2><strong>7 什么是RTMP？</strong></h2>\nReal Time Messaging Protocol（简称 RTMP）是 Macromedia 开发的一套视频直播协议，现在属于 Adobe。和HLS一样都可以应用于视频直播，区别是RTMP基于flash无法在ios的浏览器里播放，但是实时性比HLS要好。所以一般使用这种协议来上传视频流，也就是视频流推送到服务器。\n\n这里列举一下hls和rtmp对比：\n\n<img src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-25%2010.43.02.png\" alt=\"\" data-cke-saved-src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-25%2010.43.02.png\" />\n<h2><strong>8 推流</strong></h2>\n简所谓推流，就是将我们已经编码好的音视频数据发往视频流服务器中，一般常用的是使用rtmp推流，可以使用第三方库<strong><a href=\"https://github.com/ifactorylab/librtmp-iOS\" data-cke-saved-href=\"https://github.com/ifactorylab/librtmp-iOS\">librtmp-iOS</a></strong>进行推流，librtmp封装了一些核心的api供使用者调用，如果觉得麻烦，可以使用现成的ios视频推流sdk，也是基于rtmp的，<a href=\"https://github.com/runner365/LiveVideoCoreSDK\" data-cke-saved-href=\"https://github.com/runner365/LiveVideoCoreSDK\">https://github.com/runner365/LiveVideoCoreSDK</a>\n<h2><strong>9 推流服务器搭建</strong></h2>\n简简单的推流服务器搭建，由于我们上传的视频流都是基于rtmp协议的，所以服务器也必须要支持rtmp才行，大概需要以下几个步骤：\n\n<strong>1 安装一台nginx服务器。</strong>\n\n<strong>2 安装nginx的rtmp扩展，目前使用比较多的是<a href=\"https://github.com/arut/nginx-rtmp-module\" data-cke-saved-href=\"https://github.com/arut/nginx-rtmp-module\">https://github.com/arut/nginx-rtmp-module</a></strong>\n\n<strong>3 配置nginx的conf文件：</strong>\n<pre>rtmp {  \n  \n    server {  \n  \n        listen 1935;  #监听的端口\n  \n        chunk_size 4000;  \n        \n         \n        application hls {  #rtmp推流请求路径\n            live on;  \n            hls on;  \n            hls_path /usr/local/var/www/hls;  \n            hls_fragment 5s;  \n        }  \n    }  \n}</pre>\n<strong>4 重启nginx，将rtmp的推流地址写为rtmp://ip:1935/hls/mystream，其中hls_path表示生成的.m3u8和ts文件所存放的地址，hls_fragment表示切片时长，mysteam表示一个实例，即将来要生成的文件名可以先自己随便设置一个。更多配置可以参考：<a href=\"https://github.com/arut/nginx-rtmp-module/wiki/\" data-cke-saved-href=\"https://github.com/arut/nginx-rtmp-module/wiki/\">https://github.com/arut/nginx-rtmp-module/wiki/</a></strong>\n\n根据以上步骤基本上已经实现了一个支持rtmp的视频服务器了。\n<h2><strong>10 在html5页面进行播放直播视频？</strong></h2>\n简单来说，直接使用video标签即可播放hls协议的直播视频：\n<pre>&lt;video autoplay webkit-playsinline&gt;  \n    &lt;source src=\"http://10.66.69.77:8080/hls/mystream.m3u8\" type=\"application/vnd.apple.mpegurl\" /&gt;  \n    &lt;p class=\"warning\"&gt;Your browser does not support HTML5 video.&lt;/p&gt;  \n&lt;/video&gt;</pre>\n需要注意的是，给video标签增加webkit-playsinline属性，这个属性是为了让video视频在ios的uiwebview里面可以不全屏播放，默认ios会全屏播放视频，需要给uiwebview设置allowsInlineMediaPlayback＝YES。业界比较成熟的<a href=\"http://videojs.com/\" data-cke-saved-href=\"http://videojs.com/\">videojs</a>，可以根据不同平台选择不同的策略，例如ios使用video标签，pc使用flash等。\n<h2><strong>11 坑点总结</strong></h2>\n简根据以上步骤，笔者写了一个demo，从实现ios视频录制，采集，上传，nginx服务器下发直播流，h5页面播放直播视频者一整套流程，总结出以下几点比较坑的地方：\n\n1 在使用AVCaptureSession进行采集视频时，需要实现AVCaptureVideoDataOutputSampleBufferDelegate协议，同时在- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection捕获到视频流，要注意的是didOutputSampleBuffer这个方法不是didDropSampleBuffer方法，后者只会触发一次，当时开始写的是didDropSampleBuffer方法，差了半天才发现方法调用错了。\n\n2 在使用rtmp推流时，rmtp地址要以rtmp://开头，ip地址要写实际ip地址，不要写成localhost，同时要加上端口号，因为手机端上传时是无法识别localhost的。\n\n这里后续会补充上一些坑点，有的需要贴代码，这里先列这么多。\n<h2><strong>12 业界支持</strong></h2>\n目前，<a href=\"https://www.qcloud.com/solution/video.html\" data-cke-saved-href=\"https://www.qcloud.com/solution/video.html\">腾讯云</a>，百度云，阿里云都已经有了基于视频直播的解决方案，从视频录制到视频播放，推流，都有一系列的sdk可以使用，缺点就是需要收费，如果可以的话，自己实现一套也并不是难事哈。\n\n&nbsp;\n\ndemo地址：<a href=\"https://github.com/lvming6816077/LMVideoTest/\" data-cke-saved-href=\"http://blob/master/LMVideoTest/ViewController.m\">https://github.com/lvming6816077/LMVideoTest/</a>","slug":"H5视频直播扫盲","published":1,"updated":"2019-04-02T16:50:00.000Z","comments":1,"layout":"post","link":"","_id":"ckx434pzl000e2wvjeporgsya","content":"<p>视频直播这么火，再不学就out了。</p>\n<p>为了紧跟潮流，本文将向大家介绍一下视频直播中的基本流程和主要的技术点，包括但不限于前端技术。</p>\n<p></p><h2><span id=\"1-h5到底能不能做视频直播\"><strong>1 H5到底能不能做视频直播？</strong></span></h2><br>当然可以， H5火了这么久，涵盖了各个方面的技术。<br><a id=\"more\"></a><br>对于视频录制，可以使用强大的<span style=\"color: #0000cd;\">webRTC</span>（Web Real-Time Communication）是一个支持网页浏览器进行实时语音对话或视频对话的技术，缺点是只在PC的chrome上支持较好，移动端支持不太理想。<p></p>\n<p>对于视频播放，可以使用<span style=\"color: #0000cd;\">HLS</span>(HTTP Live Streaming)协议播放直播流，ios和android都天然支持这种协议，配置简单，直接使用video标签即可。</p>\n<p>webRTC兼容性：</p>\n<p><img src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2010.24.48.png\" alt data-cke-saved-src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2010.24.48.png\"></p>\n<p>video标签播放hls协议视频：</p>\n<p><pre class=\"lang:default decode:true\">&lt;video controls autoplay&gt;<br>    &lt;source src=”<a href=\"http://10.66.69.77:8080/hls/mystream.m3u8\" target=\"_blank\" rel=\"noopener\">http://10.66.69.77:8080/hls/mystream.m3u8</a>“ type=”application/vnd.apple.mpegurl” /&gt;<br>    &lt;p class=”warning”&gt;Your browser does not support HTML5 video.&lt;/p&gt;<br>&lt;/video&gt;</pre></p>\n<p></p><h2><span id=\"2-到底什么是hls协议\"><strong>2 到底什么是HLS协议？</strong></span></h2><br>当简单讲就是把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些，前面提到了用于H5播放直播视频时引入的一个<span style=\"color: #0000cd;\">.m3u8</span>的文件，这个文件就是基于HLS协议，存放视频流元数据的文件。<p></p>\n<p>每一个.m3u8文件，分别对应若干个ts文件，这些ts文件才是真正存放视频的数据，m3u8文件只是存放了一些ts文件的配置信息和相关路径，当视频播放时，.m3u8是动态改变的，video标签会解析这个文件，并找到对应的ts文件来播放，所以一般为了加快速度，.m3u8放在web服务器上，ts文件放在cdn上。</p>\n<p>.m3u8文件，其实就是以UTF-8编码的m3u文件，这个文件本身不能播放，只是存放了播放信息的文本文件：</p>\n<p><pre>​#EXTM3U                     m3u文件头</pre></p>\n<p>#EXT-X-MEDIA-SEQUENCE       第一个TS分片的序列号</p>\n<p>#EXT-X-TARGETDURATION       每个分片TS的最大的时长</p>\n<p>#EXT-X-ALLOW-CACHE          是否允许cache</p>\n<p>#EXT-X-ENDLIST              m3u8文件结束符</p>\n<p>#EXTINF                     指定每个媒体段(ts)的持续时间（秒），仅对其后面的URI有效<br>mystream-12.ts<br>ts文件：</p>\n<p><img src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2011.09.29.png\" alt data-cke-saved-src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2011.09.29.png\"></p>\n<p>HLS的请求流程是：<br><strong>1 http请求m3u8的url<br>2 服务端返回一个m3u8的播放列表，这个播放列表是实时跟新的，一般一次给出3段数据的url<br>3 客户端解析m3u8的播放列表，再按序请求每一段的url，获取ts数据流</strong></p>\n<p>简单流程：</p>\n<p><img src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2011.20.29.png\" alt data-cke-saved-src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2011.20.29.png\"></p>\n<p></p><h2><span id=\"3-hls直播延时\"><strong>3 HLS直播延时</strong></span></h2><br>当我们知道hls协议是将直播流分成一段一段的小段视频去下载播放的，所以假设列表里面的包含5个TS文件，每个TS文件包含5秒的视频内容，那么整体的延迟就是25秒。因为当你看到这些视频时，主播已经将视频录制好上传上去了，所以时这样产生的延迟。当然可以缩短列表的长度和单个TS文件的大小来降低延迟，极致来说可以缩减列表长度为1，并且TS的时长为1s，但是这样会造成请求次数增加，增大服务器压力，当网速慢时回造成更多的缓冲，所以苹果官方推荐的ts时长时10s，所以这样就会大改有30s的延迟。参考资料：<a href=\"https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/FrequentlyAskedQuestions/FrequentlyAskedQuestions.html\" data-cke-saved-href=\"https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/FrequentlyAskedQuestions/FrequentlyAskedQuestions.html\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/FrequentlyAskedQuestions/FrequentlyAskedQuestions.html</a><p></p>\n<p></p><h2><span id=\"4-视频直播的整个流程是什么\"><strong>4 视频直播的整个流程是什么？</strong></span></h2><br>当视频直播可大致分为：<p></p>\n<p><strong>1 视频录制端：一般是电脑上的音视频输入设备或者手机端的摄像头或者麦克风，目前已移动端的手机视频为主。</strong></p>\n<p><strong>2 视频播放端：可以是电脑上的播放器，手机端的native播放器，还有就是h5的video标签等，目前还是已手机端的native播放器为主。</strong></p>\n<p><strong>3 视频服务器端：一般是一台nginx服务器，用来接受视频录制端提供的视频源，同时提供给视频播放端流服务。</strong></p>\n<p>简单流程：</p>\n<p><img src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2011.33.20.png\" alt data-cke-saved-src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2011.33.20.png\"></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p></p><h2><span id=\"5-怎样进行音视频采集\"><strong>5 怎样进行音视频采集？</strong></span></h2><br>当首先明确几个概念：<p></p>\n<p><strong>视频编码：所谓视频编码就是指通过特定的压缩技术，将某个视频格式的文件转换成另一种视频格式文件的方式，我们使用的iphone录制的视频，必须要经过编码，上传，解码，才能真正的在用户端的播放器里播放。</strong></p>\n<p><strong>编解码标准：视频流传输中最为重要的编解码标准有国际电联的H.261、H.263、H.264，其中HLS协议支持<span style=\"color: #0000cd;\">H.264</span>格式的编码。<br>音频编码：同视频编码类似，将原始的音频流按照一定的标准进行编码，上传，解码，同时在播放器里播放，当然音频也有许多编码标准，例如PCM编码，WMA编码，AAC编码等等，这里我们HLS协议支持的音频编码方式是<span style=\"color: #0000cd;\">AAC编码</span>。</strong></p>\n<p>下面将利用ios上的摄像头，进行音视频的数据采集，主要分为以下几个步骤：</p>\n<p>&nbsp;</p>\n<p><strong>1 音视频的采集，ios中，利用<span style=\"color: #0000cd;\">AVCaptureSession</span>和<span style=\"color: #0000cd;\">AVCaptureDevice</span>可以采集到原始的音视频数据流。<br>2 对视频进行H264编码，对音频进行AAC编码，在ios中分别有已经封装好的编码库来实现对音视频的编码。<br>3 对编码后的音、视频数据进行组装封包；<br>4 建立<span style=\"color: #0000cd;\">RTMP</span>连接并上推到服务端。</strong></p>\n<p>&nbsp;</p>\n<p>ps：由于编码库大多使用c语言编写，需要自己使用时编译，对于ios，可以使用已经编译好的编码库。</p>\n<p>x264编码：<a href=\"https://github.com/kewlbear/x264-ios\" data-cke-saved-href=\"https://github.com/kewlbear/x264-ios\" target=\"_blank\" rel=\"noopener\">https://github.com/kewlbear/x264-ios</a></p>\n<p>faac编码：<a href=\"https://github.com/fflydev/faac-ios-build\" data-cke-saved-href=\"https://github.com/fflydev/faac-ios-build\" target=\"_blank\" rel=\"noopener\">https://github.com/fflydev/faac-ios-build</a></p>\n<p>ffmpeg编码：<a href=\"https://github.com/kewlbear/FFmpeg-iOS-build-script\" data-cke-saved-href=\"https://github.com/kewlbear/FFmpeg-iOS-build-script\" target=\"_blank\" rel=\"noopener\">https://github.com/kewlbear/FFmpeg-iOS-build-script</a></p>\n<p>关于如果想给视频增加一些特殊效果，例如增加滤镜等，一般在编码前给使用滤镜库，但是这样也会造成一些耗时，导致上传视频数据有一定延时。</p>\n<p>简单流程：</p>\n<p><img src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2012.07.49.png\" alt data-cke-saved-src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2012.07.49.png\"></p>\n<p></p><h2><span id=\"6-前面提到的ffmpeg是什么\"><strong>6 前面提到的ffmpeg是什么？</strong></span></h2><br>和之前的<span style=\"color: #0000cd;\">x264</span>一样，<span style=\"color: #0000cd;\">ffmpeg</span>其实也是一套编码库，类似的还有Xvid，Xvid是基于MPEG4协议的编解码器，x264是基于H.264协议的编码器，ffmpeg集合了各种音频，视频编解码协议，通过设置参数可以完成基于MPEG4,H.264等协议的编解码，demo这里使用的是x264编码库。<p></p>\n<p></p><h2><span id=\"7-什么是rtmp\"><strong>7 什么是RTMP？</strong></span></h2><br>Real Time Messaging Protocol（简称 RTMP）是 Macromedia 开发的一套视频直播协议，现在属于 Adobe。和HLS一样都可以应用于视频直播，区别是RTMP基于flash无法在ios的浏览器里播放，但是实时性比HLS要好。所以一般使用这种协议来上传视频流，也就是视频流推送到服务器。<p></p>\n<p>这里列举一下hls和rtmp对比：</p>\n<p><img src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-25%2010.43.02.png\" alt data-cke-saved-src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-25%2010.43.02.png\"></p>\n<p></p><h2><span id=\"8-推流\"><strong>8 推流</strong></span></h2><br>简所谓推流，就是将我们已经编码好的音视频数据发往视频流服务器中，一般常用的是使用rtmp推流，可以使用第三方库<strong><a href=\"https://github.com/ifactorylab/librtmp-iOS\" data-cke-saved-href=\"https://github.com/ifactorylab/librtmp-iOS\" target=\"_blank\" rel=\"noopener\">librtmp-iOS</a></strong>进行推流，librtmp封装了一些核心的api供使用者调用，如果觉得麻烦，可以使用现成的ios视频推流sdk，也是基于rtmp的，<a href=\"https://github.com/runner365/LiveVideoCoreSDK\" data-cke-saved-href=\"https://github.com/runner365/LiveVideoCoreSDK\" target=\"_blank\" rel=\"noopener\">https://github.com/runner365/LiveVideoCoreSDK</a><p></p>\n<p></p><h2><span id=\"9-推流服务器搭建\"><strong>9 推流服务器搭建</strong></span></h2><br>简简单的推流服务器搭建，由于我们上传的视频流都是基于rtmp协议的，所以服务器也必须要支持rtmp才行，大概需要以下几个步骤：<p></p>\n<p><strong>1 安装一台nginx服务器。</strong></p>\n<p><strong>2 安装nginx的rtmp扩展，目前使用比较多的是<a href=\"https://github.com/arut/nginx-rtmp-module\" data-cke-saved-href=\"https://github.com/arut/nginx-rtmp-module\" target=\"_blank\" rel=\"noopener\">https://github.com/arut/nginx-rtmp-module</a></strong></p>\n<p><strong>3 配置nginx的conf文件：</strong></p>\n<p><pre>rtmp {  </pre></p>\n<pre><code>server {  \n\n    listen 1935;  #监听的端口\n\n    chunk_size 4000;  \n\n\n    application hls {  #rtmp推流请求路径\n        live on;  \n        hls on;  \n        hls_path /usr/local/var/www/hls;  \n        hls_fragment 5s;  \n    }  \n}  \n</code></pre><p>}<br><strong>4 重启nginx，将rtmp的推流地址写为rtmp://ip:1935/hls/mystream，其中hls_path表示生成的.m3u8和ts文件所存放的地址，hls_fragment表示切片时长，mysteam表示一个实例，即将来要生成的文件名可以先自己随便设置一个。更多配置可以参考：<a href=\"https://github.com/arut/nginx-rtmp-module/wiki/\" data-cke-saved-href=\"https://github.com/arut/nginx-rtmp-module/wiki/\" target=\"_blank\" rel=\"noopener\">https://github.com/arut/nginx-rtmp-module/wiki/</a></strong></p>\n<p>根据以上步骤基本上已经实现了一个支持rtmp的视频服务器了。</p>\n<p></p><h2><span id=\"10-在html5页面进行播放直播视频\"><strong>10 在html5页面进行播放直播视频？</strong></span></h2><br>简单来说，直接使用video标签即可播放hls协议的直播视频：<p></p>\n<p><pre>&lt;video autoplay webkit-playsinline&gt;<br>    &lt;source src=”<a href=\"http://10.66.69.77:8080/hls/mystream.m3u8\" target=\"_blank\" rel=\"noopener\">http://10.66.69.77:8080/hls/mystream.m3u8</a>“ type=”application/vnd.apple.mpegurl” /&gt;<br>    &lt;p class=”warning”&gt;Your browser does not support HTML5 video.&lt;/p&gt;<br>&lt;/video&gt;</pre><br>需要注意的是，给video标签增加webkit-playsinline属性，这个属性是为了让video视频在ios的uiwebview里面可以不全屏播放，默认ios会全屏播放视频，需要给uiwebview设置allowsInlineMediaPlayback＝YES。业界比较成熟的<a href=\"http://videojs.com/\" data-cke-saved-href=\"http://videojs.com/\" target=\"_blank\" rel=\"noopener\">videojs</a>，可以根据不同平台选择不同的策略，例如ios使用video标签，pc使用flash等。</p>\n<p></p><h2><span id=\"11-坑点总结\"><strong>11 坑点总结</strong></span></h2><br>简根据以上步骤，笔者写了一个demo，从实现ios视频录制，采集，上传，nginx服务器下发直播流，h5页面播放直播视频者一整套流程，总结出以下几点比较坑的地方：<p></p>\n<p>1 在使用AVCaptureSession进行采集视频时，需要实现AVCaptureVideoDataOutputSampleBufferDelegate协议，同时在- (void)captureOutput:(AVCaptureOutput <em>)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection </em>)connection捕获到视频流，要注意的是didOutputSampleBuffer这个方法不是didDropSampleBuffer方法，后者只会触发一次，当时开始写的是didDropSampleBuffer方法，差了半天才发现方法调用错了。</p>\n<p>2 在使用rtmp推流时，rmtp地址要以rtmp://开头，ip地址要写实际ip地址，不要写成localhost，同时要加上端口号，因为手机端上传时是无法识别localhost的。</p>\n<p>这里后续会补充上一些坑点，有的需要贴代码，这里先列这么多。</p>\n<p></p><h2><span id=\"12-业界支持\"><strong>12 业界支持</strong></span></h2><br>目前，<a href=\"https://www.qcloud.com/solution/video.html\" data-cke-saved-href=\"https://www.qcloud.com/solution/video.html\" target=\"_blank\" rel=\"noopener\">腾讯云</a>，百度云，阿里云都已经有了基于视频直播的解决方案，从视频录制到视频播放，推流，都有一系列的sdk可以使用，缺点就是需要收费，如果可以的话，自己实现一套也并不是难事哈。<p></p>\n<p>&nbsp;</p>\n<p>demo地址：<a href=\"https://github.com/lvming6816077/LMVideoTest/\" data-cke-saved-href=\"http://blob/master/LMVideoTest/ViewController.m\" target=\"_blank\" rel=\"noopener\">https://github.com/lvming6816077/LMVideoTest/</a></p>\n","site":{"data":{}},"excerpt":"<p>视频直播这么火，再不学就out了。</p>\n<p>为了紧跟潮流，本文将向大家介绍一下视频直播中的基本流程和主要的技术点，包括但不限于前端技术。</p>\n<p></p><h2><strong>1 H5到底能不能做视频直播？</strong></h2><br>当然可以， H5火了这么久，涵盖了各个方面的技术。<br>","more":"<br>对于视频录制，可以使用强大的<span style=\"color: #0000cd;\">webRTC</span>（Web Real-Time Communication）是一个支持网页浏览器进行实时语音对话或视频对话的技术，缺点是只在PC的chrome上支持较好，移动端支持不太理想。<p></p>\n<p>对于视频播放，可以使用<span style=\"color: #0000cd;\">HLS</span>(HTTP Live Streaming)协议播放直播流，ios和android都天然支持这种协议，配置简单，直接使用video标签即可。</p>\n<p>webRTC兼容性：</p>\n<p><img src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2010.24.48.png\" alt=\"\" data-cke-saved-src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2010.24.48.png\"></p>\n<p>video标签播放hls协议视频：</p>\n<p><pre class=\"lang:default decode:true\">&lt;video controls autoplay&gt;<br>    &lt;source src=”<a href=\"http://10.66.69.77:8080/hls/mystream.m3u8\" target=\"_blank\" rel=\"noopener\">http://10.66.69.77:8080/hls/mystream.m3u8</a>“ type=”application/vnd.apple.mpegurl” /&gt;<br>    &lt;p class=”warning”&gt;Your browser does not support HTML5 video.&lt;/p&gt;<br>&lt;/video&gt;</pre></p>\n<p></p><h2><strong>2 到底什么是HLS协议？</strong></h2><br>当简单讲就是把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些，前面提到了用于H5播放直播视频时引入的一个<span style=\"color: #0000cd;\">.m3u8</span>的文件，这个文件就是基于HLS协议，存放视频流元数据的文件。<p></p>\n<p>每一个.m3u8文件，分别对应若干个ts文件，这些ts文件才是真正存放视频的数据，m3u8文件只是存放了一些ts文件的配置信息和相关路径，当视频播放时，.m3u8是动态改变的，video标签会解析这个文件，并找到对应的ts文件来播放，所以一般为了加快速度，.m3u8放在web服务器上，ts文件放在cdn上。</p>\n<p>.m3u8文件，其实就是以UTF-8编码的m3u文件，这个文件本身不能播放，只是存放了播放信息的文本文件：</p>\n<p><pre>​#EXTM3U                     m3u文件头</pre></p>\n<p>#EXT-X-MEDIA-SEQUENCE       第一个TS分片的序列号</p>\n<p>#EXT-X-TARGETDURATION       每个分片TS的最大的时长</p>\n<p>#EXT-X-ALLOW-CACHE          是否允许cache</p>\n<p>#EXT-X-ENDLIST              m3u8文件结束符</p>\n<p>#EXTINF                     指定每个媒体段(ts)的持续时间（秒），仅对其后面的URI有效<br>mystream-12.ts<br>ts文件：</p>\n<p><img src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2011.09.29.png\" alt=\"\" data-cke-saved-src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2011.09.29.png\"></p>\n<p>HLS的请求流程是：<br><strong>1 http请求m3u8的url<br>2 服务端返回一个m3u8的播放列表，这个播放列表是实时跟新的，一般一次给出3段数据的url<br>3 客户端解析m3u8的播放列表，再按序请求每一段的url，获取ts数据流</strong></p>\n<p>简单流程：</p>\n<p><img src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2011.20.29.png\" alt=\"\" data-cke-saved-src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2011.20.29.png\"></p>\n<p></p><h2><strong>3 HLS直播延时</strong></h2><br>当我们知道hls协议是将直播流分成一段一段的小段视频去下载播放的，所以假设列表里面的包含5个TS文件，每个TS文件包含5秒的视频内容，那么整体的延迟就是25秒。因为当你看到这些视频时，主播已经将视频录制好上传上去了，所以时这样产生的延迟。当然可以缩短列表的长度和单个TS文件的大小来降低延迟，极致来说可以缩减列表长度为1，并且TS的时长为1s，但是这样会造成请求次数增加，增大服务器压力，当网速慢时回造成更多的缓冲，所以苹果官方推荐的ts时长时10s，所以这样就会大改有30s的延迟。参考资料：<a href=\"https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/FrequentlyAskedQuestions/FrequentlyAskedQuestions.html\" data-cke-saved-href=\"https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/FrequentlyAskedQuestions/FrequentlyAskedQuestions.html\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/FrequentlyAskedQuestions/FrequentlyAskedQuestions.html</a><p></p>\n<p></p><h2><strong>4 视频直播的整个流程是什么？</strong></h2><br>当视频直播可大致分为：<p></p>\n<p><strong>1 视频录制端：一般是电脑上的音视频输入设备或者手机端的摄像头或者麦克风，目前已移动端的手机视频为主。</strong></p>\n<p><strong>2 视频播放端：可以是电脑上的播放器，手机端的native播放器，还有就是h5的video标签等，目前还是已手机端的native播放器为主。</strong></p>\n<p><strong>3 视频服务器端：一般是一台nginx服务器，用来接受视频录制端提供的视频源，同时提供给视频播放端流服务。</strong></p>\n<p>简单流程：</p>\n<p><img src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2011.33.20.png\" alt=\"\" data-cke-saved-src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2011.33.20.png\"></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p></p><h2><strong>5 怎样进行音视频采集？</strong></h2><br>当首先明确几个概念：<p></p>\n<p><strong>视频编码：所谓视频编码就是指通过特定的压缩技术，将某个视频格式的文件转换成另一种视频格式文件的方式，我们使用的iphone录制的视频，必须要经过编码，上传，解码，才能真正的在用户端的播放器里播放。</strong></p>\n<p><strong>编解码标准：视频流传输中最为重要的编解码标准有国际电联的H.261、H.263、H.264，其中HLS协议支持<span style=\"color: #0000cd;\">H.264</span>格式的编码。<br>音频编码：同视频编码类似，将原始的音频流按照一定的标准进行编码，上传，解码，同时在播放器里播放，当然音频也有许多编码标准，例如PCM编码，WMA编码，AAC编码等等，这里我们HLS协议支持的音频编码方式是<span style=\"color: #0000cd;\">AAC编码</span>。</strong></p>\n<p>下面将利用ios上的摄像头，进行音视频的数据采集，主要分为以下几个步骤：</p>\n<p>&nbsp;</p>\n<p><strong>1 音视频的采集，ios中，利用<span style=\"color: #0000cd;\">AVCaptureSession</span>和<span style=\"color: #0000cd;\">AVCaptureDevice</span>可以采集到原始的音视频数据流。<br>2 对视频进行H264编码，对音频进行AAC编码，在ios中分别有已经封装好的编码库来实现对音视频的编码。<br>3 对编码后的音、视频数据进行组装封包；<br>4 建立<span style=\"color: #0000cd;\">RTMP</span>连接并上推到服务端。</strong></p>\n<p>&nbsp;</p>\n<p>ps：由于编码库大多使用c语言编写，需要自己使用时编译，对于ios，可以使用已经编译好的编码库。</p>\n<p>x264编码：<a href=\"https://github.com/kewlbear/x264-ios\" data-cke-saved-href=\"https://github.com/kewlbear/x264-ios\" target=\"_blank\" rel=\"noopener\">https://github.com/kewlbear/x264-ios</a></p>\n<p>faac编码：<a href=\"https://github.com/fflydev/faac-ios-build\" data-cke-saved-href=\"https://github.com/fflydev/faac-ios-build\" target=\"_blank\" rel=\"noopener\">https://github.com/fflydev/faac-ios-build</a></p>\n<p>ffmpeg编码：<a href=\"https://github.com/kewlbear/FFmpeg-iOS-build-script\" data-cke-saved-href=\"https://github.com/kewlbear/FFmpeg-iOS-build-script\" target=\"_blank\" rel=\"noopener\">https://github.com/kewlbear/FFmpeg-iOS-build-script</a></p>\n<p>关于如果想给视频增加一些特殊效果，例如增加滤镜等，一般在编码前给使用滤镜库，但是这样也会造成一些耗时，导致上传视频数据有一定延时。</p>\n<p>简单流程：</p>\n<p><img src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2012.07.49.png\" alt=\"\" data-cke-saved-src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-23%2012.07.49.png\"></p>\n<p></p><h2><strong>6 前面提到的ffmpeg是什么？</strong></h2><br>和之前的<span style=\"color: #0000cd;\">x264</span>一样，<span style=\"color: #0000cd;\">ffmpeg</span>其实也是一套编码库，类似的还有Xvid，Xvid是基于MPEG4协议的编解码器，x264是基于H.264协议的编码器，ffmpeg集合了各种音频，视频编解码协议，通过设置参数可以完成基于MPEG4,H.264等协议的编解码，demo这里使用的是x264编码库。<p></p>\n<p></p><h2><strong>7 什么是RTMP？</strong></h2><br>Real Time Messaging Protocol（简称 RTMP）是 Macromedia 开发的一套视频直播协议，现在属于 Adobe。和HLS一样都可以应用于视频直播，区别是RTMP基于flash无法在ios的浏览器里播放，但是实时性比HLS要好。所以一般使用这种协议来上传视频流，也就是视频流推送到服务器。<p></p>\n<p>这里列举一下hls和rtmp对比：</p>\n<p><img src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-25%2010.43.02.png\" alt=\"\" data-cke-saved-src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-25%2010.43.02.png\"></p>\n<p></p><h2><strong>8 推流</strong></h2><br>简所谓推流，就是将我们已经编码好的音视频数据发往视频流服务器中，一般常用的是使用rtmp推流，可以使用第三方库<strong><a href=\"https://github.com/ifactorylab/librtmp-iOS\" data-cke-saved-href=\"https://github.com/ifactorylab/librtmp-iOS\" target=\"_blank\" rel=\"noopener\">librtmp-iOS</a></strong>进行推流，librtmp封装了一些核心的api供使用者调用，如果觉得麻烦，可以使用现成的ios视频推流sdk，也是基于rtmp的，<a href=\"https://github.com/runner365/LiveVideoCoreSDK\" data-cke-saved-href=\"https://github.com/runner365/LiveVideoCoreSDK\" target=\"_blank\" rel=\"noopener\">https://github.com/runner365/LiveVideoCoreSDK</a><p></p>\n<p></p><h2><strong>9 推流服务器搭建</strong></h2><br>简简单的推流服务器搭建，由于我们上传的视频流都是基于rtmp协议的，所以服务器也必须要支持rtmp才行，大概需要以下几个步骤：<p></p>\n<p><strong>1 安装一台nginx服务器。</strong></p>\n<p><strong>2 安装nginx的rtmp扩展，目前使用比较多的是<a href=\"https://github.com/arut/nginx-rtmp-module\" data-cke-saved-href=\"https://github.com/arut/nginx-rtmp-module\" target=\"_blank\" rel=\"noopener\">https://github.com/arut/nginx-rtmp-module</a></strong></p>\n<p><strong>3 配置nginx的conf文件：</strong></p>\n<p><pre>rtmp {  </pre></p>\n<pre><code>server {  \n\n    listen 1935;  #监听的端口\n\n    chunk_size 4000;  \n\n\n    application hls {  #rtmp推流请求路径\n        live on;  \n        hls on;  \n        hls_path /usr/local/var/www/hls;  \n        hls_fragment 5s;  \n    }  \n}  \n</code></pre><p>}<br><strong>4 重启nginx，将rtmp的推流地址写为rtmp://ip:1935/hls/mystream，其中hls_path表示生成的.m3u8和ts文件所存放的地址，hls_fragment表示切片时长，mysteam表示一个实例，即将来要生成的文件名可以先自己随便设置一个。更多配置可以参考：<a href=\"https://github.com/arut/nginx-rtmp-module/wiki/\" data-cke-saved-href=\"https://github.com/arut/nginx-rtmp-module/wiki/\" target=\"_blank\" rel=\"noopener\">https://github.com/arut/nginx-rtmp-module/wiki/</a></strong></p>\n<p>根据以上步骤基本上已经实现了一个支持rtmp的视频服务器了。</p>\n<p></p><h2><strong>10 在html5页面进行播放直播视频？</strong></h2><br>简单来说，直接使用video标签即可播放hls协议的直播视频：<p></p>\n<p><pre>&lt;video autoplay webkit-playsinline&gt;<br>    &lt;source src=”<a href=\"http://10.66.69.77:8080/hls/mystream.m3u8\" target=\"_blank\" rel=\"noopener\">http://10.66.69.77:8080/hls/mystream.m3u8</a>“ type=”application/vnd.apple.mpegurl” /&gt;<br>    &lt;p class=”warning”&gt;Your browser does not support HTML5 video.&lt;/p&gt;<br>&lt;/video&gt;</pre><br>需要注意的是，给video标签增加webkit-playsinline属性，这个属性是为了让video视频在ios的uiwebview里面可以不全屏播放，默认ios会全屏播放视频，需要给uiwebview设置allowsInlineMediaPlayback＝YES。业界比较成熟的<a href=\"http://videojs.com/\" data-cke-saved-href=\"http://videojs.com/\" target=\"_blank\" rel=\"noopener\">videojs</a>，可以根据不同平台选择不同的策略，例如ios使用video标签，pc使用flash等。</p>\n<p></p><h2><strong>11 坑点总结</strong></h2><br>简根据以上步骤，笔者写了一个demo，从实现ios视频录制，采集，上传，nginx服务器下发直播流，h5页面播放直播视频者一整套流程，总结出以下几点比较坑的地方：<p></p>\n<p>1 在使用AVCaptureSession进行采集视频时，需要实现AVCaptureVideoDataOutputSampleBufferDelegate协议，同时在- (void)captureOutput:(AVCaptureOutput <em>)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection </em>)connection捕获到视频流，要注意的是didOutputSampleBuffer这个方法不是didDropSampleBuffer方法，后者只会触发一次，当时开始写的是didDropSampleBuffer方法，差了半天才发现方法调用错了。</p>\n<p>2 在使用rtmp推流时，rmtp地址要以rtmp://开头，ip地址要写实际ip地址，不要写成localhost，同时要加上端口号，因为手机端上传时是无法识别localhost的。</p>\n<p>这里后续会补充上一些坑点，有的需要贴代码，这里先列这么多。</p>\n<p></p><h2><strong>12 业界支持</strong></h2><br>目前，<a href=\"https://www.qcloud.com/solution/video.html\" data-cke-saved-href=\"https://www.qcloud.com/solution/video.html\" target=\"_blank\" rel=\"noopener\">腾讯云</a>，百度云，阿里云都已经有了基于视频直播的解决方案，从视频录制到视频播放，推流，都有一系列的sdk可以使用，缺点就是需要收费，如果可以的话，自己实现一套也并不是难事哈。<p></p>\n<p>&nbsp;</p>\n<p>demo地址：<a href=\"https://github.com/lvming6816077/LMVideoTest/\" data-cke-saved-href=\"http://blob/master/LMVideoTest/ViewController.m\" target=\"_blank\" rel=\"noopener\">https://github.com/lvming6816077/LMVideoTest/</a></p>"},{"title":"HTML5离线存储之Application Cache","date":"2014-08-28T08:50:58.000Z","_content":"关于html5的离线存储，大致可分为：\n<ul>\n\t<li><span style=\"color: #303942;\">localStorage, sessionStorage</span></li>\n\t<li>indexedDB</li>\n\t<li>web sql</li>\n\t<li>application cache</li>\n</ul>\n<!--more-->\n可以在chrome的debug工具/Resources下产看，下面来着重说明一下Application Cache。\n<h3>访问流程</h3>\n<img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/applicationcache.png\" alt=\"\" width=\"922\" height=\"305\" />\n当我们第一次正确配置app cache后，当我们再次访问该应用时，浏览器会首先检查manifest文件是否有变动，如果有变动就会把相应的变得跟新下来，同时改变浏览器里面的app cache，如果没有变动，就会直接把app cache的资源返回，基本流程是这样的。\n\n&nbsp;\n<h3>特点</h3>\n<ul style=\"color: #4d4e53;\">\n\t<li>离线浏览: 用户可以在离线状态下浏览网站内容。</li>\n\t<li>更快的速度: 因为数据被存储在本地，所以速度会更快.</li>\n\t<li>减轻服务器的负载: 浏览器只会下载在服务器上发生改变的资源。</li>\n</ul>\n&nbsp;\n<h3>如何使用</h3>\n首先，我们建立一个html文件，类似这样：\n```html\n<!DOCTYPE html>\n<html lang=\"en\" manifest=\"manifest.appcache\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>APP CACHE</title>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"test.css\">\n</head>\n<body>\n    <img src=\"img/1.jpg\">\n    <img src=\"img/2.jpg\">\n<script type=\"text/javascript\">\n    window.addEventListener('load', function(e){\n        console.log(window.applicationCache.status);\n    })\n</script>\n</body>\n</html>\n```\n可能有些代码看不懂，我们先看最简单的，第一行配置了一个manifest=\"manifest.appcache\"（<span style=\"color: #ff0000;\">注意是mani不是main</span>），这是使用app cache首先要配置的，然后我们在这个html文件里引入了两个img做为测试用，然后监听了load时间来查看看application的status，关于applicationCache的api，可以<a href=\"http://www.w3school.com.cn/html5/html_5_app_cache.asp\" target=\"_blank\">查看</a>。\n\n然后在相同目录下新建一个manifest.appcache文件，注意关于路径要和html页面配置时一致即可。\n<pre class=\"lang:default decode:true\">CACHE MANIFEST\n#version 1.3\nCACHE:\n    img/1.jpg\n    img/2.jpg\n    test.css\nNETWORK:\n    *</pre>\n关于manifest.appcache文件，基本格式为<span style=\"color: #4d4e53;\">三段： </span><code style=\"color: #4d4e53;\">CACHE，</code><span style=\"color: #4d4e53;\"> </span><code style=\"color: #4d4e53;\">NETWORK，</code><span style=\"color: #4d4e53;\">与 </span><code style=\"color: #4d4e53;\">FALLBACK，其中NETWORK和FALLBACK为可选项，而第一行CACHE MANIFEST为固定格式，必须写在前面。</code>\n\n<strong><code style=\"font-weight: inherit; font-style: inherit;\">CACHE:（必须）</code></strong>\n\n标识出哪些文件需要缓存，可以是相对路径也可以是绝对路径。例如：aa.css，http://www.baidu.com/aa.js.\n\n\n\n<strong><code style=\"font-weight: inherit; font-style: inherit;\">NETWORK:（可选）</code></strong>\n\n这一部分是要绕过缓存直接读取的文件，可以使用通配符＊，,也就是说除了上面的cache文件，剩下的文件每次都要重新拉取。例如＊，login.php。\n\n\n\n<strong><code style=\"font-weight: inherit; font-style: inherit;\">FALLBACK:（可选）</code></strong>\n\n指定了一个后备页面，当资源无法访问时，浏览器会使用该页面。该段落的每条记录都列出两个 URI—第一个表示资源，第二个表示后备页面。两个 URI 都必须使用相对路径并且与清单文件同源。可以使用通配符。例如*.html  /offline.html。\n\n有了上面两个文件之后还要配置服务器的mime.types类型，找大盘apache的mime.types文件，添加\n<pre class=\"lang:default decode:true \">text/cache-manifest .appcache</pre>\nOK，上面文件配置完成之后，application cache就可以运行了。\n\n查看console：\n\n<img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/appcache2.png\" alt=\"\" width=\"1010\" height=\"420\" />\n可以看到，一下子这么多log，但是除了4是我们console的log之外，其他的都是appcache自己打的，因为我们配置了manifest，系统会默认打出appcache的log。关于status的值：\n\n然后，通过log，我们看到一些文件已经被缓存，我们可以查看chrome Resources来查看：\n\n<img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/appcache3.png\" alt=\"\" width=\"1439\" height=\"277\" />\n\n可以看到我们的test.html文件也已经被缓存下来了，type是master，顾名思义一个管理着，而manifest.appcache文件为manifest类型。此时我们的appcache已经完成。我们可以尝试把网线断了，或者把服务器关了，同样，我们的项目仍然可以访问，这就是离线缓存。此时console：\n\n<img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/appcache4.png\" alt=\"\" width=\"1010\" height=\"218\" />\n\n证明直接从缓存拿去文件：\n\n<img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/appcache5.png\" alt=\"\" width=\"794\" height=\"267\" />\n\n<strong>更新缓存的方式</strong>\n更新manifest文件\n浏览器发现manifest文件本身发生变化，便会根据新的manifest文件去获取新的资源进行缓存。\n\n当manifest文件列表并没有变化的时候，我们通常通过修改manifest注释的方式来改变文件，从而实现更新。\n通过javascript操作\n浏览器提供了applicationCache供js访问，通过对于applicationCache对象的操作也能达到更新缓存的目的。\n清除浏览器缓存\n\n<div>对于第一种，我们修改一下manifest文件，把version改为1.4，然后刷新页面。</div>\n<div><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/appcache6.png\" alt=\"\" width=\"1009\" height=\"292\" /></div>\n<div>我们可以发现，appcache更新了缓存重新从网络上拉去的cache的文件，但是，我们如果想要看到改变，必须再次刷新页面。</div>\n<div></div>\n<div>对于第二种方法，我们首先修改一下我们的js，添加一个监听事件：</div>\n<div>\n```javascript\nwindow.applicationCache.addEventListener('updateready', function(){\n        console.log('updateready!');\n        window.applicationCache.swapCache();\n    });\n```\n清除浏览器缓存再试一次，这次我们在console里调用window.applicationCache.update();，看看发生了什么：\n\n<img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/appcache7.png\" alt=\"\" width=\"864\" height=\"211\" />\n\nupdateready事件触发了，同样，appcache也更新了缓存，其中swapCache方法的意思是重新应用跟新后的缓存来替换原来的缓存！，到这里后基本的appcache也差不多了。\n<h3>注意事项：</h3>\n<ul>\n\t<li>站点离线存储的容量限制是5M</li>\n\t<li>如果manifest文件，或者内部列举的某一个文件不能正常下载，整个更新过程将视为失败，浏览器继续全部使用老的缓存</li>\n\t<li>引用manifest的html必须与manifest文件同源，在同一个域下</li>\n\t<li>FALLBACK中的资源必须和manifest文件同源</li>\n\t<li>当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。</li>\n\t<li>站点中的其他页面即使没有设置manifest属性，请求的资源如果在缓存中也从缓存中访问</li>\n\t<li>当manifest文件发生改变时，资源请求本身也会触发更新</li>\n</ul>\n完！\n\n</div>","source":"_posts/HTML5离线存储之Application-Cache.md","raw":"---\ntitle: HTML5离线存储之Application Cache\ndate: 2014-08-28 16:50:58\ntags:\n- 离线存储\n- HTML5\ncategories:\n- 425\n---\n关于html5的离线存储，大致可分为：\n<ul>\n\t<li><span style=\"color: #303942;\">localStorage, sessionStorage</span></li>\n\t<li>indexedDB</li>\n\t<li>web sql</li>\n\t<li>application cache</li>\n</ul>\n<!--more-->\n可以在chrome的debug工具/Resources下产看，下面来着重说明一下Application Cache。\n<h3>访问流程</h3>\n<img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/applicationcache.png\" alt=\"\" width=\"922\" height=\"305\" />\n当我们第一次正确配置app cache后，当我们再次访问该应用时，浏览器会首先检查manifest文件是否有变动，如果有变动就会把相应的变得跟新下来，同时改变浏览器里面的app cache，如果没有变动，就会直接把app cache的资源返回，基本流程是这样的。\n\n&nbsp;\n<h3>特点</h3>\n<ul style=\"color: #4d4e53;\">\n\t<li>离线浏览: 用户可以在离线状态下浏览网站内容。</li>\n\t<li>更快的速度: 因为数据被存储在本地，所以速度会更快.</li>\n\t<li>减轻服务器的负载: 浏览器只会下载在服务器上发生改变的资源。</li>\n</ul>\n&nbsp;\n<h3>如何使用</h3>\n首先，我们建立一个html文件，类似这样：\n```html\n<!DOCTYPE html>\n<html lang=\"en\" manifest=\"manifest.appcache\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>APP CACHE</title>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"test.css\">\n</head>\n<body>\n    <img src=\"img/1.jpg\">\n    <img src=\"img/2.jpg\">\n<script type=\"text/javascript\">\n    window.addEventListener('load', function(e){\n        console.log(window.applicationCache.status);\n    })\n</script>\n</body>\n</html>\n```\n可能有些代码看不懂，我们先看最简单的，第一行配置了一个manifest=\"manifest.appcache\"（<span style=\"color: #ff0000;\">注意是mani不是main</span>），这是使用app cache首先要配置的，然后我们在这个html文件里引入了两个img做为测试用，然后监听了load时间来查看看application的status，关于applicationCache的api，可以<a href=\"http://www.w3school.com.cn/html5/html_5_app_cache.asp\" target=\"_blank\">查看</a>。\n\n然后在相同目录下新建一个manifest.appcache文件，注意关于路径要和html页面配置时一致即可。\n<pre class=\"lang:default decode:true\">CACHE MANIFEST\n#version 1.3\nCACHE:\n    img/1.jpg\n    img/2.jpg\n    test.css\nNETWORK:\n    *</pre>\n关于manifest.appcache文件，基本格式为<span style=\"color: #4d4e53;\">三段： </span><code style=\"color: #4d4e53;\">CACHE，</code><span style=\"color: #4d4e53;\"> </span><code style=\"color: #4d4e53;\">NETWORK，</code><span style=\"color: #4d4e53;\">与 </span><code style=\"color: #4d4e53;\">FALLBACK，其中NETWORK和FALLBACK为可选项，而第一行CACHE MANIFEST为固定格式，必须写在前面。</code>\n\n<strong><code style=\"font-weight: inherit; font-style: inherit;\">CACHE:（必须）</code></strong>\n\n标识出哪些文件需要缓存，可以是相对路径也可以是绝对路径。例如：aa.css，http://www.baidu.com/aa.js.\n\n\n\n<strong><code style=\"font-weight: inherit; font-style: inherit;\">NETWORK:（可选）</code></strong>\n\n这一部分是要绕过缓存直接读取的文件，可以使用通配符＊，,也就是说除了上面的cache文件，剩下的文件每次都要重新拉取。例如＊，login.php。\n\n\n\n<strong><code style=\"font-weight: inherit; font-style: inherit;\">FALLBACK:（可选）</code></strong>\n\n指定了一个后备页面，当资源无法访问时，浏览器会使用该页面。该段落的每条记录都列出两个 URI—第一个表示资源，第二个表示后备页面。两个 URI 都必须使用相对路径并且与清单文件同源。可以使用通配符。例如*.html  /offline.html。\n\n有了上面两个文件之后还要配置服务器的mime.types类型，找大盘apache的mime.types文件，添加\n<pre class=\"lang:default decode:true \">text/cache-manifest .appcache</pre>\nOK，上面文件配置完成之后，application cache就可以运行了。\n\n查看console：\n\n<img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/appcache2.png\" alt=\"\" width=\"1010\" height=\"420\" />\n可以看到，一下子这么多log，但是除了4是我们console的log之外，其他的都是appcache自己打的，因为我们配置了manifest，系统会默认打出appcache的log。关于status的值：\n\n然后，通过log，我们看到一些文件已经被缓存，我们可以查看chrome Resources来查看：\n\n<img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/appcache3.png\" alt=\"\" width=\"1439\" height=\"277\" />\n\n可以看到我们的test.html文件也已经被缓存下来了，type是master，顾名思义一个管理着，而manifest.appcache文件为manifest类型。此时我们的appcache已经完成。我们可以尝试把网线断了，或者把服务器关了，同样，我们的项目仍然可以访问，这就是离线缓存。此时console：\n\n<img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/appcache4.png\" alt=\"\" width=\"1010\" height=\"218\" />\n\n证明直接从缓存拿去文件：\n\n<img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/appcache5.png\" alt=\"\" width=\"794\" height=\"267\" />\n\n<strong>更新缓存的方式</strong>\n更新manifest文件\n浏览器发现manifest文件本身发生变化，便会根据新的manifest文件去获取新的资源进行缓存。\n\n当manifest文件列表并没有变化的时候，我们通常通过修改manifest注释的方式来改变文件，从而实现更新。\n通过javascript操作\n浏览器提供了applicationCache供js访问，通过对于applicationCache对象的操作也能达到更新缓存的目的。\n清除浏览器缓存\n\n<div>对于第一种，我们修改一下manifest文件，把version改为1.4，然后刷新页面。</div>\n<div><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/appcache6.png\" alt=\"\" width=\"1009\" height=\"292\" /></div>\n<div>我们可以发现，appcache更新了缓存重新从网络上拉去的cache的文件，但是，我们如果想要看到改变，必须再次刷新页面。</div>\n<div></div>\n<div>对于第二种方法，我们首先修改一下我们的js，添加一个监听事件：</div>\n<div>\n```javascript\nwindow.applicationCache.addEventListener('updateready', function(){\n        console.log('updateready!');\n        window.applicationCache.swapCache();\n    });\n```\n清除浏览器缓存再试一次，这次我们在console里调用window.applicationCache.update();，看看发生了什么：\n\n<img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/appcache7.png\" alt=\"\" width=\"864\" height=\"211\" />\n\nupdateready事件触发了，同样，appcache也更新了缓存，其中swapCache方法的意思是重新应用跟新后的缓存来替换原来的缓存！，到这里后基本的appcache也差不多了。\n<h3>注意事项：</h3>\n<ul>\n\t<li>站点离线存储的容量限制是5M</li>\n\t<li>如果manifest文件，或者内部列举的某一个文件不能正常下载，整个更新过程将视为失败，浏览器继续全部使用老的缓存</li>\n\t<li>引用manifest的html必须与manifest文件同源，在同一个域下</li>\n\t<li>FALLBACK中的资源必须和manifest文件同源</li>\n\t<li>当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。</li>\n\t<li>站点中的其他页面即使没有设置manifest属性，请求的资源如果在缓存中也从缓存中访问</li>\n\t<li>当manifest文件发生改变时，资源请求本身也会触发更新</li>\n</ul>\n完！\n\n</div>","slug":"HTML5离线存储之Application-Cache","published":1,"updated":"2019-04-02T16:52:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434pzp000f2wvj6o1ptt5f","content":"<p>关于html5的离线存储，大致可分为：</p>\n<p><ul><br>    <li><span style=\"color: #303942;\">localStorage, sessionStorage</span></li><br>    <li>indexedDB</li><br>    <li>web sql</li><br>    <li>application cache</li><br></ul><br><a id=\"more\"></a><br>可以在chrome的debug工具/Resources下产看，下面来着重说明一下Application Cache。</p>\n<p></p><h3><span id=\"访问流程\">访问流程</span></h3><br><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/applicationcache.png\" alt width=\"922\" height=\"305\"><br>当我们第一次正确配置app cache后，当我们再次访问该应用时，浏览器会首先检查manifest文件是否有变动，如果有变动就会把相应的变得跟新下来，同时改变浏览器里面的app cache，如果没有变动，就会直接把app cache的资源返回，基本流程是这样的。<p></p>\n<p>&nbsp;</p>\n<p></p><h3><span id=\"特点\">特点</span></h3><p></p>\n<p><ul style=\"color: #4d4e53;\"><br>    <li>离线浏览: 用户可以在离线状态下浏览网站内容。</li><br>    <li>更快的速度: 因为数据被存储在本地，所以速度会更快.</li><br>    <li>减轻服务器的负载: 浏览器只会下载在服务器上发生改变的资源。</li><br></ul><br>&nbsp;</p>\n<p></p><h3><span id=\"如何使用\">如何使用</span></h3><br>首先，我们建立一个html文件，类似这样：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span> <span class=\"attr\">manifest</span>=<span class=\"string\">\"manifest.appcache\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>APP CACHE<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"test.css\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"img/1.jpg\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"img/2.jpg\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'load'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.applicationCache.status);</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;)</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p>\n<p>可能有些代码看不懂，我们先看最简单的，第一行配置了一个manifest=”manifest.appcache”（<span style=\"color: #ff0000;\">注意是mani不是main</span>），这是使用app cache首先要配置的，然后我们在这个html文件里引入了两个img做为测试用，然后监听了load时间来查看看application的status，关于applicationCache的api，可以<a href=\"http://www.w3school.com.cn/html5/html_5_app_cache.asp\" target=\"_blank\">查看</a>。</p>\n<p>然后在相同目录下新建一个manifest.appcache文件，注意关于路径要和html页面配置时一致即可。</p>\n<p><pre class=\"lang:default decode:true\">CACHE MANIFEST</pre></p>\n<p>#version 1.3<br>CACHE:<br>    img/1.jpg<br>    img/2.jpg<br>    test.css<br>NETWORK:<br>    *<br>关于manifest.appcache文件，基本格式为<span style=\"color: #4d4e53;\">三段： </span><code style=\"color: #4d4e53;\">CACHE，</code><span style=\"color: #4d4e53;\"> </span><code style=\"color: #4d4e53;\">NETWORK，</code><span style=\"color: #4d4e53;\">与 </span><code style=\"color: #4d4e53;\">FALLBACK，其中NETWORK和FALLBACK为可选项，而第一行CACHE MANIFEST为固定格式，必须写在前面。</code></p>\n<p><strong><code style=\"font-weight: inherit; font-style: inherit;\">CACHE:（必须）</code></strong></p>\n<p>标识出哪些文件需要缓存，可以是相对路径也可以是绝对路径。例如：aa.css，<a href=\"http://www.baidu.com/aa.js\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com/aa.js</a>.</p>\n<p><strong><code style=\"font-weight: inherit; font-style: inherit;\">NETWORK:（可选）</code></strong></p>\n<p>这一部分是要绕过缓存直接读取的文件，可以使用通配符＊，,也就是说除了上面的cache文件，剩下的文件每次都要重新拉取。例如＊，login.php。</p>\n<p><strong><code style=\"font-weight: inherit; font-style: inherit;\">FALLBACK:（可选）</code></strong></p>\n<p>指定了一个后备页面，当资源无法访问时，浏览器会使用该页面。该段落的每条记录都列出两个 URI—第一个表示资源，第二个表示后备页面。两个 URI 都必须使用相对路径并且与清单文件同源。可以使用通配符。例如*.html  /offline.html。</p>\n<p>有了上面两个文件之后还要配置服务器的mime.types类型，找大盘apache的mime.types文件，添加</p>\n<p><pre class=\"lang:default decode:true \">text/cache-manifest .appcache</pre><br>OK，上面文件配置完成之后，application cache就可以运行了。</p>\n<p>查看console：</p>\n<p><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/appcache2.png\" alt width=\"1010\" height=\"420\"><br>可以看到，一下子这么多log，但是除了4是我们console的log之外，其他的都是appcache自己打的，因为我们配置了manifest，系统会默认打出appcache的log。关于status的值：</p>\n<p>然后，通过log，我们看到一些文件已经被缓存，我们可以查看chrome Resources来查看：</p>\n<p><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/appcache3.png\" alt width=\"1439\" height=\"277\"></p>\n<p>可以看到我们的test.html文件也已经被缓存下来了，type是master，顾名思义一个管理着，而manifest.appcache文件为manifest类型。此时我们的appcache已经完成。我们可以尝试把网线断了，或者把服务器关了，同样，我们的项目仍然可以访问，这就是离线缓存。此时console：</p>\n<p><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/appcache4.png\" alt width=\"1010\" height=\"218\"></p>\n<p>证明直接从缓存拿去文件：</p>\n<p><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/appcache5.png\" alt width=\"794\" height=\"267\"></p>\n<p><strong>更新缓存的方式</strong><br>更新manifest文件<br>浏览器发现manifest文件本身发生变化，便会根据新的manifest文件去获取新的资源进行缓存。</p>\n<p>当manifest文件列表并没有变化的时候，我们通常通过修改manifest注释的方式来改变文件，从而实现更新。<br>通过javascript操作<br>浏览器提供了applicationCache供js访问，通过对于applicationCache对象的操作也能达到更新缓存的目的。<br>清除浏览器缓存</p>\n<div>对于第一种，我们修改一下manifest文件，把version改为1.4，然后刷新页面。</div><br><div><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/appcache6.png\" alt width=\"1009\" height=\"292\"></div><br><div>我们可以发现，appcache更新了缓存重新从网络上拉去的cache的文件，但是，我们如果想要看到改变，必须再次刷新页面。</div><br><div></div><br><div>对于第二种方法，我们首先修改一下我们的js，添加一个监听事件：</div><br><div><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.applicationCache.addEventListener(<span class=\"string\">'updateready'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'updateready!'</span>);</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.applicationCache.swapCache();</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure><br><br>清除浏览器缓存再试一次，这次我们在console里调用window.applicationCache.update();，看看发生了什么：<br><br><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/appcache7.png\" alt width=\"864\" height=\"211\"><br><br>updateready事件触发了，同样，appcache也更新了缓存，其中swapCache方法的意思是重新应用跟新后的缓存来替换原来的缓存！，到这里后基本的appcache也差不多了。<br><h3><span id=\"注意事项\">注意事项：</span></h3><br><ul><br>    <li>站点离线存储的容量限制是5M</li><br>    <li>如果manifest文件，或者内部列举的某一个文件不能正常下载，整个更新过程将视为失败，浏览器继续全部使用老的缓存</li><br>    <li>引用manifest的html必须与manifest文件同源，在同一个域下</li><br>    <li>FALLBACK中的资源必须和manifest文件同源</li><br>    <li>当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。</li><br>    <li>站点中的其他页面即使没有设置manifest属性，请求的资源如果在缓存中也从缓存中访问</li><br>    <li>当manifest文件发生改变时，资源请求本身也会触发更新</li><br></ul><br>完！<br><br></div>","site":{"data":{}},"excerpt":"<p>关于html5的离线存储，大致可分为：</p>\n<p><ul><br>    <li><span style=\"color: #303942;\">localStorage, sessionStorage</span></li><br>    <li>indexedDB</li><br>    <li>web sql</li><br>    <li>application cache</li><br></ul><br>","more":"<br>可以在chrome的debug工具/Resources下产看，下面来着重说明一下Application Cache。</p>\n<p></p><h3>访问流程</h3><br><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/applicationcache.png\" alt=\"\" width=\"922\" height=\"305\"><br>当我们第一次正确配置app cache后，当我们再次访问该应用时，浏览器会首先检查manifest文件是否有变动，如果有变动就会把相应的变得跟新下来，同时改变浏览器里面的app cache，如果没有变动，就会直接把app cache的资源返回，基本流程是这样的。<p></p>\n<p>&nbsp;</p>\n<p></p><h3>特点</h3><p></p>\n<p><ul style=\"color: #4d4e53;\"><br>    <li>离线浏览: 用户可以在离线状态下浏览网站内容。</li><br>    <li>更快的速度: 因为数据被存储在本地，所以速度会更快.</li><br>    <li>减轻服务器的负载: 浏览器只会下载在服务器上发生改变的资源。</li><br></ul><br>&nbsp;</p>\n<p></p><h3>如何使用</h3><br>首先，我们建立一个html文件，类似这样：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span> <span class=\"attr\">manifest</span>=<span class=\"string\">\"manifest.appcache\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>APP CACHE<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"test.css\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"img/1.jpg\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"img/2.jpg\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'load'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.applicationCache.status);</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;)</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p>\n<p>可能有些代码看不懂，我们先看最简单的，第一行配置了一个manifest=”manifest.appcache”（<span style=\"color: #ff0000;\">注意是mani不是main</span>），这是使用app cache首先要配置的，然后我们在这个html文件里引入了两个img做为测试用，然后监听了load时间来查看看application的status，关于applicationCache的api，可以<a href=\"http://www.w3school.com.cn/html5/html_5_app_cache.asp\" target=\"_blank\">查看</a>。</p>\n<p>然后在相同目录下新建一个manifest.appcache文件，注意关于路径要和html页面配置时一致即可。</p>\n<p><pre class=\"lang:default decode:true\">CACHE MANIFEST</pre></p>\n<p>#version 1.3<br>CACHE:<br>    img/1.jpg<br>    img/2.jpg<br>    test.css<br>NETWORK:<br>    *<br>关于manifest.appcache文件，基本格式为<span style=\"color: #4d4e53;\">三段： </span><code style=\"color: #4d4e53;\">CACHE，</code><span style=\"color: #4d4e53;\"> </span><code style=\"color: #4d4e53;\">NETWORK，</code><span style=\"color: #4d4e53;\">与 </span><code style=\"color: #4d4e53;\">FALLBACK，其中NETWORK和FALLBACK为可选项，而第一行CACHE MANIFEST为固定格式，必须写在前面。</code></p>\n<p><strong><code style=\"font-weight: inherit; font-style: inherit;\">CACHE:（必须）</code></strong></p>\n<p>标识出哪些文件需要缓存，可以是相对路径也可以是绝对路径。例如：aa.css，<a href=\"http://www.baidu.com/aa.js\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com/aa.js</a>.</p>\n<p><strong><code style=\"font-weight: inherit; font-style: inherit;\">NETWORK:（可选）</code></strong></p>\n<p>这一部分是要绕过缓存直接读取的文件，可以使用通配符＊，,也就是说除了上面的cache文件，剩下的文件每次都要重新拉取。例如＊，login.php。</p>\n<p><strong><code style=\"font-weight: inherit; font-style: inherit;\">FALLBACK:（可选）</code></strong></p>\n<p>指定了一个后备页面，当资源无法访问时，浏览器会使用该页面。该段落的每条记录都列出两个 URI—第一个表示资源，第二个表示后备页面。两个 URI 都必须使用相对路径并且与清单文件同源。可以使用通配符。例如*.html  /offline.html。</p>\n<p>有了上面两个文件之后还要配置服务器的mime.types类型，找大盘apache的mime.types文件，添加</p>\n<p><pre class=\"lang:default decode:true \">text/cache-manifest .appcache</pre><br>OK，上面文件配置完成之后，application cache就可以运行了。</p>\n<p>查看console：</p>\n<p><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/appcache2.png\" alt=\"\" width=\"1010\" height=\"420\"><br>可以看到，一下子这么多log，但是除了4是我们console的log之外，其他的都是appcache自己打的，因为我们配置了manifest，系统会默认打出appcache的log。关于status的值：</p>\n<p>然后，通过log，我们看到一些文件已经被缓存，我们可以查看chrome Resources来查看：</p>\n<p><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/appcache3.png\" alt=\"\" width=\"1439\" height=\"277\"></p>\n<p>可以看到我们的test.html文件也已经被缓存下来了，type是master，顾名思义一个管理着，而manifest.appcache文件为manifest类型。此时我们的appcache已经完成。我们可以尝试把网线断了，或者把服务器关了，同样，我们的项目仍然可以访问，这就是离线缓存。此时console：</p>\n<p><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/appcache4.png\" alt=\"\" width=\"1010\" height=\"218\"></p>\n<p>证明直接从缓存拿去文件：</p>\n<p><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/appcache5.png\" alt=\"\" width=\"794\" height=\"267\"></p>\n<p><strong>更新缓存的方式</strong><br>更新manifest文件<br>浏览器发现manifest文件本身发生变化，便会根据新的manifest文件去获取新的资源进行缓存。</p>\n<p>当manifest文件列表并没有变化的时候，我们通常通过修改manifest注释的方式来改变文件，从而实现更新。<br>通过javascript操作<br>浏览器提供了applicationCache供js访问，通过对于applicationCache对象的操作也能达到更新缓存的目的。<br>清除浏览器缓存</p>\n<div>对于第一种，我们修改一下manifest文件，把version改为1.4，然后刷新页面。</div><br><div><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/appcache6.png\" alt=\"\" width=\"1009\" height=\"292\"></div><br><div>我们可以发现，appcache更新了缓存重新从网络上拉去的cache的文件，但是，我们如果想要看到改变，必须再次刷新页面。</div><br><div></div><br><div>对于第二种方法，我们首先修改一下我们的js，添加一个监听事件：</div><br><div><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.applicationCache.addEventListener(<span class=\"string\">'updateready'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'updateready!'</span>);</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.applicationCache.swapCache();</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure><br><br>清除浏览器缓存再试一次，这次我们在console里调用window.applicationCache.update();，看看发生了什么：<br><br><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/appcache7.png\" alt=\"\" width=\"864\" height=\"211\"><br><br>updateready事件触发了，同样，appcache也更新了缓存，其中swapCache方法的意思是重新应用跟新后的缓存来替换原来的缓存！，到这里后基本的appcache也差不多了。<br><h3>注意事项：</h3><br><ul><br>    <li>站点离线存储的容量限制是5M</li><br>    <li>如果manifest文件，或者内部列举的某一个文件不能正常下载，整个更新过程将视为失败，浏览器继续全部使用老的缓存</li><br>    <li>引用manifest的html必须与manifest文件同源，在同一个域下</li><br>    <li>FALLBACK中的资源必须和manifest文件同源</li><br>    <li>当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。</li><br>    <li>站点中的其他页面即使没有设置manifest属性，请求的资源如果在缓存中也从缓存中访问</li><br>    <li>当manifest文件发生改变时，资源请求本身也会触发更新</li><br></ul><br>完！<br><br></div>"},{"title":"HTTP,HTTP2.0,SPDY,HTTPS看这篇就够了","date":"2016-07-24T13:01:09.000Z","_content":"<p>作为一个经常和web打交道的程序员，了解这些协议是必须的，本文就向大家介绍一下这些协议的区别和基本概念，文中可能不局限于前端知识，还包括一些运维，协议方面的知识，希望能给读者带来一些收获，如有不对之处还请指出。  </p><h2><strong>1. web始祖HTTP</strong></h2><p>全称：超文本传输协议(HyperText Transfer Protocol) 伴随着计算机网络和浏览器的诞生，HTTP1.0也随之而来，处于计算机网络中的应用层，HTTP是建立在TCP协议之上，所以HTTP协议的瓶颈及其优化技巧都是基于TCP协议本身的特性，例如tcp建立连接的3次握手和断开连接的4次挥手以及每次建立连接带来的RTT延迟时间。    </p><!--more--><h2><strong>2. HTTP与现代化浏览器</strong></h2><p>早在HTTP建立之初，主要就是为了将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。也是说对于前端来说，我们所写的HTML页面将要放在我们的web服务器上，用户端通过浏览器访问url地址来获取网页的显示内容，但是到了WEB2.0以来，我们的页面变得复杂，不仅仅单纯的是一些简单的文字和图片，同时我们的HTML页面有了CSS，Javascript，来丰富我们的页面展示，当ajax的出现，我们又多了一种向服务器端获取数据的方法，这些其实都是基于HTTP协议的。同样到了移动互联网时代，我们页面可以跑在手机端浏览器里面，但是和PC相比，手机端的网络情况更加复杂，这使得我们开始了不得不对HTTP进行深入理解并不断优化过程中。 <img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/timeline.png\" alt=\"\" data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/timeline.png\" />  </p><h2><strong>3. HTTP的基本优化</strong></h2><p>影响一个HTTP网络请求的因素主要有两个：带宽和延迟。</p><ul><li><strong>带宽：</strong>如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，当时现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。</li><li><strong>延迟：</strong></li></ul><ol><li><strong>浏览器阻塞（HOL blocking）</strong>：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。</li><li> <strong>DNS 查询（DNS Lookup）</strong>：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。</li><li> <strong>建立连接（Initial connection）</strong>：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和<a href=\"http://en.wikipedia.org/wiki/Slow-start\" data-cke-saved-href=\"http://en.wikipedia.org/wiki/Slow-start\">慢启动</a>。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</li></ol><p><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/3woshou.png\" alt=\"\" data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/3woshou.png\" />    </p><h2><strong>4. HTTP1.0和HTTP1.1的一些区别</strong></h2><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 <strong>主要区别主要体现在：</strong></p><ol><li><strong>缓存处理，</strong>在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong>，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>错误通知的管理</strong>，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>Host头处理</strong>，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li><li><strong>长连接</strong>，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。以下是常见的HTTP1.0：</li></ol><p><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/host1.png\" alt=\"\" data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/host1.png\" /></p><h2><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/http11.png\" alt=\"\" data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/http11.png\" /></h2><h2> </h2><h2><strong>5. HTTP1.0和1.1现存的一些问题</strong></h2><ol><li>上面提到过的，HTTP1.x在传输数据时，每次都需要重新建立连接，无疑增加了大量的延迟时间，特别是在移动端更为突出。</li><li> HTTP1.x在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性。</li><li> HTTP1.x在使用时，header里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求header基本不怎么变化，尤其在移动端增加用户流量。</li><li> 虽然HTTP1.x支持了keep-alive，来弥补多次创建连接产生的延迟，但是keep-alive使用多了同样会给服务端带来大量的性能压力，并且对于单个文件被不断请求的服务(例如图片存放网站)，keep-alive可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。</li></ol><p>&nbsp;</p><h2><strong>6. HTTPS应声而出</strong></h2><p>为了解决以上问题，网景在1994年创建了HTTPS，并应用在网景导航者浏览器中。 最初，HTTPS是与<a href=\"https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E5%8D%94%E8%AD%B0\" data-cke-saved-href=\"https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E5%8D%94%E8%AD%B0\">SSL</a>一起使用的；在SSL逐渐演变到<a href=\"https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E5%8D%94%E8%AD%B0#TLS_1.0\" data-cke-saved-href=\"https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E5%8D%94%E8%AD%B0#TLS_1.0\">TLS</a>时（其实两个是一个东西，只是名字不同而已），最新的HTTPS也由在2000年五月公布的RFC 2818正式确定下来。简单来说，HTTPS就是安全版的HTTP，并且由于当今时代对安全性要求更高，chrome和firefox都大力支持网站使用HTTPS，苹果也在ios 10系统中强制app使用HTTPS来传输数据，由此可见HTTPS势在必行。  </p><h2><strong>7. HTTPS与HTTP的一些区别</strong></h2><ol><li>HTTPS协议需要到ca申请证书，一般免费证书很少，需要交费。</li><li>HTTP是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的ssl加密传输协议。</li><li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>HTTPS的连接很简单，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ol><p>&nbsp;</p><h2><strong>8. HTTPS改造</strong></h2><p><strong>如果一个网站要全站由HTTP替换成HTTPS，可能需要关注以下几点：</strong></p><ol><li>安装CA证书，一般的证书都是需要收费的，这边推荐一个比较好的购买证书网站：1）<a href=\"https://www.google.com.hk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwiR-aqIuonOAhVEJJQKHRUyB9kQFggcMAA&amp;url=%68%74%74%70%73%3a%2f%2f%6c%65%74%73%65%6e%63%72%79%70%74%2e%6f%72%67%2f&amp;usg=AFQjCNHLSK55fO3YLnyT_sYlhlFMyyILjg\" data-cke-saved-href=\"https://www.google.com.hk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwiR-aqIuonOAhVEJJQKHRUyB9kQFggcMAA&amp;url=%68%74%74%70%73%3a%2f%2f%6c%65%74%73%65%6e%63%72%79%70%74%2e%6f%72%67%2f&amp;usg=AFQjCNHLSK55fO3YLnyT_sYlhlFMyyILjg\">Let's Encrypt</a>，免费，快捷，支持多域名（不是通配符），三条命令即时签署+导出证书。缺点是暂时只有三个月有效期，到期需续签。2<a href=\"http://www.googleadservices.com/pagead/aclk?sa=L&amp;ai=DChcSEwiw__OzuonOAhWXl70KHckjAFwYABAA&amp;ohost=www.google.cn&amp;cid=CAASJORoai_i-_0j0yr7GaclkrgOrZjgeqXX5_EFZU_1oxVUunWc5A&amp;sig=AOD64_2e98s_eLbDZ4LOE0bxIwoqy8RZ6g&amp;q=&amp;ved=0ahUKEwim1_GzuonOAhVLHZQKHf--BB4Q0QwIGg&amp;adurl=\" data-cke-saved-href=\"http://www.googleadservices.com/pagead/aclk?sa=L&amp;ai=DChcSEwiw__OzuonOAhWXl70KHckjAFwYABAA&amp;ohost=www.google.cn&amp;cid=CAASJORoai_i-_0j0yr7GaclkrgOrZjgeqXX5_EFZU_1oxVUunWc5A&amp;sig=AOD64_2e98s_eLbDZ4LOE0bxIwoqy8RZ6g&amp;q=&amp;ved=0ahUKEwim1_GzuonOAhVLHZQKHf--BB4Q0QwIGg&amp;adurl=\">Comodo PositiveSSL</a>，收费，但是比较稳定。</li><li>在购买证书之后，在证书提供的网站上配置自己的域名，将证书下载下来之后，配置自己的web服务器，同时进行代码改造。</li><li>HTTPS 降低用户访问速度。<a href=\"http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html\" data-cke-saved-href=\"http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html\">SSL握手</a>，HTTPS 对速度会有一定程度的降低，但是只要经过合理优化和部署，HTTPS 对速度的影响完全可以接受。在很多场景下，HTTPS 速度完全不逊于 HTTP，如果使用 SPDY，HTTPS 的速度甚至还要比 HTTP 快。</li><li>相对于HTTPS降低访问速度，其实更需要关心的是服务器端的CPU压力，HTTPS中大量的密钥算法计算，会消耗大量的CPU资源，只有足够的优化，HTTPS 的机器成本才不会明显增加。</li></ol><p>推荐一则<a href=\"http://velocity.oreilly.com.cn/2015/ppts/lizhenyu.pdf\" data-cke-saved-href=\"http://velocity.oreilly.com.cn/2015/ppts/lizhenyu.pdf\">淘宝网改造HTTPS</a>的文章。  </p><h2><strong>9. 使用SPDY加快你的网站速度</strong></h2><p>2012年google如一声惊雷提出了SPDY的方案，大家才开始从正面看待和解决老版本HTTP协议本身的问题，SPDY可以说是综合了HTTPS和HTTP两者有点于一体的传输协议，主要解决：</p><ol><li><strong>降低延迟</strong>，针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。</li><li><strong>请求优先级</strong>（request prioritization）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。</li><li><strong>header压缩</strong>。前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。</li><li><strong>基于HTTPS的加密协议传输</strong>，大大提高了传输数据的可靠性。</li><li><strong>服务端推送</strong>（server push），采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。SPDY构成图：</li></ol><p><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/SPDY.png\" alt=\"\" data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/SPDY.png\" /> SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。   <strong>兼容性：</strong> <img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/sodyuse.png\" alt=\"\" data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/sodyuse.png\" />  </p><h2><strong>10. HTTP2.0的前世今生</strong></h2><p>S顾名思义有了HTTP1.x，那么HTTP2.0也就顺理成章的出现了。HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，主要是以下两点：</p><ul><li>HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</li><li>HTTP2.0 消息头的压缩算法采用 <a href=\"http://http2.github.io/http2-spec/compression.html\" data-cke-saved-href=\"http://http2.github.io/http2-spec/compression.html\">HPACK</a>，而非 SPDY 采用的 <a href=\"http://zh.wikipedia.org/wiki/DEFLATE\" data-cke-saved-href=\"http://zh.wikipedia.org/wiki/DEFLATE\">DEFLATE</a></li></ul><p>&nbsp;</p><h2><strong>11. HTTP2.0的新特性</strong></h2><ul><li><strong>新的二进制格式</strong>（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li><li><strong>多路复用</strong>（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。<strong>多路复用原理图</strong>：</li></ul><p><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/duolufuyong.png\" alt=\"\" data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/duolufuyong.png\" /></p><ul><li><strong>header压缩，</strong>如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li><li><strong>服务端推送</strong>（server push），同SPDY一样，HTTP2.0也具有server push功能。目前，有大多数网站已经启用HTTP2.0，例如<a href=\"https://www.youtube.com\" data-cke-saved-href=\"https://www.youtube.com\">YouTuBe</a>，<a href=\"http://www.taobao.com\" data-cke-saved-href=\"http://www.taobao.com\">淘宝网</a>等网站，利用chrome控制台可以查看是否启用H2：</li></ul><p><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/h2.png\" alt=\"\" data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/h2.png\" /> 更多关于HTTP2的问题可以参考：<a href=\"http://www.alloyteam.com/2015/03/http2-0-di-qi-miao-ri-chang/\" data-cke-saved-href=\"http://www.alloyteam.com/2015/03/http2-0-di-qi-miao-ri-chang/\">HTTP2奇妙日常</a>，以及HTTP2.0的<a href=\"https://http2.akamai.com/\" data-cke-saved-href=\"https://http2.akamai.com/\">官方网站</a>。  </p><h2><strong>12. HTTP2.0的升级改造</strong></h2><p><strong>对比HTTPS的升级改造，HTTP2.0获取会稍微简单一些，你可能需要关注以下问题：</strong></p><ol><li>前文说了HTTP2.0其实可以支持非HTTPS的，但是现在主流的浏览器像chrome，firefox表示还是只支持基于 TLS 部署的HTTP2.0协议，所以要想升级成HTTP2.0还是先生气HTTPS为好。</li><li>当你的网站已经升级HTTPS之后，那么升级HTTP2.0就简单很多，如果你使用NGINX，只要在配置文件中启动相应的协议就可以了，可以参考<a href=\"https://www.nginx.com/wp-content/uploads/2015/09/NGINX_HTTP2_White_Paper_v4.pdf\" data-cke-saved-href=\"https://www.nginx.com/wp-content/uploads/2015/09/NGINX_HTTP2_White_Paper_v4.pdf\">NGINX白皮书</a>，<a href=\"https://www.nginx.com/blog/nginx-1-9-5/\" data-cke-saved-href=\"https://www.nginx.com/blog/nginx-1-9-5/\">NGINX配置HTTP2.0官方指南</a>。</li><li>使用了HTTP2.0那么，原本的HTTP1.x怎么办，这个问题其实不用担心，HTTP2.0完全兼容HTTP1.x的语义，对于不支持HTTP2.0的浏览器，NGINX会自动向下兼容的。</li></ol><p>&nbsp;</p><h2>后记</h2><ol><li>以上就是关于HTTP,HTTP2.0,SPDY,HTTPS的一些基本理论，有些内容没有深入讲解，大家可以跟进参考连接具体查看。</li><li>关于HTTP1.x的一些优化方式，例如文件合并压缩，资源cdn，js，css优化等等同样使用与HTTP2.0和HTTPS，所以web前端的优化，还是要继续进行。</li><li>其实WEB发展如此迅速的今天，有些技术是真的要与时俱进的，就像苹果宣布ios 10必须使用HTTPS开始，关于web协议革新就已经开始了，为了更好的性能，更优越的方式，现在就开始升级改造吧</li></ol>","source":"_posts/HTTP-HTTP2-0-SPDY-HTTPS看这篇就够了.md","raw":"---\ntitle: 'HTTP,HTTP2.0,SPDY,HTTPS看这篇就够了'\ndate: 2016-07-24 21:01:09\ntags:\n- http2\n- https\ncategories:\n- 630\n---\n<p>作为一个经常和web打交道的程序员，了解这些协议是必须的，本文就向大家介绍一下这些协议的区别和基本概念，文中可能不局限于前端知识，还包括一些运维，协议方面的知识，希望能给读者带来一些收获，如有不对之处还请指出。  </p><h2><strong>1. web始祖HTTP</strong></h2><p>全称：超文本传输协议(HyperText Transfer Protocol) 伴随着计算机网络和浏览器的诞生，HTTP1.0也随之而来，处于计算机网络中的应用层，HTTP是建立在TCP协议之上，所以HTTP协议的瓶颈及其优化技巧都是基于TCP协议本身的特性，例如tcp建立连接的3次握手和断开连接的4次挥手以及每次建立连接带来的RTT延迟时间。    </p><!--more--><h2><strong>2. HTTP与现代化浏览器</strong></h2><p>早在HTTP建立之初，主要就是为了将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。也是说对于前端来说，我们所写的HTML页面将要放在我们的web服务器上，用户端通过浏览器访问url地址来获取网页的显示内容，但是到了WEB2.0以来，我们的页面变得复杂，不仅仅单纯的是一些简单的文字和图片，同时我们的HTML页面有了CSS，Javascript，来丰富我们的页面展示，当ajax的出现，我们又多了一种向服务器端获取数据的方法，这些其实都是基于HTTP协议的。同样到了移动互联网时代，我们页面可以跑在手机端浏览器里面，但是和PC相比，手机端的网络情况更加复杂，这使得我们开始了不得不对HTTP进行深入理解并不断优化过程中。 <img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/timeline.png\" alt=\"\" data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/timeline.png\" />  </p><h2><strong>3. HTTP的基本优化</strong></h2><p>影响一个HTTP网络请求的因素主要有两个：带宽和延迟。</p><ul><li><strong>带宽：</strong>如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，当时现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。</li><li><strong>延迟：</strong></li></ul><ol><li><strong>浏览器阻塞（HOL blocking）</strong>：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。</li><li> <strong>DNS 查询（DNS Lookup）</strong>：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。</li><li> <strong>建立连接（Initial connection）</strong>：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和<a href=\"http://en.wikipedia.org/wiki/Slow-start\" data-cke-saved-href=\"http://en.wikipedia.org/wiki/Slow-start\">慢启动</a>。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</li></ol><p><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/3woshou.png\" alt=\"\" data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/3woshou.png\" />    </p><h2><strong>4. HTTP1.0和HTTP1.1的一些区别</strong></h2><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 <strong>主要区别主要体现在：</strong></p><ol><li><strong>缓存处理，</strong>在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong>，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>错误通知的管理</strong>，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>Host头处理</strong>，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li><li><strong>长连接</strong>，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。以下是常见的HTTP1.0：</li></ol><p><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/host1.png\" alt=\"\" data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/host1.png\" /></p><h2><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/http11.png\" alt=\"\" data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/http11.png\" /></h2><h2> </h2><h2><strong>5. HTTP1.0和1.1现存的一些问题</strong></h2><ol><li>上面提到过的，HTTP1.x在传输数据时，每次都需要重新建立连接，无疑增加了大量的延迟时间，特别是在移动端更为突出。</li><li> HTTP1.x在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性。</li><li> HTTP1.x在使用时，header里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求header基本不怎么变化，尤其在移动端增加用户流量。</li><li> 虽然HTTP1.x支持了keep-alive，来弥补多次创建连接产生的延迟，但是keep-alive使用多了同样会给服务端带来大量的性能压力，并且对于单个文件被不断请求的服务(例如图片存放网站)，keep-alive可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。</li></ol><p>&nbsp;</p><h2><strong>6. HTTPS应声而出</strong></h2><p>为了解决以上问题，网景在1994年创建了HTTPS，并应用在网景导航者浏览器中。 最初，HTTPS是与<a href=\"https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E5%8D%94%E8%AD%B0\" data-cke-saved-href=\"https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E5%8D%94%E8%AD%B0\">SSL</a>一起使用的；在SSL逐渐演变到<a href=\"https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E5%8D%94%E8%AD%B0#TLS_1.0\" data-cke-saved-href=\"https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E5%8D%94%E8%AD%B0#TLS_1.0\">TLS</a>时（其实两个是一个东西，只是名字不同而已），最新的HTTPS也由在2000年五月公布的RFC 2818正式确定下来。简单来说，HTTPS就是安全版的HTTP，并且由于当今时代对安全性要求更高，chrome和firefox都大力支持网站使用HTTPS，苹果也在ios 10系统中强制app使用HTTPS来传输数据，由此可见HTTPS势在必行。  </p><h2><strong>7. HTTPS与HTTP的一些区别</strong></h2><ol><li>HTTPS协议需要到ca申请证书，一般免费证书很少，需要交费。</li><li>HTTP是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的ssl加密传输协议。</li><li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>HTTPS的连接很简单，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ol><p>&nbsp;</p><h2><strong>8. HTTPS改造</strong></h2><p><strong>如果一个网站要全站由HTTP替换成HTTPS，可能需要关注以下几点：</strong></p><ol><li>安装CA证书，一般的证书都是需要收费的，这边推荐一个比较好的购买证书网站：1）<a href=\"https://www.google.com.hk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwiR-aqIuonOAhVEJJQKHRUyB9kQFggcMAA&amp;url=%68%74%74%70%73%3a%2f%2f%6c%65%74%73%65%6e%63%72%79%70%74%2e%6f%72%67%2f&amp;usg=AFQjCNHLSK55fO3YLnyT_sYlhlFMyyILjg\" data-cke-saved-href=\"https://www.google.com.hk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwiR-aqIuonOAhVEJJQKHRUyB9kQFggcMAA&amp;url=%68%74%74%70%73%3a%2f%2f%6c%65%74%73%65%6e%63%72%79%70%74%2e%6f%72%67%2f&amp;usg=AFQjCNHLSK55fO3YLnyT_sYlhlFMyyILjg\">Let's Encrypt</a>，免费，快捷，支持多域名（不是通配符），三条命令即时签署+导出证书。缺点是暂时只有三个月有效期，到期需续签。2<a href=\"http://www.googleadservices.com/pagead/aclk?sa=L&amp;ai=DChcSEwiw__OzuonOAhWXl70KHckjAFwYABAA&amp;ohost=www.google.cn&amp;cid=CAASJORoai_i-_0j0yr7GaclkrgOrZjgeqXX5_EFZU_1oxVUunWc5A&amp;sig=AOD64_2e98s_eLbDZ4LOE0bxIwoqy8RZ6g&amp;q=&amp;ved=0ahUKEwim1_GzuonOAhVLHZQKHf--BB4Q0QwIGg&amp;adurl=\" data-cke-saved-href=\"http://www.googleadservices.com/pagead/aclk?sa=L&amp;ai=DChcSEwiw__OzuonOAhWXl70KHckjAFwYABAA&amp;ohost=www.google.cn&amp;cid=CAASJORoai_i-_0j0yr7GaclkrgOrZjgeqXX5_EFZU_1oxVUunWc5A&amp;sig=AOD64_2e98s_eLbDZ4LOE0bxIwoqy8RZ6g&amp;q=&amp;ved=0ahUKEwim1_GzuonOAhVLHZQKHf--BB4Q0QwIGg&amp;adurl=\">Comodo PositiveSSL</a>，收费，但是比较稳定。</li><li>在购买证书之后，在证书提供的网站上配置自己的域名，将证书下载下来之后，配置自己的web服务器，同时进行代码改造。</li><li>HTTPS 降低用户访问速度。<a href=\"http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html\" data-cke-saved-href=\"http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html\">SSL握手</a>，HTTPS 对速度会有一定程度的降低，但是只要经过合理优化和部署，HTTPS 对速度的影响完全可以接受。在很多场景下，HTTPS 速度完全不逊于 HTTP，如果使用 SPDY，HTTPS 的速度甚至还要比 HTTP 快。</li><li>相对于HTTPS降低访问速度，其实更需要关心的是服务器端的CPU压力，HTTPS中大量的密钥算法计算，会消耗大量的CPU资源，只有足够的优化，HTTPS 的机器成本才不会明显增加。</li></ol><p>推荐一则<a href=\"http://velocity.oreilly.com.cn/2015/ppts/lizhenyu.pdf\" data-cke-saved-href=\"http://velocity.oreilly.com.cn/2015/ppts/lizhenyu.pdf\">淘宝网改造HTTPS</a>的文章。  </p><h2><strong>9. 使用SPDY加快你的网站速度</strong></h2><p>2012年google如一声惊雷提出了SPDY的方案，大家才开始从正面看待和解决老版本HTTP协议本身的问题，SPDY可以说是综合了HTTPS和HTTP两者有点于一体的传输协议，主要解决：</p><ol><li><strong>降低延迟</strong>，针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。</li><li><strong>请求优先级</strong>（request prioritization）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。</li><li><strong>header压缩</strong>。前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。</li><li><strong>基于HTTPS的加密协议传输</strong>，大大提高了传输数据的可靠性。</li><li><strong>服务端推送</strong>（server push），采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。SPDY构成图：</li></ol><p><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/SPDY.png\" alt=\"\" data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/SPDY.png\" /> SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。   <strong>兼容性：</strong> <img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/sodyuse.png\" alt=\"\" data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/sodyuse.png\" />  </p><h2><strong>10. HTTP2.0的前世今生</strong></h2><p>S顾名思义有了HTTP1.x，那么HTTP2.0也就顺理成章的出现了。HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，主要是以下两点：</p><ul><li>HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</li><li>HTTP2.0 消息头的压缩算法采用 <a href=\"http://http2.github.io/http2-spec/compression.html\" data-cke-saved-href=\"http://http2.github.io/http2-spec/compression.html\">HPACK</a>，而非 SPDY 采用的 <a href=\"http://zh.wikipedia.org/wiki/DEFLATE\" data-cke-saved-href=\"http://zh.wikipedia.org/wiki/DEFLATE\">DEFLATE</a></li></ul><p>&nbsp;</p><h2><strong>11. HTTP2.0的新特性</strong></h2><ul><li><strong>新的二进制格式</strong>（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li><li><strong>多路复用</strong>（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。<strong>多路复用原理图</strong>：</li></ul><p><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/duolufuyong.png\" alt=\"\" data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/duolufuyong.png\" /></p><ul><li><strong>header压缩，</strong>如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li><li><strong>服务端推送</strong>（server push），同SPDY一样，HTTP2.0也具有server push功能。目前，有大多数网站已经启用HTTP2.0，例如<a href=\"https://www.youtube.com\" data-cke-saved-href=\"https://www.youtube.com\">YouTuBe</a>，<a href=\"http://www.taobao.com\" data-cke-saved-href=\"http://www.taobao.com\">淘宝网</a>等网站，利用chrome控制台可以查看是否启用H2：</li></ul><p><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/h2.png\" alt=\"\" data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/h2.png\" /> 更多关于HTTP2的问题可以参考：<a href=\"http://www.alloyteam.com/2015/03/http2-0-di-qi-miao-ri-chang/\" data-cke-saved-href=\"http://www.alloyteam.com/2015/03/http2-0-di-qi-miao-ri-chang/\">HTTP2奇妙日常</a>，以及HTTP2.0的<a href=\"https://http2.akamai.com/\" data-cke-saved-href=\"https://http2.akamai.com/\">官方网站</a>。  </p><h2><strong>12. HTTP2.0的升级改造</strong></h2><p><strong>对比HTTPS的升级改造，HTTP2.0获取会稍微简单一些，你可能需要关注以下问题：</strong></p><ol><li>前文说了HTTP2.0其实可以支持非HTTPS的，但是现在主流的浏览器像chrome，firefox表示还是只支持基于 TLS 部署的HTTP2.0协议，所以要想升级成HTTP2.0还是先生气HTTPS为好。</li><li>当你的网站已经升级HTTPS之后，那么升级HTTP2.0就简单很多，如果你使用NGINX，只要在配置文件中启动相应的协议就可以了，可以参考<a href=\"https://www.nginx.com/wp-content/uploads/2015/09/NGINX_HTTP2_White_Paper_v4.pdf\" data-cke-saved-href=\"https://www.nginx.com/wp-content/uploads/2015/09/NGINX_HTTP2_White_Paper_v4.pdf\">NGINX白皮书</a>，<a href=\"https://www.nginx.com/blog/nginx-1-9-5/\" data-cke-saved-href=\"https://www.nginx.com/blog/nginx-1-9-5/\">NGINX配置HTTP2.0官方指南</a>。</li><li>使用了HTTP2.0那么，原本的HTTP1.x怎么办，这个问题其实不用担心，HTTP2.0完全兼容HTTP1.x的语义，对于不支持HTTP2.0的浏览器，NGINX会自动向下兼容的。</li></ol><p>&nbsp;</p><h2>后记</h2><ol><li>以上就是关于HTTP,HTTP2.0,SPDY,HTTPS的一些基本理论，有些内容没有深入讲解，大家可以跟进参考连接具体查看。</li><li>关于HTTP1.x的一些优化方式，例如文件合并压缩，资源cdn，js，css优化等等同样使用与HTTP2.0和HTTPS，所以web前端的优化，还是要继续进行。</li><li>其实WEB发展如此迅速的今天，有些技术是真的要与时俱进的，就像苹果宣布ios 10必须使用HTTPS开始，关于web协议革新就已经开始了，为了更好的性能，更优越的方式，现在就开始升级改造吧</li></ol>","slug":"HTTP-HTTP2-0-SPDY-HTTPS看这篇就够了","published":1,"updated":"2019-04-02T16:52:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434pzr000j2wvjaoxnevkx","content":"<p></p><p>作为一个经常和web打交道的程序员，了解这些协议是必须的，本文就向大家介绍一下这些协议的区别和基本概念，文中可能不局限于前端知识，还包括一些运维，协议方面的知识，希望能给读者带来一些收获，如有不对之处还请指出。  </p><h2><span id=\"1-web始祖http\"><strong>1. web始祖HTTP</strong></span></h2><p>全称：超文本传输协议(HyperText Transfer Protocol) 伴随着计算机网络和浏览器的诞生，HTTP1.0也随之而来，处于计算机网络中的应用层，HTTP是建立在TCP协议之上，所以HTTP协议的瓶颈及其优化技巧都是基于TCP协议本身的特性，例如tcp建立连接的3次握手和断开连接的4次挥手以及每次建立连接带来的RTT延迟时间。    </p><a id=\"more\"></a><h2><span id=\"2-http与现代化浏览器\"><strong>2. HTTP与现代化浏览器</strong></span></h2><p>早在HTTP建立之初，主要就是为了将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。也是说对于前端来说，我们所写的HTML页面将要放在我们的web服务器上，用户端通过浏览器访问url地址来获取网页的显示内容，但是到了WEB2.0以来，我们的页面变得复杂，不仅仅单纯的是一些简单的文字和图片，同时我们的HTML页面有了CSS，Javascript，来丰富我们的页面展示，当ajax的出现，我们又多了一种向服务器端获取数据的方法，这些其实都是基于HTTP协议的。同样到了移动互联网时代，我们页面可以跑在手机端浏览器里面，但是和PC相比，手机端的网络情况更加复杂，这使得我们开始了不得不对HTTP进行深入理解并不断优化过程中。 <img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/timeline.png\" alt data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/timeline.png\">  </p><h2><span id=\"3-http的基本优化\"><strong>3. HTTP的基本优化</strong></span></h2><p>影响一个HTTP网络请求的因素主要有两个：带宽和延迟。</p><ul><li><strong>带宽：</strong>如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，当时现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。</li><li><strong>延迟：</strong></li></ul><ol><li><strong>浏览器阻塞（HOL blocking）</strong>：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。</li><li> <strong>DNS 查询（DNS Lookup）</strong>：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。</li><li> <strong>建立连接（Initial connection）</strong>：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和<a href=\"http://en.wikipedia.org/wiki/Slow-start\" data-cke-saved-href=\"http://en.wikipedia.org/wiki/Slow-start\" target=\"_blank\" rel=\"noopener\">慢启动</a>。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</li></ol><p><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/3woshou.png\" alt data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/3woshou.png\">    </p><h2><span id=\"4-http10和http11的一些区别\"><strong>4. HTTP1.0和HTTP1.1的一些区别</strong></span></h2><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 <strong>主要区别主要体现在：</strong></p><ol><li><strong>缓存处理，</strong>在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong>，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>错误通知的管理</strong>，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>Host头处理</strong>，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li><li><strong>长连接</strong>，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。以下是常见的HTTP1.0：</li></ol><p><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/host1.png\" alt data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/host1.png\"></p><h2><span id><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/http11.png\" alt data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/http11.png\"></span></h2><h2><span id> </span></h2><h2><span id=\"5-http10和11现存的一些问题\"><strong>5. HTTP1.0和1.1现存的一些问题</strong></span></h2><ol><li>上面提到过的，HTTP1.x在传输数据时，每次都需要重新建立连接，无疑增加了大量的延迟时间，特别是在移动端更为突出。</li><li> HTTP1.x在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性。</li><li> HTTP1.x在使用时，header里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求header基本不怎么变化，尤其在移动端增加用户流量。</li><li> 虽然HTTP1.x支持了keep-alive，来弥补多次创建连接产生的延迟，但是keep-alive使用多了同样会给服务端带来大量的性能压力，并且对于单个文件被不断请求的服务(例如图片存放网站)，keep-alive可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。</li></ol><p>&nbsp;</p><h2><span id=\"6-https应声而出\"><strong>6. HTTPS应声而出</strong></span></h2><p>为了解决以上问题，网景在1994年创建了HTTPS，并应用在网景导航者浏览器中。 最初，HTTPS是与<a href=\"https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E5%8D%94%E8%AD%B0\" data-cke-saved-href=\"https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E5%8D%94%E8%AD%B0\" target=\"_blank\" rel=\"noopener\">SSL</a>一起使用的；在SSL逐渐演变到<a href=\"https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E5%8D%94%E8%AD%B0#TLS_1.0\" data-cke-saved-href=\"https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E5%8D%94%E8%AD%B0#TLS_1.0\" target=\"_blank\" rel=\"noopener\">TLS</a>时（其实两个是一个东西，只是名字不同而已），最新的HTTPS也由在2000年五月公布的RFC 2818正式确定下来。简单来说，HTTPS就是安全版的HTTP，并且由于当今时代对安全性要求更高，chrome和firefox都大力支持网站使用HTTPS，苹果也在ios 10系统中强制app使用HTTPS来传输数据，由此可见HTTPS势在必行。  </p><h2><span id=\"7-https与http的一些区别\"><strong>7. HTTPS与HTTP的一些区别</strong></span></h2><ol><li>HTTPS协议需要到ca申请证书，一般免费证书很少，需要交费。</li><li>HTTP是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的ssl加密传输协议。</li><li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>HTTPS的连接很简单，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ol><p>&nbsp;</p><h2><span id=\"8-https改造\"><strong>8. HTTPS改造</strong></span></h2><p><strong>如果一个网站要全站由HTTP替换成HTTPS，可能需要关注以下几点：</strong></p><ol><li>安装CA证书，一般的证书都是需要收费的，这边推荐一个比较好的购买证书网站：1）<a href=\"https://www.google.com.hk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwiR-aqIuonOAhVEJJQKHRUyB9kQFggcMAA&amp;url=%68%74%74%70%73%3a%2f%2f%6c%65%74%73%65%6e%63%72%79%70%74%2e%6f%72%67%2f&amp;usg=AFQjCNHLSK55fO3YLnyT_sYlhlFMyyILjg\" data-cke-saved-href=\"https://www.google.com.hk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwiR-aqIuonOAhVEJJQKHRUyB9kQFggcMAA&amp;url=%68%74%74%70%73%3a%2f%2f%6c%65%74%73%65%6e%63%72%79%70%74%2e%6f%72%67%2f&amp;usg=AFQjCNHLSK55fO3YLnyT_sYlhlFMyyILjg\" target=\"_blank\" rel=\"noopener\">Let’s Encrypt</a>，免费，快捷，支持多域名（不是通配符），三条命令即时签署+导出证书。缺点是暂时只有三个月有效期，到期需续签。2<a href=\"http://www.googleadservices.com/pagead/aclk?sa=L&amp;ai=DChcSEwiw__OzuonOAhWXl70KHckjAFwYABAA&amp;ohost=www.google.cn&amp;cid=CAASJORoai_i-_0j0yr7GaclkrgOrZjgeqXX5_EFZU_1oxVUunWc5A&amp;sig=AOD64_2e98s_eLbDZ4LOE0bxIwoqy8RZ6g&amp;q=&amp;ved=0ahUKEwim1_GzuonOAhVLHZQKHf--BB4Q0QwIGg&amp;adurl=\" data-cke-saved-href=\"http://www.googleadservices.com/pagead/aclk?sa=L&amp;ai=DChcSEwiw__OzuonOAhWXl70KHckjAFwYABAA&amp;ohost=www.google.cn&amp;cid=CAASJORoai_i-_0j0yr7GaclkrgOrZjgeqXX5_EFZU_1oxVUunWc5A&amp;sig=AOD64_2e98s_eLbDZ4LOE0bxIwoqy8RZ6g&amp;q=&amp;ved=0ahUKEwim1_GzuonOAhVLHZQKHf--BB4Q0QwIGg&amp;adurl=\" target=\"_blank\" rel=\"noopener\">Comodo PositiveSSL</a>，收费，但是比较稳定。</li><li>在购买证书之后，在证书提供的网站上配置自己的域名，将证书下载下来之后，配置自己的web服务器，同时进行代码改造。</li><li>HTTPS 降低用户访问速度。<a href=\"http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html\" data-cke-saved-href=\"http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html\" target=\"_blank\" rel=\"noopener\">SSL握手</a>，HTTPS 对速度会有一定程度的降低，但是只要经过合理优化和部署，HTTPS 对速度的影响完全可以接受。在很多场景下，HTTPS 速度完全不逊于 HTTP，如果使用 SPDY，HTTPS 的速度甚至还要比 HTTP 快。</li><li>相对于HTTPS降低访问速度，其实更需要关心的是服务器端的CPU压力，HTTPS中大量的密钥算法计算，会消耗大量的CPU资源，只有足够的优化，HTTPS 的机器成本才不会明显增加。</li></ol><p>推荐一则<a href=\"http://velocity.oreilly.com.cn/2015/ppts/lizhenyu.pdf\" data-cke-saved-href=\"http://velocity.oreilly.com.cn/2015/ppts/lizhenyu.pdf\" target=\"_blank\" rel=\"noopener\">淘宝网改造HTTPS</a>的文章。  </p><h2><span id=\"9-使用spdy加快你的网站速度\"><strong>9. 使用SPDY加快你的网站速度</strong></span></h2><p>2012年google如一声惊雷提出了SPDY的方案，大家才开始从正面看待和解决老版本HTTP协议本身的问题，SPDY可以说是综合了HTTPS和HTTP两者有点于一体的传输协议，主要解决：</p><ol><li><strong>降低延迟</strong>，针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。</li><li><strong>请求优先级</strong>（request prioritization）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。</li><li><strong>header压缩</strong>。前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。</li><li><strong>基于HTTPS的加密协议传输</strong>，大大提高了传输数据的可靠性。</li><li><strong>服务端推送</strong>（server push），采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。SPDY构成图：</li></ol><p><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/SPDY.png\" alt data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/SPDY.png\"> SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。   <strong>兼容性：</strong> <img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/sodyuse.png\" alt data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/sodyuse.png\">  </p><h2><span id=\"10-http20的前世今生\"><strong>10. HTTP2.0的前世今生</strong></span></h2><p>S顾名思义有了HTTP1.x，那么HTTP2.0也就顺理成章的出现了。HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，主要是以下两点：</p><ul><li>HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</li><li>HTTP2.0 消息头的压缩算法采用 <a href=\"http://http2.github.io/http2-spec/compression.html\" data-cke-saved-href=\"http://http2.github.io/http2-spec/compression.html\" target=\"_blank\" rel=\"noopener\">HPACK</a>，而非 SPDY 采用的 <a href=\"http://zh.wikipedia.org/wiki/DEFLATE\" data-cke-saved-href=\"http://zh.wikipedia.org/wiki/DEFLATE\" target=\"_blank\" rel=\"noopener\">DEFLATE</a></li></ul><p>&nbsp;</p><h2><span id=\"11-http20的新特性\"><strong>11. HTTP2.0的新特性</strong></span></h2><ul><li><strong>新的二进制格式</strong>（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li><li><strong>多路复用</strong>（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。<strong>多路复用原理图</strong>：</li></ul><p><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/duolufuyong.png\" alt data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/duolufuyong.png\"></p><ul><li><strong>header压缩，</strong>如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li><li><strong>服务端推送</strong>（server push），同SPDY一样，HTTP2.0也具有server push功能。目前，有大多数网站已经启用HTTP2.0，例如<a href=\"https://www.youtube.com\" data-cke-saved-href=\"https://www.youtube.com\" target=\"_blank\" rel=\"noopener\">YouTuBe</a>，<a href=\"http://www.taobao.com\" data-cke-saved-href=\"http://www.taobao.com\" target=\"_blank\" rel=\"noopener\">淘宝网</a>等网站，利用chrome控制台可以查看是否启用H2：</li></ul><p><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/h2.png\" alt data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/h2.png\"> 更多关于HTTP2的问题可以参考：<a href=\"http://www.alloyteam.com/2015/03/http2-0-di-qi-miao-ri-chang/\" data-cke-saved-href=\"http://www.alloyteam.com/2015/03/http2-0-di-qi-miao-ri-chang/\" target=\"_blank\" rel=\"noopener\">HTTP2奇妙日常</a>，以及HTTP2.0的<a href=\"https://http2.akamai.com/\" data-cke-saved-href=\"https://http2.akamai.com/\" target=\"_blank\" rel=\"noopener\">官方网站</a>。  </p><h2><span id=\"12-http20的升级改造\"><strong>12. HTTP2.0的升级改造</strong></span></h2><p><strong>对比HTTPS的升级改造，HTTP2.0获取会稍微简单一些，你可能需要关注以下问题：</strong></p><ol><li>前文说了HTTP2.0其实可以支持非HTTPS的，但是现在主流的浏览器像chrome，firefox表示还是只支持基于 TLS 部署的HTTP2.0协议，所以要想升级成HTTP2.0还是先生气HTTPS为好。</li><li>当你的网站已经升级HTTPS之后，那么升级HTTP2.0就简单很多，如果你使用NGINX，只要在配置文件中启动相应的协议就可以了，可以参考<a href=\"https://www.nginx.com/wp-content/uploads/2015/09/NGINX_HTTP2_White_Paper_v4.pdf\" data-cke-saved-href=\"https://www.nginx.com/wp-content/uploads/2015/09/NGINX_HTTP2_White_Paper_v4.pdf\" target=\"_blank\" rel=\"noopener\">NGINX白皮书</a>，<a href=\"https://www.nginx.com/blog/nginx-1-9-5/\" data-cke-saved-href=\"https://www.nginx.com/blog/nginx-1-9-5/\" target=\"_blank\" rel=\"noopener\">NGINX配置HTTP2.0官方指南</a>。</li><li>使用了HTTP2.0那么，原本的HTTP1.x怎么办，这个问题其实不用担心，HTTP2.0完全兼容HTTP1.x的语义，对于不支持HTTP2.0的浏览器，NGINX会自动向下兼容的。</li></ol><p>&nbsp;</p><h2><span id=\"后记\">后记</span></h2><ol><li>以上就是关于HTTP,HTTP2.0,SPDY,HTTPS的一些基本理论，有些内容没有深入讲解，大家可以跟进参考连接具体查看。</li><li>关于HTTP1.x的一些优化方式，例如文件合并压缩，资源cdn，js，css优化等等同样使用与HTTP2.0和HTTPS，所以web前端的优化，还是要继续进行。</li><li>其实WEB发展如此迅速的今天，有些技术是真的要与时俱进的，就像苹果宣布ios 10必须使用HTTPS开始，关于web协议革新就已经开始了，为了更好的性能，更优越的方式，现在就开始升级改造吧</li></ol><p></p>\n","site":{"data":{}},"excerpt":"<p></p><p>作为一个经常和web打交道的程序员，了解这些协议是必须的，本文就向大家介绍一下这些协议的区别和基本概念，文中可能不局限于前端知识，还包括一些运维，协议方面的知识，希望能给读者带来一些收获，如有不对之处还请指出。  </p><h2><strong>1. web始祖HTTP</strong></h2><p>全称：超文本传输协议(HyperText Transfer Protocol) 伴随着计算机网络和浏览器的诞生，HTTP1.0也随之而来，处于计算机网络中的应用层，HTTP是建立在TCP协议之上，所以HTTP协议的瓶颈及其优化技巧都是基于TCP协议本身的特性，例如tcp建立连接的3次握手和断开连接的4次挥手以及每次建立连接带来的RTT延迟时间。    </p>","more":"<h2><strong>2. HTTP与现代化浏览器</strong></h2><p>早在HTTP建立之初，主要就是为了将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。也是说对于前端来说，我们所写的HTML页面将要放在我们的web服务器上，用户端通过浏览器访问url地址来获取网页的显示内容，但是到了WEB2.0以来，我们的页面变得复杂，不仅仅单纯的是一些简单的文字和图片，同时我们的HTML页面有了CSS，Javascript，来丰富我们的页面展示，当ajax的出现，我们又多了一种向服务器端获取数据的方法，这些其实都是基于HTTP协议的。同样到了移动互联网时代，我们页面可以跑在手机端浏览器里面，但是和PC相比，手机端的网络情况更加复杂，这使得我们开始了不得不对HTTP进行深入理解并不断优化过程中。 <img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/timeline.png\" alt=\"\" data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/timeline.png\">  </p><h2><strong>3. HTTP的基本优化</strong></h2><p>影响一个HTTP网络请求的因素主要有两个：带宽和延迟。</p><ul><li><strong>带宽：</strong>如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，当时现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。</li><li><strong>延迟：</strong></li></ul><ol><li><strong>浏览器阻塞（HOL blocking）</strong>：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。</li><li> <strong>DNS 查询（DNS Lookup）</strong>：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。</li><li> <strong>建立连接（Initial connection）</strong>：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和<a href=\"http://en.wikipedia.org/wiki/Slow-start\" data-cke-saved-href=\"http://en.wikipedia.org/wiki/Slow-start\" target=\"_blank\" rel=\"noopener\">慢启动</a>。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</li></ol><p><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/3woshou.png\" alt=\"\" data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/3woshou.png\">    </p><h2><strong>4. HTTP1.0和HTTP1.1的一些区别</strong></h2><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 <strong>主要区别主要体现在：</strong></p><ol><li><strong>缓存处理，</strong>在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong>，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>错误通知的管理</strong>，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>Host头处理</strong>，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li><li><strong>长连接</strong>，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。以下是常见的HTTP1.0：</li></ol><p><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/host1.png\" alt=\"\" data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/host1.png\"></p><h2><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/http11.png\" alt=\"\" data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/http11.png\"></h2><h2> </h2><h2><strong>5. HTTP1.0和1.1现存的一些问题</strong></h2><ol><li>上面提到过的，HTTP1.x在传输数据时，每次都需要重新建立连接，无疑增加了大量的延迟时间，特别是在移动端更为突出。</li><li> HTTP1.x在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性。</li><li> HTTP1.x在使用时，header里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求header基本不怎么变化，尤其在移动端增加用户流量。</li><li> 虽然HTTP1.x支持了keep-alive，来弥补多次创建连接产生的延迟，但是keep-alive使用多了同样会给服务端带来大量的性能压力，并且对于单个文件被不断请求的服务(例如图片存放网站)，keep-alive可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。</li></ol><p>&nbsp;</p><h2><strong>6. HTTPS应声而出</strong></h2><p>为了解决以上问题，网景在1994年创建了HTTPS，并应用在网景导航者浏览器中。 最初，HTTPS是与<a href=\"https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E5%8D%94%E8%AD%B0\" data-cke-saved-href=\"https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E5%8D%94%E8%AD%B0\" target=\"_blank\" rel=\"noopener\">SSL</a>一起使用的；在SSL逐渐演变到<a href=\"https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E5%8D%94%E8%AD%B0#TLS_1.0\" data-cke-saved-href=\"https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E5%8D%94%E8%AD%B0#TLS_1.0\" target=\"_blank\" rel=\"noopener\">TLS</a>时（其实两个是一个东西，只是名字不同而已），最新的HTTPS也由在2000年五月公布的RFC 2818正式确定下来。简单来说，HTTPS就是安全版的HTTP，并且由于当今时代对安全性要求更高，chrome和firefox都大力支持网站使用HTTPS，苹果也在ios 10系统中强制app使用HTTPS来传输数据，由此可见HTTPS势在必行。  </p><h2><strong>7. HTTPS与HTTP的一些区别</strong></h2><ol><li>HTTPS协议需要到ca申请证书，一般免费证书很少，需要交费。</li><li>HTTP是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的ssl加密传输协议。</li><li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>HTTPS的连接很简单，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ol><p>&nbsp;</p><h2><strong>8. HTTPS改造</strong></h2><p><strong>如果一个网站要全站由HTTP替换成HTTPS，可能需要关注以下几点：</strong></p><ol><li>安装CA证书，一般的证书都是需要收费的，这边推荐一个比较好的购买证书网站：1）<a href=\"https://www.google.com.hk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwiR-aqIuonOAhVEJJQKHRUyB9kQFggcMAA&amp;url=%68%74%74%70%73%3a%2f%2f%6c%65%74%73%65%6e%63%72%79%70%74%2e%6f%72%67%2f&amp;usg=AFQjCNHLSK55fO3YLnyT_sYlhlFMyyILjg\" data-cke-saved-href=\"https://www.google.com.hk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwiR-aqIuonOAhVEJJQKHRUyB9kQFggcMAA&amp;url=%68%74%74%70%73%3a%2f%2f%6c%65%74%73%65%6e%63%72%79%70%74%2e%6f%72%67%2f&amp;usg=AFQjCNHLSK55fO3YLnyT_sYlhlFMyyILjg\" target=\"_blank\" rel=\"noopener\">Let’s Encrypt</a>，免费，快捷，支持多域名（不是通配符），三条命令即时签署+导出证书。缺点是暂时只有三个月有效期，到期需续签。2<a href=\"http://www.googleadservices.com/pagead/aclk?sa=L&amp;ai=DChcSEwiw__OzuonOAhWXl70KHckjAFwYABAA&amp;ohost=www.google.cn&amp;cid=CAASJORoai_i-_0j0yr7GaclkrgOrZjgeqXX5_EFZU_1oxVUunWc5A&amp;sig=AOD64_2e98s_eLbDZ4LOE0bxIwoqy8RZ6g&amp;q=&amp;ved=0ahUKEwim1_GzuonOAhVLHZQKHf--BB4Q0QwIGg&amp;adurl=\" data-cke-saved-href=\"http://www.googleadservices.com/pagead/aclk?sa=L&amp;ai=DChcSEwiw__OzuonOAhWXl70KHckjAFwYABAA&amp;ohost=www.google.cn&amp;cid=CAASJORoai_i-_0j0yr7GaclkrgOrZjgeqXX5_EFZU_1oxVUunWc5A&amp;sig=AOD64_2e98s_eLbDZ4LOE0bxIwoqy8RZ6g&amp;q=&amp;ved=0ahUKEwim1_GzuonOAhVLHZQKHf--BB4Q0QwIGg&amp;adurl=\" target=\"_blank\" rel=\"noopener\">Comodo PositiveSSL</a>，收费，但是比较稳定。</li><li>在购买证书之后，在证书提供的网站上配置自己的域名，将证书下载下来之后，配置自己的web服务器，同时进行代码改造。</li><li>HTTPS 降低用户访问速度。<a href=\"http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html\" data-cke-saved-href=\"http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html\" target=\"_blank\" rel=\"noopener\">SSL握手</a>，HTTPS 对速度会有一定程度的降低，但是只要经过合理优化和部署，HTTPS 对速度的影响完全可以接受。在很多场景下，HTTPS 速度完全不逊于 HTTP，如果使用 SPDY，HTTPS 的速度甚至还要比 HTTP 快。</li><li>相对于HTTPS降低访问速度，其实更需要关心的是服务器端的CPU压力，HTTPS中大量的密钥算法计算，会消耗大量的CPU资源，只有足够的优化，HTTPS 的机器成本才不会明显增加。</li></ol><p>推荐一则<a href=\"http://velocity.oreilly.com.cn/2015/ppts/lizhenyu.pdf\" data-cke-saved-href=\"http://velocity.oreilly.com.cn/2015/ppts/lizhenyu.pdf\" target=\"_blank\" rel=\"noopener\">淘宝网改造HTTPS</a>的文章。  </p><h2><strong>9. 使用SPDY加快你的网站速度</strong></h2><p>2012年google如一声惊雷提出了SPDY的方案，大家才开始从正面看待和解决老版本HTTP协议本身的问题，SPDY可以说是综合了HTTPS和HTTP两者有点于一体的传输协议，主要解决：</p><ol><li><strong>降低延迟</strong>，针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。</li><li><strong>请求优先级</strong>（request prioritization）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。</li><li><strong>header压缩</strong>。前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。</li><li><strong>基于HTTPS的加密协议传输</strong>，大大提高了传输数据的可靠性。</li><li><strong>服务端推送</strong>（server push），采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。SPDY构成图：</li></ol><p><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/SPDY.png\" alt=\"\" data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/SPDY.png\"> SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。   <strong>兼容性：</strong> <img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/sodyuse.png\" alt=\"\" data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/sodyuse.png\">  </p><h2><strong>10. HTTP2.0的前世今生</strong></h2><p>S顾名思义有了HTTP1.x，那么HTTP2.0也就顺理成章的出现了。HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，主要是以下两点：</p><ul><li>HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</li><li>HTTP2.0 消息头的压缩算法采用 <a href=\"http://http2.github.io/http2-spec/compression.html\" data-cke-saved-href=\"http://http2.github.io/http2-spec/compression.html\" target=\"_blank\" rel=\"noopener\">HPACK</a>，而非 SPDY 采用的 <a href=\"http://zh.wikipedia.org/wiki/DEFLATE\" data-cke-saved-href=\"http://zh.wikipedia.org/wiki/DEFLATE\" target=\"_blank\" rel=\"noopener\">DEFLATE</a></li></ul><p>&nbsp;</p><h2><strong>11. HTTP2.0的新特性</strong></h2><ul><li><strong>新的二进制格式</strong>（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li><li><strong>多路复用</strong>（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。<strong>多路复用原理图</strong>：</li></ul><p><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/duolufuyong.png\" alt=\"\" data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/duolufuyong.png\"></p><ul><li><strong>header压缩，</strong>如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li><li><strong>服务端推送</strong>（server push），同SPDY一样，HTTP2.0也具有server push功能。目前，有大多数网站已经启用HTTP2.0，例如<a href=\"https://www.youtube.com\" data-cke-saved-href=\"https://www.youtube.com\" target=\"_blank\" rel=\"noopener\">YouTuBe</a>，<a href=\"http://www.taobao.com\" data-cke-saved-href=\"http://www.taobao.com\" target=\"_blank\" rel=\"noopener\">淘宝网</a>等网站，利用chrome控制台可以查看是否启用H2：</li></ul><p><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/h2.png\" alt=\"\" data-cke-saved-src=\"http://qiniu.nihaoshijie.com.cn/h2.png\"> 更多关于HTTP2的问题可以参考：<a href=\"http://www.alloyteam.com/2015/03/http2-0-di-qi-miao-ri-chang/\" data-cke-saved-href=\"http://www.alloyteam.com/2015/03/http2-0-di-qi-miao-ri-chang/\" target=\"_blank\" rel=\"noopener\">HTTP2奇妙日常</a>，以及HTTP2.0的<a href=\"https://http2.akamai.com/\" data-cke-saved-href=\"https://http2.akamai.com/\" target=\"_blank\" rel=\"noopener\">官方网站</a>。  </p><h2><strong>12. HTTP2.0的升级改造</strong></h2><p><strong>对比HTTPS的升级改造，HTTP2.0获取会稍微简单一些，你可能需要关注以下问题：</strong></p><ol><li>前文说了HTTP2.0其实可以支持非HTTPS的，但是现在主流的浏览器像chrome，firefox表示还是只支持基于 TLS 部署的HTTP2.0协议，所以要想升级成HTTP2.0还是先生气HTTPS为好。</li><li>当你的网站已经升级HTTPS之后，那么升级HTTP2.0就简单很多，如果你使用NGINX，只要在配置文件中启动相应的协议就可以了，可以参考<a href=\"https://www.nginx.com/wp-content/uploads/2015/09/NGINX_HTTP2_White_Paper_v4.pdf\" data-cke-saved-href=\"https://www.nginx.com/wp-content/uploads/2015/09/NGINX_HTTP2_White_Paper_v4.pdf\" target=\"_blank\" rel=\"noopener\">NGINX白皮书</a>，<a href=\"https://www.nginx.com/blog/nginx-1-9-5/\" data-cke-saved-href=\"https://www.nginx.com/blog/nginx-1-9-5/\" target=\"_blank\" rel=\"noopener\">NGINX配置HTTP2.0官方指南</a>。</li><li>使用了HTTP2.0那么，原本的HTTP1.x怎么办，这个问题其实不用担心，HTTP2.0完全兼容HTTP1.x的语义，对于不支持HTTP2.0的浏览器，NGINX会自动向下兼容的。</li></ol><p>&nbsp;</p><h2>后记</h2><ol><li>以上就是关于HTTP,HTTP2.0,SPDY,HTTPS的一些基本理论，有些内容没有深入讲解，大家可以跟进参考连接具体查看。</li><li>关于HTTP1.x的一些优化方式，例如文件合并压缩，资源cdn，js，css优化等等同样使用与HTTP2.0和HTTPS，所以web前端的优化，还是要继续进行。</li><li>其实WEB发展如此迅速的今天，有些技术是真的要与时俱进的，就像苹果宣布ios 10必须使用HTTPS开始，关于web协议革新就已经开始了，为了更好的性能，更优越的方式，现在就开始升级改造吧</li></ol><p></p>"},{"title":"HTTP2 Server Push 研究","date":"2016-11-27T12:40:27.000Z","photos":["https://qiniu.nihaoshijie.com.cn/7542543_SPDY-to-HTTP2-Upgrade-and-Nginx_thumb.jpg"],"_content":"<h2>1，HTTP2的新特性。</h2>\n关于HTTP2的新特性，读着可以参看我之前的文章，这里就不在多说了，本篇文章主要讲一下server push这个特性。\n\n<a href=\"http://km.oa.com/group/19674/articles/show/276552\" target=\"_blank\" rel=\"noopener noreferrer\">HTTPS与HTTP2的原理，搭建，性能测试对比</a>\n\n<a href=\"http://km.oa.com/articles/view/290595\" target=\"_blank\" rel=\"noopener noreferrer\">HTTP,HTTP2.0,SPDY,HTTPS你应该知道的一些事</a>\n<!--more-->\n<h2>2，Server Push是什么。</h2>\n简单来讲就是当用户的浏览器和服务器在建立链接后，服务器主动将一些资源推送给浏览器并缓存起来，这样当浏览器接下来请求这些资源时就直接从缓存中读取，不会在从服务器上拉了，提升了速率。举一个例子就是：\n\n假如一个页面有3个资源文件<strong>index.html</strong>,<strong>index.css</strong>,<strong>index.js</strong>,当浏览器请求index.html的时候，服务器不仅返回index.html的内容，同时将index.css和index.js的内容push给浏览器，当浏览器下次请求这2两个文件时就可以直接从缓存中读取了。\n<h2></h2>\n<h2>3，Server Push原理是什么。</h2>\n要想了解server push原理，首先要理解一些概念。我们知道HTTP2传输的格式并不像HTTP1使用文本来传输，而是启用了二进制帧(Frames)格式来传输，和server push相关的帧主要分成这几种类型：\n<ol>\n \t<li>HEADERS frame(请求返回头帧):这种帧主要携带的http请求头信息，和HTTP1的header类似。</li>\n \t<li>DATA frames(数据帧) :这种帧存放真正的数据content，用来传输。</li>\n \t<li>PUSH_PROMISE frame(推送帧):这种帧是由server端发送给client的帧，用来表示server push的帧，这种帧是实现server push的主要帧类型。</li>\n \t<li>RST_STREAM(取消推送帧):这种帧表示请求关闭帧，简单讲就是当client不想接受某些资源或者接受timeout时会向发送方发送此帧，和PUSH_PROMISE frame一起使用时表示拒绝或者关闭server push。</li>\n</ol>\n<span style=\"font-weight: bolder;\">Note:</span>HTTP2.0相关的帧其实包括<a href=\"https://tools.ietf.org/html/rfc7540#section-11.2\" target=\"_blank\" rel=\"noopener noreferrer\">10种帧</a>，正是因为底层数据格式的改变，才为HTTP2.0带来许多的特性，帧的引入不仅有利于压缩数据，也有利于数据的安全性和可靠传输性。\n\n<strong>了解了相关的帧类型，下面就是具体server push的实现过程了：</strong>\n<ol>\n \t<li>由多路复用我们可以知道HTTP2中对于同一个域名的请求会使用一条tcp链接而用不同的stream ID来区分各自的请求。</li>\n \t<li>当client使用stream 1请求index.html时，server正常处理index.html的请求，并可以得知index.html页面还将要会请求index.css和index.js。</li>\n \t<li>server使用stream 1发送PUSH_PROMISE frame给client告诉client我这边可以使用stream 2来推送index.js和stream 3来推送index.css资源。</li>\n \t<li>server使用stream 1正常的发送HEADERS frame和DATA frames将index.html的内容返回给client。</li>\n \t<li>client接收到PUSH_PROMISE frame得知stream 2和stream 3来接收推送资源。</li>\n \t<li>server拿到index.css和index.js便会发送HEADERS frame和DATA frames将资源发送给client。</li>\n \t<li>client拿到push的资源后会缓存起来当请求这个资源时会从直接从从缓存中读取。</li>\n</ol>\n下图表示了整个流程：\n\n<a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2016/11/屏幕快照-2016-11-27-19.07.58.png\"><img class=\"alignnone size-full wp-image-656\" src=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2016/11/屏幕快照-2016-11-27-19.07.58.png\" alt=\"%e5%b1%8f%e5%b9%95%e5%bf%ab%e7%85%a7-2016-11-27-19-07-58\" width=\"2024\" height=\"1448\" /></a>\n<h2>4，Server Push怎么用。</h2>\n既然server push这么神奇，那么我们如何使用呢？怎么设置服务器push哪些文件呢？\n\n首先并不是所有的服务器都支持server push，nginx目前还不支持这个特性，可以在nginx的官方博客上得到证实<a href=\"https://www.nginx.com/blog/http2-r7/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.nginx.com/blog/http2-r7/</a>，但是Apache和nodejs都已经支持了server push这一个特性，需要说明一点的是server push这个特性是基于浏览器和服务器的，所以浏览器并没有提供相应的js api来让用户直接操作和控制push的内容，所以只能是通过header信息和server的配置来实现具体的push内容，本文主要以nodejs来说明具体如何使用server push这一特性。\n\n<strong>准备工作</strong>：下载<a href=\"https://github.com/molnarg/node-http2\" target=\"_blank\" rel=\"noopener noreferrer\">nodejs http2</a>支持，本地启动nodejs服务。\n\n<strong>1. 首先我们使用nodejs搭建基本的server：</strong>\n<div class=\"km_insert_code\">\n<pre><code><span class=\"hljs-keyword\">var</span> http2 = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'http2'</span>);\n\n<span class=\"hljs-keyword\">var</span> url=<span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'url'</span>);\n<span class=\"hljs-keyword\">var</span> fs=<span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>);\n<span class=\"hljs-keyword\">var</span> mine=<span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./mine'</span>).types;\n<span class=\"hljs-keyword\">var</span> path=<span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'path'</span>);\n\n<span class=\"hljs-keyword\">var</span> server = http2.createServer({\n  key: fs.readFileSync(<span class=\"hljs-string\">'./zs/localhost.key'</span>),\n  cert: fs.readFileSync(<span class=\"hljs-string\">'./zs/localhost.crt'</span>)\n}, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">request, response</span>) </span>{\n    <span class=\"hljs-keyword\">var</span> pathname = url.parse(request.url).pathname;\n    <span class=\"hljs-keyword\">var</span> realPath = path.join(<span class=\"hljs-string\">\"my\"</span>, pathname);    <span class=\"hljs-comment\">//这里设置自己的文件名称;</span>\n\n    <span class=\"hljs-keyword\">var</span> pushArray = [];\n    <span class=\"hljs-keyword\">var</span> ext = path.extname(realPath);\n    ext = ext ? ext.slice(<span class=\"hljs-number\">1</span>) : <span class=\"hljs-string\">'unknown'</span>;\n    <span class=\"hljs-keyword\">var</span> contentType = mine[ext] || <span class=\"hljs-string\">\"text/plain\"</span>;\n\n    <span class=\"hljs-keyword\">if</span> (fs.existsSync(realPath)) {\n\n        response.writeHead(<span class=\"hljs-number\">200</span>, {\n            <span class=\"hljs-string\">'Content-Type'</span>: contentType\n        });\n\n        response.write(fs.readFileSync(realPath,<span class=\"hljs-string\">'binary'</span>));\n\n    } <span class=\"hljs-keyword\">else</span> {\n      response.writeHead(<span class=\"hljs-number\">404</span>, {\n          <span class=\"hljs-string\">'Content-Type'</span>: <span class=\"hljs-string\">'text/plain'</span>\n      });\n\n      response.write(<span class=\"hljs-string\">\"This request URL \"</span> + pathname + <span class=\"hljs-string\">\" was not found on this server.\"</span>);\n      response.end();\n    }\n\n});\n\nserver.listen(<span class=\"hljs-number\">443</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>() </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'listen on 443'</span>);\n});</code></pre>\n</div>\n这几行代码就是简单搭建一个nodejs http2服务，打开chrome，我们可以看到所有请求都走了http2，同时也可以验证多路复用的特性。\n\n<a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2016/11/h21.png\"><img class=\"alignnone size-full wp-image-657\" src=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2016/11/h21.png\" alt=\"h21\" width=\"1327\" height=\"257\" /></a>\n\n<strong>这里需要注意几点：</strong>\n<ol>\n \t<li>创建http2的nodejs服务必须时基于https的，因为现在主流的浏览器都要支持SSL/TLS的http2，证书和私钥可以自己通过<a href=\"https://www.openssl.org/\" target=\"_blank\" rel=\"noopener noreferrer\">OPENSSL</a>生成。</li>\n \t<li>node http2的相关api和正常的node httpserver相同，可以直接使用。</li>\n</ol>\n<span style=\"font-weight: bolder;\">2. 设置我们的server push：</span>\n<div class=\"km_insert_code\">\n<pre><code><span class=\"hljs-keyword\">var</span> pushItem = response.push(<span class=\"hljs-string\">'/css/bootstrap.min.css'</span>, {\n       request: {\n            accept: <span class=\"hljs-string\">'*/\\*'</span>\n       },\n      response: {\n            <span class=\"hljs-string\">'content-type'</span>: <span class=\"hljs-string\">'text/css'</span>\n     }\n});\npushItem.end(fs.readFileSync(<span class=\"hljs-string\">'/css/bootstrap.min.css'</span>,<span class=\"hljs-string\">'binary'</span>));</code></pre>\n</div>\n我们设置了bootstrap.min.css来通过server push到我们的浏览器,我们可以在浏览器中查看：\n\n<a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2016/11/h22.png\"><img class=\"alignnone size-full wp-image-658\" src=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2016/11/h22.png\" alt=\"h22\" width=\"1716\" height=\"356\" /></a>\n\n可以看到，启动server push的资源timelime非常快，大大加速了css的获取时间。\n\n<strong>这里需要注意下面几点：</strong>\n<ol>\n \t<li>我们调用response.push(),就是相当于server发起了PUSH_PROMISE frame来告知浏览器bootstrap.min.css将会由server push来获取。</li>\n \t<li>response.push()返回的对象时一个正常的ServerResponse,end(),writeHeader()等方法都可以正常调用。</li>\n \t<li>这里一旦针对某个资源调用response.push()即发起PUSH_PROMISE frame后，要做好容错机制，因为浏览器在下次请求这个资源时会且只会等待这个server push回来的资源，这里要做好超时和容错即下面的代码：</li>\n \t<li>\n<div class=\"km_insert_code\">\n<pre><code><span class=\"hljs-keyword\">try</span> {\n    pushItem.end(fs.readFileSync(<span class=\"hljs-string\">'my/css/bootstrap.min.css'</span>,<span class=\"hljs-string\">'binary'</span>));\n    } <span class=\"hljs-keyword\">catch</span>(e) {\n       response.writeHead(<span class=\"hljs-number\">404</span>, {\n           <span class=\"hljs-string\">'Content-Type'</span>: <span class=\"hljs-string\">'text/plain'</span>\n       });\n       response.end(<span class=\"hljs-string\">'request error'</span>);\n}\n\npushItem.stream.on(<span class=\"hljs-string\">'error'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err</span>)</span>{\n    response.end(err.message);\n});\n\npushItem.stream.on(<span class=\"hljs-string\">'finish'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err</span>)</span>{\n   <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'finish'</span>);\n});</code></pre>\n</div>\n上面的代码你可能会发现许多和正常nodejs的httpserver不一样的东西，那就是stream，其实整个http2都是以stream为单位，这里的stream其实可以理解成一个请求，更多的api可以参考：<a href=\"https://github.com/molnarg/node-http2/wiki/Public-API\" target=\"_blank\" rel=\"noopener noreferrer\">node-http2</a>。</li>\n \t<li>最后给大家推荐一个老外写的专门服务http2的node server有兴趣的可以尝试一下。<a href=\"https://gitlab.com/sebdeckers/http2server\" target=\"_blank\" rel=\"noopener noreferrer\">https://gitlab.com/sebdeckers/http2server</a></li>\n</ol>\n<h2></h2>\n<h2>5，Server Push相关问题。</h2>\n<ol>\n \t<li>我们知道现在我们web的资源一般都是放在CDN上的，那么CDN的优势和server push的优势有何区别呢，到底是哪个比较快呢？这个问题笔者也一直在研究，本文的相关demo都只能算做一个演示，具体的线上实践还在进行中。</li>\n \t<li>由于HTTP2的一些新特性例如多路复用，server push等等都是基于同一个域名的，所以这可能会对我们之前对于HTTP1的一些优化措施例如(资源拆分域名，合并等等)不一定适用。</li>\n \t<li>server push不仅可以用作拉取静态资源，我们的cgi请求即ajax请求同样可以使用server push来发送数据。</li>\n \t<li>最完美的结果是CDN域名支持HTTP2,web server域名也同时支持HTTP2。</li>\n</ol>\n&nbsp;\n\n参考资料：\n<ol>\n \t<li>HTTP2官方标准：<a href=\"https://tools.ietf.org/html/rfc7540\" target=\"_blank\" rel=\"noopener noreferrer\">https://tools.ietf.org/html/rfc7540</a></li>\n \t<li>维基百科：<a href=\"https://en.wikipedia.org/wiki/HTTP/2_Server_Push\" target=\"_blank\" rel=\"noopener noreferrer\">https://en.wikipedia.org/wiki/HTTP/2_Server_Push</a></li>\n</ol>","source":"_posts/HTTP2-Server-Push-研究.md","raw":"---\ntitle: HTTP2 Server Push 研究\ndate: 2016-11-27 20:40:27\ntags:\n- http2\ncategories:\n- 651\nphotos: https://qiniu.nihaoshijie.com.cn/7542543_SPDY-to-HTTP2-Upgrade-and-Nginx_thumb.jpg\n---\n<h2>1，HTTP2的新特性。</h2>\n关于HTTP2的新特性，读着可以参看我之前的文章，这里就不在多说了，本篇文章主要讲一下server push这个特性。\n\n<a href=\"http://km.oa.com/group/19674/articles/show/276552\" target=\"_blank\" rel=\"noopener noreferrer\">HTTPS与HTTP2的原理，搭建，性能测试对比</a>\n\n<a href=\"http://km.oa.com/articles/view/290595\" target=\"_blank\" rel=\"noopener noreferrer\">HTTP,HTTP2.0,SPDY,HTTPS你应该知道的一些事</a>\n<!--more-->\n<h2>2，Server Push是什么。</h2>\n简单来讲就是当用户的浏览器和服务器在建立链接后，服务器主动将一些资源推送给浏览器并缓存起来，这样当浏览器接下来请求这些资源时就直接从缓存中读取，不会在从服务器上拉了，提升了速率。举一个例子就是：\n\n假如一个页面有3个资源文件<strong>index.html</strong>,<strong>index.css</strong>,<strong>index.js</strong>,当浏览器请求index.html的时候，服务器不仅返回index.html的内容，同时将index.css和index.js的内容push给浏览器，当浏览器下次请求这2两个文件时就可以直接从缓存中读取了。\n<h2></h2>\n<h2>3，Server Push原理是什么。</h2>\n要想了解server push原理，首先要理解一些概念。我们知道HTTP2传输的格式并不像HTTP1使用文本来传输，而是启用了二进制帧(Frames)格式来传输，和server push相关的帧主要分成这几种类型：\n<ol>\n \t<li>HEADERS frame(请求返回头帧):这种帧主要携带的http请求头信息，和HTTP1的header类似。</li>\n \t<li>DATA frames(数据帧) :这种帧存放真正的数据content，用来传输。</li>\n \t<li>PUSH_PROMISE frame(推送帧):这种帧是由server端发送给client的帧，用来表示server push的帧，这种帧是实现server push的主要帧类型。</li>\n \t<li>RST_STREAM(取消推送帧):这种帧表示请求关闭帧，简单讲就是当client不想接受某些资源或者接受timeout时会向发送方发送此帧，和PUSH_PROMISE frame一起使用时表示拒绝或者关闭server push。</li>\n</ol>\n<span style=\"font-weight: bolder;\">Note:</span>HTTP2.0相关的帧其实包括<a href=\"https://tools.ietf.org/html/rfc7540#section-11.2\" target=\"_blank\" rel=\"noopener noreferrer\">10种帧</a>，正是因为底层数据格式的改变，才为HTTP2.0带来许多的特性，帧的引入不仅有利于压缩数据，也有利于数据的安全性和可靠传输性。\n\n<strong>了解了相关的帧类型，下面就是具体server push的实现过程了：</strong>\n<ol>\n \t<li>由多路复用我们可以知道HTTP2中对于同一个域名的请求会使用一条tcp链接而用不同的stream ID来区分各自的请求。</li>\n \t<li>当client使用stream 1请求index.html时，server正常处理index.html的请求，并可以得知index.html页面还将要会请求index.css和index.js。</li>\n \t<li>server使用stream 1发送PUSH_PROMISE frame给client告诉client我这边可以使用stream 2来推送index.js和stream 3来推送index.css资源。</li>\n \t<li>server使用stream 1正常的发送HEADERS frame和DATA frames将index.html的内容返回给client。</li>\n \t<li>client接收到PUSH_PROMISE frame得知stream 2和stream 3来接收推送资源。</li>\n \t<li>server拿到index.css和index.js便会发送HEADERS frame和DATA frames将资源发送给client。</li>\n \t<li>client拿到push的资源后会缓存起来当请求这个资源时会从直接从从缓存中读取。</li>\n</ol>\n下图表示了整个流程：\n\n<a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2016/11/屏幕快照-2016-11-27-19.07.58.png\"><img class=\"alignnone size-full wp-image-656\" src=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2016/11/屏幕快照-2016-11-27-19.07.58.png\" alt=\"%e5%b1%8f%e5%b9%95%e5%bf%ab%e7%85%a7-2016-11-27-19-07-58\" width=\"2024\" height=\"1448\" /></a>\n<h2>4，Server Push怎么用。</h2>\n既然server push这么神奇，那么我们如何使用呢？怎么设置服务器push哪些文件呢？\n\n首先并不是所有的服务器都支持server push，nginx目前还不支持这个特性，可以在nginx的官方博客上得到证实<a href=\"https://www.nginx.com/blog/http2-r7/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.nginx.com/blog/http2-r7/</a>，但是Apache和nodejs都已经支持了server push这一个特性，需要说明一点的是server push这个特性是基于浏览器和服务器的，所以浏览器并没有提供相应的js api来让用户直接操作和控制push的内容，所以只能是通过header信息和server的配置来实现具体的push内容，本文主要以nodejs来说明具体如何使用server push这一特性。\n\n<strong>准备工作</strong>：下载<a href=\"https://github.com/molnarg/node-http2\" target=\"_blank\" rel=\"noopener noreferrer\">nodejs http2</a>支持，本地启动nodejs服务。\n\n<strong>1. 首先我们使用nodejs搭建基本的server：</strong>\n<div class=\"km_insert_code\">\n<pre><code><span class=\"hljs-keyword\">var</span> http2 = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'http2'</span>);\n\n<span class=\"hljs-keyword\">var</span> url=<span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'url'</span>);\n<span class=\"hljs-keyword\">var</span> fs=<span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>);\n<span class=\"hljs-keyword\">var</span> mine=<span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./mine'</span>).types;\n<span class=\"hljs-keyword\">var</span> path=<span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'path'</span>);\n\n<span class=\"hljs-keyword\">var</span> server = http2.createServer({\n  key: fs.readFileSync(<span class=\"hljs-string\">'./zs/localhost.key'</span>),\n  cert: fs.readFileSync(<span class=\"hljs-string\">'./zs/localhost.crt'</span>)\n}, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">request, response</span>) </span>{\n    <span class=\"hljs-keyword\">var</span> pathname = url.parse(request.url).pathname;\n    <span class=\"hljs-keyword\">var</span> realPath = path.join(<span class=\"hljs-string\">\"my\"</span>, pathname);    <span class=\"hljs-comment\">//这里设置自己的文件名称;</span>\n\n    <span class=\"hljs-keyword\">var</span> pushArray = [];\n    <span class=\"hljs-keyword\">var</span> ext = path.extname(realPath);\n    ext = ext ? ext.slice(<span class=\"hljs-number\">1</span>) : <span class=\"hljs-string\">'unknown'</span>;\n    <span class=\"hljs-keyword\">var</span> contentType = mine[ext] || <span class=\"hljs-string\">\"text/plain\"</span>;\n\n    <span class=\"hljs-keyword\">if</span> (fs.existsSync(realPath)) {\n\n        response.writeHead(<span class=\"hljs-number\">200</span>, {\n            <span class=\"hljs-string\">'Content-Type'</span>: contentType\n        });\n\n        response.write(fs.readFileSync(realPath,<span class=\"hljs-string\">'binary'</span>));\n\n    } <span class=\"hljs-keyword\">else</span> {\n      response.writeHead(<span class=\"hljs-number\">404</span>, {\n          <span class=\"hljs-string\">'Content-Type'</span>: <span class=\"hljs-string\">'text/plain'</span>\n      });\n\n      response.write(<span class=\"hljs-string\">\"This request URL \"</span> + pathname + <span class=\"hljs-string\">\" was not found on this server.\"</span>);\n      response.end();\n    }\n\n});\n\nserver.listen(<span class=\"hljs-number\">443</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>() </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'listen on 443'</span>);\n});</code></pre>\n</div>\n这几行代码就是简单搭建一个nodejs http2服务，打开chrome，我们可以看到所有请求都走了http2，同时也可以验证多路复用的特性。\n\n<a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2016/11/h21.png\"><img class=\"alignnone size-full wp-image-657\" src=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2016/11/h21.png\" alt=\"h21\" width=\"1327\" height=\"257\" /></a>\n\n<strong>这里需要注意几点：</strong>\n<ol>\n \t<li>创建http2的nodejs服务必须时基于https的，因为现在主流的浏览器都要支持SSL/TLS的http2，证书和私钥可以自己通过<a href=\"https://www.openssl.org/\" target=\"_blank\" rel=\"noopener noreferrer\">OPENSSL</a>生成。</li>\n \t<li>node http2的相关api和正常的node httpserver相同，可以直接使用。</li>\n</ol>\n<span style=\"font-weight: bolder;\">2. 设置我们的server push：</span>\n<div class=\"km_insert_code\">\n<pre><code><span class=\"hljs-keyword\">var</span> pushItem = response.push(<span class=\"hljs-string\">'/css/bootstrap.min.css'</span>, {\n       request: {\n            accept: <span class=\"hljs-string\">'*/\\*'</span>\n       },\n      response: {\n            <span class=\"hljs-string\">'content-type'</span>: <span class=\"hljs-string\">'text/css'</span>\n     }\n});\npushItem.end(fs.readFileSync(<span class=\"hljs-string\">'/css/bootstrap.min.css'</span>,<span class=\"hljs-string\">'binary'</span>));</code></pre>\n</div>\n我们设置了bootstrap.min.css来通过server push到我们的浏览器,我们可以在浏览器中查看：\n\n<a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2016/11/h22.png\"><img class=\"alignnone size-full wp-image-658\" src=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2016/11/h22.png\" alt=\"h22\" width=\"1716\" height=\"356\" /></a>\n\n可以看到，启动server push的资源timelime非常快，大大加速了css的获取时间。\n\n<strong>这里需要注意下面几点：</strong>\n<ol>\n \t<li>我们调用response.push(),就是相当于server发起了PUSH_PROMISE frame来告知浏览器bootstrap.min.css将会由server push来获取。</li>\n \t<li>response.push()返回的对象时一个正常的ServerResponse,end(),writeHeader()等方法都可以正常调用。</li>\n \t<li>这里一旦针对某个资源调用response.push()即发起PUSH_PROMISE frame后，要做好容错机制，因为浏览器在下次请求这个资源时会且只会等待这个server push回来的资源，这里要做好超时和容错即下面的代码：</li>\n \t<li>\n<div class=\"km_insert_code\">\n<pre><code><span class=\"hljs-keyword\">try</span> {\n    pushItem.end(fs.readFileSync(<span class=\"hljs-string\">'my/css/bootstrap.min.css'</span>,<span class=\"hljs-string\">'binary'</span>));\n    } <span class=\"hljs-keyword\">catch</span>(e) {\n       response.writeHead(<span class=\"hljs-number\">404</span>, {\n           <span class=\"hljs-string\">'Content-Type'</span>: <span class=\"hljs-string\">'text/plain'</span>\n       });\n       response.end(<span class=\"hljs-string\">'request error'</span>);\n}\n\npushItem.stream.on(<span class=\"hljs-string\">'error'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err</span>)</span>{\n    response.end(err.message);\n});\n\npushItem.stream.on(<span class=\"hljs-string\">'finish'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err</span>)</span>{\n   <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'finish'</span>);\n});</code></pre>\n</div>\n上面的代码你可能会发现许多和正常nodejs的httpserver不一样的东西，那就是stream，其实整个http2都是以stream为单位，这里的stream其实可以理解成一个请求，更多的api可以参考：<a href=\"https://github.com/molnarg/node-http2/wiki/Public-API\" target=\"_blank\" rel=\"noopener noreferrer\">node-http2</a>。</li>\n \t<li>最后给大家推荐一个老外写的专门服务http2的node server有兴趣的可以尝试一下。<a href=\"https://gitlab.com/sebdeckers/http2server\" target=\"_blank\" rel=\"noopener noreferrer\">https://gitlab.com/sebdeckers/http2server</a></li>\n</ol>\n<h2></h2>\n<h2>5，Server Push相关问题。</h2>\n<ol>\n \t<li>我们知道现在我们web的资源一般都是放在CDN上的，那么CDN的优势和server push的优势有何区别呢，到底是哪个比较快呢？这个问题笔者也一直在研究，本文的相关demo都只能算做一个演示，具体的线上实践还在进行中。</li>\n \t<li>由于HTTP2的一些新特性例如多路复用，server push等等都是基于同一个域名的，所以这可能会对我们之前对于HTTP1的一些优化措施例如(资源拆分域名，合并等等)不一定适用。</li>\n \t<li>server push不仅可以用作拉取静态资源，我们的cgi请求即ajax请求同样可以使用server push来发送数据。</li>\n \t<li>最完美的结果是CDN域名支持HTTP2,web server域名也同时支持HTTP2。</li>\n</ol>\n&nbsp;\n\n参考资料：\n<ol>\n \t<li>HTTP2官方标准：<a href=\"https://tools.ietf.org/html/rfc7540\" target=\"_blank\" rel=\"noopener noreferrer\">https://tools.ietf.org/html/rfc7540</a></li>\n \t<li>维基百科：<a href=\"https://en.wikipedia.org/wiki/HTTP/2_Server_Push\" target=\"_blank\" rel=\"noopener noreferrer\">https://en.wikipedia.org/wiki/HTTP/2_Server_Push</a></li>\n</ol>","slug":"HTTP2-Server-Push-研究","published":1,"updated":"2019-04-02T16:50:00.000Z","comments":1,"layout":"post","link":"","_id":"ckx434pzt000l2wvjok0mto2h","content":"<p></p><h2><span id=\"1http2的新特性\">1，HTTP2的新特性。</span></h2><br>关于HTTP2的新特性，读着可以参看我之前的文章，这里就不在多说了，本篇文章主要讲一下server push这个特性。<p></p>\n<p><a href=\"http://km.oa.com/group/19674/articles/show/276552\" target=\"_blank\" rel=\"noopener noreferrer\">HTTPS与HTTP2的原理，搭建，性能测试对比</a></p>\n<p><a href=\"http://km.oa.com/articles/view/290595\" target=\"_blank\" rel=\"noopener noreferrer\">HTTP,HTTP2.0,SPDY,HTTPS你应该知道的一些事</a><br><a id=\"more\"></a></p>\n<p></p><h2><span id=\"2server-push是什么\">2，Server Push是什么。</span></h2><br>简单来讲就是当用户的浏览器和服务器在建立链接后，服务器主动将一些资源推送给浏览器并缓存起来，这样当浏览器接下来请求这些资源时就直接从缓存中读取，不会在从服务器上拉了，提升了速率。举一个例子就是：<p></p>\n<p>假如一个页面有3个资源文件<strong>index.html</strong>,<strong>index.css</strong>,<strong>index.js</strong>,当浏览器请求index.html的时候，服务器不仅返回index.html的内容，同时将index.css和index.js的内容push给浏览器，当浏览器下次请求这2两个文件时就可以直接从缓存中读取了。</p>\n<p></p><h2><span id></span></h2><p></p>\n<p></p><h2><span id=\"3server-push原理是什么\">3，Server Push原理是什么。</span></h2><br>要想了解server push原理，首先要理解一些概念。我们知道HTTP2传输的格式并不像HTTP1使用文本来传输，而是启用了二进制帧(Frames)格式来传输，和server push相关的帧主要分成这几种类型：<p></p>\n<ol><br>     <li>HEADERS frame(请求返回头帧):这种帧主要携带的http请求头信息，和HTTP1的header类似。</li><br>     <li>DATA frames(数据帧) :这种帧存放真正的数据content，用来传输。</li><br>     <li>PUSH_PROMISE frame(推送帧):这种帧是由server端发送给client的帧，用来表示server push的帧，这种帧是实现server push的主要帧类型。</li><br>     <li>RST_STREAM(取消推送帧):这种帧表示请求关闭帧，简单讲就是当client不想接受某些资源或者接受timeout时会向发送方发送此帧，和PUSH_PROMISE frame一起使用时表示拒绝或者关闭server push。</li><br></ol><br><span style=\"font-weight: bolder;\">Note:</span>HTTP2.0相关的帧其实包括<a href=\"https://tools.ietf.org/html/rfc7540#section-11.2\" target=\"_blank\" rel=\"noopener noreferrer\">10种帧</a>，正是因为底层数据格式的改变，才为HTTP2.0带来许多的特性，帧的引入不仅有利于压缩数据，也有利于数据的安全性和可靠传输性。<br><br><strong>了解了相关的帧类型，下面就是具体server push的实现过程了：</strong><br><ol><br>     <li>由多路复用我们可以知道HTTP2中对于同一个域名的请求会使用一条tcp链接而用不同的stream ID来区分各自的请求。</li><br>     <li>当client使用stream 1请求index.html时，server正常处理index.html的请求，并可以得知index.html页面还将要会请求index.css和index.js。</li><br>     <li>server使用stream 1发送PUSH_PROMISE frame给client告诉client我这边可以使用stream 2来推送index.js和stream 3来推送index.css资源。</li><br>     <li>server使用stream 1正常的发送HEADERS frame和DATA frames将index.html的内容返回给client。</li><br>     <li>client接收到PUSH_PROMISE frame得知stream 2和stream 3来接收推送资源。</li><br>     <li>server拿到index.css和index.js便会发送HEADERS frame和DATA frames将资源发送给client。</li><br>     <li>client拿到push的资源后会缓存起来当请求这个资源时会从直接从从缓存中读取。</li><br></ol><br>下图表示了整个流程：<br><br><a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2016/11/屏幕快照-2016-11-27-19.07.58.png\"><img class=\"alignnone size-full wp-image-656\" src=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2016/11/屏幕快照-2016-11-27-19.07.58.png\" alt=\"%e5%b1%8f%e5%b9%95%e5%bf%ab%e7%85%a7-2016-11-27-19-07-58\" width=\"2024\" height=\"1448\"></a><br><h2><span id=\"4server-push怎么用\">4，Server Push怎么用。</span></h2><br>既然server push这么神奇，那么我们如何使用呢？怎么设置服务器push哪些文件呢？<br><br>首先并不是所有的服务器都支持server push，nginx目前还不支持这个特性，可以在nginx的官方博客上得到证实<a href=\"https://www.nginx.com/blog/http2-r7/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.nginx.com/blog/http2-r7/</a>，但是Apache和nodejs都已经支持了server push这一个特性，需要说明一点的是server push这个特性是基于浏览器和服务器的，所以浏览器并没有提供相应的js api来让用户直接操作和控制push的内容，所以只能是通过header信息和server的配置来实现具体的push内容，本文主要以nodejs来说明具体如何使用server push这一特性。<br><br><strong>准备工作</strong>：下载<a href=\"https://github.com/molnarg/node-http2\" target=\"_blank\" rel=\"noopener noreferrer\">nodejs http2</a>支持，本地启动nodejs服务。<br><br><strong>1. 首先我们使用nodejs搭建基本的server：</strong><br><div class=\"km_insert_code\"><br><pre><code><span class=\"hljs-keyword\">var</span> http2 = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">‘http2’</span>);<br><br><span class=\"hljs-keyword\">var</span> url=<span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">‘url’</span>);<br><span class=\"hljs-keyword\">var</span> fs=<span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">‘fs’</span>);<br><span class=\"hljs-keyword\">var</span> mine=<span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">‘./mine’</span>).types;<br><span class=\"hljs-keyword\">var</span> path=<span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">‘path’</span>);<br><br><span class=\"hljs-keyword\">var</span> server = http2.createServer({<br>  key: fs.readFileSync(<span class=\"hljs-string\">‘./zs/localhost.key’</span>),<br>  cert: fs.readFileSync(<span class=\"hljs-string\">‘./zs/localhost.crt’</span>)<br>}, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">request, response</span>) </span>{<br>    <span class=\"hljs-keyword\">var</span> pathname = url.parse(request.url).pathname;<br>    <span class=\"hljs-keyword\">var</span> realPath = path.join(<span class=\"hljs-string\">“my”</span>, pathname);    <span class=\"hljs-comment\">//这里设置自己的文件名称;</span><br><br>    <span class=\"hljs-keyword\">var</span> pushArray = [];<br>    <span class=\"hljs-keyword\">var</span> ext = path.extname(realPath);<br>    ext = ext ? ext.slice(<span class=\"hljs-number\">1</span>) : <span class=\"hljs-string\">‘unknown’</span>;<br>    <span class=\"hljs-keyword\">var</span> contentType = mine[ext] || <span class=\"hljs-string\">“text/plain”</span>;<br><br>    <span class=\"hljs-keyword\">if</span> (fs.existsSync(realPath)) {<br><br>        response.writeHead(<span class=\"hljs-number\">200</span>, {<br>            <span class=\"hljs-string\">‘Content-Type’</span>: contentType<br>        });<br><br>        response.write(fs.readFileSync(realPath,<span class=\"hljs-string\">‘binary’</span>));<br><br>    } <span class=\"hljs-keyword\">else</span> {<br>      response.writeHead(<span class=\"hljs-number\">404</span>, {<br>          <span class=\"hljs-string\">‘Content-Type’</span>: <span class=\"hljs-string\">‘text/plain’</span><br>      });<br><br>      response.write(<span class=\"hljs-string\">“This request URL “</span> + pathname + <span class=\"hljs-string\">“ was not found on this server.”</span>);<br>      response.end();<br>    }<br><br>});<br><br>server.listen(<span class=\"hljs-number\">443</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>() </span>{<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">‘listen on 443’</span>);<br>});</code></pre><br></div><br>这几行代码就是简单搭建一个nodejs http2服务，打开chrome，我们可以看到所有请求都走了http2，同时也可以验证多路复用的特性。<br><br><a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2016/11/h21.png\"><img class=\"alignnone size-full wp-image-657\" src=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2016/11/h21.png\" alt=\"h21\" width=\"1327\" height=\"257\"></a><br><br><strong>这里需要注意几点：</strong><br><ol><br>     <li>创建http2的nodejs服务必须时基于https的，因为现在主流的浏览器都要支持SSL/TLS的http2，证书和私钥可以自己通过<a href=\"https://www.openssl.org/\" target=\"_blank\" rel=\"noopener noreferrer\">OPENSSL</a>生成。</li><br>     <li>node http2的相关api和正常的node httpserver相同，可以直接使用。</li><br></ol><br><span style=\"font-weight: bolder;\">2. 设置我们的server push：</span><br><div class=\"km_insert_code\"><br><pre><code><span class=\"hljs-keyword\">var</span> pushItem = response.push(<span class=\"hljs-string\">‘/css/bootstrap.min.css’</span>, {<br>       request: {<br>            accept: <span class=\"hljs-string\">‘<em>/\\</em>‘</span><br>       },<br>      response: {<br>            <span class=\"hljs-string\">‘content-type’</span>: <span class=\"hljs-string\">‘text/css’</span><br>     }<br>});<br>pushItem.end(fs.readFileSync(<span class=\"hljs-string\">‘/css/bootstrap.min.css’</span>,<span class=\"hljs-string\">‘binary’</span>));</code></pre><br></div><br>我们设置了bootstrap.min.css来通过server push到我们的浏览器,我们可以在浏览器中查看：<br><br><a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2016/11/h22.png\"><img class=\"alignnone size-full wp-image-658\" src=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2016/11/h22.png\" alt=\"h22\" width=\"1716\" height=\"356\"></a><br><br>可以看到，启动server push的资源timelime非常快，大大加速了css的获取时间。<br><br><strong>这里需要注意下面几点：</strong><br><ol><br>     <li>我们调用response.push(),就是相当于server发起了PUSH_PROMISE frame来告知浏览器bootstrap.min.css将会由server push来获取。</li><br>     <li>response.push()返回的对象时一个正常的ServerResponse,end(),writeHeader()等方法都可以正常调用。</li><br>     <li>这里一旦针对某个资源调用response.push()即发起PUSH_PROMISE frame后，要做好容错机制，因为浏览器在下次请求这个资源时会且只会等待这个server push回来的资源，这里要做好超时和容错即下面的代码：</li><br>     <li><br><div class=\"km_insert_code\"><br><pre><code><span class=\"hljs-keyword\">try</span> {<br>    pushItem.end(fs.readFileSync(<span class=\"hljs-string\">‘my/css/bootstrap.min.css’</span>,<span class=\"hljs-string\">‘binary’</span>));<br>    } <span class=\"hljs-keyword\">catch</span>(e) {<br>       response.writeHead(<span class=\"hljs-number\">404</span>, {<br>           <span class=\"hljs-string\">‘Content-Type’</span>: <span class=\"hljs-string\">‘text/plain’</span><br>       });<br>       response.end(<span class=\"hljs-string\">‘request error’</span>);<br>}<br><br>pushItem.stream.on(<span class=\"hljs-string\">‘error’</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err</span>)</span>{<br>    response.end(err.message);<br>});<br><br>pushItem.stream.on(<span class=\"hljs-string\">‘finish’</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err</span>)</span>{<br>   <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">‘finish’</span>);<br>});</code></pre><br></div><br>上面的代码你可能会发现许多和正常nodejs的httpserver不一样的东西，那就是stream，其实整个http2都是以stream为单位，这里的stream其实可以理解成一个请求，更多的api可以参考：<a href=\"https://github.com/molnarg/node-http2/wiki/Public-API\" target=\"_blank\" rel=\"noopener noreferrer\">node-http2</a>。</li><br>     <li>最后给大家推荐一个老外写的专门服务http2的node server有兴趣的可以尝试一下。<a href=\"https://gitlab.com/sebdeckers/http2server\" target=\"_blank\" rel=\"noopener noreferrer\">https://gitlab.com/sebdeckers/http2server</a></li><br></ol><br><h2><span id></span></h2><br><h2><span id=\"5server-push相关问题\">5，Server Push相关问题。</span></h2><br><ol><br>     <li>我们知道现在我们web的资源一般都是放在CDN上的，那么CDN的优势和server push的优势有何区别呢，到底是哪个比较快呢？这个问题笔者也一直在研究，本文的相关demo都只能算做一个演示，具体的线上实践还在进行中。</li><br>     <li>由于HTTP2的一些新特性例如多路复用，server push等等都是基于同一个域名的，所以这可能会对我们之前对于HTTP1的一些优化措施例如(资源拆分域名，合并等等)不一定适用。</li><br>     <li>server push不仅可以用作拉取静态资源，我们的cgi请求即ajax请求同样可以使用server push来发送数据。</li><br>     <li>最完美的结果是CDN域名支持HTTP2,web server域名也同时支持HTTP2。</li><br></ol><br>&nbsp;<br><br>参考资料：<br><ol><br>     <li>HTTP2官方标准：<a href=\"https://tools.ietf.org/html/rfc7540\" target=\"_blank\" rel=\"noopener noreferrer\">https://tools.ietf.org/html/rfc7540</a></li><br>     <li>维基百科：<a href=\"https://en.wikipedia.org/wiki/HTTP/2_Server_Push\" target=\"_blank\" rel=\"noopener noreferrer\">https://en.wikipedia.org/wiki/HTTP/2_Server_Push</a></li><br></ol>","site":{"data":{}},"excerpt":"<p></p><h2>1，HTTP2的新特性。</h2><br>关于HTTP2的新特性，读着可以参看我之前的文章，这里就不在多说了，本篇文章主要讲一下server push这个特性。<p></p>\n<p><a href=\"http://km.oa.com/group/19674/articles/show/276552\" target=\"_blank\" rel=\"noopener noreferrer\">HTTPS与HTTP2的原理，搭建，性能测试对比</a></p>\n<p><a href=\"http://km.oa.com/articles/view/290595\" target=\"_blank\" rel=\"noopener noreferrer\">HTTP,HTTP2.0,SPDY,HTTPS你应该知道的一些事</a><br>","more":"</p>\n<p></p><h2>2，Server Push是什么。</h2><br>简单来讲就是当用户的浏览器和服务器在建立链接后，服务器主动将一些资源推送给浏览器并缓存起来，这样当浏览器接下来请求这些资源时就直接从缓存中读取，不会在从服务器上拉了，提升了速率。举一个例子就是：<p></p>\n<p>假如一个页面有3个资源文件<strong>index.html</strong>,<strong>index.css</strong>,<strong>index.js</strong>,当浏览器请求index.html的时候，服务器不仅返回index.html的内容，同时将index.css和index.js的内容push给浏览器，当浏览器下次请求这2两个文件时就可以直接从缓存中读取了。</p>\n<p></p><h2></h2><p></p>\n<p></p><h2>3，Server Push原理是什么。</h2><br>要想了解server push原理，首先要理解一些概念。我们知道HTTP2传输的格式并不像HTTP1使用文本来传输，而是启用了二进制帧(Frames)格式来传输，和server push相关的帧主要分成这几种类型：<p></p>\n<ol><br>     <li>HEADERS frame(请求返回头帧):这种帧主要携带的http请求头信息，和HTTP1的header类似。</li><br>     <li>DATA frames(数据帧) :这种帧存放真正的数据content，用来传输。</li><br>     <li>PUSH_PROMISE frame(推送帧):这种帧是由server端发送给client的帧，用来表示server push的帧，这种帧是实现server push的主要帧类型。</li><br>     <li>RST_STREAM(取消推送帧):这种帧表示请求关闭帧，简单讲就是当client不想接受某些资源或者接受timeout时会向发送方发送此帧，和PUSH_PROMISE frame一起使用时表示拒绝或者关闭server push。</li><br></ol><br><span style=\"font-weight: bolder;\">Note:</span>HTTP2.0相关的帧其实包括<a href=\"https://tools.ietf.org/html/rfc7540#section-11.2\" target=\"_blank\" rel=\"noopener noreferrer\">10种帧</a>，正是因为底层数据格式的改变，才为HTTP2.0带来许多的特性，帧的引入不仅有利于压缩数据，也有利于数据的安全性和可靠传输性。<br><br><strong>了解了相关的帧类型，下面就是具体server push的实现过程了：</strong><br><ol><br>     <li>由多路复用我们可以知道HTTP2中对于同一个域名的请求会使用一条tcp链接而用不同的stream ID来区分各自的请求。</li><br>     <li>当client使用stream 1请求index.html时，server正常处理index.html的请求，并可以得知index.html页面还将要会请求index.css和index.js。</li><br>     <li>server使用stream 1发送PUSH_PROMISE frame给client告诉client我这边可以使用stream 2来推送index.js和stream 3来推送index.css资源。</li><br>     <li>server使用stream 1正常的发送HEADERS frame和DATA frames将index.html的内容返回给client。</li><br>     <li>client接收到PUSH_PROMISE frame得知stream 2和stream 3来接收推送资源。</li><br>     <li>server拿到index.css和index.js便会发送HEADERS frame和DATA frames将资源发送给client。</li><br>     <li>client拿到push的资源后会缓存起来当请求这个资源时会从直接从从缓存中读取。</li><br></ol><br>下图表示了整个流程：<br><br><a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2016/11/屏幕快照-2016-11-27-19.07.58.png\"><img class=\"alignnone size-full wp-image-656\" src=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2016/11/屏幕快照-2016-11-27-19.07.58.png\" alt=\"%e5%b1%8f%e5%b9%95%e5%bf%ab%e7%85%a7-2016-11-27-19-07-58\" width=\"2024\" height=\"1448\"></a><br><h2>4，Server Push怎么用。</h2><br>既然server push这么神奇，那么我们如何使用呢？怎么设置服务器push哪些文件呢？<br><br>首先并不是所有的服务器都支持server push，nginx目前还不支持这个特性，可以在nginx的官方博客上得到证实<a href=\"https://www.nginx.com/blog/http2-r7/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.nginx.com/blog/http2-r7/</a>，但是Apache和nodejs都已经支持了server push这一个特性，需要说明一点的是server push这个特性是基于浏览器和服务器的，所以浏览器并没有提供相应的js api来让用户直接操作和控制push的内容，所以只能是通过header信息和server的配置来实现具体的push内容，本文主要以nodejs来说明具体如何使用server push这一特性。<br><br><strong>准备工作</strong>：下载<a href=\"https://github.com/molnarg/node-http2\" target=\"_blank\" rel=\"noopener noreferrer\">nodejs http2</a>支持，本地启动nodejs服务。<br><br><strong>1. 首先我们使用nodejs搭建基本的server：</strong><br><div class=\"km_insert_code\"><br><pre><code><span class=\"hljs-keyword\">var</span> http2 = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">‘http2’</span>);<br><br><span class=\"hljs-keyword\">var</span> url=<span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">‘url’</span>);<br><span class=\"hljs-keyword\">var</span> fs=<span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">‘fs’</span>);<br><span class=\"hljs-keyword\">var</span> mine=<span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">‘./mine’</span>).types;<br><span class=\"hljs-keyword\">var</span> path=<span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">‘path’</span>);<br><br><span class=\"hljs-keyword\">var</span> server = http2.createServer({<br>  key: fs.readFileSync(<span class=\"hljs-string\">‘./zs/localhost.key’</span>),<br>  cert: fs.readFileSync(<span class=\"hljs-string\">‘./zs/localhost.crt’</span>)<br>}, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">request, response</span>) </span>{<br>    <span class=\"hljs-keyword\">var</span> pathname = url.parse(request.url).pathname;<br>    <span class=\"hljs-keyword\">var</span> realPath = path.join(<span class=\"hljs-string\">“my”</span>, pathname);    <span class=\"hljs-comment\">//这里设置自己的文件名称;</span><br><br>    <span class=\"hljs-keyword\">var</span> pushArray = [];<br>    <span class=\"hljs-keyword\">var</span> ext = path.extname(realPath);<br>    ext = ext ? ext.slice(<span class=\"hljs-number\">1</span>) : <span class=\"hljs-string\">‘unknown’</span>;<br>    <span class=\"hljs-keyword\">var</span> contentType = mine[ext] || <span class=\"hljs-string\">“text/plain”</span>;<br><br>    <span class=\"hljs-keyword\">if</span> (fs.existsSync(realPath)) {<br><br>        response.writeHead(<span class=\"hljs-number\">200</span>, {<br>            <span class=\"hljs-string\">‘Content-Type’</span>: contentType<br>        });<br><br>        response.write(fs.readFileSync(realPath,<span class=\"hljs-string\">‘binary’</span>));<br><br>    } <span class=\"hljs-keyword\">else</span> {<br>      response.writeHead(<span class=\"hljs-number\">404</span>, {<br>          <span class=\"hljs-string\">‘Content-Type’</span>: <span class=\"hljs-string\">‘text/plain’</span><br>      });<br><br>      response.write(<span class=\"hljs-string\">“This request URL “</span> + pathname + <span class=\"hljs-string\">“ was not found on this server.”</span>);<br>      response.end();<br>    }<br><br>});<br><br>server.listen(<span class=\"hljs-number\">443</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>() </span>{<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">‘listen on 443’</span>);<br>});</code></pre><br></div><br>这几行代码就是简单搭建一个nodejs http2服务，打开chrome，我们可以看到所有请求都走了http2，同时也可以验证多路复用的特性。<br><br><a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2016/11/h21.png\"><img class=\"alignnone size-full wp-image-657\" src=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2016/11/h21.png\" alt=\"h21\" width=\"1327\" height=\"257\"></a><br><br><strong>这里需要注意几点：</strong><br><ol><br>     <li>创建http2的nodejs服务必须时基于https的，因为现在主流的浏览器都要支持SSL/TLS的http2，证书和私钥可以自己通过<a href=\"https://www.openssl.org/\" target=\"_blank\" rel=\"noopener noreferrer\">OPENSSL</a>生成。</li><br>     <li>node http2的相关api和正常的node httpserver相同，可以直接使用。</li><br></ol><br><span style=\"font-weight: bolder;\">2. 设置我们的server push：</span><br><div class=\"km_insert_code\"><br><pre><code><span class=\"hljs-keyword\">var</span> pushItem = response.push(<span class=\"hljs-string\">‘/css/bootstrap.min.css’</span>, {<br>       request: {<br>            accept: <span class=\"hljs-string\">‘<em>/\\</em>‘</span><br>       },<br>      response: {<br>            <span class=\"hljs-string\">‘content-type’</span>: <span class=\"hljs-string\">‘text/css’</span><br>     }<br>});<br>pushItem.end(fs.readFileSync(<span class=\"hljs-string\">‘/css/bootstrap.min.css’</span>,<span class=\"hljs-string\">‘binary’</span>));</code></pre><br></div><br>我们设置了bootstrap.min.css来通过server push到我们的浏览器,我们可以在浏览器中查看：<br><br><a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2016/11/h22.png\"><img class=\"alignnone size-full wp-image-658\" src=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2016/11/h22.png\" alt=\"h22\" width=\"1716\" height=\"356\"></a><br><br>可以看到，启动server push的资源timelime非常快，大大加速了css的获取时间。<br><br><strong>这里需要注意下面几点：</strong><br><ol><br>     <li>我们调用response.push(),就是相当于server发起了PUSH_PROMISE frame来告知浏览器bootstrap.min.css将会由server push来获取。</li><br>     <li>response.push()返回的对象时一个正常的ServerResponse,end(),writeHeader()等方法都可以正常调用。</li><br>     <li>这里一旦针对某个资源调用response.push()即发起PUSH_PROMISE frame后，要做好容错机制，因为浏览器在下次请求这个资源时会且只会等待这个server push回来的资源，这里要做好超时和容错即下面的代码：</li><br>     <li><br><div class=\"km_insert_code\"><br><pre><code><span class=\"hljs-keyword\">try</span> {<br>    pushItem.end(fs.readFileSync(<span class=\"hljs-string\">‘my/css/bootstrap.min.css’</span>,<span class=\"hljs-string\">‘binary’</span>));<br>    } <span class=\"hljs-keyword\">catch</span>(e) {<br>       response.writeHead(<span class=\"hljs-number\">404</span>, {<br>           <span class=\"hljs-string\">‘Content-Type’</span>: <span class=\"hljs-string\">‘text/plain’</span><br>       });<br>       response.end(<span class=\"hljs-string\">‘request error’</span>);<br>}<br><br>pushItem.stream.on(<span class=\"hljs-string\">‘error’</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err</span>)</span>{<br>    response.end(err.message);<br>});<br><br>pushItem.stream.on(<span class=\"hljs-string\">‘finish’</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err</span>)</span>{<br>   <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">‘finish’</span>);<br>});</code></pre><br></div><br>上面的代码你可能会发现许多和正常nodejs的httpserver不一样的东西，那就是stream，其实整个http2都是以stream为单位，这里的stream其实可以理解成一个请求，更多的api可以参考：<a href=\"https://github.com/molnarg/node-http2/wiki/Public-API\" target=\"_blank\" rel=\"noopener noreferrer\">node-http2</a>。</li><br>     <li>最后给大家推荐一个老外写的专门服务http2的node server有兴趣的可以尝试一下。<a href=\"https://gitlab.com/sebdeckers/http2server\" target=\"_blank\" rel=\"noopener noreferrer\">https://gitlab.com/sebdeckers/http2server</a></li><br></ol><br><h2></h2><br><h2>5，Server Push相关问题。</h2><br><ol><br>     <li>我们知道现在我们web的资源一般都是放在CDN上的，那么CDN的优势和server push的优势有何区别呢，到底是哪个比较快呢？这个问题笔者也一直在研究，本文的相关demo都只能算做一个演示，具体的线上实践还在进行中。</li><br>     <li>由于HTTP2的一些新特性例如多路复用，server push等等都是基于同一个域名的，所以这可能会对我们之前对于HTTP1的一些优化措施例如(资源拆分域名，合并等等)不一定适用。</li><br>     <li>server push不仅可以用作拉取静态资源，我们的cgi请求即ajax请求同样可以使用server push来发送数据。</li><br>     <li>最完美的结果是CDN域名支持HTTP2,web server域名也同时支持HTTP2。</li><br></ol><br>&nbsp;<br><br>参考资料：<br><ol><br>     <li>HTTP2官方标准：<a href=\"https://tools.ietf.org/html/rfc7540\" target=\"_blank\" rel=\"noopener noreferrer\">https://tools.ietf.org/html/rfc7540</a></li><br>     <li>维基百科：<a href=\"https://en.wikipedia.org/wiki/HTTP/2_Server_Push\" target=\"_blank\" rel=\"noopener noreferrer\">https://en.wikipedia.org/wiki/HTTP/2_Server_Push</a></li><br></ol>"},{"title":"HTTP2.0关于多路复用的研究","date":"2017-04-25T08:52:32.000Z","_content":"关于HTTP2中其他特性的研究可以参考我之前写的文章\n\n<a href=\"http://km.oa.com/group/19674/articles/show/286253?kmref=kb_categories\" target=\"_blank\" rel=\"noopener noreferrer\">关于Server Push的研究</a>\n<h3><span style=\"font-weight: bolder;\">问题一：什么是keep live？</span></h3>\nHTTP持久连接（HTTP persistent connection，也称作HTTP keep-alive或HTTP connection reuse）是使用同一个TCP连接来发送和接收多个HTTP请求/应答，而不是为每一个新的请求/应答打开新的连接的方法。\n<!--more-->\n我们知道HTTP协议采用“请求-应答”模式，当使用普通模式，即非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接（HTTP协议为无连接的协议）；当使用Keep-Alive模式（又称持久连接）时，Keep-Alive功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。\n\n&nbsp;\n<h3><span style=\"font-weight: bolder;\">问题二：keep alive和传统的区别？</span></h3>\n<a href=\"https://qiniu.nihaoshijie.com.cn/blog/kp1.png\"><img class=\"alignnone size-full wp-image-700\" src=\"https://qiniu.nihaoshijie.com.cn/blog/kp1.png\" alt=\"\" width=\"495\" height=\"289\" /></a>\n\n一图胜千言，由图可知引入的keep alive的链接不必在每次请求都开启一个新的链接。\n\n&nbsp;\n<h3><span style=\"font-weight: bolder;\">问题三：keep alive如何配置？</span></h3>\n<span style=\"font-weight: bolder;\">Apache服务器：</span>\n\nhttpd.conf：\n```php\nKeepAlive On             // 是否打开keep alive\nMaxKeepAliveRequests 300 // 每个连接最大可复用的请求数\nKeepAliveTimeout 3       // 每个请求可复用的time时间s\n```\n<span style=\"font-weight: bolder;\"> Nginx服务器：</span>\n\nnginx.conf：\n```php\nkeepalive_timeout //服务器接收在10s以内的所有connection复用超过10则关闭建立一个新的connection 0代表关闭keepalive\n```\nNode.js\n\n<a href=\"https://nodejs.org/api/http.html#http_class_http_agent\" target=\"_blank\" rel=\"noopener noreferrer\">https://nodejs.org/api/http.html#http_class_http_agent</a>\n\n&nbsp;\n<h3><span style=\"font-weight: bolder;\">问题4：多路复用是什么？</span><a href=\"https://qiniu.nihaoshijie.com.cn/blog/kp3.png\"><img class=\"alignnone size-full wp-image-703\" src=\"https://qiniu.nihaoshijie.com.cn/blog/kp3.png\" alt=\"\" width=\"1472\" height=\"234\" /></a></h3>\n1）HTTP2的请求的TCP的connection一旦建立，后续请求以stream的方式发送。\n\n2）每个stream的基本组成单位是frame（二进制帧），每种frame又分为很多种类型例如HEADERS Frame（头部帧），DATA Frame（内容帧）等等。\n\n3）请求头HEADERS Frame组成了resquest，返回头HEADERS Frame和DATA Frame组成了response，request和response组成了一个stream。\n\n&nbsp;\n<h3><span style=\"font-weight: bolder;\">问题5：多路复用和keep alive区别？</span></h3>\n<a href=\"https://qiniu.nihaoshijie.com.cn/kp2.png\"><img class=\"alignnone size-full wp-image-701\" src=\"https://qiniu.nihaoshijie.com.cn/kp2.png\" alt=\"\" width=\"779\" height=\"765\" /></a>\n\n1）线头阻塞（Head-of-Line Blocking），HTTP1.X虽然可以采用keep alive来解决复用TCP的问题，但是还是无法解决请求阻塞问题。\n\n2）所谓请求阻塞意思就是一条TCP的connection在同一时间只能允许一个请求经过，这样假如后续请求想要复用这个链接就必须等到前一个完成才行，正如上图左边表示的。\n\n3）之所以有这个问题就是因为HTTP1.x需要每条请求都是可是识别，按顺序发送，否则server就无法判断该相应哪个具体的请求。\n\n4）HTTP2采用多路复用是指，在同一个域名下，开启一个TCP的connection，每个请求以stream的方式传输，每个stream有唯一标识，connection一旦建立，后续的请求都可以复用这个connection并且可以同时发送，server端可以根据stream的唯一标识来相应对应的请求。\n\n&nbsp;\n<h3><span style=\"font-weight: bolder;\">问题6：多路复用就不会关闭了么？</span></h3>\n多路复用使用的同一个TCP的connection会关闭么，什么时候关闭，这是个问题？从标准上看到一段文字：\n<div class=\"newpage\" style=\"padding:10px;font-size: 13.3333px; margin-top: 0px; margin-bottom: 0px; break-before: page; color: #000000;\">HTTP/2 connections are persistent.  For best performance, it is\n   expected that clients will not close connections until it is\n   determined that no further communication with a server is necessary\n   (for example, when a user navigates away from a particular web page)\n   or until the server closes the connection.</div>\n意思就是说关闭的时机有2个：\n1）用户离开这个页面。\n2）server主动关闭connection。\n但是标准总归标准，不同的服务器实现时有了自己的约定，就行keep alive一样，每种服务器都有对自己多路复用的这个connection有相关的配置：\n\n<strong>Apache：</strong>\n```php\nSyntax:\thttp2_idle_timeout time;\nDefault:\t\nhttp2_idle_timeout 3m;\nContext:\thttp, server\n\nSyntax:\thttp2_recv_timeout time;\nDefault:\t\nhttp2_recv_timeout 30s;\nContext:\thttp, server\n```\n<a href=\"http://nginx.org/en/docs/http/ngx_http_v2_module.html#http2_idle_timeout\" target=\"_blank\" rel=\"noopener noreferrer\">http://nginx.org/en/docs/http/ngx_http_v2_module.html#http2_idle_timeout</a>\n\n参考资料：\n<ol style=\"padding-top: 0px; padding-right: 0px; padding-bottom: 0px;\">\n \t<li style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 0px;\">HTTP2官方标准：<a style=\"color: #336699;\" href=\"https://tools.ietf.org/html/rfc7540\" target=\"_blank\" rel=\"noopener noreferrer\">https://tools.ietf.org/html/rfc7540</a></li>\n \t<li style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 0px;\"><a href=\"https://cascadingmedia.com/insites/2015/03/http-2.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://cascadingmedia.com/insites/2015/03/http-2.html</a></li>\n</ol>","source":"_posts/HTTP2.0关于多路复用的研究.md","raw":"---\ntitle: HTTP2.0关于多路复用的研究\ndate: 2017-04-25 16:52:32\ntags:\n- http2\ncategories:\n- 698\n\n---\n关于HTTP2中其他特性的研究可以参考我之前写的文章\n\n<a href=\"http://km.oa.com/group/19674/articles/show/286253?kmref=kb_categories\" target=\"_blank\" rel=\"noopener noreferrer\">关于Server Push的研究</a>\n<h3><span style=\"font-weight: bolder;\">问题一：什么是keep live？</span></h3>\nHTTP持久连接（HTTP persistent connection，也称作HTTP keep-alive或HTTP connection reuse）是使用同一个TCP连接来发送和接收多个HTTP请求/应答，而不是为每一个新的请求/应答打开新的连接的方法。\n<!--more-->\n我们知道HTTP协议采用“请求-应答”模式，当使用普通模式，即非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接（HTTP协议为无连接的协议）；当使用Keep-Alive模式（又称持久连接）时，Keep-Alive功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。\n\n&nbsp;\n<h3><span style=\"font-weight: bolder;\">问题二：keep alive和传统的区别？</span></h3>\n<a href=\"https://qiniu.nihaoshijie.com.cn/blog/kp1.png\"><img class=\"alignnone size-full wp-image-700\" src=\"https://qiniu.nihaoshijie.com.cn/blog/kp1.png\" alt=\"\" width=\"495\" height=\"289\" /></a>\n\n一图胜千言，由图可知引入的keep alive的链接不必在每次请求都开启一个新的链接。\n\n&nbsp;\n<h3><span style=\"font-weight: bolder;\">问题三：keep alive如何配置？</span></h3>\n<span style=\"font-weight: bolder;\">Apache服务器：</span>\n\nhttpd.conf：\n```php\nKeepAlive On             // 是否打开keep alive\nMaxKeepAliveRequests 300 // 每个连接最大可复用的请求数\nKeepAliveTimeout 3       // 每个请求可复用的time时间s\n```\n<span style=\"font-weight: bolder;\"> Nginx服务器：</span>\n\nnginx.conf：\n```php\nkeepalive_timeout //服务器接收在10s以内的所有connection复用超过10则关闭建立一个新的connection 0代表关闭keepalive\n```\nNode.js\n\n<a href=\"https://nodejs.org/api/http.html#http_class_http_agent\" target=\"_blank\" rel=\"noopener noreferrer\">https://nodejs.org/api/http.html#http_class_http_agent</a>\n\n&nbsp;\n<h3><span style=\"font-weight: bolder;\">问题4：多路复用是什么？</span><a href=\"https://qiniu.nihaoshijie.com.cn/blog/kp3.png\"><img class=\"alignnone size-full wp-image-703\" src=\"https://qiniu.nihaoshijie.com.cn/blog/kp3.png\" alt=\"\" width=\"1472\" height=\"234\" /></a></h3>\n1）HTTP2的请求的TCP的connection一旦建立，后续请求以stream的方式发送。\n\n2）每个stream的基本组成单位是frame（二进制帧），每种frame又分为很多种类型例如HEADERS Frame（头部帧），DATA Frame（内容帧）等等。\n\n3）请求头HEADERS Frame组成了resquest，返回头HEADERS Frame和DATA Frame组成了response，request和response组成了一个stream。\n\n&nbsp;\n<h3><span style=\"font-weight: bolder;\">问题5：多路复用和keep alive区别？</span></h3>\n<a href=\"https://qiniu.nihaoshijie.com.cn/kp2.png\"><img class=\"alignnone size-full wp-image-701\" src=\"https://qiniu.nihaoshijie.com.cn/kp2.png\" alt=\"\" width=\"779\" height=\"765\" /></a>\n\n1）线头阻塞（Head-of-Line Blocking），HTTP1.X虽然可以采用keep alive来解决复用TCP的问题，但是还是无法解决请求阻塞问题。\n\n2）所谓请求阻塞意思就是一条TCP的connection在同一时间只能允许一个请求经过，这样假如后续请求想要复用这个链接就必须等到前一个完成才行，正如上图左边表示的。\n\n3）之所以有这个问题就是因为HTTP1.x需要每条请求都是可是识别，按顺序发送，否则server就无法判断该相应哪个具体的请求。\n\n4）HTTP2采用多路复用是指，在同一个域名下，开启一个TCP的connection，每个请求以stream的方式传输，每个stream有唯一标识，connection一旦建立，后续的请求都可以复用这个connection并且可以同时发送，server端可以根据stream的唯一标识来相应对应的请求。\n\n&nbsp;\n<h3><span style=\"font-weight: bolder;\">问题6：多路复用就不会关闭了么？</span></h3>\n多路复用使用的同一个TCP的connection会关闭么，什么时候关闭，这是个问题？从标准上看到一段文字：\n<div class=\"newpage\" style=\"padding:10px;font-size: 13.3333px; margin-top: 0px; margin-bottom: 0px; break-before: page; color: #000000;\">HTTP/2 connections are persistent.  For best performance, it is\n   expected that clients will not close connections until it is\n   determined that no further communication with a server is necessary\n   (for example, when a user navigates away from a particular web page)\n   or until the server closes the connection.</div>\n意思就是说关闭的时机有2个：\n1）用户离开这个页面。\n2）server主动关闭connection。\n但是标准总归标准，不同的服务器实现时有了自己的约定，就行keep alive一样，每种服务器都有对自己多路复用的这个connection有相关的配置：\n\n<strong>Apache：</strong>\n```php\nSyntax:\thttp2_idle_timeout time;\nDefault:\t\nhttp2_idle_timeout 3m;\nContext:\thttp, server\n\nSyntax:\thttp2_recv_timeout time;\nDefault:\t\nhttp2_recv_timeout 30s;\nContext:\thttp, server\n```\n<a href=\"http://nginx.org/en/docs/http/ngx_http_v2_module.html#http2_idle_timeout\" target=\"_blank\" rel=\"noopener noreferrer\">http://nginx.org/en/docs/http/ngx_http_v2_module.html#http2_idle_timeout</a>\n\n参考资料：\n<ol style=\"padding-top: 0px; padding-right: 0px; padding-bottom: 0px;\">\n \t<li style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 0px;\">HTTP2官方标准：<a style=\"color: #336699;\" href=\"https://tools.ietf.org/html/rfc7540\" target=\"_blank\" rel=\"noopener noreferrer\">https://tools.ietf.org/html/rfc7540</a></li>\n \t<li style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 0px;\"><a href=\"https://cascadingmedia.com/insites/2015/03/http-2.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://cascadingmedia.com/insites/2015/03/http-2.html</a></li>\n</ol>","slug":"HTTP2.0关于多路复用的研究","published":1,"updated":"2019-04-02T16:49:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434pzv000p2wvj4inb4d3y","content":"<p>关于HTTP2中其他特性的研究可以参考我之前写的文章</p>\n<p><a href=\"http://km.oa.com/group/19674/articles/show/286253?kmref=kb_categories\" target=\"_blank\" rel=\"noopener noreferrer\">关于Server Push的研究</a></p>\n<p></p><h3><span id=\"问题一什么是keep-live\"><span style=\"font-weight: bolder;\">问题一：什么是keep live？</span></span></h3><br>HTTP持久连接（HTTP persistent connection，也称作HTTP keep-alive或HTTP connection reuse）是使用同一个TCP连接来发送和接收多个HTTP请求/应答，而不是为每一个新的请求/应答打开新的连接的方法。<br><a id=\"more\"></a><br>我们知道HTTP协议采用“请求-应答”模式，当使用普通模式，即非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接（HTTP协议为无连接的协议）；当使用Keep-Alive模式（又称持久连接）时，Keep-Alive功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。<p></p>\n<p>&nbsp;</p>\n<p></p><h3><span id=\"问题二keep-alive和传统的区别\"><span style=\"font-weight: bolder;\">问题二：keep alive和传统的区别？</span></span></h3><br><a href=\"https://qiniu.nihaoshijie.com.cn/blog/kp1.png\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-700\" src=\"https://qiniu.nihaoshijie.com.cn/blog/kp1.png\" alt width=\"495\" height=\"289\"></a><p></p>\n<p>一图胜千言，由图可知引入的keep alive的链接不必在每次请求都开启一个新的链接。</p>\n<p>&nbsp;</p>\n<p></p><h3><span id=\"问题三keep-alive如何配置\"><span style=\"font-weight: bolder;\">问题三：keep alive如何配置？</span></span></h3><br><span style=\"font-weight: bolder;\">Apache服务器：</span><p></p>\n<p>httpd.conf：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KeepAlive On             <span class=\"comment\">// 是否打开keep alive</span></span><br><span class=\"line\">MaxKeepAliveRequests <span class=\"number\">300</span> <span class=\"comment\">// 每个连接最大可复用的请求数</span></span><br><span class=\"line\">KeepAliveTimeout <span class=\"number\">3</span>       <span class=\"comment\">// 每个请求可复用的time时间s</span></span><br></pre></td></tr></table></figure></p>\n<p><span style=\"font-weight: bolder;\"> Nginx服务器：</span></p>\n<p>nginx.conf：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keepalive_timeout <span class=\"comment\">//服务器接收在10s以内的所有connection复用超过10则关闭建立一个新的connection 0代表关闭keepalive</span></span><br></pre></td></tr></table></figure></p>\n<p>Node.js</p>\n<p><a href=\"https://nodejs.org/api/http.html#http_class_http_agent\" target=\"_blank\" rel=\"noopener noreferrer\">https://nodejs.org/api/http.html#http_class_http_agent</a></p>\n<p>&nbsp;</p>\n<p></p><h3><span id=\"问题4多路复用是什么\"><span style=\"font-weight: bolder;\">问题4：多路复用是什么？</span></span></h3><br>1）HTTP2的请求的TCP的connection一旦建立，后续请求以stream的方式发送。<p></p>\n<p>2）每个stream的基本组成单位是frame（二进制帧），每种frame又分为很多种类型例如HEADERS Frame（头部帧），DATA Frame（内容帧）等等。</p>\n<p>3）请求头HEADERS Frame组成了resquest，返回头HEADERS Frame和DATA Frame组成了response，request和response组成了一个stream。</p>\n<p>&nbsp;</p>\n<p></p><h3><span id=\"问题5多路复用和keep-alive区别\"><span style=\"font-weight: bolder;\">问题5：多路复用和keep alive区别？</span></span></h3><br><a href=\"https://qiniu.nihaoshijie.com.cn/kp2.png\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-701\" src=\"https://qiniu.nihaoshijie.com.cn/kp2.png\" alt width=\"779\" height=\"765\"></a><p></p>\n<p>1）线头阻塞（Head-of-Line Blocking），HTTP1.X虽然可以采用keep alive来解决复用TCP的问题，但是还是无法解决请求阻塞问题。</p>\n<p>2）所谓请求阻塞意思就是一条TCP的connection在同一时间只能允许一个请求经过，这样假如后续请求想要复用这个链接就必须等到前一个完成才行，正如上图左边表示的。</p>\n<p>3）之所以有这个问题就是因为HTTP1.x需要每条请求都是可是识别，按顺序发送，否则server就无法判断该相应哪个具体的请求。</p>\n<p>4）HTTP2采用多路复用是指，在同一个域名下，开启一个TCP的connection，每个请求以stream的方式传输，每个stream有唯一标识，connection一旦建立，后续的请求都可以复用这个connection并且可以同时发送，server端可以根据stream的唯一标识来相应对应的请求。</p>\n<p>&nbsp;</p>\n<p></p><h3><span id=\"问题6多路复用就不会关闭了么\"><span style=\"font-weight: bolder;\">问题6：多路复用就不会关闭了么？</span></span></h3><br>多路复用使用的同一个TCP的connection会关闭么，什么时候关闭，这是个问题？从标准上看到一段文字：<p></p>\n<p><div class=\"newpage\" style=\"padding:10px;font-size: 13.3333px; margin-top: 0px; margin-bottom: 0px; break-before: page; color: #000000;\">HTTP/2 connections are persistent.  For best performance, it is<br>   expected that clients will not close connections until it is<br>   determined that no further communication with a server is necessary<br>   (for example, when a user navigates away from a particular web page)<br>   or until the server closes the connection.</div><br>意思就是说关闭的时机有2个：<br>1）用户离开这个页面。<br>2）server主动关闭connection。<br>但是标准总归标准，不同的服务器实现时有了自己的约定，就行keep alive一样，每种服务器都有对自己多路复用的这个connection有相关的配置：</p>\n<p><strong>Apache：</strong><br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Syntax:\thttp2_idle_timeout time;</span><br><span class=\"line\"><span class=\"keyword\">Default</span>:\t</span><br><span class=\"line\">http2_idle_timeout <span class=\"number\">3</span>m;</span><br><span class=\"line\">Context:\thttp, server</span><br><span class=\"line\"></span><br><span class=\"line\">Syntax:\thttp2_recv_timeout time;</span><br><span class=\"line\"><span class=\"keyword\">Default</span>:\t</span><br><span class=\"line\">http2_recv_timeout <span class=\"number\">30</span>s;</span><br><span class=\"line\">Context:\thttp, server</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"http://nginx.org/en/docs/http/ngx_http_v2_module.html#http2_idle_timeout\" target=\"_blank\" rel=\"noopener noreferrer\">http://nginx.org/en/docs/http/ngx_http_v2_module.html#http2_idle_timeout</a></p>\n<p>参考资料：</p>\n<ol style=\"padding-top: 0px; padding-right: 0px; padding-bottom: 0px;\"><br>     <li style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 0px;\">HTTP2官方标准：<a style=\"color: #336699;\" href=\"https://tools.ietf.org/html/rfc7540\" target=\"_blank\" rel=\"noopener noreferrer\">https://tools.ietf.org/html/rfc7540</a></li><br>     <li style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 0px;\"><a href=\"https://cascadingmedia.com/insites/2015/03/http-2.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://cascadingmedia.com/insites/2015/03/http-2.html</a></li><br></ol>","site":{"data":{}},"excerpt":"<p>关于HTTP2中其他特性的研究可以参考我之前写的文章</p>\n<p><a href=\"http://km.oa.com/group/19674/articles/show/286253?kmref=kb_categories\" target=\"_blank\" rel=\"noopener noreferrer\">关于Server Push的研究</a></p>\n<p></p><h3><span style=\"font-weight: bolder;\">问题一：什么是keep live？</span></h3><br>HTTP持久连接（HTTP persistent connection，也称作HTTP keep-alive或HTTP connection reuse）是使用同一个TCP连接来发送和接收多个HTTP请求/应答，而不是为每一个新的请求/应答打开新的连接的方法。<br>","more":"<br>我们知道HTTP协议采用“请求-应答”模式，当使用普通模式，即非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接（HTTP协议为无连接的协议）；当使用Keep-Alive模式（又称持久连接）时，Keep-Alive功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。<p></p>\n<p>&nbsp;</p>\n<p></p><h3><span style=\"font-weight: bolder;\">问题二：keep alive和传统的区别？</span></h3><br><a href=\"https://qiniu.nihaoshijie.com.cn/blog/kp1.png\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-700\" src=\"https://qiniu.nihaoshijie.com.cn/blog/kp1.png\" alt=\"\" width=\"495\" height=\"289\"></a><p></p>\n<p>一图胜千言，由图可知引入的keep alive的链接不必在每次请求都开启一个新的链接。</p>\n<p>&nbsp;</p>\n<p></p><h3><span style=\"font-weight: bolder;\">问题三：keep alive如何配置？</span></h3><br><span style=\"font-weight: bolder;\">Apache服务器：</span><p></p>\n<p>httpd.conf：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KeepAlive On             <span class=\"comment\">// 是否打开keep alive</span></span><br><span class=\"line\">MaxKeepAliveRequests <span class=\"number\">300</span> <span class=\"comment\">// 每个连接最大可复用的请求数</span></span><br><span class=\"line\">KeepAliveTimeout <span class=\"number\">3</span>       <span class=\"comment\">// 每个请求可复用的time时间s</span></span><br></pre></td></tr></table></figure></p>\n<p><span style=\"font-weight: bolder;\"> Nginx服务器：</span></p>\n<p>nginx.conf：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keepalive_timeout <span class=\"comment\">//服务器接收在10s以内的所有connection复用超过10则关闭建立一个新的connection 0代表关闭keepalive</span></span><br></pre></td></tr></table></figure></p>\n<p>Node.js</p>\n<p><a href=\"https://nodejs.org/api/http.html#http_class_http_agent\" target=\"_blank\" rel=\"noopener noreferrer\">https://nodejs.org/api/http.html#http_class_http_agent</a></p>\n<p>&nbsp;</p>\n<p></p><h3><span style=\"font-weight: bolder;\">问题4：多路复用是什么？</span><a href=\"https://qiniu.nihaoshijie.com.cn/blog/kp3.png\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-703\" src=\"https://qiniu.nihaoshijie.com.cn/blog/kp3.png\" alt=\"\" width=\"1472\" height=\"234\"></a></h3><br>1）HTTP2的请求的TCP的connection一旦建立，后续请求以stream的方式发送。<p></p>\n<p>2）每个stream的基本组成单位是frame（二进制帧），每种frame又分为很多种类型例如HEADERS Frame（头部帧），DATA Frame（内容帧）等等。</p>\n<p>3）请求头HEADERS Frame组成了resquest，返回头HEADERS Frame和DATA Frame组成了response，request和response组成了一个stream。</p>\n<p>&nbsp;</p>\n<p></p><h3><span style=\"font-weight: bolder;\">问题5：多路复用和keep alive区别？</span></h3><br><a href=\"https://qiniu.nihaoshijie.com.cn/kp2.png\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-701\" src=\"https://qiniu.nihaoshijie.com.cn/kp2.png\" alt=\"\" width=\"779\" height=\"765\"></a><p></p>\n<p>1）线头阻塞（Head-of-Line Blocking），HTTP1.X虽然可以采用keep alive来解决复用TCP的问题，但是还是无法解决请求阻塞问题。</p>\n<p>2）所谓请求阻塞意思就是一条TCP的connection在同一时间只能允许一个请求经过，这样假如后续请求想要复用这个链接就必须等到前一个完成才行，正如上图左边表示的。</p>\n<p>3）之所以有这个问题就是因为HTTP1.x需要每条请求都是可是识别，按顺序发送，否则server就无法判断该相应哪个具体的请求。</p>\n<p>4）HTTP2采用多路复用是指，在同一个域名下，开启一个TCP的connection，每个请求以stream的方式传输，每个stream有唯一标识，connection一旦建立，后续的请求都可以复用这个connection并且可以同时发送，server端可以根据stream的唯一标识来相应对应的请求。</p>\n<p>&nbsp;</p>\n<p></p><h3><span style=\"font-weight: bolder;\">问题6：多路复用就不会关闭了么？</span></h3><br>多路复用使用的同一个TCP的connection会关闭么，什么时候关闭，这是个问题？从标准上看到一段文字：<p></p>\n<p><div class=\"newpage\" style=\"padding:10px;font-size: 13.3333px; margin-top: 0px; margin-bottom: 0px; break-before: page; color: #000000;\">HTTP/2 connections are persistent.  For best performance, it is<br>   expected that clients will not close connections until it is<br>   determined that no further communication with a server is necessary<br>   (for example, when a user navigates away from a particular web page)<br>   or until the server closes the connection.</div><br>意思就是说关闭的时机有2个：<br>1）用户离开这个页面。<br>2）server主动关闭connection。<br>但是标准总归标准，不同的服务器实现时有了自己的约定，就行keep alive一样，每种服务器都有对自己多路复用的这个connection有相关的配置：</p>\n<p><strong>Apache：</strong><br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Syntax:\thttp2_idle_timeout time;</span><br><span class=\"line\"><span class=\"keyword\">Default</span>:\t</span><br><span class=\"line\">http2_idle_timeout <span class=\"number\">3</span>m;</span><br><span class=\"line\">Context:\thttp, server</span><br><span class=\"line\"></span><br><span class=\"line\">Syntax:\thttp2_recv_timeout time;</span><br><span class=\"line\"><span class=\"keyword\">Default</span>:\t</span><br><span class=\"line\">http2_recv_timeout <span class=\"number\">30</span>s;</span><br><span class=\"line\">Context:\thttp, server</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"http://nginx.org/en/docs/http/ngx_http_v2_module.html#http2_idle_timeout\" target=\"_blank\" rel=\"noopener noreferrer\">http://nginx.org/en/docs/http/ngx_http_v2_module.html#http2_idle_timeout</a></p>\n<p>参考资料：</p>\n<ol style=\"padding-top: 0px; padding-right: 0px; padding-bottom: 0px;\"><br>     <li style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 0px;\">HTTP2官方标准：<a style=\"color: #336699;\" href=\"https://tools.ietf.org/html/rfc7540\" target=\"_blank\" rel=\"noopener noreferrer\">https://tools.ietf.org/html/rfc7540</a></li><br>     <li style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 0px;\"><a href=\"https://cascadingmedia.com/insites/2015/03/http-2.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://cascadingmedia.com/insites/2015/03/http-2.html</a></li><br></ol>"},{"title":"Javascript基本概念梳理","date":"2014-06-13T10:48:16.000Z","_content":"<p style=\"color: #362e2b;\">javascript里的数据类型：</p>\n\n<blockquote style=\"color: #362e2b;\">原始类型：数字，字符串，布尔值。（原始值：null，undefined）\n\n对象类型：键值对，数组，function，全局对象（MATH，JSON）\n\n保留字：export，NaA。。\n\n</blockquote>\n<!--more-->\n<span style=\"color: #362e2b;\">包装对象的概念：</span>\n<blockquote style=\"color: #362e2b;\">字符串\"aaa\".len 字符串并不是对象，但是却可以调用它的属性，说明这只是一个临时对象，内部用new String（）来创建的临时的。</blockquote>\n<p style=\"color: #362e2b;\">原始类型是永远不可变的，所以可以比较他们的值，但是对象类型是可变的，不能比较他们的值.</p>\n<p style=\"color: #362e2b;\">Javascript原型和继承：</p>\n\n\n\nJavascript里每个对象都和另外一个对象关联，这个对象就是__proto__（原型对象）注意这里的原型对象并不是prototype。\n\n解释一下：这里的prototype指的是通过关键字new和构造函数调用创建的对象的原型就是构造函数的prototype属性。\n\n对象实例的__proto__指向这个对象的prototype，而对象的__proto__为空。举个例子就是：\n\n\n```javascript\nvar array = new Array();  \narray.__proto__ === Array.prororype  //true  \nArray.__proro //null\n```\n当然，也可以使用Object.getPrototypeOf()替代__proto__来使用来得到对象所继承的原型，举例说明：\n```javascript\nObject.getPrototypeOf(Array) === Array.__proto__;\n```\nObject.getPrototypeOf()来查看原型继承，例如：\n```javascript\nObject.getPrototypeOf(Array.prototype) // Object\n```\n可以看出Array的prototype继承Object所以Array也有他的方法例如totring()等。可以得到所有的对象都有一个共同的原型，就是Object但是Object只是一个构造函数，想要访问他，就只用Object.prototype来得到。\n\n\nJavascript的实例属性和原型属性：\n```javascript\nfunction A(){};\nA.prototype.title = '123'; // 原型属性\nvar a = new A();\nconsole.log(a.title); // 123\na.title = '234';// 实例属性\nconsole.log(a.title); // 234\n\na.hasOwnProperty('title'); // 只能访问到实例属性 不能访问原型属性\n\n// for in的时候要加hasOwnProperty判断\n\n```\nJavascript实现继承的方式：\n\n<p style=\"color: #362e2b;\">自定义继承：</p>\n```javascript\nfunction A(){};  \nfunction B(){};\n// A 继承 B\nA.prototype = new B();  \n//or\nvar b = new B();\nA.prototype = b;\n// 两种写法差不多\n\n```\n\n例如，Object.getPrototypeOf()来查看自定义的继承\n```javascript\nfunction A(){};  \nfunction B(){};  \nA.prototype = new B();  \nObject.getPrototypeOf(A.prototype) //B\n```\n\n<p style=\"color: #362e2b;\">使用Object.create()实现继承：</p>\n\n\nObject.create()接受一个参数，为对象的prototype，其实还有第二个参数用来描述熟悉的特性，在es5中直接实现了Object.create()这个方法不用自己写了\n```javascript\nObject.create = function (o) {  \n  \n     var F = function () {};  \n\n     F.prototype = o;  \n\n     return new F();  \n\n };\nfunction A(){}; \n\nvar b = Object.create(A.prototype);\n```\nObject.create()可以创建对象，当然也可以创建对象的子对象，可以这样理解\n```javascript\nvar a = Object.create({a:1})\n```\n那么a就有了一个熟悉a，这样就可以理解为继承了，如果是一个函数，例如Array是一个函数对象\n```javascript\nvar myArray = Object.create(Array.prototype)\n```\n那个myArray也就具有了Array的所有方法\n\nmyArray.push\n\n自定义的函数\n```javascript\nfunction Acc(){}  \nAcc.prototype.dd = 123;  \nvar accc = Object.create(Acc.prototype)；  \naccc.dd //123\n```\n未完！","source":"_posts/Javascript基本概念梳理.md","raw":"---\ntitle: Javascript基本概念梳理\ndate: 2014-06-13 18:48:16\ntags:\n- javascript\n- 面试\ncategories:\n- 149\n---\n<p style=\"color: #362e2b;\">javascript里的数据类型：</p>\n\n<blockquote style=\"color: #362e2b;\">原始类型：数字，字符串，布尔值。（原始值：null，undefined）\n\n对象类型：键值对，数组，function，全局对象（MATH，JSON）\n\n保留字：export，NaA。。\n\n</blockquote>\n<!--more-->\n<span style=\"color: #362e2b;\">包装对象的概念：</span>\n<blockquote style=\"color: #362e2b;\">字符串\"aaa\".len 字符串并不是对象，但是却可以调用它的属性，说明这只是一个临时对象，内部用new String（）来创建的临时的。</blockquote>\n<p style=\"color: #362e2b;\">原始类型是永远不可变的，所以可以比较他们的值，但是对象类型是可变的，不能比较他们的值.</p>\n<p style=\"color: #362e2b;\">Javascript原型和继承：</p>\n\n\n\nJavascript里每个对象都和另外一个对象关联，这个对象就是__proto__（原型对象）注意这里的原型对象并不是prototype。\n\n解释一下：这里的prototype指的是通过关键字new和构造函数调用创建的对象的原型就是构造函数的prototype属性。\n\n对象实例的__proto__指向这个对象的prototype，而对象的__proto__为空。举个例子就是：\n\n\n```javascript\nvar array = new Array();  \narray.__proto__ === Array.prororype  //true  \nArray.__proro //null\n```\n当然，也可以使用Object.getPrototypeOf()替代__proto__来使用来得到对象所继承的原型，举例说明：\n```javascript\nObject.getPrototypeOf(Array) === Array.__proto__;\n```\nObject.getPrototypeOf()来查看原型继承，例如：\n```javascript\nObject.getPrototypeOf(Array.prototype) // Object\n```\n可以看出Array的prototype继承Object所以Array也有他的方法例如totring()等。可以得到所有的对象都有一个共同的原型，就是Object但是Object只是一个构造函数，想要访问他，就只用Object.prototype来得到。\n\n\nJavascript的实例属性和原型属性：\n```javascript\nfunction A(){};\nA.prototype.title = '123'; // 原型属性\nvar a = new A();\nconsole.log(a.title); // 123\na.title = '234';// 实例属性\nconsole.log(a.title); // 234\n\na.hasOwnProperty('title'); // 只能访问到实例属性 不能访问原型属性\n\n// for in的时候要加hasOwnProperty判断\n\n```\nJavascript实现继承的方式：\n\n<p style=\"color: #362e2b;\">自定义继承：</p>\n```javascript\nfunction A(){};  \nfunction B(){};\n// A 继承 B\nA.prototype = new B();  \n//or\nvar b = new B();\nA.prototype = b;\n// 两种写法差不多\n\n```\n\n例如，Object.getPrototypeOf()来查看自定义的继承\n```javascript\nfunction A(){};  \nfunction B(){};  \nA.prototype = new B();  \nObject.getPrototypeOf(A.prototype) //B\n```\n\n<p style=\"color: #362e2b;\">使用Object.create()实现继承：</p>\n\n\nObject.create()接受一个参数，为对象的prototype，其实还有第二个参数用来描述熟悉的特性，在es5中直接实现了Object.create()这个方法不用自己写了\n```javascript\nObject.create = function (o) {  \n  \n     var F = function () {};  \n\n     F.prototype = o;  \n\n     return new F();  \n\n };\nfunction A(){}; \n\nvar b = Object.create(A.prototype);\n```\nObject.create()可以创建对象，当然也可以创建对象的子对象，可以这样理解\n```javascript\nvar a = Object.create({a:1})\n```\n那么a就有了一个熟悉a，这样就可以理解为继承了，如果是一个函数，例如Array是一个函数对象\n```javascript\nvar myArray = Object.create(Array.prototype)\n```\n那个myArray也就具有了Array的所有方法\n\nmyArray.push\n\n自定义的函数\n```javascript\nfunction Acc(){}  \nAcc.prototype.dd = 123;  \nvar accc = Object.create(Acc.prototype)；  \naccc.dd //123\n```\n未完！","slug":"Javascript基本概念梳理","published":1,"updated":"2018-03-20T08:01:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434pzx000q2wvjme4ood7a","content":"<p style=\"color: #362e2b;\">javascript里的数据类型：</p>\n\n<p><blockquote style=\"color: #362e2b;\">原始类型：数字，字符串，布尔值。（原始值：null，undefined）</blockquote></p>\n<p>对象类型：键值对，数组，function，全局对象（MATH，JSON）</p>\n<p>保留字：export，NaA。。</p>\n<p><br><a id=\"more\"></a><br><span style=\"color: #362e2b;\">包装对象的概念：</span></p>\n<p><blockquote style=\"color: #362e2b;\">字符串”aaa”.len 字符串并不是对象，但是却可以调用它的属性，说明这只是一个临时对象，内部用new String（）来创建的临时的。</blockquote></p>\n<p style=\"color: #362e2b;\">原始类型是永远不可变的，所以可以比较他们的值，但是对象类型是可变的，不能比较他们的值.</p><br><p style=\"color: #362e2b;\">Javascript原型和继承：</p>\n\n\n\n<p>Javascript里每个对象都和另外一个对象关联，这个对象就是<strong>proto</strong>（原型对象）注意这里的原型对象并不是prototype。</p>\n<p>解释一下：这里的prototype指的是通过关键字new和构造函数调用创建的对象的原型就是构造函数的prototype属性。</p>\n<p>对象实例的<strong>proto</strong>指向这个对象的prototype，而对象的<strong>proto</strong>为空。举个例子就是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();  </span><br><span class=\"line\">array.__proto__ === <span class=\"built_in\">Array</span>.prororype  <span class=\"comment\">//true  </span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.__proro <span class=\"comment\">//null</span></span><br></pre></td></tr></table></figure>\n<p>当然，也可以使用Object.getPrototypeOf()替代<strong>proto</strong>来使用来得到对象所继承的原型，举例说明：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"built_in\">Array</span>) === <span class=\"built_in\">Array</span>.__proto__;</span><br></pre></td></tr></table></figure></p>\n<p>Object.getPrototypeOf()来查看原型继承，例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"built_in\">Array</span>.prototype) <span class=\"comment\">// Object</span></span><br></pre></td></tr></table></figure></p>\n<p>可以看出Array的prototype继承Object所以Array也有他的方法例如totring()等。可以得到所有的对象都有一个共同的原型，就是Object但是Object只是一个构造函数，想要访问他，就只用Object.prototype来得到。</p>\n<p>Javascript的实例属性和原型属性：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">A.prototype.title = <span class=\"string\">'123'</span>; <span class=\"comment\">// 原型属性</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.title); <span class=\"comment\">// 123</span></span><br><span class=\"line\">a.title = <span class=\"string\">'234'</span>;<span class=\"comment\">// 实例属性</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.title); <span class=\"comment\">// 234</span></span><br><span class=\"line\"></span><br><span class=\"line\">a.hasOwnProperty(<span class=\"string\">'title'</span>); <span class=\"comment\">// 只能访问到实例属性 不能访问原型属性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// for in的时候要加hasOwnProperty判断</span></span><br></pre></td></tr></table></figure></p>\n<p>Javascript实现继承的方式：</p>\n<p style=\"color: #362e2b;\">自定义继承：</p><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>)</span>&#123;&#125;;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// A 继承 B</span></span><br><span class=\"line\">A.prototype = <span class=\"keyword\">new</span> B();  </span><br><span class=\"line\"><span class=\"comment\">//or</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\">A.prototype = b;</span><br><span class=\"line\"><span class=\"comment\">// 两种写法差不多</span></span><br></pre></td></tr></table></figure><br><br>例如，Object.getPrototypeOf()来查看自定义的继承<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>)</span>&#123;&#125;;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span>(<span class=\"params\"></span>)</span>&#123;&#125;;  </span><br><span class=\"line\">A.prototype = <span class=\"keyword\">new</span> B();  </span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(A.prototype) <span class=\"comment\">//B</span></span><br></pre></td></tr></table></figure><br><br><p style=\"color: #362e2b;\">使用Object.create()实现继承：</p>\n\n\n<p>Object.create()接受一个参数，为对象的prototype，其实还有第二个参数用来描述熟悉的特性，在es5中直接实现了Object.create()这个方法不用自己写了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.create = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">o</span>) </span>&#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">     <span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;  </span><br><span class=\"line\"></span><br><span class=\"line\">     F.prototype = o;  </span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();  </span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>)</span>&#123;&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"built_in\">Object</span>.create(A.prototype);</span><br></pre></td></tr></table></figure></p>\n<p>Object.create()可以创建对象，当然也可以创建对象的子对象，可以这样理解<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">Object</span>.create(&#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>那么a就有了一个熟悉a，这样就可以理解为继承了，如果是一个函数，例如Array是一个函数对象<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myArray = <span class=\"built_in\">Object</span>.create(<span class=\"built_in\">Array</span>.prototype)</span><br></pre></td></tr></table></figure></p>\n<p>那个myArray也就具有了Array的所有方法</p>\n<p>myArray.push</p>\n<p>自定义的函数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Acc</span>(<span class=\"params\"></span>)</span>&#123;&#125;  </span><br><span class=\"line\">Acc.prototype.dd = <span class=\"number\">123</span>;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> accc = <span class=\"built_in\">Object</span>.create(Acc.prototype)；  </span><br><span class=\"line\">accc.dd <span class=\"comment\">//123</span></span><br></pre></td></tr></table></figure></p>\n<p>未完！</p>\n","site":{"data":{}},"excerpt":"<p style=\"color: #362e2b;\">javascript里的数据类型：</p>\n\n<p><blockquote style=\"color: #362e2b;\">原始类型：数字，字符串，布尔值。（原始值：null，undefined）</blockquote></p>\n<p>对象类型：键值对，数组，function，全局对象（MATH，JSON）</p>\n<p>保留字：export，NaA。。</p>\n<p><br>","more":"<br><span style=\"color: #362e2b;\">包装对象的概念：</span></p>\n<p><blockquote style=\"color: #362e2b;\">字符串”aaa”.len 字符串并不是对象，但是却可以调用它的属性，说明这只是一个临时对象，内部用new String（）来创建的临时的。</blockquote></p>\n<p style=\"color: #362e2b;\">原始类型是永远不可变的，所以可以比较他们的值，但是对象类型是可变的，不能比较他们的值.</p><br><p style=\"color: #362e2b;\">Javascript原型和继承：</p>\n\n\n\n<p>Javascript里每个对象都和另外一个对象关联，这个对象就是<strong>proto</strong>（原型对象）注意这里的原型对象并不是prototype。</p>\n<p>解释一下：这里的prototype指的是通过关键字new和构造函数调用创建的对象的原型就是构造函数的prototype属性。</p>\n<p>对象实例的<strong>proto</strong>指向这个对象的prototype，而对象的<strong>proto</strong>为空。举个例子就是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();  </span><br><span class=\"line\">array.__proto__ === <span class=\"built_in\">Array</span>.prororype  <span class=\"comment\">//true  </span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.__proro <span class=\"comment\">//null</span></span><br></pre></td></tr></table></figure>\n<p>当然，也可以使用Object.getPrototypeOf()替代<strong>proto</strong>来使用来得到对象所继承的原型，举例说明：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"built_in\">Array</span>) === <span class=\"built_in\">Array</span>.__proto__;</span><br></pre></td></tr></table></figure></p>\n<p>Object.getPrototypeOf()来查看原型继承，例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"built_in\">Array</span>.prototype) <span class=\"comment\">// Object</span></span><br></pre></td></tr></table></figure></p>\n<p>可以看出Array的prototype继承Object所以Array也有他的方法例如totring()等。可以得到所有的对象都有一个共同的原型，就是Object但是Object只是一个构造函数，想要访问他，就只用Object.prototype来得到。</p>\n<p>Javascript的实例属性和原型属性：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">A.prototype.title = <span class=\"string\">'123'</span>; <span class=\"comment\">// 原型属性</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.title); <span class=\"comment\">// 123</span></span><br><span class=\"line\">a.title = <span class=\"string\">'234'</span>;<span class=\"comment\">// 实例属性</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.title); <span class=\"comment\">// 234</span></span><br><span class=\"line\"></span><br><span class=\"line\">a.hasOwnProperty(<span class=\"string\">'title'</span>); <span class=\"comment\">// 只能访问到实例属性 不能访问原型属性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// for in的时候要加hasOwnProperty判断</span></span><br></pre></td></tr></table></figure></p>\n<p>Javascript实现继承的方式：</p>\n<p style=\"color: #362e2b;\">自定义继承：</p><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>)</span>&#123;&#125;;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// A 继承 B</span></span><br><span class=\"line\">A.prototype = <span class=\"keyword\">new</span> B();  </span><br><span class=\"line\"><span class=\"comment\">//or</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\">A.prototype = b;</span><br><span class=\"line\"><span class=\"comment\">// 两种写法差不多</span></span><br></pre></td></tr></table></figure><br><br>例如，Object.getPrototypeOf()来查看自定义的继承<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>)</span>&#123;&#125;;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span>(<span class=\"params\"></span>)</span>&#123;&#125;;  </span><br><span class=\"line\">A.prototype = <span class=\"keyword\">new</span> B();  </span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(A.prototype) <span class=\"comment\">//B</span></span><br></pre></td></tr></table></figure><br><br><p style=\"color: #362e2b;\">使用Object.create()实现继承：</p>\n\n\n<p>Object.create()接受一个参数，为对象的prototype，其实还有第二个参数用来描述熟悉的特性，在es5中直接实现了Object.create()这个方法不用自己写了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.create = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">o</span>) </span>&#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">     <span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;  </span><br><span class=\"line\"></span><br><span class=\"line\">     F.prototype = o;  </span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();  </span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>)</span>&#123;&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"built_in\">Object</span>.create(A.prototype);</span><br></pre></td></tr></table></figure></p>\n<p>Object.create()可以创建对象，当然也可以创建对象的子对象，可以这样理解<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">Object</span>.create(&#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>那么a就有了一个熟悉a，这样就可以理解为继承了，如果是一个函数，例如Array是一个函数对象<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myArray = <span class=\"built_in\">Object</span>.create(<span class=\"built_in\">Array</span>.prototype)</span><br></pre></td></tr></table></figure></p>\n<p>那个myArray也就具有了Array的所有方法</p>\n<p>myArray.push</p>\n<p>自定义的函数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Acc</span>(<span class=\"params\"></span>)</span>&#123;&#125;  </span><br><span class=\"line\">Acc.prototype.dd = <span class=\"number\">123</span>;  </span><br><span class=\"line\"><span class=\"keyword\">var</span> accc = <span class=\"built_in\">Object</span>.create(Acc.prototype)；  </span><br><span class=\"line\">accc.dd <span class=\"comment\">//123</span></span><br></pre></td></tr></table></figure></p>\n<p>未完！</p>"},{"title":"PWA技术理论+实战","date":"2020-05-31T09:26:17.000Z","photos":["https://pic2.zhimg.com/v2-c2ac2c2e0007cd1025836c03d4ad7d24_1440w.jpg?source=172ae18b"],"_content":"\n\n\n### 导读\n\n随着互联网技术的发展，web应用已经越来越流行，技术的发展越来越迅速，尤其是移动互联网的到来使得HTML5技术，Hybrid混合开发，更加火爆起来，但是web应用没能摆脱PC时代的一些根本性的问题，所需的资源依赖网络下载，用户体验始终要依赖浏览器，这让web应用和Native应用相比尤其在移动手机端的体验，总让人感觉\"不正规\"，而PWA技术的到来，让下一代web应用终于步入正轨！\n\n基于此，本文主要有以下几部分内容：\n\n- PWA基本概念讲解\n- Service Worker原理讲解\n- Web Push协议讲解\n- 将一个SPA项目改造为PWA\n  - manifest.json配置解析\n  - Service Worker资源缓存\n  - 添加保存到桌面功能\n  - 接收消息推送\n- 总结\n\n<!--more-->\n\n### 什么是PWA？\n![图片描述](https://user-gold-cdn.xitu.io/2020/5/28/1725a24c14c71ec6?w=640&h=377&f=png&s=44504)\nPWA(progressing web app)，渐进式网页应用程序，是Google在2016年GoogleI/O大会上提出的下一代web应用模型，并在随后的日子里迅速发展。\n一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后借助于 App Manifest 和 Service Worker 来实现 PWA 的安装和离线等功能。\n\n\n\n### PWA的特点\n - **渐进式**：适用于选用任何浏览器的所有用户，因为它是以渐进式增强作为核心宗旨来开发的。\n - **自适应**：适合任何机型：桌面设备、移动设备、平板电脑或任何未来设备。\n - **连接无关性**：能够借助于服务工作线程在离线或低质量网络状况下工作。\n - **离线推送**：使用推送消息通知，能够让我们的应用像 Native App 一样，提升用户体验。\n - **及时更新**：在服务工作线程更新进程的作用下时刻保持最新状态。\n - **安全性**：通过 HTTPS 提供，以防止窥探和确保内容不被篡改。\n\n对于我们移动端来讲，用简单的一句话来概况一个PWA应用就是，我们开发的H5页面增加可以添加至屏幕的功能，点击主屏幕图标可以实现启动动画以及隐藏地址栏实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能。\n这些特点和功能不正是我们目前针对移动web的优化方向吗，有了这些特性将使得 Web 应用渐进式接近原生 App，真正实现秒开优化。\n\n\n### Service Worker是什么\nService Worker 是一个 基于HTML5 API ，也是PWA技术栈中最重要的特性， 它在 Web Worker 的基础上加上了持久离线缓存和网络代理能力，结合Cache API面向提供了JavaScript来操作浏览器缓存的能力，这使得Service Worker和PWA密不可分。\n#### Service Worker概述：\n\n\n - 一个独立的执行线程，单独的作用域范围，单独的运行环境，有自己独立的context上下文。\n - 一旦被 install，就永远存在，除非被手动 unregister。即使Chrome（浏览器）关闭也会在后台运行。利用这个特性可以实现离线消息推送功能。\n - 处于安全性考虑，必须在 HTTPS 环境下才能工作。当然在本地调试时，使用localhost则不受HTTPS限制。\n - 提供拦截浏览器请求的接口，可以控制打开的作用域范围下所有的页面请求。需要注意的是一旦请求被Service Worker接管，意味着任何请求都由你来控制，一定要做好容错机制，保证页面的正常运行。\n - 由于是独立线程，Service Worker不能直接操作页面 DOM。但可以通过事件机制来处理。例如使用postMessage。\n\n\n#### Service Worker生命周期：\n\n - 注册（register）：这里一般指在浏览器解析到JavaScript有注册Service Worker时的逻辑，即调用navigator.serviceWorker.register()时所处理的事情。\n - 安装中( installing )：这个状态发生在 Service Worker 注册之后，表示开始安装。\n - 安装后( installed/waiting )：Service Worker 已经完成了安装，这时会触发install事件，在这里一般会做一些静态资源的离线缓存。如果还有旧的Service Worker正在运行，会进入waiting状态，如果你关闭当前浏览器，或者调用self.skipWaiting()，方法表示强制当前处在 waiting 状态的 Service Worker 进入 activate 状态。\n - 激活( activating )：表示正在进入activate状态，调用self.clients.claim())会来强制控制未受控制的客户端，例如你的浏览器开了多个含有Service Worker的窗口，会在不切的情况下，替换旧的 Service Worker 脚本不再控制着这些页面，之后会被停止。此时会触发activate事件。\n - 激活后( activated )：在这个状态表示Service Worker激活成功，在activate事件回调中，一般会清除上一个版本的静态资源缓存，或者其他更新缓存的策略。这代表Service Worker已经可以处理功能性的事件fetch (请求)、sync (后台同步)、push (推送)，message（操作dom）。\n - 废弃状态 ( redundant )：这个状态表示一个 Service Worker 的生命周期结束。\n\n\n整个流程可以用下图解释： \n![图片描述](https://user-gold-cdn.xitu.io/2020/5/28/1725a24bf36b2185?w=432&h=672&f=png&s=36756)\n\nService Worker支持的事件：\n![图片描述](https://user-gold-cdn.xitu.io/2020/5/28/1725a24bf0dc3c18?w=573&h=167&f=png&s=6454)\n\n\n#### Service Worker浏览器兼容性：\n![图片描述](https://user-gold-cdn.xitu.io/2020/5/28/1725a24bf378bba3?w=2170&h=1184&f=png&s=291603)\nService Worker作为一个新的技术，那么就必然会有浏览器兼容性问题，从图上可以看到对于大部分的Android来说支持性还是很不错的，尤其是Chrome for Android，但是对于iOS系统而言11.3之前是不支持Service Worker的，这可能也是Service Worker没能普及开来的一个原因，但是好消息是苹果宣布后续会持续更新对Service Worker的支持，那么前景还是很值得期待的。\n\n### 消息推送\n消息推送，顾名思义就是你在手机上收到的某个 APP 的消息推送，相较于移动端 Native 应用，web 应用是缺少这一项常用的功能。而借助 PWA 的 Push 特性，就是用户在打开浏览器时，不需要进入特定的网站，就能收到该网站推送而来的消息，例如：新评论，新动态等等，而借助于 Android 的 Chrome，我们可以实现在用户不打开任何浏览器或者应用的情况下，收到我们项目的推送，就像一个真实的手机推送。\n### 什么是Web Push\n\nWeb Push是一个基于客户端，服务端和推送服务器三者组成的一种流程规范，可以分为三个步骤：\n1. 客户端完成请求订阅一个用户的逻辑。\n2. 服务端调用遵从 web push 协议的接口，传送消息推送（push message）到推送服务器（该服务器由浏览器决定，开发者所能做的只有控制发送的数据）。\n3. 推送服务器将该消息推送至对应的浏览器，用户收到该推送。\n\n下图展示了一个用户订阅的过程：\n![图片描述](https://user-gold-cdn.xitu.io/2020/5/29/1725e621d4f1bfe4?w=800&h=205&f=png&s=50100)\n\n所谓用户订阅，就是说我想要收到你的网站或者你的 APP 的推送通知，我就需要告诉你我是谁，我要把我的标识传给你，否则你怎么知道要给我推送。\n\n下图展示了服务端收到用户订阅请求后如何推送：\n\n![图片描述](https://user-gold-cdn.xitu.io/2020/5/29/1725e621d4f43140?w=817&h=218&f=png&s=27819)\n\n\n1. 首先，在你项目的后台(Your Server)要存储一下用户订阅时传给你的标识。\n2. 在后台需要给你推送的时候，找到这个标识，然后联系推送服务器(Push Service)将内容和标识传给推送服务，然后让推送服务将消息推送给用户端。（iOS和Android各自有自己的推送服务器，这个和操作系统相关）。\n3. 这里就有一个约定，用户的标识，要和推送服务达成一致，例如使用Chrome浏览器，那么推送服务就是谷歌的推送服务[(FCM)](https://firebase.google.cn/docs/cloud-messaging/concept-options?hl=zh-cn)。\n\n### 开始改造现有的SPA应用\n本章节会将一个基于Vue.js2.6版本的SPA项目进行PWA改造，原有项目的开发过程就不再讲解，各位读者可以到[Github](https://github.com/lvming6816077/wecircleCode/tree/master/app)来看源码，最终的体验地址：https://app.nihaoshijie.com.cn，请使用Safari或者Android Chrome打开体验。\n#### 添加manifest.json配置页面参数：\n添加到桌面快捷方式功能本身是PWA应用的一部分，他让我们的应用看起来更像是一个Web App，我们在前端项目的 public 文件夹下新建 manifest.json 文件：\n```json\n{\n    \"name\": \"WECIRCLE\",\n    \"short_name\": \"WECIRCLE\",\n    \"icons\": [\n        {\n          \"src\": \"./img/icons/android-chrome-192x192.png\",\n          \"sizes\": \"192x192\",\n          \"type\": \"image/png\"\n        },\n        {\n          \"src\": \"./img/icons/android-chrome-512x512.png\",\n          \"sizes\": \"512x512\",\n          \"type\": \"image/png\"\n        }\n    ],\n    \"start_url\": \"./index.html\",\n    \"display\": \"standalone\",\n    \"background_color\": \"#000000\",\n    \"theme_color\": \"#181818\"\n}\n```\n其中：\n\n 1. **name**：指定了 Web App 的名称，也就是保存到桌面图标的名称。\n 2. **short_name**：当 name 名称过长时，将会使用 short_name 来代替name显示，也就是 Web App 的简称。\n 3. **start_url**：指定了用户打开该 Web App 时加载的URL。相对URL会相对于 manifest.json 。这里我们指定了 index.html 作为 Web App 的启动页。\n 4. **display**：指定了应用的显示模式，它有四个值可以选择：\n    `fullscreen`：全屏显示，会尽可能将所有的显示区域都占满。\n    `standalone`：浏览器相关UI（如导航栏、工具栏等）将会被隐藏，因此看起来更像一个Native App。\n    `minimal-ui`：显示形式与standalone类似，浏览器相关UI会最小化为一个按钮，不同浏览器在实现上略有不同。\n    `browser`：一般来说，会和正常使用浏览器打开样式一致。\n    这里需要说明一下的是当一些系统的浏览器不支持fullscreen时将会显示成 standalone 的效果，当不支持 standalone 属性时，将会显示成 minimal-ui 的效果，以此类推。\n 5. **icons**：指定了应用的桌面图标和启动页图像，用数组表示：\n    `sizes`：图标的大小。通过指定大小，系统会选取最合适的图标展示在相应位置上。\n    `src`：图标的文件路径。相对路径是相对于 manifest.json 文件，也可以使用绝对路径例如http://xxx.png。\n    `type`：图标的图片类型。\n    浏览器会从 icons 中选择最接近 128dp(px = dp * (dpi / 160)) 的图片作为启动画面图像。\n 6. **background_color**：指定了启动画面的背景颜色，采用相同的颜色可以实现从启动画面到首页的平稳过渡，也可以用来改善页面资源正在加载时的用户体验，结合icons属性，可以定义背景颜色+图片icon的启动页效果，类似与Native App的splash screen效果。\n 7. **theme_color**：指定了 Web App 的主题颜色。可以通过该属性来控制浏览器 UI 的颜色。比如状态栏、内容页中状态栏、地址栏的颜色。\n\n当然，这里我们只是列举我我们项目中用到的 manifest.json 相关属性的讲解，更多的参数配置可以参考[MDN](https://developer.mozilla.org/en-US/docs/Web/Manifest)，当然如果你觉得这些配置太过于繁琐，也可以用[Web App Manifest Generator](https://tomitm.github.io/appmanifest/)来实现可视化的配置。\n\n#### 配置iOS系统的页面参数：\n理想很丰满，现实却很骨感，manifest.json 那么强大但是也逃不过浏览器兼容性问题，正如下图 manifest.json 的兼容性：![图片描述](https://user-gold-cdn.xitu.io/2020/5/28/1725a24c19886826?w=2196&h=980&f=png&s=241974)\n由于iOS系统对 manifest.json 是属于部分支持，所以我们需要在head里给配置而外的 meta 属性才能让iOS系统更加完善：\n```html\n <meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\n <meta name=\"apple-mobile-web-app-title\" content=\"WECIRCLE\">\n <link rel=\"apple-touch-icon\" sizes=\"76x76\" href=\"./img/icons/apple-touch-icon-76x76-1.png\" />\n <link rel=\"apple-touch-icon\" sizes=\"152x152\" href=\"./img/icons/apple-touch-icon-152x152.png-1\" />\n <link rel=\"apple-touch-icon\" sizes=\"180x180\" href=\"./img/icons/apple-touch-icon-180x180.png-1\" />\n```\n\n- **apple-touch-icon**:指定了应用的图标，类似与manifest.json文件的icons配置，也是支持sizes属性，来供不同场景的选择。\n- **apple-mobile-web-app-capable**：类似于 manifest.json 中的display的功能，通过设置为yes可以进入standalone模式，目前来说iOS系统还支持这个模式。\n- **apple-mobile-web-app-title**：指定了应用的名称。\n- **apple-mobile-web-app-status-bar-style**：指定了iOS移动设备的状态栏(status bar)的样式，有Default，Black，Black-translucent可以设置。\n \n采用iOS12.0测试下来看，`apple-touch-icon`，`apple-mobile-web-app-status-bar-style`是真实生效的，而 manifest.json 的 icons 则不会被iOS系统识别，下面是iOS系统safari保存到桌面操作的截图：\n \n\n![](https://user-gold-cdn.xitu.io/2020/5/29/1725f7380af29bc7?w=332&h=589&f=jpeg&s=22168)\n在Android的Chrome中：\n\n![](https://user-gold-cdn.xitu.io/2020/5/29/1725f7440dbf5b42?w=332&h=590&f=jpeg&s=30936)\n最后，别忘了将manifest.json文件在html中进行引入：\n```html\n<link rel=\"manifest\" href=\"manifest.json\">\n```\n\n#### 注册和使用Service Worker的缓存功能：\n\n##### 1. 要将Service Worker进行注册：\n在前端项目public文件夹下的index.html中添加如下代码：\n```javascript\nif ('serviceWorker' in navigator) {\n  window.addEventListener('load', function () {\n    navigator.serviceWorker.register('/sw-my.js', {scope: '/'})\n      .then(function (registration) {\n        // 注册成功\n        console.log('ServiceWorker registration successful with scope: ', registration.scope)\n      })\n      .catch(function (err) {\n        // 注册失败:(\n        console.log('ServiceWorker registration failed: ', err)\n      })\n  })\n}\n```\n采用`serviceWorkerContainer.register()`来注册Service Worker，这里要做好容错判断，保证某些机型在不支持Service Worker的情况下可以正常运行，而不会报错。\n\n另外需要注意的是只有在https下，navigator里才会有serviceWorker这个对象。\n##### 2. 在前端项目public文件夹下新建`sw-my.js`，并定义需要缓存的文件路径：\n```javascript\n// 定义需要缓存的文件\nvar cacheFiles = [\n  './lib/weui/weui.min.js',\n  './lib/slider/slider.js',\n  './lib/weui/weui.min.css'\n]\n// 定义缓存的key值\nvar cacheName = '20190301'\n```\n##### 3. 监听install事件，来进行相关文件的缓存操作：\n```javascript\n// 监听install事件，安装完成后，进行文件缓存\nself.addEventListener('install', function (e) {\n  console.log('Service Worker 状态： install')\n\n  // 找到key对应的缓存并且获得可以操作的cache对象\n  var cacheOpenPromise = caches.open(cacheName).then(function (cache) {\n    // 将需要缓存的文件加进来\n    return cache.addAll(cacheFiles)\n  })\n  // 将promise对象传给event\n  e.waitUntil(cacheOpenPromise)\n})\n\n```\n我们在`sw-my.js`里面采用的标准的web worker的编程方式，由于运行在另一个全局上下文中（`self`），这个全局上下文不同于window，所以我们采用`self.addEventListener()`。\n\n[Cache API](https://developer.mozilla.org/zh-CN/docs/Web/API/Cache)是由Service Worker提供用来操作缓存的的接口，这些接口基于Promise来实现，包括了`Cache`和`Cache Storage`，Cache直接和请求打交道，为缓存的 Request / Response  对象对提供存储机制，CacheStorage 表示 Cache 对象的存储实例，我们可以直接使用全局的caches属性访问Cache API。\n\n\n![](https://user-gold-cdn.xitu.io/2020/5/29/1725f76349d16f00?w=332&h=534&f=png&s=45159)\n\nCache相关API说明：\n\n```\nCache.match(request, options) 返回一个 Promise对象，resolve的结果是跟 Cache 对象匹配的第一个已经缓存的请求。\nCache.matchAll(request, options) 返回一个Promise 对象，resolve的结果是跟Cache对象匹配的所有请求组成的数组。\nCache.addAll(requests)接收一个URL数组，检索并把返回的response对象添加到给定的Cache对象。\nCache.delete(request, options)搜索key值为request的Cache 条目。如果找到，则删除该Cache 条目，并且返回一个resolve为true的Promise对象；如果未找到，则返回一个resolve为false的Promise对象。\nCache.keys(request, options)返回一个Promise对象，resolve的结果是Cache对象key值组成的数组。\n```\n##### 4. 监听fetch事件来使用缓存数据：\n\n```javascript\nself.addEventListener('fetch', function (e) {\n  console.log('现在正在请求：' + e.request.url)\n\n  e.respondWith(\n    // 判断当前请求是否需要缓存\n    caches.match(e.request).then(function (cache) {\n      // 有缓存就用缓存，没有就从新发请求获取\n      return cache || fetch(e.request)\n    }).catch(function (err) {\n      console.log(err)\n      // 缓存报错还直接从新发请求获取\n      return fetch(e.request)\n    })\n  )\n})\n```\n上一步我们将相关的资源进行了缓存，那么接下来就要使用这些缓存，这里同样要做好容错逻辑，记住一旦请求被Service Worker接管，浏览器的默认请求就不再生效了，意思就是请求的发与不发，出错与否全部由自己的代码控制，这里一定要做好兼容，当缓存失效或者发生内部错误时，及时调用fetch重新在发起请求。\n正如上面提到的Service Worker的生命周期，fetch事件的触发，必须依赖Service Worker进入`activated`状态，于是来到第五步。\n\n##### 5. 监听activate事件来更新缓存数据：\n使用缓存一个必不可少的步骤就是更新缓存，如果缓存无法更新，那么将毫无意义。\n我们在`sw-my.js`中添加如下代码：\n```javascript\n// 监听activate事件，激活后通过cache的key来判断是否更新cache中的静态资源\nself.addEventListener('activate', function (e) {\n  console.log('Service Worker 状态： activate')\n  var cachePromise = caches.keys().then(function (keys) {\n    // 遍历当前scope使用的key值\n    return Promise.all(keys.map(function (key) {\n      // 如果新获取到的key和之前缓存的key不一致，就删除之前版本的缓存\n      if (key !== cacheName) {\n        return caches.delete(key)\n      }\n    }))\n  })\n  e.waitUntil(cachePromise)\n  // 保证第一次加载fetch触发\n  return self.clients.claim()\n})\n```\n\n- 每当已安装的Service Worker页面被打开时，便会触发Service Worker脚本更新。\n- 当上次脚本更新写入Service Worker数据库的时间戳与本次更新超过24小时，便会触发Service Worker脚本更新。\n- 当sw-my.js文件改变时，便会触发Service Worker脚本更新。\n\n更新流程与安装类似，只是在更新安装成功后不会立即进入`active`状态，更新后的Service Worker会和原始的Service Worker共同存在，并运行它的`install`，一旦新Service Worker安装成功，它会进入wait状态，需要等待旧版本的Service Worker进/线程终止。\n`self.skipWaiting()`可以阻止等待，让新Service Worker安装成功后立即激活。\n`self.clients.claim()`方法来让没被控制的 clients 受控，也就是设置本身为activate的Service Worker。\n![图片描述](https://user-gold-cdn.xitu.io/2020/5/28/1725a24c24d512ec?w=866&h=383&f=png&s=34142)\n\n打开Chrome控制台，点击Application，查看Service Worker状态：\n![图片描述](https://user-gold-cdn.xitu.io/2020/5/28/1725a24c3d74638e?w=1556&h=976&f=png&s=236331)\n\n- status表示当前Service Worker的状态。\n- clients表示当前几个窗口连接这个Service Worker。\n\n这里需要说明是，如果你的浏览器开了多个窗口，那么如果在不调用`self.skipWaiting()`的情况下，必须将窗口关闭在打开才能使Service Worker更新成功。\n\n\n#### 采用offline-plugin插件完善Service Worker：\n上面的我们写的Service Worker逻辑虽然已经完成，但是还有一些不完善的地方，比如，我们每次构建完之后，每个文件的md5都会改变，所以我们每次在写缓存文件列表时，都需要手动的的修改:\n```javascript\nvar cacheFiles = [\n  './static/js/vendor.d70d8829.js'\n  './static/js/app.d70d8869.js'\n]\n```\n这带来的一定的复杂性，那么接下来就利用webpack的[offline-plugin](https://github.com/NekR/offline-plugin)插件来帮助我们完善这些事情，自动生成sw-my.js。\n\n##### 1. 安装offline-plugin插件：\n \n```bash\n   npm install offline-plugin --save\n```\n\n##### 2. 在`vue.config.js`里配置：\n \n```javascript\n   configureWebpack: {\n    plugins: [\n      new OfflinePlugin({\n        // 要求触发ServiceWorker事件回调\n        ServiceWorker: {\n          events: true\n        },\n        // 更更新策略选择全部更新\n        updateStrategy: 'all',\n        // 除去一些不需要缓存的文件\n        excludes: ['**/.*', '**/*.map', '**/*.gz', '**/*.png', '**/*.jpg'],\n\n        // 添加index.html的更新\n        rewrites (asset) {\n          if (asset.indexOf('index.html') > -1) {\n            return './index.html'\n          }\n\n          return asset\n        }\n      })\n    ]\n  }\n```\n\n##### 3. 在前端项目src目录新建`registerServiceWorker.js`里面对Service Worker进行注册：\n\n```javascript\n  import * as OfflinePluginRuntime from 'offline-plugin/runtime'\n  OfflinePluginRuntime.install({\n\n    onUpdateReady: () => {\n      // 更新完成之后，调用applyUpdate即skipwaiting()方法\n      OfflinePluginRuntime.applyUpdate()\n    },\n    onUpdated: () => {\n      //弹一个确认框\n      weui.confirm('发现新版本，是否更新？', ()=>{ \n        // 刷新一下页面\n        window.location.reload()\n      }, ()=>{\n\n      }, {\n          title: ''\n      });\n    }\n\n  })\n```\n当发现Service Worker更新后，弹窗来确认是否更新，如下图：\n![](https://user-gold-cdn.xitu.io/2020/5/29/1725f76fc0001021?w=332&h=590&f=jpeg&s=29318)\n\n这里说明一下：\n\n - 选择了offline-plugin插件之后呢，之前我们手写的注册Service Worker和Service Worker缓存相关逻辑都可以去掉了，因为offline-plugin会帮我们做这些事情。\n - offline-plugin插件会自动扫描webpack构建出来的dist目录里的文件，对这些文件配置缓存列表，正如上面插件里面的配置。\n - `excludes`：指定了一些不需要缓存的文件列表，例如我们不希望对图片资源进行缓存，并且支持正则表达式的方式。\n - `updateStrategy`：指定了缓存策略选择全部更新，另外一种是增量更新`changed`。\n - `event：true`指定了要触发Service Worker事件的回调，这个`main.js`里的配置是相对应的，只有这里设置成true，那边的回调才会触发。\n - 我们在`main.js`里的配置是为了，当Service Worker有更新时，立刻进行更新，而不让Service Worker进入wait状态，这和上面我们讲到的Service Worker更新流程相对应。\n\n\n当让更多的offline-plugin相关配置，也可以去官网看[文档](https://github.com/NekR/offline-plugin/blob/master/docs/options.md)。\n \n在执行npm run build命令之后，就会生成对应`的sw.js`文件，部署之后就可以替换我们之前手写的`sw-my.js`了。\n\n除此之外，我们在PC端的Chrome也可以选择使用安装到桌面的功能，这让我们的程序应用看起来更像是一个桌面应用：\n![图片描述](https://user-gold-cdn.xitu.io/2020/5/28/1725a24c41746b82?w=2408&h=1450&f=png&s=671812)\n\n#### 添加消息推送逻辑：\n消息推送逻辑，主要分为两种方案，一种的非常简单的使用PC的Chrome的开发者工具自带的Push功能，可以通过Application->Service Worker面板->Push按钮来实现，如下图：\n\n![](https://user-gold-cdn.xitu.io/2020/5/29/1725e6820c5e5538?w=880&h=414&f=png&s=43113)\n这种方式只能模拟简单的推送，并且依赖浏览器，大多数作为调试来使用，而真正的为APP添加消息推送，需要结合Web Push协议来实现，同时消息推送主要包括前端逻辑和后端逻辑，其中：\n\n前端逻辑包括：\n- 用户授权订阅逻辑\n- 收到推送后借助Notification通知逻辑\n\n后端逻辑包括：\n- 存储用户授权标识\n- 根据标识向推送服务器发送推送请求\n\n##### 1.前端订阅逻辑\n获取到用户标识呢，要借助与Service Worker，基于Web Push的推送和通知相关全部要用到Service Worker。在之前创建的registerServiceWorker.js中，增加如下代码：\n```javascript\nnavigator.serviceWorker.ready.then((registration) => {\n  //publicKey和后台的publicKey对应保持一致\n\n  const publicKey = 'BAWz0cMW0hw4yYH-DwPrwyIVU0ee3f4oMrt6YLGPaDn3k5MNZtqjpYwUkD7nLz3AJwtgo-kZhB_1pbcmzyTVAxA';//web-push定义的客户端的公钥，用来和后端的web-push对应\n  \n  //获取订阅请求（浏览器会弹出一个确认框，用户是否同意消息推送）\n  try {\n\n      if (window.PushManager) {\n          registration.pushManager.getSubscription().then(subscription => {\n         \n              // 如果用户没有订阅 并且是一个登录用户\n              if (subscription && window.localStorage.getItem('cuser')) {\n\n                const subscription = registration.pushManager.subscribe({\n                  userVisibleOnly: true,//表明该推送是否需要显性地展示给用户，即推送时是否会有消息提醒。如果没有消息提醒就表明是进行“静默”推送。在Chrome中，必须要将其设置为true，否则浏览器就会在控制台报错\n                  applicationServerKey: urlBase64ToUint8Array(publicKey)//web-push定义的客户端的公钥，用来和后端的web-push对应\n                })\n\n                //用户同意\n                .then(function(subscription) {\n                  console.log(subscription)\n                  alert(subscription)\n                  if (subscription && subscription.endpoint) {\n\n                    // 存入数据库\n                    let resp = service.post('users/addsubscription', {\n                      subscription: JSON.stringify(subscription)\n                    })\n                  }\n                })\n\n                //用户不同意或者生成失败\n                .catch(function(err) {\n                    console.log(\"No it didn't. This happened: \", err)\n                  });\n\n              } else {//用户已经订阅过\n                console.log(\"You have subscribed our notification\");\n              }       \n          });   \n      }\n\n\n    }catch(e){\n      console.log(e)\n    }\n\n});\n```\n上面代码的逻辑主要要如下：\n1. 通过`registration.pushManager.getSubscription()`先要确定用户是否已经订阅过，就是是否已经获取过标识，然后得到的`subscription`就是我们要的标识。（后面将`subscription`代替标识）。\n2. 如果用户没有订阅过，通过`registration.pushManager.subscribe()`可以拿到`subscription`，在调用这个方法的时候，浏览器就会询问用户是否接受订阅，也就是会弹一个框：\n![](https://user-gold-cdn.xitu.io/2020/5/29/1725f77e1f609acc?w=332&h=164&f=png&s=25576)\n如果是在手机端，前提是使用Android的Chrome，会收到这样的提示，如图：\n![](https://user-gold-cdn.xitu.io/2020/5/29/1725f78946c2423f?w=332&h=689&f=jpeg&s=33684)\n3. 当我们点击同意，就会获取到`subscription`，然后通过 service 发请求到后台存储。这个`subscription`其实是一个对象，长这样：\n```javascript\n{\n    \"endpoint\": \"https://fcm.googleapis.com/fcm/send/eekuJ6272vI:APA91bEdnUY1cpyTfRFVMUJBx2CNQdA6Qg2FwP0oPibqltHxgZz__2ggmgSpE5bGRoI81cginuT2clRDuqmmmtiqgYiG_WXQtvw83Mv41bJxJj89y1rglr5mvyiyHpBRml_y07uq1pVIc\",\n    \"expirationTime\": null,\n    \"keys\": {\n        \"p256dh\": \"BLcOaaco6_dIjfIo3uiR6nDqERiCUwOuVT1mD5W45V99hvuYoqJxJZzKrKLsgE16zI_DA7o5PXXa8HVZvNz8PHg1\",\n        \"auth\": \"vRqwuyij2AR9qkzUOwP3Pwx\"\n    }\n}\n```\n\n对于每一个客户端来说`subscription`都是唯一的。\n\n##### 2.后端推送逻辑\n后端是基于Node.js的Express框架开发的接口服务，其中推送逻辑包括在内，其他逻辑就不再文章里说明，各位可以直接浏览源码，这里只讲解Web Push的这块推送逻辑。\n由于要存储前端发送的用户标识，所以需要采用数据库来持久化数据，这里使用MongoDB来存储，需要新建一张表`Subscription`。\n在后端项目的models文件夹下新建`Subscription.js`代码如下：\n```javascript\nvar mongoose = require('mongoose');\n\nvar Schema = mongoose.Schema;\n\nvar SubscriptionSchema = new mongoose.Schema({\n  subscription: { type: String,required:true },\n  userid:{ type: String, unique: true },//注意这里不用ref外键\n  update: { type: Date, default: Date.now },\n  create: { type: Date, default: Date.now },\n},{timestamps:{createdAt: 'create',updatedAt:'update'}});\n\nmodule.exports = mongoose.model('Subscription', SubscriptionSchema);\n```\n- **subscription**:字段是一个字符串，我们会将前端传的对象`JSON.stringify()`一下。\n- **userid**：这个字段是标识那个用户，采用`unique:true`表明唯一性，这里不用 ref 外键是为了该字段可空，为了后续可能会给没登录过的用户也推送一些消息。\n\n然后在后端项目中，新增一个基于Express的路由方法：\n```javascript\n/*\n* 添加订阅信息\n*/\nrouter.post('/addsubscription', async (req, res, next)=> {\n  var userid = req.user ? req.user._id : '';\n\n  try {\n    var result = await Subscription.create({\n      subscription: req.body.subscription,\n      userid:userid\n    })\n\n    res.json({\n      code:0,\n      data:result\n    })\n  }catch(e){\n    // console.log(e)\n    res.json({\n      code:0,\n      data: e.errmsg.indexOf('dup key') ? 'has scription' : e.errmsg // 说明用户已经订阅过\n    })\n  }\n\n});\n```\n\n上面代码通过`Subscription.create()`就完成了对一个`subscription`的存储。当存储时发现 userid 已经有过，就会抛出一个错误，就说明这个用户已经订阅过了。\n\n然后，在后端项目的 utils 文件夹下新建`push.js`工具方法，来实现后台推送逻辑，首先安装[web-push](https://www.npmjs.com/package/web-push)，是一个基于Node.js的web-push封装，当然还有基于[Java](https://github.com/web-push-libs/web-push-java)或者[Php](https://github.com/web-push-libs/web-push-php)的：\n\n```bash\nnpm install web-push --save\n```\n然后在`push.js`新增代码，首先需要生成`vapidKeys`，这个就是我们在前端用的那个key，要和这里保持一致，代码如下：\n```javascript\nvar vapidKeys = webpush.generateVAPIDKeys();\n```\n只需要生成一次，然后设置一下，得到之后后面一只用这个就可以，代码如下：\n```javascript\nvar vapidKeys = { publicKey:\n   'BAWz0cMW0hw4yYH-DwPrwyIVU0ee3f4oMrt6YLGPaDn3k5MNZ1tqjpYwUkD7nLz3AJwtgo-kZhB_1pbcmzyTVAxA',\n  privateKey: 'BJ_V2wtPYaVCl7Ef2GAkVxXB2ft9cTgw-b5lM2ggc8lo' };\n\n  webpush.setVapidDetails(\n  'mailto:example@yourdomain.org',//不需要邮箱通知的话这里可以随意填\n  vapidKeys.publicKey,\n  vapidKeys.privateKey\n);\n  ```\n完成这些设置之后，就可以和Push Service通信，来实现推送了，代码如下：\n```javascript\nmodule.exports = async function(userid,data){\n\n  //国内使用的话，需要设置代理才行\n  var option = {\n    proxy: 'http://113.10.152.92:3128'   //http://www.freeproxylists.net/zh/hk.html\n  }\n\n  //从数据库中找到subscription\n  var obj = await Subscription.findOne({\n    userid: userid\n  }).exec();\n  console.log('检查是否有可推送的subscription')\n  console.log(obj)\n  if (obj && obj.subscription) {\n    console.log('找到subscription 可以推送')\n    // 调用webpush的sendNotification来发起推送通知\n    webpush.sendNotification(JSON.parse(obj.subscription), JSON.stringify(data),option).catch(function(err) {\n      console.error(err)\n    });\n  }\n\n} \n```\n\n这里解释一下，由于我们使用的推送服务器是基于谷歌的FCM，这个服务在国内是无法使用的（或者说有时可用有时不可用），所以我们需要设置一个代理，当然网上有很多免费的国外代理，可以在[http://www.freeproxylists.net/zh/hk.html](http://www.freeproxylists.net/zh/hk.html)找找，如果想要稳定一点的可以掏钱买一个 VPN 服务。\n\n##### 3.收到推送后弹出通知\n在收到Push之后如何通知提示呢，这就涉及到[Notification](https://developer.mozilla.org/en-US/docs/Web/API/notification)相关的API了。\n\n接下来，在Service Worker里注册`push`事件来接收`push`请求，在前端项目的public目录下新建一个`sw-push.js`:\n```javascript\n// 添加service worker对push的监听\nself.addEventListener('push', function (e) {\n  var data = e.data\n  if (e.data) {\n    data = data.json()\n      e.waitUntil(\n        self.registration.showNotification(data.title, {\n          body: data.body || '',\n          icon: data.img || \"https://app.nihaoshijie.com.cn/img/icons/apple-touch-icon-180x180-1-touming.png\",\n          actions: [{\n              action: 'go-in',\n              title: '进入程序'\n          }]\n        })\n      );\n    ;\n  } else {\n    console.log('push没有任何数据')\n  }\n})\n```\n当浏览器收到推送通知时，就会进入这个事件里，我们通过`self.registration.showNotification()`\n\n* title：消息的标题，属于必传的值。\n* body：消息的实体，可以不传。\n* icon：配置消息的图片，会出现在消息里面。\n* actions：配置消息的操作项，在结合`notificationclick`事件可以实现消息的点击交互。\n\n就可以弹出一个通知框，前提是你在之前的通知允许中点击了确定：\n\n![](https://user-gold-cdn.xitu.io/2020/5/29/1725f79f0c22be2b?w=332&h=66&f=png&s=17326)\n在手机端是这个样子：\n\n![](https://user-gold-cdn.xitu.io/2020/5/29/1725f7a53080ea29?w=332&h=590&f=jpeg&s=49461)\n\n\n如果想要在手机端或者是PC端收到提示，前端必须满足下面条件：\n1. PC端的Chrome要可以翻墙，也就是能够使用谷歌相关的服务。\n2. 手机端的Chrome要内置了Chrome服务(GMS)，据笔者实验国内的华为，vivo，小米系列基本是没有内置Chrome服务的，而[Nexus](https://www.baidu.com/link?url=nZuqraAz78j_tPKufmQifMOaS7DGYRM_9iQdh6L_l2kWnEwum0kdJcJiRuTidFSw3Dn5rv4ws-FD6Ny9Uv6Pxa&wd=&eqid=8b2ed65c0001716b000000025cfe8839)系列的手机则可以正常使用。能够连接Google Play则代表可以。\n\n你要问我为什么这么多条件？原因是web-push是基于谷歌的[FCM](https://firebase.google.cn/docs/cloud-messaging/concept-options?hl=zh-cn)(云消息机制)实现的推送，而[FCM](https://firebase.google.cn/docs/cloud-messaging/concept-options?hl=zh-cn)包含在GMS里面。知道谷歌禁止国外的华为手机使用谷歌服务有多大影响了吧，连消息都收不到啊。\n\n在 Notification 添加点击事件实现完整消息流程，在`sw-push.js`增加如下代码：\n```javascript\nself.addEventListener('notificationclick', function (e) {\n    var action = e.action;\n    e.waitUntil(\n        // 获取所有clients\n        self.clients.matchAll().then(function (clientList) {\n          if (clientList.length > 0) {\n            return clientList[0].focus();\n          }\n\n          if (action === 'go-in') {\n            return self.clients.openWindow('https://app.nihaoshijie.com.cn/index.html#/mypage');\n          }\n            \n        })\n    );\n    e.notification.close();\n});\n```\n在`self.registration.showNotification()`中，我们传了一个action，这里就对应了消息弹出时，有选项可以选择：\n在PC端：\n\n![](https://user-gold-cdn.xitu.io/2020/5/29/1725f7b4de068f20?w=332&h=139&f=png&s=36416)\n在手机端：\n\n![](https://user-gold-cdn.xitu.io/2020/5/29/1725f7c0c77a0d43?w=332&h=600&f=png&s=126650)\n\n根据上节我们讲的离线APP，收到消息通知的条件不限于你必须打开着APP，经过验证，即使APP已经关闭，同样可以收到推送消息，调用`self.clients.openWindow()`可以将APP呼起来，可以看下图的流程：![图片描述](https://user-gold-cdn.xitu.io/2020/5/29/1725f56d771b11b7?w=314&h=595&f=gif&s=893266)\n\n最后，我们的`sw-push.js`需要配置在 offline-plugin 插件里面进行合并，最终对于Service Worker 只有一个`sw.js`，在`vue.config.js`里修改代码，如下：\n```\n...\n  ServiceWorker: {\n    events: true,\n    // push事件逻辑写在另外一个文件里面\n    entry: './public/sw-push.js'\n  },\n...\n```\n\n### 总结\n本文主要讨论了PWA的相关知识，以及如何将SPA项目改成成一个PWA应用。\n相关知识点：\n1. PWA应用的概念以及PWA应用的特性。\n2. Service Worker的兼容性以及生命周期和事件等基本概念。\n3. Web Push的概念和基本流程。\n4. manifest.json文件的各个配置项作用。\n5. 拦截`fetch`事件，缓存前端静态资源文件的原理。\n6. 结合offline-plugin插件，将项目改造成PWA应用。\n7. 在Node.js里使用Web Push，并推送给前端。\n8. Web Notification的API及相关的配置来提示消息。\n\n\n本文改造的SPA项目完整源代码地址：[Github](https://github.com/lvming6816077/wecircleCode)，\n更多关于PWA技术可关注《HTML5移动web+Vue.js应用开发实战》，新书刚出版感谢支持！\n\n**码字不易，如果本文对你有帮助，动手点个赞！**\n\n\n\n","source":"_posts/PWA技术理论+实战.md","raw":"---\ntitle: PWA技术理论+实战\ndate: 2020-05-31 17:26:17\ntags:\n- PWA\n- 前端\ncategories:\n- 1120\nphotos: https://pic2.zhimg.com/v2-c2ac2c2e0007cd1025836c03d4ad7d24_1440w.jpg?source=172ae18b\n---\n\n\n\n### 导读\n\n随着互联网技术的发展，web应用已经越来越流行，技术的发展越来越迅速，尤其是移动互联网的到来使得HTML5技术，Hybrid混合开发，更加火爆起来，但是web应用没能摆脱PC时代的一些根本性的问题，所需的资源依赖网络下载，用户体验始终要依赖浏览器，这让web应用和Native应用相比尤其在移动手机端的体验，总让人感觉\"不正规\"，而PWA技术的到来，让下一代web应用终于步入正轨！\n\n基于此，本文主要有以下几部分内容：\n\n- PWA基本概念讲解\n- Service Worker原理讲解\n- Web Push协议讲解\n- 将一个SPA项目改造为PWA\n  - manifest.json配置解析\n  - Service Worker资源缓存\n  - 添加保存到桌面功能\n  - 接收消息推送\n- 总结\n\n<!--more-->\n\n### 什么是PWA？\n![图片描述](https://user-gold-cdn.xitu.io/2020/5/28/1725a24c14c71ec6?w=640&h=377&f=png&s=44504)\nPWA(progressing web app)，渐进式网页应用程序，是Google在2016年GoogleI/O大会上提出的下一代web应用模型，并在随后的日子里迅速发展。\n一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后借助于 App Manifest 和 Service Worker 来实现 PWA 的安装和离线等功能。\n\n\n\n### PWA的特点\n - **渐进式**：适用于选用任何浏览器的所有用户，因为它是以渐进式增强作为核心宗旨来开发的。\n - **自适应**：适合任何机型：桌面设备、移动设备、平板电脑或任何未来设备。\n - **连接无关性**：能够借助于服务工作线程在离线或低质量网络状况下工作。\n - **离线推送**：使用推送消息通知，能够让我们的应用像 Native App 一样，提升用户体验。\n - **及时更新**：在服务工作线程更新进程的作用下时刻保持最新状态。\n - **安全性**：通过 HTTPS 提供，以防止窥探和确保内容不被篡改。\n\n对于我们移动端来讲，用简单的一句话来概况一个PWA应用就是，我们开发的H5页面增加可以添加至屏幕的功能，点击主屏幕图标可以实现启动动画以及隐藏地址栏实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能。\n这些特点和功能不正是我们目前针对移动web的优化方向吗，有了这些特性将使得 Web 应用渐进式接近原生 App，真正实现秒开优化。\n\n\n### Service Worker是什么\nService Worker 是一个 基于HTML5 API ，也是PWA技术栈中最重要的特性， 它在 Web Worker 的基础上加上了持久离线缓存和网络代理能力，结合Cache API面向提供了JavaScript来操作浏览器缓存的能力，这使得Service Worker和PWA密不可分。\n#### Service Worker概述：\n\n\n - 一个独立的执行线程，单独的作用域范围，单独的运行环境，有自己独立的context上下文。\n - 一旦被 install，就永远存在，除非被手动 unregister。即使Chrome（浏览器）关闭也会在后台运行。利用这个特性可以实现离线消息推送功能。\n - 处于安全性考虑，必须在 HTTPS 环境下才能工作。当然在本地调试时，使用localhost则不受HTTPS限制。\n - 提供拦截浏览器请求的接口，可以控制打开的作用域范围下所有的页面请求。需要注意的是一旦请求被Service Worker接管，意味着任何请求都由你来控制，一定要做好容错机制，保证页面的正常运行。\n - 由于是独立线程，Service Worker不能直接操作页面 DOM。但可以通过事件机制来处理。例如使用postMessage。\n\n\n#### Service Worker生命周期：\n\n - 注册（register）：这里一般指在浏览器解析到JavaScript有注册Service Worker时的逻辑，即调用navigator.serviceWorker.register()时所处理的事情。\n - 安装中( installing )：这个状态发生在 Service Worker 注册之后，表示开始安装。\n - 安装后( installed/waiting )：Service Worker 已经完成了安装，这时会触发install事件，在这里一般会做一些静态资源的离线缓存。如果还有旧的Service Worker正在运行，会进入waiting状态，如果你关闭当前浏览器，或者调用self.skipWaiting()，方法表示强制当前处在 waiting 状态的 Service Worker 进入 activate 状态。\n - 激活( activating )：表示正在进入activate状态，调用self.clients.claim())会来强制控制未受控制的客户端，例如你的浏览器开了多个含有Service Worker的窗口，会在不切的情况下，替换旧的 Service Worker 脚本不再控制着这些页面，之后会被停止。此时会触发activate事件。\n - 激活后( activated )：在这个状态表示Service Worker激活成功，在activate事件回调中，一般会清除上一个版本的静态资源缓存，或者其他更新缓存的策略。这代表Service Worker已经可以处理功能性的事件fetch (请求)、sync (后台同步)、push (推送)，message（操作dom）。\n - 废弃状态 ( redundant )：这个状态表示一个 Service Worker 的生命周期结束。\n\n\n整个流程可以用下图解释： \n![图片描述](https://user-gold-cdn.xitu.io/2020/5/28/1725a24bf36b2185?w=432&h=672&f=png&s=36756)\n\nService Worker支持的事件：\n![图片描述](https://user-gold-cdn.xitu.io/2020/5/28/1725a24bf0dc3c18?w=573&h=167&f=png&s=6454)\n\n\n#### Service Worker浏览器兼容性：\n![图片描述](https://user-gold-cdn.xitu.io/2020/5/28/1725a24bf378bba3?w=2170&h=1184&f=png&s=291603)\nService Worker作为一个新的技术，那么就必然会有浏览器兼容性问题，从图上可以看到对于大部分的Android来说支持性还是很不错的，尤其是Chrome for Android，但是对于iOS系统而言11.3之前是不支持Service Worker的，这可能也是Service Worker没能普及开来的一个原因，但是好消息是苹果宣布后续会持续更新对Service Worker的支持，那么前景还是很值得期待的。\n\n### 消息推送\n消息推送，顾名思义就是你在手机上收到的某个 APP 的消息推送，相较于移动端 Native 应用，web 应用是缺少这一项常用的功能。而借助 PWA 的 Push 特性，就是用户在打开浏览器时，不需要进入特定的网站，就能收到该网站推送而来的消息，例如：新评论，新动态等等，而借助于 Android 的 Chrome，我们可以实现在用户不打开任何浏览器或者应用的情况下，收到我们项目的推送，就像一个真实的手机推送。\n### 什么是Web Push\n\nWeb Push是一个基于客户端，服务端和推送服务器三者组成的一种流程规范，可以分为三个步骤：\n1. 客户端完成请求订阅一个用户的逻辑。\n2. 服务端调用遵从 web push 协议的接口，传送消息推送（push message）到推送服务器（该服务器由浏览器决定，开发者所能做的只有控制发送的数据）。\n3. 推送服务器将该消息推送至对应的浏览器，用户收到该推送。\n\n下图展示了一个用户订阅的过程：\n![图片描述](https://user-gold-cdn.xitu.io/2020/5/29/1725e621d4f1bfe4?w=800&h=205&f=png&s=50100)\n\n所谓用户订阅，就是说我想要收到你的网站或者你的 APP 的推送通知，我就需要告诉你我是谁，我要把我的标识传给你，否则你怎么知道要给我推送。\n\n下图展示了服务端收到用户订阅请求后如何推送：\n\n![图片描述](https://user-gold-cdn.xitu.io/2020/5/29/1725e621d4f43140?w=817&h=218&f=png&s=27819)\n\n\n1. 首先，在你项目的后台(Your Server)要存储一下用户订阅时传给你的标识。\n2. 在后台需要给你推送的时候，找到这个标识，然后联系推送服务器(Push Service)将内容和标识传给推送服务，然后让推送服务将消息推送给用户端。（iOS和Android各自有自己的推送服务器，这个和操作系统相关）。\n3. 这里就有一个约定，用户的标识，要和推送服务达成一致，例如使用Chrome浏览器，那么推送服务就是谷歌的推送服务[(FCM)](https://firebase.google.cn/docs/cloud-messaging/concept-options?hl=zh-cn)。\n\n### 开始改造现有的SPA应用\n本章节会将一个基于Vue.js2.6版本的SPA项目进行PWA改造，原有项目的开发过程就不再讲解，各位读者可以到[Github](https://github.com/lvming6816077/wecircleCode/tree/master/app)来看源码，最终的体验地址：https://app.nihaoshijie.com.cn，请使用Safari或者Android Chrome打开体验。\n#### 添加manifest.json配置页面参数：\n添加到桌面快捷方式功能本身是PWA应用的一部分，他让我们的应用看起来更像是一个Web App，我们在前端项目的 public 文件夹下新建 manifest.json 文件：\n```json\n{\n    \"name\": \"WECIRCLE\",\n    \"short_name\": \"WECIRCLE\",\n    \"icons\": [\n        {\n          \"src\": \"./img/icons/android-chrome-192x192.png\",\n          \"sizes\": \"192x192\",\n          \"type\": \"image/png\"\n        },\n        {\n          \"src\": \"./img/icons/android-chrome-512x512.png\",\n          \"sizes\": \"512x512\",\n          \"type\": \"image/png\"\n        }\n    ],\n    \"start_url\": \"./index.html\",\n    \"display\": \"standalone\",\n    \"background_color\": \"#000000\",\n    \"theme_color\": \"#181818\"\n}\n```\n其中：\n\n 1. **name**：指定了 Web App 的名称，也就是保存到桌面图标的名称。\n 2. **short_name**：当 name 名称过长时，将会使用 short_name 来代替name显示，也就是 Web App 的简称。\n 3. **start_url**：指定了用户打开该 Web App 时加载的URL。相对URL会相对于 manifest.json 。这里我们指定了 index.html 作为 Web App 的启动页。\n 4. **display**：指定了应用的显示模式，它有四个值可以选择：\n    `fullscreen`：全屏显示，会尽可能将所有的显示区域都占满。\n    `standalone`：浏览器相关UI（如导航栏、工具栏等）将会被隐藏，因此看起来更像一个Native App。\n    `minimal-ui`：显示形式与standalone类似，浏览器相关UI会最小化为一个按钮，不同浏览器在实现上略有不同。\n    `browser`：一般来说，会和正常使用浏览器打开样式一致。\n    这里需要说明一下的是当一些系统的浏览器不支持fullscreen时将会显示成 standalone 的效果，当不支持 standalone 属性时，将会显示成 minimal-ui 的效果，以此类推。\n 5. **icons**：指定了应用的桌面图标和启动页图像，用数组表示：\n    `sizes`：图标的大小。通过指定大小，系统会选取最合适的图标展示在相应位置上。\n    `src`：图标的文件路径。相对路径是相对于 manifest.json 文件，也可以使用绝对路径例如http://xxx.png。\n    `type`：图标的图片类型。\n    浏览器会从 icons 中选择最接近 128dp(px = dp * (dpi / 160)) 的图片作为启动画面图像。\n 6. **background_color**：指定了启动画面的背景颜色，采用相同的颜色可以实现从启动画面到首页的平稳过渡，也可以用来改善页面资源正在加载时的用户体验，结合icons属性，可以定义背景颜色+图片icon的启动页效果，类似与Native App的splash screen效果。\n 7. **theme_color**：指定了 Web App 的主题颜色。可以通过该属性来控制浏览器 UI 的颜色。比如状态栏、内容页中状态栏、地址栏的颜色。\n\n当然，这里我们只是列举我我们项目中用到的 manifest.json 相关属性的讲解，更多的参数配置可以参考[MDN](https://developer.mozilla.org/en-US/docs/Web/Manifest)，当然如果你觉得这些配置太过于繁琐，也可以用[Web App Manifest Generator](https://tomitm.github.io/appmanifest/)来实现可视化的配置。\n\n#### 配置iOS系统的页面参数：\n理想很丰满，现实却很骨感，manifest.json 那么强大但是也逃不过浏览器兼容性问题，正如下图 manifest.json 的兼容性：![图片描述](https://user-gold-cdn.xitu.io/2020/5/28/1725a24c19886826?w=2196&h=980&f=png&s=241974)\n由于iOS系统对 manifest.json 是属于部分支持，所以我们需要在head里给配置而外的 meta 属性才能让iOS系统更加完善：\n```html\n <meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\n <meta name=\"apple-mobile-web-app-title\" content=\"WECIRCLE\">\n <link rel=\"apple-touch-icon\" sizes=\"76x76\" href=\"./img/icons/apple-touch-icon-76x76-1.png\" />\n <link rel=\"apple-touch-icon\" sizes=\"152x152\" href=\"./img/icons/apple-touch-icon-152x152.png-1\" />\n <link rel=\"apple-touch-icon\" sizes=\"180x180\" href=\"./img/icons/apple-touch-icon-180x180.png-1\" />\n```\n\n- **apple-touch-icon**:指定了应用的图标，类似与manifest.json文件的icons配置，也是支持sizes属性，来供不同场景的选择。\n- **apple-mobile-web-app-capable**：类似于 manifest.json 中的display的功能，通过设置为yes可以进入standalone模式，目前来说iOS系统还支持这个模式。\n- **apple-mobile-web-app-title**：指定了应用的名称。\n- **apple-mobile-web-app-status-bar-style**：指定了iOS移动设备的状态栏(status bar)的样式，有Default，Black，Black-translucent可以设置。\n \n采用iOS12.0测试下来看，`apple-touch-icon`，`apple-mobile-web-app-status-bar-style`是真实生效的，而 manifest.json 的 icons 则不会被iOS系统识别，下面是iOS系统safari保存到桌面操作的截图：\n \n\n![](https://user-gold-cdn.xitu.io/2020/5/29/1725f7380af29bc7?w=332&h=589&f=jpeg&s=22168)\n在Android的Chrome中：\n\n![](https://user-gold-cdn.xitu.io/2020/5/29/1725f7440dbf5b42?w=332&h=590&f=jpeg&s=30936)\n最后，别忘了将manifest.json文件在html中进行引入：\n```html\n<link rel=\"manifest\" href=\"manifest.json\">\n```\n\n#### 注册和使用Service Worker的缓存功能：\n\n##### 1. 要将Service Worker进行注册：\n在前端项目public文件夹下的index.html中添加如下代码：\n```javascript\nif ('serviceWorker' in navigator) {\n  window.addEventListener('load', function () {\n    navigator.serviceWorker.register('/sw-my.js', {scope: '/'})\n      .then(function (registration) {\n        // 注册成功\n        console.log('ServiceWorker registration successful with scope: ', registration.scope)\n      })\n      .catch(function (err) {\n        // 注册失败:(\n        console.log('ServiceWorker registration failed: ', err)\n      })\n  })\n}\n```\n采用`serviceWorkerContainer.register()`来注册Service Worker，这里要做好容错判断，保证某些机型在不支持Service Worker的情况下可以正常运行，而不会报错。\n\n另外需要注意的是只有在https下，navigator里才会有serviceWorker这个对象。\n##### 2. 在前端项目public文件夹下新建`sw-my.js`，并定义需要缓存的文件路径：\n```javascript\n// 定义需要缓存的文件\nvar cacheFiles = [\n  './lib/weui/weui.min.js',\n  './lib/slider/slider.js',\n  './lib/weui/weui.min.css'\n]\n// 定义缓存的key值\nvar cacheName = '20190301'\n```\n##### 3. 监听install事件，来进行相关文件的缓存操作：\n```javascript\n// 监听install事件，安装完成后，进行文件缓存\nself.addEventListener('install', function (e) {\n  console.log('Service Worker 状态： install')\n\n  // 找到key对应的缓存并且获得可以操作的cache对象\n  var cacheOpenPromise = caches.open(cacheName).then(function (cache) {\n    // 将需要缓存的文件加进来\n    return cache.addAll(cacheFiles)\n  })\n  // 将promise对象传给event\n  e.waitUntil(cacheOpenPromise)\n})\n\n```\n我们在`sw-my.js`里面采用的标准的web worker的编程方式，由于运行在另一个全局上下文中（`self`），这个全局上下文不同于window，所以我们采用`self.addEventListener()`。\n\n[Cache API](https://developer.mozilla.org/zh-CN/docs/Web/API/Cache)是由Service Worker提供用来操作缓存的的接口，这些接口基于Promise来实现，包括了`Cache`和`Cache Storage`，Cache直接和请求打交道，为缓存的 Request / Response  对象对提供存储机制，CacheStorage 表示 Cache 对象的存储实例，我们可以直接使用全局的caches属性访问Cache API。\n\n\n![](https://user-gold-cdn.xitu.io/2020/5/29/1725f76349d16f00?w=332&h=534&f=png&s=45159)\n\nCache相关API说明：\n\n```\nCache.match(request, options) 返回一个 Promise对象，resolve的结果是跟 Cache 对象匹配的第一个已经缓存的请求。\nCache.matchAll(request, options) 返回一个Promise 对象，resolve的结果是跟Cache对象匹配的所有请求组成的数组。\nCache.addAll(requests)接收一个URL数组，检索并把返回的response对象添加到给定的Cache对象。\nCache.delete(request, options)搜索key值为request的Cache 条目。如果找到，则删除该Cache 条目，并且返回一个resolve为true的Promise对象；如果未找到，则返回一个resolve为false的Promise对象。\nCache.keys(request, options)返回一个Promise对象，resolve的结果是Cache对象key值组成的数组。\n```\n##### 4. 监听fetch事件来使用缓存数据：\n\n```javascript\nself.addEventListener('fetch', function (e) {\n  console.log('现在正在请求：' + e.request.url)\n\n  e.respondWith(\n    // 判断当前请求是否需要缓存\n    caches.match(e.request).then(function (cache) {\n      // 有缓存就用缓存，没有就从新发请求获取\n      return cache || fetch(e.request)\n    }).catch(function (err) {\n      console.log(err)\n      // 缓存报错还直接从新发请求获取\n      return fetch(e.request)\n    })\n  )\n})\n```\n上一步我们将相关的资源进行了缓存，那么接下来就要使用这些缓存，这里同样要做好容错逻辑，记住一旦请求被Service Worker接管，浏览器的默认请求就不再生效了，意思就是请求的发与不发，出错与否全部由自己的代码控制，这里一定要做好兼容，当缓存失效或者发生内部错误时，及时调用fetch重新在发起请求。\n正如上面提到的Service Worker的生命周期，fetch事件的触发，必须依赖Service Worker进入`activated`状态，于是来到第五步。\n\n##### 5. 监听activate事件来更新缓存数据：\n使用缓存一个必不可少的步骤就是更新缓存，如果缓存无法更新，那么将毫无意义。\n我们在`sw-my.js`中添加如下代码：\n```javascript\n// 监听activate事件，激活后通过cache的key来判断是否更新cache中的静态资源\nself.addEventListener('activate', function (e) {\n  console.log('Service Worker 状态： activate')\n  var cachePromise = caches.keys().then(function (keys) {\n    // 遍历当前scope使用的key值\n    return Promise.all(keys.map(function (key) {\n      // 如果新获取到的key和之前缓存的key不一致，就删除之前版本的缓存\n      if (key !== cacheName) {\n        return caches.delete(key)\n      }\n    }))\n  })\n  e.waitUntil(cachePromise)\n  // 保证第一次加载fetch触发\n  return self.clients.claim()\n})\n```\n\n- 每当已安装的Service Worker页面被打开时，便会触发Service Worker脚本更新。\n- 当上次脚本更新写入Service Worker数据库的时间戳与本次更新超过24小时，便会触发Service Worker脚本更新。\n- 当sw-my.js文件改变时，便会触发Service Worker脚本更新。\n\n更新流程与安装类似，只是在更新安装成功后不会立即进入`active`状态，更新后的Service Worker会和原始的Service Worker共同存在，并运行它的`install`，一旦新Service Worker安装成功，它会进入wait状态，需要等待旧版本的Service Worker进/线程终止。\n`self.skipWaiting()`可以阻止等待，让新Service Worker安装成功后立即激活。\n`self.clients.claim()`方法来让没被控制的 clients 受控，也就是设置本身为activate的Service Worker。\n![图片描述](https://user-gold-cdn.xitu.io/2020/5/28/1725a24c24d512ec?w=866&h=383&f=png&s=34142)\n\n打开Chrome控制台，点击Application，查看Service Worker状态：\n![图片描述](https://user-gold-cdn.xitu.io/2020/5/28/1725a24c3d74638e?w=1556&h=976&f=png&s=236331)\n\n- status表示当前Service Worker的状态。\n- clients表示当前几个窗口连接这个Service Worker。\n\n这里需要说明是，如果你的浏览器开了多个窗口，那么如果在不调用`self.skipWaiting()`的情况下，必须将窗口关闭在打开才能使Service Worker更新成功。\n\n\n#### 采用offline-plugin插件完善Service Worker：\n上面的我们写的Service Worker逻辑虽然已经完成，但是还有一些不完善的地方，比如，我们每次构建完之后，每个文件的md5都会改变，所以我们每次在写缓存文件列表时，都需要手动的的修改:\n```javascript\nvar cacheFiles = [\n  './static/js/vendor.d70d8829.js'\n  './static/js/app.d70d8869.js'\n]\n```\n这带来的一定的复杂性，那么接下来就利用webpack的[offline-plugin](https://github.com/NekR/offline-plugin)插件来帮助我们完善这些事情，自动生成sw-my.js。\n\n##### 1. 安装offline-plugin插件：\n \n```bash\n   npm install offline-plugin --save\n```\n\n##### 2. 在`vue.config.js`里配置：\n \n```javascript\n   configureWebpack: {\n    plugins: [\n      new OfflinePlugin({\n        // 要求触发ServiceWorker事件回调\n        ServiceWorker: {\n          events: true\n        },\n        // 更更新策略选择全部更新\n        updateStrategy: 'all',\n        // 除去一些不需要缓存的文件\n        excludes: ['**/.*', '**/*.map', '**/*.gz', '**/*.png', '**/*.jpg'],\n\n        // 添加index.html的更新\n        rewrites (asset) {\n          if (asset.indexOf('index.html') > -1) {\n            return './index.html'\n          }\n\n          return asset\n        }\n      })\n    ]\n  }\n```\n\n##### 3. 在前端项目src目录新建`registerServiceWorker.js`里面对Service Worker进行注册：\n\n```javascript\n  import * as OfflinePluginRuntime from 'offline-plugin/runtime'\n  OfflinePluginRuntime.install({\n\n    onUpdateReady: () => {\n      // 更新完成之后，调用applyUpdate即skipwaiting()方法\n      OfflinePluginRuntime.applyUpdate()\n    },\n    onUpdated: () => {\n      //弹一个确认框\n      weui.confirm('发现新版本，是否更新？', ()=>{ \n        // 刷新一下页面\n        window.location.reload()\n      }, ()=>{\n\n      }, {\n          title: ''\n      });\n    }\n\n  })\n```\n当发现Service Worker更新后，弹窗来确认是否更新，如下图：\n![](https://user-gold-cdn.xitu.io/2020/5/29/1725f76fc0001021?w=332&h=590&f=jpeg&s=29318)\n\n这里说明一下：\n\n - 选择了offline-plugin插件之后呢，之前我们手写的注册Service Worker和Service Worker缓存相关逻辑都可以去掉了，因为offline-plugin会帮我们做这些事情。\n - offline-plugin插件会自动扫描webpack构建出来的dist目录里的文件，对这些文件配置缓存列表，正如上面插件里面的配置。\n - `excludes`：指定了一些不需要缓存的文件列表，例如我们不希望对图片资源进行缓存，并且支持正则表达式的方式。\n - `updateStrategy`：指定了缓存策略选择全部更新，另外一种是增量更新`changed`。\n - `event：true`指定了要触发Service Worker事件的回调，这个`main.js`里的配置是相对应的，只有这里设置成true，那边的回调才会触发。\n - 我们在`main.js`里的配置是为了，当Service Worker有更新时，立刻进行更新，而不让Service Worker进入wait状态，这和上面我们讲到的Service Worker更新流程相对应。\n\n\n当让更多的offline-plugin相关配置，也可以去官网看[文档](https://github.com/NekR/offline-plugin/blob/master/docs/options.md)。\n \n在执行npm run build命令之后，就会生成对应`的sw.js`文件，部署之后就可以替换我们之前手写的`sw-my.js`了。\n\n除此之外，我们在PC端的Chrome也可以选择使用安装到桌面的功能，这让我们的程序应用看起来更像是一个桌面应用：\n![图片描述](https://user-gold-cdn.xitu.io/2020/5/28/1725a24c41746b82?w=2408&h=1450&f=png&s=671812)\n\n#### 添加消息推送逻辑：\n消息推送逻辑，主要分为两种方案，一种的非常简单的使用PC的Chrome的开发者工具自带的Push功能，可以通过Application->Service Worker面板->Push按钮来实现，如下图：\n\n![](https://user-gold-cdn.xitu.io/2020/5/29/1725e6820c5e5538?w=880&h=414&f=png&s=43113)\n这种方式只能模拟简单的推送，并且依赖浏览器，大多数作为调试来使用，而真正的为APP添加消息推送，需要结合Web Push协议来实现，同时消息推送主要包括前端逻辑和后端逻辑，其中：\n\n前端逻辑包括：\n- 用户授权订阅逻辑\n- 收到推送后借助Notification通知逻辑\n\n后端逻辑包括：\n- 存储用户授权标识\n- 根据标识向推送服务器发送推送请求\n\n##### 1.前端订阅逻辑\n获取到用户标识呢，要借助与Service Worker，基于Web Push的推送和通知相关全部要用到Service Worker。在之前创建的registerServiceWorker.js中，增加如下代码：\n```javascript\nnavigator.serviceWorker.ready.then((registration) => {\n  //publicKey和后台的publicKey对应保持一致\n\n  const publicKey = 'BAWz0cMW0hw4yYH-DwPrwyIVU0ee3f4oMrt6YLGPaDn3k5MNZtqjpYwUkD7nLz3AJwtgo-kZhB_1pbcmzyTVAxA';//web-push定义的客户端的公钥，用来和后端的web-push对应\n  \n  //获取订阅请求（浏览器会弹出一个确认框，用户是否同意消息推送）\n  try {\n\n      if (window.PushManager) {\n          registration.pushManager.getSubscription().then(subscription => {\n         \n              // 如果用户没有订阅 并且是一个登录用户\n              if (subscription && window.localStorage.getItem('cuser')) {\n\n                const subscription = registration.pushManager.subscribe({\n                  userVisibleOnly: true,//表明该推送是否需要显性地展示给用户，即推送时是否会有消息提醒。如果没有消息提醒就表明是进行“静默”推送。在Chrome中，必须要将其设置为true，否则浏览器就会在控制台报错\n                  applicationServerKey: urlBase64ToUint8Array(publicKey)//web-push定义的客户端的公钥，用来和后端的web-push对应\n                })\n\n                //用户同意\n                .then(function(subscription) {\n                  console.log(subscription)\n                  alert(subscription)\n                  if (subscription && subscription.endpoint) {\n\n                    // 存入数据库\n                    let resp = service.post('users/addsubscription', {\n                      subscription: JSON.stringify(subscription)\n                    })\n                  }\n                })\n\n                //用户不同意或者生成失败\n                .catch(function(err) {\n                    console.log(\"No it didn't. This happened: \", err)\n                  });\n\n              } else {//用户已经订阅过\n                console.log(\"You have subscribed our notification\");\n              }       \n          });   \n      }\n\n\n    }catch(e){\n      console.log(e)\n    }\n\n});\n```\n上面代码的逻辑主要要如下：\n1. 通过`registration.pushManager.getSubscription()`先要确定用户是否已经订阅过，就是是否已经获取过标识，然后得到的`subscription`就是我们要的标识。（后面将`subscription`代替标识）。\n2. 如果用户没有订阅过，通过`registration.pushManager.subscribe()`可以拿到`subscription`，在调用这个方法的时候，浏览器就会询问用户是否接受订阅，也就是会弹一个框：\n![](https://user-gold-cdn.xitu.io/2020/5/29/1725f77e1f609acc?w=332&h=164&f=png&s=25576)\n如果是在手机端，前提是使用Android的Chrome，会收到这样的提示，如图：\n![](https://user-gold-cdn.xitu.io/2020/5/29/1725f78946c2423f?w=332&h=689&f=jpeg&s=33684)\n3. 当我们点击同意，就会获取到`subscription`，然后通过 service 发请求到后台存储。这个`subscription`其实是一个对象，长这样：\n```javascript\n{\n    \"endpoint\": \"https://fcm.googleapis.com/fcm/send/eekuJ6272vI:APA91bEdnUY1cpyTfRFVMUJBx2CNQdA6Qg2FwP0oPibqltHxgZz__2ggmgSpE5bGRoI81cginuT2clRDuqmmmtiqgYiG_WXQtvw83Mv41bJxJj89y1rglr5mvyiyHpBRml_y07uq1pVIc\",\n    \"expirationTime\": null,\n    \"keys\": {\n        \"p256dh\": \"BLcOaaco6_dIjfIo3uiR6nDqERiCUwOuVT1mD5W45V99hvuYoqJxJZzKrKLsgE16zI_DA7o5PXXa8HVZvNz8PHg1\",\n        \"auth\": \"vRqwuyij2AR9qkzUOwP3Pwx\"\n    }\n}\n```\n\n对于每一个客户端来说`subscription`都是唯一的。\n\n##### 2.后端推送逻辑\n后端是基于Node.js的Express框架开发的接口服务，其中推送逻辑包括在内，其他逻辑就不再文章里说明，各位可以直接浏览源码，这里只讲解Web Push的这块推送逻辑。\n由于要存储前端发送的用户标识，所以需要采用数据库来持久化数据，这里使用MongoDB来存储，需要新建一张表`Subscription`。\n在后端项目的models文件夹下新建`Subscription.js`代码如下：\n```javascript\nvar mongoose = require('mongoose');\n\nvar Schema = mongoose.Schema;\n\nvar SubscriptionSchema = new mongoose.Schema({\n  subscription: { type: String,required:true },\n  userid:{ type: String, unique: true },//注意这里不用ref外键\n  update: { type: Date, default: Date.now },\n  create: { type: Date, default: Date.now },\n},{timestamps:{createdAt: 'create',updatedAt:'update'}});\n\nmodule.exports = mongoose.model('Subscription', SubscriptionSchema);\n```\n- **subscription**:字段是一个字符串，我们会将前端传的对象`JSON.stringify()`一下。\n- **userid**：这个字段是标识那个用户，采用`unique:true`表明唯一性，这里不用 ref 外键是为了该字段可空，为了后续可能会给没登录过的用户也推送一些消息。\n\n然后在后端项目中，新增一个基于Express的路由方法：\n```javascript\n/*\n* 添加订阅信息\n*/\nrouter.post('/addsubscription', async (req, res, next)=> {\n  var userid = req.user ? req.user._id : '';\n\n  try {\n    var result = await Subscription.create({\n      subscription: req.body.subscription,\n      userid:userid\n    })\n\n    res.json({\n      code:0,\n      data:result\n    })\n  }catch(e){\n    // console.log(e)\n    res.json({\n      code:0,\n      data: e.errmsg.indexOf('dup key') ? 'has scription' : e.errmsg // 说明用户已经订阅过\n    })\n  }\n\n});\n```\n\n上面代码通过`Subscription.create()`就完成了对一个`subscription`的存储。当存储时发现 userid 已经有过，就会抛出一个错误，就说明这个用户已经订阅过了。\n\n然后，在后端项目的 utils 文件夹下新建`push.js`工具方法，来实现后台推送逻辑，首先安装[web-push](https://www.npmjs.com/package/web-push)，是一个基于Node.js的web-push封装，当然还有基于[Java](https://github.com/web-push-libs/web-push-java)或者[Php](https://github.com/web-push-libs/web-push-php)的：\n\n```bash\nnpm install web-push --save\n```\n然后在`push.js`新增代码，首先需要生成`vapidKeys`，这个就是我们在前端用的那个key，要和这里保持一致，代码如下：\n```javascript\nvar vapidKeys = webpush.generateVAPIDKeys();\n```\n只需要生成一次，然后设置一下，得到之后后面一只用这个就可以，代码如下：\n```javascript\nvar vapidKeys = { publicKey:\n   'BAWz0cMW0hw4yYH-DwPrwyIVU0ee3f4oMrt6YLGPaDn3k5MNZ1tqjpYwUkD7nLz3AJwtgo-kZhB_1pbcmzyTVAxA',\n  privateKey: 'BJ_V2wtPYaVCl7Ef2GAkVxXB2ft9cTgw-b5lM2ggc8lo' };\n\n  webpush.setVapidDetails(\n  'mailto:example@yourdomain.org',//不需要邮箱通知的话这里可以随意填\n  vapidKeys.publicKey,\n  vapidKeys.privateKey\n);\n  ```\n完成这些设置之后，就可以和Push Service通信，来实现推送了，代码如下：\n```javascript\nmodule.exports = async function(userid,data){\n\n  //国内使用的话，需要设置代理才行\n  var option = {\n    proxy: 'http://113.10.152.92:3128'   //http://www.freeproxylists.net/zh/hk.html\n  }\n\n  //从数据库中找到subscription\n  var obj = await Subscription.findOne({\n    userid: userid\n  }).exec();\n  console.log('检查是否有可推送的subscription')\n  console.log(obj)\n  if (obj && obj.subscription) {\n    console.log('找到subscription 可以推送')\n    // 调用webpush的sendNotification来发起推送通知\n    webpush.sendNotification(JSON.parse(obj.subscription), JSON.stringify(data),option).catch(function(err) {\n      console.error(err)\n    });\n  }\n\n} \n```\n\n这里解释一下，由于我们使用的推送服务器是基于谷歌的FCM，这个服务在国内是无法使用的（或者说有时可用有时不可用），所以我们需要设置一个代理，当然网上有很多免费的国外代理，可以在[http://www.freeproxylists.net/zh/hk.html](http://www.freeproxylists.net/zh/hk.html)找找，如果想要稳定一点的可以掏钱买一个 VPN 服务。\n\n##### 3.收到推送后弹出通知\n在收到Push之后如何通知提示呢，这就涉及到[Notification](https://developer.mozilla.org/en-US/docs/Web/API/notification)相关的API了。\n\n接下来，在Service Worker里注册`push`事件来接收`push`请求，在前端项目的public目录下新建一个`sw-push.js`:\n```javascript\n// 添加service worker对push的监听\nself.addEventListener('push', function (e) {\n  var data = e.data\n  if (e.data) {\n    data = data.json()\n      e.waitUntil(\n        self.registration.showNotification(data.title, {\n          body: data.body || '',\n          icon: data.img || \"https://app.nihaoshijie.com.cn/img/icons/apple-touch-icon-180x180-1-touming.png\",\n          actions: [{\n              action: 'go-in',\n              title: '进入程序'\n          }]\n        })\n      );\n    ;\n  } else {\n    console.log('push没有任何数据')\n  }\n})\n```\n当浏览器收到推送通知时，就会进入这个事件里，我们通过`self.registration.showNotification()`\n\n* title：消息的标题，属于必传的值。\n* body：消息的实体，可以不传。\n* icon：配置消息的图片，会出现在消息里面。\n* actions：配置消息的操作项，在结合`notificationclick`事件可以实现消息的点击交互。\n\n就可以弹出一个通知框，前提是你在之前的通知允许中点击了确定：\n\n![](https://user-gold-cdn.xitu.io/2020/5/29/1725f79f0c22be2b?w=332&h=66&f=png&s=17326)\n在手机端是这个样子：\n\n![](https://user-gold-cdn.xitu.io/2020/5/29/1725f7a53080ea29?w=332&h=590&f=jpeg&s=49461)\n\n\n如果想要在手机端或者是PC端收到提示，前端必须满足下面条件：\n1. PC端的Chrome要可以翻墙，也就是能够使用谷歌相关的服务。\n2. 手机端的Chrome要内置了Chrome服务(GMS)，据笔者实验国内的华为，vivo，小米系列基本是没有内置Chrome服务的，而[Nexus](https://www.baidu.com/link?url=nZuqraAz78j_tPKufmQifMOaS7DGYRM_9iQdh6L_l2kWnEwum0kdJcJiRuTidFSw3Dn5rv4ws-FD6Ny9Uv6Pxa&wd=&eqid=8b2ed65c0001716b000000025cfe8839)系列的手机则可以正常使用。能够连接Google Play则代表可以。\n\n你要问我为什么这么多条件？原因是web-push是基于谷歌的[FCM](https://firebase.google.cn/docs/cloud-messaging/concept-options?hl=zh-cn)(云消息机制)实现的推送，而[FCM](https://firebase.google.cn/docs/cloud-messaging/concept-options?hl=zh-cn)包含在GMS里面。知道谷歌禁止国外的华为手机使用谷歌服务有多大影响了吧，连消息都收不到啊。\n\n在 Notification 添加点击事件实现完整消息流程，在`sw-push.js`增加如下代码：\n```javascript\nself.addEventListener('notificationclick', function (e) {\n    var action = e.action;\n    e.waitUntil(\n        // 获取所有clients\n        self.clients.matchAll().then(function (clientList) {\n          if (clientList.length > 0) {\n            return clientList[0].focus();\n          }\n\n          if (action === 'go-in') {\n            return self.clients.openWindow('https://app.nihaoshijie.com.cn/index.html#/mypage');\n          }\n            \n        })\n    );\n    e.notification.close();\n});\n```\n在`self.registration.showNotification()`中，我们传了一个action，这里就对应了消息弹出时，有选项可以选择：\n在PC端：\n\n![](https://user-gold-cdn.xitu.io/2020/5/29/1725f7b4de068f20?w=332&h=139&f=png&s=36416)\n在手机端：\n\n![](https://user-gold-cdn.xitu.io/2020/5/29/1725f7c0c77a0d43?w=332&h=600&f=png&s=126650)\n\n根据上节我们讲的离线APP，收到消息通知的条件不限于你必须打开着APP，经过验证，即使APP已经关闭，同样可以收到推送消息，调用`self.clients.openWindow()`可以将APP呼起来，可以看下图的流程：![图片描述](https://user-gold-cdn.xitu.io/2020/5/29/1725f56d771b11b7?w=314&h=595&f=gif&s=893266)\n\n最后，我们的`sw-push.js`需要配置在 offline-plugin 插件里面进行合并，最终对于Service Worker 只有一个`sw.js`，在`vue.config.js`里修改代码，如下：\n```\n...\n  ServiceWorker: {\n    events: true,\n    // push事件逻辑写在另外一个文件里面\n    entry: './public/sw-push.js'\n  },\n...\n```\n\n### 总结\n本文主要讨论了PWA的相关知识，以及如何将SPA项目改成成一个PWA应用。\n相关知识点：\n1. PWA应用的概念以及PWA应用的特性。\n2. Service Worker的兼容性以及生命周期和事件等基本概念。\n3. Web Push的概念和基本流程。\n4. manifest.json文件的各个配置项作用。\n5. 拦截`fetch`事件，缓存前端静态资源文件的原理。\n6. 结合offline-plugin插件，将项目改造成PWA应用。\n7. 在Node.js里使用Web Push，并推送给前端。\n8. Web Notification的API及相关的配置来提示消息。\n\n\n本文改造的SPA项目完整源代码地址：[Github](https://github.com/lvming6816077/wecircleCode)，\n更多关于PWA技术可关注《HTML5移动web+Vue.js应用开发实战》，新书刚出版感谢支持！\n\n**码字不易，如果本文对你有帮助，动手点个赞！**\n\n\n\n","slug":"PWA技术理论+实战","published":1,"updated":"2020-07-26T15:11:10.000Z","comments":1,"layout":"post","link":"","_id":"ckx434pzy000u2wvj47jofst0","content":"<h3><span id=\"导读\">导读</span></h3><p>随着互联网技术的发展，web应用已经越来越流行，技术的发展越来越迅速，尤其是移动互联网的到来使得HTML5技术，Hybrid混合开发，更加火爆起来，但是web应用没能摆脱PC时代的一些根本性的问题，所需的资源依赖网络下载，用户体验始终要依赖浏览器，这让web应用和Native应用相比尤其在移动手机端的体验，总让人感觉”不正规”，而PWA技术的到来，让下一代web应用终于步入正轨！</p>\n<p>基于此，本文主要有以下几部分内容：</p>\n<ul>\n<li>PWA基本概念讲解</li>\n<li>Service Worker原理讲解</li>\n<li>Web Push协议讲解</li>\n<li>将一个SPA项目改造为PWA<ul>\n<li>manifest.json配置解析</li>\n<li>Service Worker资源缓存</li>\n<li>添加保存到桌面功能</li>\n<li>接收消息推送</li>\n</ul>\n</li>\n<li>总结</li>\n</ul>\n<a id=\"more\"></a>\n<h3><span id=\"什么是pwa\">什么是PWA？</span></h3><p><img src=\"https://user-gold-cdn.xitu.io/2020/5/28/1725a24c14c71ec6?w=640&amp;h=377&amp;f=png&amp;s=44504\" alt=\"图片描述\"><br>PWA(progressing web app)，渐进式网页应用程序，是Google在2016年GoogleI/O大会上提出的下一代web应用模型，并在随后的日子里迅速发展。<br>一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后借助于 App Manifest 和 Service Worker 来实现 PWA 的安装和离线等功能。</p>\n<h3><span id=\"pwa的特点\">PWA的特点</span></h3><ul>\n<li><strong>渐进式</strong>：适用于选用任何浏览器的所有用户，因为它是以渐进式增强作为核心宗旨来开发的。</li>\n<li><strong>自适应</strong>：适合任何机型：桌面设备、移动设备、平板电脑或任何未来设备。</li>\n<li><strong>连接无关性</strong>：能够借助于服务工作线程在离线或低质量网络状况下工作。</li>\n<li><strong>离线推送</strong>：使用推送消息通知，能够让我们的应用像 Native App 一样，提升用户体验。</li>\n<li><strong>及时更新</strong>：在服务工作线程更新进程的作用下时刻保持最新状态。</li>\n<li><strong>安全性</strong>：通过 HTTPS 提供，以防止窥探和确保内容不被篡改。</li>\n</ul>\n<p>对于我们移动端来讲，用简单的一句话来概况一个PWA应用就是，我们开发的H5页面增加可以添加至屏幕的功能，点击主屏幕图标可以实现启动动画以及隐藏地址栏实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能。<br>这些特点和功能不正是我们目前针对移动web的优化方向吗，有了这些特性将使得 Web 应用渐进式接近原生 App，真正实现秒开优化。</p>\n<h3><span id=\"service-worker是什么\">Service Worker是什么</span></h3><p>Service Worker 是一个 基于HTML5 API ，也是PWA技术栈中最重要的特性， 它在 Web Worker 的基础上加上了持久离线缓存和网络代理能力，结合Cache API面向提供了JavaScript来操作浏览器缓存的能力，这使得Service Worker和PWA密不可分。</p>\n<h4><span id=\"service-worker概述\">Service Worker概述：</span></h4><ul>\n<li>一个独立的执行线程，单独的作用域范围，单独的运行环境，有自己独立的context上下文。</li>\n<li>一旦被 install，就永远存在，除非被手动 unregister。即使Chrome（浏览器）关闭也会在后台运行。利用这个特性可以实现离线消息推送功能。</li>\n<li>处于安全性考虑，必须在 HTTPS 环境下才能工作。当然在本地调试时，使用localhost则不受HTTPS限制。</li>\n<li>提供拦截浏览器请求的接口，可以控制打开的作用域范围下所有的页面请求。需要注意的是一旦请求被Service Worker接管，意味着任何请求都由你来控制，一定要做好容错机制，保证页面的正常运行。</li>\n<li>由于是独立线程，Service Worker不能直接操作页面 DOM。但可以通过事件机制来处理。例如使用postMessage。</li>\n</ul>\n<h4><span id=\"service-worker生命周期\">Service Worker生命周期：</span></h4><ul>\n<li>注册（register）：这里一般指在浏览器解析到JavaScript有注册Service Worker时的逻辑，即调用navigator.serviceWorker.register()时所处理的事情。</li>\n<li>安装中( installing )：这个状态发生在 Service Worker 注册之后，表示开始安装。</li>\n<li>安装后( installed/waiting )：Service Worker 已经完成了安装，这时会触发install事件，在这里一般会做一些静态资源的离线缓存。如果还有旧的Service Worker正在运行，会进入waiting状态，如果你关闭当前浏览器，或者调用self.skipWaiting()，方法表示强制当前处在 waiting 状态的 Service Worker 进入 activate 状态。</li>\n<li>激活( activating )：表示正在进入activate状态，调用self.clients.claim())会来强制控制未受控制的客户端，例如你的浏览器开了多个含有Service Worker的窗口，会在不切的情况下，替换旧的 Service Worker 脚本不再控制着这些页面，之后会被停止。此时会触发activate事件。</li>\n<li>激活后( activated )：在这个状态表示Service Worker激活成功，在activate事件回调中，一般会清除上一个版本的静态资源缓存，或者其他更新缓存的策略。这代表Service Worker已经可以处理功能性的事件fetch (请求)、sync (后台同步)、push (推送)，message（操作dom）。</li>\n<li>废弃状态 ( redundant )：这个状态表示一个 Service Worker 的生命周期结束。</li>\n</ul>\n<p>整个流程可以用下图解释：<br><img src=\"https://user-gold-cdn.xitu.io/2020/5/28/1725a24bf36b2185?w=432&amp;h=672&amp;f=png&amp;s=36756\" alt=\"图片描述\"></p>\n<p>Service Worker支持的事件：<br><img src=\"https://user-gold-cdn.xitu.io/2020/5/28/1725a24bf0dc3c18?w=573&amp;h=167&amp;f=png&amp;s=6454\" alt=\"图片描述\"></p>\n<h4><span id=\"service-worker浏览器兼容性\">Service Worker浏览器兼容性：</span></h4><p><img src=\"https://user-gold-cdn.xitu.io/2020/5/28/1725a24bf378bba3?w=2170&amp;h=1184&amp;f=png&amp;s=291603\" alt=\"图片描述\"><br>Service Worker作为一个新的技术，那么就必然会有浏览器兼容性问题，从图上可以看到对于大部分的Android来说支持性还是很不错的，尤其是Chrome for Android，但是对于iOS系统而言11.3之前是不支持Service Worker的，这可能也是Service Worker没能普及开来的一个原因，但是好消息是苹果宣布后续会持续更新对Service Worker的支持，那么前景还是很值得期待的。</p>\n<h3><span id=\"消息推送\">消息推送</span></h3><p>消息推送，顾名思义就是你在手机上收到的某个 APP 的消息推送，相较于移动端 Native 应用，web 应用是缺少这一项常用的功能。而借助 PWA 的 Push 特性，就是用户在打开浏览器时，不需要进入特定的网站，就能收到该网站推送而来的消息，例如：新评论，新动态等等，而借助于 Android 的 Chrome，我们可以实现在用户不打开任何浏览器或者应用的情况下，收到我们项目的推送，就像一个真实的手机推送。</p>\n<h3><span id=\"什么是web-push\">什么是Web Push</span></h3><p>Web Push是一个基于客户端，服务端和推送服务器三者组成的一种流程规范，可以分为三个步骤：</p>\n<ol>\n<li>客户端完成请求订阅一个用户的逻辑。</li>\n<li>服务端调用遵从 web push 协议的接口，传送消息推送（push message）到推送服务器（该服务器由浏览器决定，开发者所能做的只有控制发送的数据）。</li>\n<li>推送服务器将该消息推送至对应的浏览器，用户收到该推送。</li>\n</ol>\n<p>下图展示了一个用户订阅的过程：<br><img src=\"https://user-gold-cdn.xitu.io/2020/5/29/1725e621d4f1bfe4?w=800&amp;h=205&amp;f=png&amp;s=50100\" alt=\"图片描述\"></p>\n<p>所谓用户订阅，就是说我想要收到你的网站或者你的 APP 的推送通知，我就需要告诉你我是谁，我要把我的标识传给你，否则你怎么知道要给我推送。</p>\n<p>下图展示了服务端收到用户订阅请求后如何推送：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/5/29/1725e621d4f43140?w=817&amp;h=218&amp;f=png&amp;s=27819\" alt=\"图片描述\"></p>\n<ol>\n<li>首先，在你项目的后台(Your Server)要存储一下用户订阅时传给你的标识。</li>\n<li>在后台需要给你推送的时候，找到这个标识，然后联系推送服务器(Push Service)将内容和标识传给推送服务，然后让推送服务将消息推送给用户端。（iOS和Android各自有自己的推送服务器，这个和操作系统相关）。</li>\n<li>这里就有一个约定，用户的标识，要和推送服务达成一致，例如使用Chrome浏览器，那么推送服务就是谷歌的推送服务<a href=\"https://firebase.google.cn/docs/cloud-messaging/concept-options?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">(FCM)</a>。</li>\n</ol>\n<h3><span id=\"开始改造现有的spa应用\">开始改造现有的SPA应用</span></h3><p>本章节会将一个基于Vue.js2.6版本的SPA项目进行PWA改造，原有项目的开发过程就不再讲解，各位读者可以到<a href=\"https://github.com/lvming6816077/wecircleCode/tree/master/app\" target=\"_blank\" rel=\"noopener\">Github</a>来看源码，最终的体验地址：<a href=\"https://app.nihaoshijie.com.cn，请使用Safari或者Android\" target=\"_blank\" rel=\"noopener\">https://app.nihaoshijie.com.cn，请使用Safari或者Android</a> Chrome打开体验。</p>\n<h4><span id=\"添加manifestjson配置页面参数\">添加manifest.json配置页面参数：</span></h4><p>添加到桌面快捷方式功能本身是PWA应用的一部分，他让我们的应用看起来更像是一个Web App，我们在前端项目的 public 文件夹下新建 manifest.json 文件：<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"WECIRCLE\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"short_name\"</span>: <span class=\"string\">\"WECIRCLE\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"icons\"</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"attr\">\"src\"</span>: <span class=\"string\">\"./img/icons/android-chrome-192x192.png\"</span>,</span><br><span class=\"line\">          <span class=\"attr\">\"sizes\"</span>: <span class=\"string\">\"192x192\"</span>,</span><br><span class=\"line\">          <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"image/png\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"attr\">\"src\"</span>: <span class=\"string\">\"./img/icons/android-chrome-512x512.png\"</span>,</span><br><span class=\"line\">          <span class=\"attr\">\"sizes\"</span>: <span class=\"string\">\"512x512\"</span>,</span><br><span class=\"line\">          <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"image/png\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"attr\">\"start_url\"</span>: <span class=\"string\">\"./index.html\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"display\"</span>: <span class=\"string\">\"standalone\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"background_color\"</span>: <span class=\"string\">\"#000000\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"theme_color\"</span>: <span class=\"string\">\"#181818\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中：</p>\n<ol>\n<li><strong>name</strong>：指定了 Web App 的名称，也就是保存到桌面图标的名称。</li>\n<li><strong>short_name</strong>：当 name 名称过长时，将会使用 short_name 来代替name显示，也就是 Web App 的简称。</li>\n<li><strong>start_url</strong>：指定了用户打开该 Web App 时加载的URL。相对URL会相对于 manifest.json 。这里我们指定了 index.html 作为 Web App 的启动页。</li>\n<li><strong>display</strong>：指定了应用的显示模式，它有四个值可以选择：<br><code>fullscreen</code>：全屏显示，会尽可能将所有的显示区域都占满。<br><code>standalone</code>：浏览器相关UI（如导航栏、工具栏等）将会被隐藏，因此看起来更像一个Native App。<br><code>minimal-ui</code>：显示形式与standalone类似，浏览器相关UI会最小化为一个按钮，不同浏览器在实现上略有不同。<br><code>browser</code>：一般来说，会和正常使用浏览器打开样式一致。<br>这里需要说明一下的是当一些系统的浏览器不支持fullscreen时将会显示成 standalone 的效果，当不支持 standalone 属性时，将会显示成 minimal-ui 的效果，以此类推。</li>\n<li><strong>icons</strong>：指定了应用的桌面图标和启动页图像，用数组表示：<br><code>sizes</code>：图标的大小。通过指定大小，系统会选取最合适的图标展示在相应位置上。<br><code>src</code>：图标的文件路径。相对路径是相对于 manifest.json 文件，也可以使用绝对路径例如<a href=\"http://xxx.png。\" target=\"_blank\" rel=\"noopener\">http://xxx.png。</a><br><code>type</code>：图标的图片类型。<br>浏览器会从 icons 中选择最接近 128dp(px = dp * (dpi / 160)) 的图片作为启动画面图像。</li>\n<li><strong>background_color</strong>：指定了启动画面的背景颜色，采用相同的颜色可以实现从启动画面到首页的平稳过渡，也可以用来改善页面资源正在加载时的用户体验，结合icons属性，可以定义背景颜色+图片icon的启动页效果，类似与Native App的splash screen效果。</li>\n<li><strong>theme_color</strong>：指定了 Web App 的主题颜色。可以通过该属性来控制浏览器 UI 的颜色。比如状态栏、内容页中状态栏、地址栏的颜色。</li>\n</ol>\n<p>当然，这里我们只是列举我我们项目中用到的 manifest.json 相关属性的讲解，更多的参数配置可以参考<a href=\"https://developer.mozilla.org/en-US/docs/Web/Manifest\" target=\"_blank\" rel=\"noopener\">MDN</a>，当然如果你觉得这些配置太过于繁琐，也可以用<a href=\"https://tomitm.github.io/appmanifest/\" target=\"_blank\" rel=\"noopener\">Web App Manifest Generator</a>来实现可视化的配置。</p>\n<h4><span id=\"配置ios系统的页面参数\">配置iOS系统的页面参数：</span></h4><p>理想很丰满，现实却很骨感，manifest.json 那么强大但是也逃不过浏览器兼容性问题，正如下图 manifest.json 的兼容性：<img src=\"https://user-gold-cdn.xitu.io/2020/5/28/1725a24c19886826?w=2196&amp;h=980&amp;f=png&amp;s=241974\" alt=\"图片描述\"><br>由于iOS系统对 manifest.json 是属于部分支持，所以我们需要在head里给配置而外的 meta 属性才能让iOS系统更加完善：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"apple-mobile-web-app-capable\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"yes\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"apple-mobile-web-app-title\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"WECIRCLE\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"apple-touch-icon\"</span> <span class=\"attr\">sizes</span>=<span class=\"string\">\"76x76\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"./img/icons/apple-touch-icon-76x76-1.png\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"apple-touch-icon\"</span> <span class=\"attr\">sizes</span>=<span class=\"string\">\"152x152\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"./img/icons/apple-touch-icon-152x152.png-1\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"apple-touch-icon\"</span> <span class=\"attr\">sizes</span>=<span class=\"string\">\"180x180\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"./img/icons/apple-touch-icon-180x180.png-1\"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>apple-touch-icon</strong>:指定了应用的图标，类似与manifest.json文件的icons配置，也是支持sizes属性，来供不同场景的选择。</li>\n<li><strong>apple-mobile-web-app-capable</strong>：类似于 manifest.json 中的display的功能，通过设置为yes可以进入standalone模式，目前来说iOS系统还支持这个模式。</li>\n<li><strong>apple-mobile-web-app-title</strong>：指定了应用的名称。</li>\n<li><strong>apple-mobile-web-app-status-bar-style</strong>：指定了iOS移动设备的状态栏(status bar)的样式，有Default，Black，Black-translucent可以设置。</li>\n</ul>\n<p>采用iOS12.0测试下来看，<code>apple-touch-icon</code>，<code>apple-mobile-web-app-status-bar-style</code>是真实生效的，而 manifest.json 的 icons 则不会被iOS系统识别，下面是iOS系统safari保存到桌面操作的截图：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/5/29/1725f7380af29bc7?w=332&amp;h=589&amp;f=jpeg&amp;s=22168\" alt><br>在Android的Chrome中：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/5/29/1725f7440dbf5b42?w=332&amp;h=590&amp;f=jpeg&amp;s=30936\" alt><br>最后，别忘了将manifest.json文件在html中进行引入：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"manifest\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"manifest.json\"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h4><span id=\"注册和使用service-worker的缓存功能\">注册和使用Service Worker的缓存功能：</span></h4><h5><span id=\"1-要将service-worker进行注册\">1. 要将Service Worker进行注册：</span></h5><p>在前端项目public文件夹下的index.html中添加如下代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"string\">'serviceWorker'</span> <span class=\"keyword\">in</span> navigator) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'load'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    navigator.serviceWorker.register(<span class=\"string\">'/sw-my.js'</span>, &#123;<span class=\"attr\">scope</span>: <span class=\"string\">'/'</span>&#125;)</span><br><span class=\"line\">      .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">registration</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 注册成功</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'ServiceWorker registration successful with scope: '</span>, registration.scope)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 注册失败:(</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'ServiceWorker registration failed: '</span>, err)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>采用<code>serviceWorkerContainer.register()</code>来注册Service Worker，这里要做好容错判断，保证某些机型在不支持Service Worker的情况下可以正常运行，而不会报错。</p>\n<p>另外需要注意的是只有在https下，navigator里才会有serviceWorker这个对象。</p>\n<h5><span id=\"2-在前端项目public文件夹下新建sw-myjs并定义需要缓存的文件路径\">2. 在前端项目public文件夹下新建<code>sw-my.js</code>，并定义需要缓存的文件路径：</span></h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义需要缓存的文件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cacheFiles = [</span><br><span class=\"line\">  <span class=\"string\">'./lib/weui/weui.min.js'</span>,</span><br><span class=\"line\">  <span class=\"string\">'./lib/slider/slider.js'</span>,</span><br><span class=\"line\">  <span class=\"string\">'./lib/weui/weui.min.css'</span></span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"comment\">// 定义缓存的key值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cacheName = <span class=\"string\">'20190301'</span></span><br></pre></td></tr></table></figure>\n<h5><span id=\"3-监听install事件来进行相关文件的缓存操作\">3. 监听install事件，来进行相关文件的缓存操作：</span></h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 监听install事件，安装完成后，进行文件缓存</span></span><br><span class=\"line\">self.addEventListener(<span class=\"string\">'install'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Service Worker 状态： install'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 找到key对应的缓存并且获得可以操作的cache对象</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> cacheOpenPromise = caches.open(cacheName).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">cache</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将需要缓存的文件加进来</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cache.addAll(cacheFiles)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"comment\">// 将promise对象传给event</span></span><br><span class=\"line\">  e.waitUntil(cacheOpenPromise)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>我们在<code>sw-my.js</code>里面采用的标准的web worker的编程方式，由于运行在另一个全局上下文中（<code>self</code>），这个全局上下文不同于window，所以我们采用<code>self.addEventListener()</code>。</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Cache\" target=\"_blank\" rel=\"noopener\">Cache API</a>是由Service Worker提供用来操作缓存的的接口，这些接口基于Promise来实现，包括了<code>Cache</code>和<code>Cache Storage</code>，Cache直接和请求打交道，为缓存的 Request / Response  对象对提供存储机制，CacheStorage 表示 Cache 对象的存储实例，我们可以直接使用全局的caches属性访问Cache API。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/5/29/1725f76349d16f00?w=332&amp;h=534&amp;f=png&amp;s=45159\" alt></p>\n<p>Cache相关API说明：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache.match(request, options) 返回一个 Promise对象，resolve的结果是跟 Cache 对象匹配的第一个已经缓存的请求。</span><br><span class=\"line\">Cache.matchAll(request, options) 返回一个Promise 对象，resolve的结果是跟Cache对象匹配的所有请求组成的数组。</span><br><span class=\"line\">Cache.addAll(requests)接收一个URL数组，检索并把返回的response对象添加到给定的Cache对象。</span><br><span class=\"line\">Cache.delete(request, options)搜索key值为request的Cache 条目。如果找到，则删除该Cache 条目，并且返回一个resolve为true的Promise对象；如果未找到，则返回一个resolve为false的Promise对象。</span><br><span class=\"line\">Cache.keys(request, options)返回一个Promise对象，resolve的结果是Cache对象key值组成的数组。</span><br></pre></td></tr></table></figure>\n<h5><span id=\"4-监听fetch事件来使用缓存数据\">4. 监听fetch事件来使用缓存数据：</span></h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.addEventListener(<span class=\"string\">'fetch'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'现在正在请求：'</span> + e.request.url)</span><br><span class=\"line\"></span><br><span class=\"line\">  e.respondWith(</span><br><span class=\"line\">    <span class=\"comment\">// 判断当前请求是否需要缓存</span></span><br><span class=\"line\">    caches.match(e.request).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">cache</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 有缓存就用缓存，没有就从新发请求获取</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> cache || fetch(e.request)</span><br><span class=\"line\">    &#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">      <span class=\"comment\">// 缓存报错还直接从新发请求获取</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> fetch(e.request)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>上一步我们将相关的资源进行了缓存，那么接下来就要使用这些缓存，这里同样要做好容错逻辑，记住一旦请求被Service Worker接管，浏览器的默认请求就不再生效了，意思就是请求的发与不发，出错与否全部由自己的代码控制，这里一定要做好兼容，当缓存失效或者发生内部错误时，及时调用fetch重新在发起请求。<br>正如上面提到的Service Worker的生命周期，fetch事件的触发，必须依赖Service Worker进入<code>activated</code>状态，于是来到第五步。</p>\n<h5><span id=\"5-监听activate事件来更新缓存数据\">5. 监听activate事件来更新缓存数据：</span></h5><p>使用缓存一个必不可少的步骤就是更新缓存，如果缓存无法更新，那么将毫无意义。<br>我们在<code>sw-my.js</code>中添加如下代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 监听activate事件，激活后通过cache的key来判断是否更新cache中的静态资源</span></span><br><span class=\"line\">self.addEventListener(<span class=\"string\">'activate'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Service Worker 状态： activate'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> cachePromise = caches.keys().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">keys</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历当前scope使用的key值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.all(keys.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果新获取到的key和之前缓存的key不一致，就删除之前版本的缓存</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (key !== cacheName) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> caches.delete(key)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  e.waitUntil(cachePromise)</span><br><span class=\"line\">  <span class=\"comment\">// 保证第一次加载fetch触发</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> self.clients.claim()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>每当已安装的Service Worker页面被打开时，便会触发Service Worker脚本更新。</li>\n<li>当上次脚本更新写入Service Worker数据库的时间戳与本次更新超过24小时，便会触发Service Worker脚本更新。</li>\n<li>当sw-my.js文件改变时，便会触发Service Worker脚本更新。</li>\n</ul>\n<p>更新流程与安装类似，只是在更新安装成功后不会立即进入<code>active</code>状态，更新后的Service Worker会和原始的Service Worker共同存在，并运行它的<code>install</code>，一旦新Service Worker安装成功，它会进入wait状态，需要等待旧版本的Service Worker进/线程终止。<br><code>self.skipWaiting()</code>可以阻止等待，让新Service Worker安装成功后立即激活。<br><code>self.clients.claim()</code>方法来让没被控制的 clients 受控，也就是设置本身为activate的Service Worker。<br><img src=\"https://user-gold-cdn.xitu.io/2020/5/28/1725a24c24d512ec?w=866&amp;h=383&amp;f=png&amp;s=34142\" alt=\"图片描述\"></p>\n<p>打开Chrome控制台，点击Application，查看Service Worker状态：<br><img src=\"https://user-gold-cdn.xitu.io/2020/5/28/1725a24c3d74638e?w=1556&amp;h=976&amp;f=png&amp;s=236331\" alt=\"图片描述\"></p>\n<ul>\n<li>status表示当前Service Worker的状态。</li>\n<li>clients表示当前几个窗口连接这个Service Worker。</li>\n</ul>\n<p>这里需要说明是，如果你的浏览器开了多个窗口，那么如果在不调用<code>self.skipWaiting()</code>的情况下，必须将窗口关闭在打开才能使Service Worker更新成功。</p>\n<h4><span id=\"采用offline-plugin插件完善service-worker\">采用offline-plugin插件完善Service Worker：</span></h4><p>上面的我们写的Service Worker逻辑虽然已经完成，但是还有一些不完善的地方，比如，我们每次构建完之后，每个文件的md5都会改变，所以我们每次在写缓存文件列表时，都需要手动的的修改:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cacheFiles = [</span><br><span class=\"line\">  <span class=\"string\">'./static/js/vendor.d70d8829.js'</span></span><br><span class=\"line\">  <span class=\"string\">'./static/js/app.d70d8869.js'</span></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<p>这带来的一定的复杂性，那么接下来就利用webpack的<a href=\"https://github.com/NekR/offline-plugin\" target=\"_blank\" rel=\"noopener\">offline-plugin</a>插件来帮助我们完善这些事情，自动生成sw-my.js。</p>\n<h5><span id=\"1-安装offline-plugin插件\">1. 安装offline-plugin插件：</span></h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install offline-plugin --save</span><br></pre></td></tr></table></figure>\n<h5><span id=\"2-在vueconfigjs里配置\">2. 在<code>vue.config.js</code>里配置：</span></h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> configureWebpack: &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> OfflinePlugin(&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 要求触发ServiceWorker事件回调</span></span><br><span class=\"line\">      ServiceWorker: &#123;</span><br><span class=\"line\">        events: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"comment\">// 更更新策略选择全部更新</span></span><br><span class=\"line\">      updateStrategy: <span class=\"string\">'all'</span>,</span><br><span class=\"line\">      <span class=\"comment\">// 除去一些不需要缓存的文件</span></span><br><span class=\"line\">      excludes: [<span class=\"string\">'**/.*'</span>, <span class=\"string\">'**/*.map'</span>, <span class=\"string\">'**/*.gz'</span>, <span class=\"string\">'**/*.png'</span>, <span class=\"string\">'**/*.jpg'</span>],</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 添加index.html的更新</span></span><br><span class=\"line\">      rewrites (asset) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (asset.indexOf(<span class=\"string\">'index.html'</span>) &gt; <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"string\">'./index.html'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> asset</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5><span id=\"3-在前端项目src目录新建registerserviceworkerjs里面对service-worker进行注册\">3. 在前端项目src目录新建<code>registerServiceWorker.js</code>里面对Service Worker进行注册：</span></h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> OfflinePluginRuntime <span class=\"keyword\">from</span> <span class=\"string\">'offline-plugin/runtime'</span></span><br><span class=\"line\">OfflinePluginRuntime.install(&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  onUpdateReady: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 更新完成之后，调用applyUpdate即skipwaiting()方法</span></span><br><span class=\"line\">    OfflinePluginRuntime.applyUpdate()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  onUpdated: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//弹一个确认框</span></span><br><span class=\"line\">    weui.confirm(<span class=\"string\">'发现新版本，是否更新？'</span>, ()=&gt;&#123; </span><br><span class=\"line\">      <span class=\"comment\">// 刷新一下页面</span></span><br><span class=\"line\">      <span class=\"built_in\">window</span>.location.reload()</span><br><span class=\"line\">    &#125;, ()=&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        title: <span class=\"string\">''</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>当发现Service Worker更新后，弹窗来确认是否更新，如下图：<br><img src=\"https://user-gold-cdn.xitu.io/2020/5/29/1725f76fc0001021?w=332&amp;h=590&amp;f=jpeg&amp;s=29318\" alt></p>\n<p>这里说明一下：</p>\n<ul>\n<li>选择了offline-plugin插件之后呢，之前我们手写的注册Service Worker和Service Worker缓存相关逻辑都可以去掉了，因为offline-plugin会帮我们做这些事情。</li>\n<li>offline-plugin插件会自动扫描webpack构建出来的dist目录里的文件，对这些文件配置缓存列表，正如上面插件里面的配置。</li>\n<li><code>excludes</code>：指定了一些不需要缓存的文件列表，例如我们不希望对图片资源进行缓存，并且支持正则表达式的方式。</li>\n<li><code>updateStrategy</code>：指定了缓存策略选择全部更新，另外一种是增量更新<code>changed</code>。</li>\n<li><code>event：true</code>指定了要触发Service Worker事件的回调，这个<code>main.js</code>里的配置是相对应的，只有这里设置成true，那边的回调才会触发。</li>\n<li>我们在<code>main.js</code>里的配置是为了，当Service Worker有更新时，立刻进行更新，而不让Service Worker进入wait状态，这和上面我们讲到的Service Worker更新流程相对应。</li>\n</ul>\n<p>当让更多的offline-plugin相关配置，也可以去官网看<a href=\"https://github.com/NekR/offline-plugin/blob/master/docs/options.md\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n<p>在执行npm run build命令之后，就会生成对应<code>的sw.js</code>文件，部署之后就可以替换我们之前手写的<code>sw-my.js</code>了。</p>\n<p>除此之外，我们在PC端的Chrome也可以选择使用安装到桌面的功能，这让我们的程序应用看起来更像是一个桌面应用：<br><img src=\"https://user-gold-cdn.xitu.io/2020/5/28/1725a24c41746b82?w=2408&amp;h=1450&amp;f=png&amp;s=671812\" alt=\"图片描述\"></p>\n<h4><span id=\"添加消息推送逻辑\">添加消息推送逻辑：</span></h4><p>消息推送逻辑，主要分为两种方案，一种的非常简单的使用PC的Chrome的开发者工具自带的Push功能，可以通过Application-&gt;Service Worker面板-&gt;Push按钮来实现，如下图：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/5/29/1725e6820c5e5538?w=880&amp;h=414&amp;f=png&amp;s=43113\" alt><br>这种方式只能模拟简单的推送，并且依赖浏览器，大多数作为调试来使用，而真正的为APP添加消息推送，需要结合Web Push协议来实现，同时消息推送主要包括前端逻辑和后端逻辑，其中：</p>\n<p>前端逻辑包括：</p>\n<ul>\n<li>用户授权订阅逻辑</li>\n<li>收到推送后借助Notification通知逻辑</li>\n</ul>\n<p>后端逻辑包括：</p>\n<ul>\n<li>存储用户授权标识</li>\n<li>根据标识向推送服务器发送推送请求</li>\n</ul>\n<h5><span id=\"1前端订阅逻辑\">1.前端订阅逻辑</span></h5><p>获取到用户标识呢，要借助与Service Worker，基于Web Push的推送和通知相关全部要用到Service Worker。在之前创建的registerServiceWorker.js中，增加如下代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">navigator.serviceWorker.ready.then(<span class=\"function\">(<span class=\"params\">registration</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//publicKey和后台的publicKey对应保持一致</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> publicKey = <span class=\"string\">'BAWz0cMW0hw4yYH-DwPrwyIVU0ee3f4oMrt6YLGPaDn3k5MNZtqjpYwUkD7nLz3AJwtgo-kZhB_1pbcmzyTVAxA'</span>;<span class=\"comment\">//web-push定义的客户端的公钥，用来和后端的web-push对应</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//获取订阅请求（浏览器会弹出一个确认框，用户是否同意消息推送）</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.PushManager) &#123;</span><br><span class=\"line\">          registration.pushManager.getSubscription().then(<span class=\"function\"><span class=\"params\">subscription</span> =&gt;</span> &#123;</span><br><span class=\"line\">         </span><br><span class=\"line\">              <span class=\"comment\">// 如果用户没有订阅 并且是一个登录用户</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (subscription &amp;&amp; <span class=\"built_in\">window</span>.localStorage.getItem(<span class=\"string\">'cuser'</span>)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">const</span> subscription = registration.pushManager.subscribe(&#123;</span><br><span class=\"line\">                  userVisibleOnly: <span class=\"literal\">true</span>,<span class=\"comment\">//表明该推送是否需要显性地展示给用户，即推送时是否会有消息提醒。如果没有消息提醒就表明是进行“静默”推送。在Chrome中，必须要将其设置为true，否则浏览器就会在控制台报错</span></span><br><span class=\"line\">                  applicationServerKey: urlBase64ToUint8Array(publicKey)<span class=\"comment\">//web-push定义的客户端的公钥，用来和后端的web-push对应</span></span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//用户同意</span></span><br><span class=\"line\">                .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">subscription</span>) </span>&#123;</span><br><span class=\"line\">                  <span class=\"built_in\">console</span>.log(subscription)</span><br><span class=\"line\">                  alert(subscription)</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (subscription &amp;&amp; subscription.endpoint) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 存入数据库</span></span><br><span class=\"line\">                    <span class=\"keyword\">let</span> resp = service.post(<span class=\"string\">'users/addsubscription'</span>, &#123;</span><br><span class=\"line\">                      subscription: <span class=\"built_in\">JSON</span>.stringify(subscription)</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//用户不同意或者生成失败</span></span><br><span class=\"line\">                .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"No it didn't. This happened: \"</span>, err)</span><br><span class=\"line\">                  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">              &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//用户已经订阅过</span></span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"You have subscribed our notification\"</span>);</span><br><span class=\"line\">              &#125;       </span><br><span class=\"line\">          &#125;);   </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(e)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(e)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>上面代码的逻辑主要要如下：</p>\n<ol>\n<li>通过<code>registration.pushManager.getSubscription()</code>先要确定用户是否已经订阅过，就是是否已经获取过标识，然后得到的<code>subscription</code>就是我们要的标识。（后面将<code>subscription</code>代替标识）。</li>\n<li>如果用户没有订阅过，通过<code>registration.pushManager.subscribe()</code>可以拿到<code>subscription</code>，在调用这个方法的时候，浏览器就会询问用户是否接受订阅，也就是会弹一个框：<br><img src=\"https://user-gold-cdn.xitu.io/2020/5/29/1725f77e1f609acc?w=332&amp;h=164&amp;f=png&amp;s=25576\" alt><br>如果是在手机端，前提是使用Android的Chrome，会收到这样的提示，如图：<br><img src=\"https://user-gold-cdn.xitu.io/2020/5/29/1725f78946c2423f?w=332&amp;h=689&amp;f=jpeg&amp;s=33684\" alt></li>\n<li>当我们点击同意，就会获取到<code>subscription</code>，然后通过 service 发请求到后台存储。这个<code>subscription</code>其实是一个对象，长这样：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"endpoint\"</span>: <span class=\"string\">\"https://fcm.googleapis.com/fcm/send/eekuJ6272vI:APA91bEdnUY1cpyTfRFVMUJBx2CNQdA6Qg2FwP0oPibqltHxgZz__2ggmgSpE5bGRoI81cginuT2clRDuqmmmtiqgYiG_WXQtvw83Mv41bJxJj89y1rglr5mvyiyHpBRml_y07uq1pVIc\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"expirationTime\"</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"string\">\"keys\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"p256dh\"</span>: <span class=\"string\">\"BLcOaaco6_dIjfIo3uiR6nDqERiCUwOuVT1mD5W45V99hvuYoqJxJZzKrKLsgE16zI_DA7o5PXXa8HVZvNz8PHg1\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"auth\"</span>: <span class=\"string\">\"vRqwuyij2AR9qkzUOwP3Pwx\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>对于每一个客户端来说<code>subscription</code>都是唯一的。</p>\n<h5><span id=\"2后端推送逻辑\">2.后端推送逻辑</span></h5><p>后端是基于Node.js的Express框架开发的接口服务，其中推送逻辑包括在内，其他逻辑就不再文章里说明，各位可以直接浏览源码，这里只讲解Web Push的这块推送逻辑。<br>由于要存储前端发送的用户标识，所以需要采用数据库来持久化数据，这里使用MongoDB来存储，需要新建一张表<code>Subscription</code>。<br>在后端项目的models文件夹下新建<code>Subscription.js</code>代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'mongoose'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Schema = mongoose.Schema;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> SubscriptionSchema = <span class=\"keyword\">new</span> mongoose.Schema(&#123;</span><br><span class=\"line\">  subscription: &#123; <span class=\"attr\">type</span>: <span class=\"built_in\">String</span>,<span class=\"attr\">required</span>:<span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">  userid:&#123; <span class=\"attr\">type</span>: <span class=\"built_in\">String</span>, <span class=\"attr\">unique</span>: <span class=\"literal\">true</span> &#125;,<span class=\"comment\">//注意这里不用ref外键</span></span><br><span class=\"line\">  update: &#123; <span class=\"attr\">type</span>: <span class=\"built_in\">Date</span>, <span class=\"attr\">default</span>: <span class=\"built_in\">Date</span>.now &#125;,</span><br><span class=\"line\">  create: &#123; <span class=\"attr\">type</span>: <span class=\"built_in\">Date</span>, <span class=\"attr\">default</span>: <span class=\"built_in\">Date</span>.now &#125;,</span><br><span class=\"line\">&#125;,&#123;<span class=\"attr\">timestamps</span>:&#123;<span class=\"attr\">createdAt</span>: <span class=\"string\">'create'</span>,<span class=\"attr\">updatedAt</span>:<span class=\"string\">'update'</span>&#125;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = mongoose.model(<span class=\"string\">'Subscription'</span>, SubscriptionSchema);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>subscription</strong>:字段是一个字符串，我们会将前端传的对象<code>JSON.stringify()</code>一下。</li>\n<li><strong>userid</strong>：这个字段是标识那个用户，采用<code>unique:true</code>表明唯一性，这里不用 ref 外键是为了该字段可空，为了后续可能会给没登录过的用户也推送一些消息。</li>\n</ul>\n<p>然后在后端项目中，新增一个基于Express的路由方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 添加订阅信息</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">router.post(<span class=\"string\">'/addsubscription'</span>, <span class=\"keyword\">async</span> (req, res, next)=&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> userid = req.user ? req.user._id : <span class=\"string\">''</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = <span class=\"keyword\">await</span> Subscription.create(&#123;</span><br><span class=\"line\">      subscription: req.body.subscription,</span><br><span class=\"line\">      userid:userid</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    res.json(&#123;</span><br><span class=\"line\">      code:<span class=\"number\">0</span>,</span><br><span class=\"line\">      data:result</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;<span class=\"keyword\">catch</span>(e)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// console.log(e)</span></span><br><span class=\"line\">    res.json(&#123;</span><br><span class=\"line\">      code:<span class=\"number\">0</span>,</span><br><span class=\"line\">      data: e.errmsg.indexOf(<span class=\"string\">'dup key'</span>) ? <span class=\"string\">'has scription'</span> : e.errmsg <span class=\"comment\">// 说明用户已经订阅过</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>上面代码通过<code>Subscription.create()</code>就完成了对一个<code>subscription</code>的存储。当存储时发现 userid 已经有过，就会抛出一个错误，就说明这个用户已经订阅过了。</p>\n<p>然后，在后端项目的 utils 文件夹下新建<code>push.js</code>工具方法，来实现后台推送逻辑，首先安装<a href=\"https://www.npmjs.com/package/web-push\" target=\"_blank\" rel=\"noopener\">web-push</a>，是一个基于Node.js的web-push封装，当然还有基于<a href=\"https://github.com/web-push-libs/web-push-java\" target=\"_blank\" rel=\"noopener\">Java</a>或者<a href=\"https://github.com/web-push-libs/web-push-php\" target=\"_blank\" rel=\"noopener\">Php</a>的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install web-push --save</span><br></pre></td></tr></table></figure>\n<p>然后在<code>push.js</code>新增代码，首先需要生成<code>vapidKeys</code>，这个就是我们在前端用的那个key，要和这里保持一致，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vapidKeys = webpush.generateVAPIDKeys();</span><br></pre></td></tr></table></figure></p>\n<p>只需要生成一次，然后设置一下，得到之后后面一只用这个就可以，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vapidKeys = &#123; <span class=\"attr\">publicKey</span>:</span><br><span class=\"line\">   <span class=\"string\">'BAWz0cMW0hw4yYH-DwPrwyIVU0ee3f4oMrt6YLGPaDn3k5MNZ1tqjpYwUkD7nLz3AJwtgo-kZhB_1pbcmzyTVAxA'</span>,</span><br><span class=\"line\">  privateKey: <span class=\"string\">'BJ_V2wtPYaVCl7Ef2GAkVxXB2ft9cTgw-b5lM2ggc8lo'</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  webpush.setVapidDetails(</span><br><span class=\"line\">  <span class=\"string\">'mailto:example@yourdomain.org'</span>,<span class=\"comment\">//不需要邮箱通知的话这里可以随意填</span></span><br><span class=\"line\">  vapidKeys.publicKey,</span><br><span class=\"line\">  vapidKeys.privateKey</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>完成这些设置之后，就可以和Push Service通信，来实现推送了，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">userid,data</span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//国内使用的话，需要设置代理才行</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> option = &#123;</span><br><span class=\"line\">    proxy: <span class=\"string\">'http://113.10.152.92:3128'</span>   <span class=\"comment\">//http://www.freeproxylists.net/zh/hk.html</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//从数据库中找到subscription</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> obj = <span class=\"keyword\">await</span> Subscription.findOne(&#123;</span><br><span class=\"line\">    userid: userid</span><br><span class=\"line\">  &#125;).exec();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'检查是否有可推送的subscription'</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(obj)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj &amp;&amp; obj.subscription) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'找到subscription 可以推送'</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 调用webpush的sendNotification来发起推送通知</span></span><br><span class=\"line\">    webpush.sendNotification(<span class=\"built_in\">JSON</span>.parse(obj.subscription), <span class=\"built_in\">JSON</span>.stringify(data),option).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(err)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里解释一下，由于我们使用的推送服务器是基于谷歌的FCM，这个服务在国内是无法使用的（或者说有时可用有时不可用），所以我们需要设置一个代理，当然网上有很多免费的国外代理，可以在<a href=\"http://www.freeproxylists.net/zh/hk.html\" target=\"_blank\" rel=\"noopener\">http://www.freeproxylists.net/zh/hk.html</a>找找，如果想要稳定一点的可以掏钱买一个 VPN 服务。</p>\n<h5><span id=\"3收到推送后弹出通知\">3.收到推送后弹出通知</span></h5><p>在收到Push之后如何通知提示呢，这就涉及到<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/notification\" target=\"_blank\" rel=\"noopener\">Notification</a>相关的API了。</p>\n<p>接下来，在Service Worker里注册<code>push</code>事件来接收<code>push</code>请求，在前端项目的public目录下新建一个<code>sw-push.js</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加service worker对push的监听</span></span><br><span class=\"line\">self.addEventListener(<span class=\"string\">'push'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> data = e.data</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (e.data) &#123;</span><br><span class=\"line\">    data = data.json()</span><br><span class=\"line\">      e.waitUntil(</span><br><span class=\"line\">        self.registration.showNotification(data.title, &#123;</span><br><span class=\"line\">          body: data.body || <span class=\"string\">''</span>,</span><br><span class=\"line\">          icon: data.img || <span class=\"string\">\"https://app.nihaoshijie.com.cn/img/icons/apple-touch-icon-180x180-1-touming.png\"</span>,</span><br><span class=\"line\">          actions: [&#123;</span><br><span class=\"line\">              action: <span class=\"string\">'go-in'</span>,</span><br><span class=\"line\">              title: <span class=\"string\">'进入程序'</span></span><br><span class=\"line\">          &#125;]</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      );</span><br><span class=\"line\">    ;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'push没有任何数据'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>当浏览器收到推送通知时，就会进入这个事件里，我们通过<code>self.registration.showNotification()</code></p>\n<ul>\n<li>title：消息的标题，属于必传的值。</li>\n<li>body：消息的实体，可以不传。</li>\n<li>icon：配置消息的图片，会出现在消息里面。</li>\n<li>actions：配置消息的操作项，在结合<code>notificationclick</code>事件可以实现消息的点击交互。</li>\n</ul>\n<p>就可以弹出一个通知框，前提是你在之前的通知允许中点击了确定：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/5/29/1725f79f0c22be2b?w=332&amp;h=66&amp;f=png&amp;s=17326\" alt><br>在手机端是这个样子：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/5/29/1725f7a53080ea29?w=332&amp;h=590&amp;f=jpeg&amp;s=49461\" alt></p>\n<p>如果想要在手机端或者是PC端收到提示，前端必须满足下面条件：</p>\n<ol>\n<li>PC端的Chrome要可以翻墙，也就是能够使用谷歌相关的服务。</li>\n<li>手机端的Chrome要内置了Chrome服务(GMS)，据笔者实验国内的华为，vivo，小米系列基本是没有内置Chrome服务的，而<a href=\"https://www.baidu.com/link?url=nZuqraAz78j_tPKufmQifMOaS7DGYRM_9iQdh6L_l2kWnEwum0kdJcJiRuTidFSw3Dn5rv4ws-FD6Ny9Uv6Pxa&amp;wd=&amp;eqid=8b2ed65c0001716b000000025cfe8839\" target=\"_blank\" rel=\"noopener\">Nexus</a>系列的手机则可以正常使用。能够连接Google Play则代表可以。</li>\n</ol>\n<p>你要问我为什么这么多条件？原因是web-push是基于谷歌的<a href=\"https://firebase.google.cn/docs/cloud-messaging/concept-options?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">FCM</a>(云消息机制)实现的推送，而<a href=\"https://firebase.google.cn/docs/cloud-messaging/concept-options?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">FCM</a>包含在GMS里面。知道谷歌禁止国外的华为手机使用谷歌服务有多大影响了吧，连消息都收不到啊。</p>\n<p>在 Notification 添加点击事件实现完整消息流程，在<code>sw-push.js</code>增加如下代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.addEventListener(<span class=\"string\">'notificationclick'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> action = e.action;</span><br><span class=\"line\">    e.waitUntil(</span><br><span class=\"line\">        <span class=\"comment\">// 获取所有clients</span></span><br><span class=\"line\">        self.clients.matchAll().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">clientList</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (clientList.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> clientList[<span class=\"number\">0</span>].focus();</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (action === <span class=\"string\">'go-in'</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.clients.openWindow(<span class=\"string\">'https://app.nihaoshijie.com.cn/index.html#/mypage'</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    );</span><br><span class=\"line\">    e.notification.close();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>在<code>self.registration.showNotification()</code>中，我们传了一个action，这里就对应了消息弹出时，有选项可以选择：<br>在PC端：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/5/29/1725f7b4de068f20?w=332&amp;h=139&amp;f=png&amp;s=36416\" alt><br>在手机端：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/5/29/1725f7c0c77a0d43?w=332&amp;h=600&amp;f=png&amp;s=126650\" alt></p>\n<p>根据上节我们讲的离线APP，收到消息通知的条件不限于你必须打开着APP，经过验证，即使APP已经关闭，同样可以收到推送消息，调用<code>self.clients.openWindow()</code>可以将APP呼起来，可以看下图的流程：<img src=\"https://user-gold-cdn.xitu.io/2020/5/29/1725f56d771b11b7?w=314&amp;h=595&amp;f=gif&amp;s=893266\" alt=\"图片描述\"></p>\n<p>最后，我们的<code>sw-push.js</code>需要配置在 offline-plugin 插件里面进行合并，最终对于Service Worker 只有一个<code>sw.js</code>，在<code>vue.config.js</code>里修改代码，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">  ServiceWorker: &#123;</span><br><span class=\"line\">    events: true,</span><br><span class=\"line\">    // push事件逻辑写在另外一个文件里面</span><br><span class=\"line\">    entry: &apos;./public/sw-push.js&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<h3><span id=\"总结\">总结</span></h3><p>本文主要讨论了PWA的相关知识，以及如何将SPA项目改成成一个PWA应用。<br>相关知识点：</p>\n<ol>\n<li>PWA应用的概念以及PWA应用的特性。</li>\n<li>Service Worker的兼容性以及生命周期和事件等基本概念。</li>\n<li>Web Push的概念和基本流程。</li>\n<li>manifest.json文件的各个配置项作用。</li>\n<li>拦截<code>fetch</code>事件，缓存前端静态资源文件的原理。</li>\n<li>结合offline-plugin插件，将项目改造成PWA应用。</li>\n<li>在Node.js里使用Web Push，并推送给前端。</li>\n<li>Web Notification的API及相关的配置来提示消息。</li>\n</ol>\n<p>本文改造的SPA项目完整源代码地址：<a href=\"https://github.com/lvming6816077/wecircleCode\" target=\"_blank\" rel=\"noopener\">Github</a>，<br>更多关于PWA技术可关注《HTML5移动web+Vue.js应用开发实战》，新书刚出版感谢支持！</p>\n<p><strong>码字不易，如果本文对你有帮助，动手点个赞！</strong></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"导读\"><a href=\"#导读\" class=\"headerlink\" title=\"导读\"></a>导读</h3><p>随着互联网技术的发展，web应用已经越来越流行，技术的发展越来越迅速，尤其是移动互联网的到来使得HTML5技术，Hybrid混合开发，更加火爆起来，但是web应用没能摆脱PC时代的一些根本性的问题，所需的资源依赖网络下载，用户体验始终要依赖浏览器，这让web应用和Native应用相比尤其在移动手机端的体验，总让人感觉”不正规”，而PWA技术的到来，让下一代web应用终于步入正轨！</p>\n<p>基于此，本文主要有以下几部分内容：</p>\n<ul>\n<li>PWA基本概念讲解</li>\n<li>Service Worker原理讲解</li>\n<li>Web Push协议讲解</li>\n<li>将一个SPA项目改造为PWA<ul>\n<li>manifest.json配置解析</li>\n<li>Service Worker资源缓存</li>\n<li>添加保存到桌面功能</li>\n<li>接收消息推送</li>\n</ul>\n</li>\n<li>总结</li>\n</ul>","more":"<h3 id=\"什么是PWA？\"><a href=\"#什么是PWA？\" class=\"headerlink\" title=\"什么是PWA？\"></a>什么是PWA？</h3><p><img src=\"https://user-gold-cdn.xitu.io/2020/5/28/1725a24c14c71ec6?w=640&amp;h=377&amp;f=png&amp;s=44504\" alt=\"图片描述\"><br>PWA(progressing web app)，渐进式网页应用程序，是Google在2016年GoogleI/O大会上提出的下一代web应用模型，并在随后的日子里迅速发展。<br>一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后借助于 App Manifest 和 Service Worker 来实现 PWA 的安装和离线等功能。</p>\n<h3 id=\"PWA的特点\"><a href=\"#PWA的特点\" class=\"headerlink\" title=\"PWA的特点\"></a>PWA的特点</h3><ul>\n<li><strong>渐进式</strong>：适用于选用任何浏览器的所有用户，因为它是以渐进式增强作为核心宗旨来开发的。</li>\n<li><strong>自适应</strong>：适合任何机型：桌面设备、移动设备、平板电脑或任何未来设备。</li>\n<li><strong>连接无关性</strong>：能够借助于服务工作线程在离线或低质量网络状况下工作。</li>\n<li><strong>离线推送</strong>：使用推送消息通知，能够让我们的应用像 Native App 一样，提升用户体验。</li>\n<li><strong>及时更新</strong>：在服务工作线程更新进程的作用下时刻保持最新状态。</li>\n<li><strong>安全性</strong>：通过 HTTPS 提供，以防止窥探和确保内容不被篡改。</li>\n</ul>\n<p>对于我们移动端来讲，用简单的一句话来概况一个PWA应用就是，我们开发的H5页面增加可以添加至屏幕的功能，点击主屏幕图标可以实现启动动画以及隐藏地址栏实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能。<br>这些特点和功能不正是我们目前针对移动web的优化方向吗，有了这些特性将使得 Web 应用渐进式接近原生 App，真正实现秒开优化。</p>\n<h3 id=\"Service-Worker是什么\"><a href=\"#Service-Worker是什么\" class=\"headerlink\" title=\"Service Worker是什么\"></a>Service Worker是什么</h3><p>Service Worker 是一个 基于HTML5 API ，也是PWA技术栈中最重要的特性， 它在 Web Worker 的基础上加上了持久离线缓存和网络代理能力，结合Cache API面向提供了JavaScript来操作浏览器缓存的能力，这使得Service Worker和PWA密不可分。</p>\n<h4 id=\"Service-Worker概述：\"><a href=\"#Service-Worker概述：\" class=\"headerlink\" title=\"Service Worker概述：\"></a>Service Worker概述：</h4><ul>\n<li>一个独立的执行线程，单独的作用域范围，单独的运行环境，有自己独立的context上下文。</li>\n<li>一旦被 install，就永远存在，除非被手动 unregister。即使Chrome（浏览器）关闭也会在后台运行。利用这个特性可以实现离线消息推送功能。</li>\n<li>处于安全性考虑，必须在 HTTPS 环境下才能工作。当然在本地调试时，使用localhost则不受HTTPS限制。</li>\n<li>提供拦截浏览器请求的接口，可以控制打开的作用域范围下所有的页面请求。需要注意的是一旦请求被Service Worker接管，意味着任何请求都由你来控制，一定要做好容错机制，保证页面的正常运行。</li>\n<li>由于是独立线程，Service Worker不能直接操作页面 DOM。但可以通过事件机制来处理。例如使用postMessage。</li>\n</ul>\n<h4 id=\"Service-Worker生命周期：\"><a href=\"#Service-Worker生命周期：\" class=\"headerlink\" title=\"Service Worker生命周期：\"></a>Service Worker生命周期：</h4><ul>\n<li>注册（register）：这里一般指在浏览器解析到JavaScript有注册Service Worker时的逻辑，即调用navigator.serviceWorker.register()时所处理的事情。</li>\n<li>安装中( installing )：这个状态发生在 Service Worker 注册之后，表示开始安装。</li>\n<li>安装后( installed/waiting )：Service Worker 已经完成了安装，这时会触发install事件，在这里一般会做一些静态资源的离线缓存。如果还有旧的Service Worker正在运行，会进入waiting状态，如果你关闭当前浏览器，或者调用self.skipWaiting()，方法表示强制当前处在 waiting 状态的 Service Worker 进入 activate 状态。</li>\n<li>激活( activating )：表示正在进入activate状态，调用self.clients.claim())会来强制控制未受控制的客户端，例如你的浏览器开了多个含有Service Worker的窗口，会在不切的情况下，替换旧的 Service Worker 脚本不再控制着这些页面，之后会被停止。此时会触发activate事件。</li>\n<li>激活后( activated )：在这个状态表示Service Worker激活成功，在activate事件回调中，一般会清除上一个版本的静态资源缓存，或者其他更新缓存的策略。这代表Service Worker已经可以处理功能性的事件fetch (请求)、sync (后台同步)、push (推送)，message（操作dom）。</li>\n<li>废弃状态 ( redundant )：这个状态表示一个 Service Worker 的生命周期结束。</li>\n</ul>\n<p>整个流程可以用下图解释：<br><img src=\"https://user-gold-cdn.xitu.io/2020/5/28/1725a24bf36b2185?w=432&amp;h=672&amp;f=png&amp;s=36756\" alt=\"图片描述\"></p>\n<p>Service Worker支持的事件：<br><img src=\"https://user-gold-cdn.xitu.io/2020/5/28/1725a24bf0dc3c18?w=573&amp;h=167&amp;f=png&amp;s=6454\" alt=\"图片描述\"></p>\n<h4 id=\"Service-Worker浏览器兼容性：\"><a href=\"#Service-Worker浏览器兼容性：\" class=\"headerlink\" title=\"Service Worker浏览器兼容性：\"></a>Service Worker浏览器兼容性：</h4><p><img src=\"https://user-gold-cdn.xitu.io/2020/5/28/1725a24bf378bba3?w=2170&amp;h=1184&amp;f=png&amp;s=291603\" alt=\"图片描述\"><br>Service Worker作为一个新的技术，那么就必然会有浏览器兼容性问题，从图上可以看到对于大部分的Android来说支持性还是很不错的，尤其是Chrome for Android，但是对于iOS系统而言11.3之前是不支持Service Worker的，这可能也是Service Worker没能普及开来的一个原因，但是好消息是苹果宣布后续会持续更新对Service Worker的支持，那么前景还是很值得期待的。</p>\n<h3 id=\"消息推送\"><a href=\"#消息推送\" class=\"headerlink\" title=\"消息推送\"></a>消息推送</h3><p>消息推送，顾名思义就是你在手机上收到的某个 APP 的消息推送，相较于移动端 Native 应用，web 应用是缺少这一项常用的功能。而借助 PWA 的 Push 特性，就是用户在打开浏览器时，不需要进入特定的网站，就能收到该网站推送而来的消息，例如：新评论，新动态等等，而借助于 Android 的 Chrome，我们可以实现在用户不打开任何浏览器或者应用的情况下，收到我们项目的推送，就像一个真实的手机推送。</p>\n<h3 id=\"什么是Web-Push\"><a href=\"#什么是Web-Push\" class=\"headerlink\" title=\"什么是Web Push\"></a>什么是Web Push</h3><p>Web Push是一个基于客户端，服务端和推送服务器三者组成的一种流程规范，可以分为三个步骤：</p>\n<ol>\n<li>客户端完成请求订阅一个用户的逻辑。</li>\n<li>服务端调用遵从 web push 协议的接口，传送消息推送（push message）到推送服务器（该服务器由浏览器决定，开发者所能做的只有控制发送的数据）。</li>\n<li>推送服务器将该消息推送至对应的浏览器，用户收到该推送。</li>\n</ol>\n<p>下图展示了一个用户订阅的过程：<br><img src=\"https://user-gold-cdn.xitu.io/2020/5/29/1725e621d4f1bfe4?w=800&amp;h=205&amp;f=png&amp;s=50100\" alt=\"图片描述\"></p>\n<p>所谓用户订阅，就是说我想要收到你的网站或者你的 APP 的推送通知，我就需要告诉你我是谁，我要把我的标识传给你，否则你怎么知道要给我推送。</p>\n<p>下图展示了服务端收到用户订阅请求后如何推送：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/5/29/1725e621d4f43140?w=817&amp;h=218&amp;f=png&amp;s=27819\" alt=\"图片描述\"></p>\n<ol>\n<li>首先，在你项目的后台(Your Server)要存储一下用户订阅时传给你的标识。</li>\n<li>在后台需要给你推送的时候，找到这个标识，然后联系推送服务器(Push Service)将内容和标识传给推送服务，然后让推送服务将消息推送给用户端。（iOS和Android各自有自己的推送服务器，这个和操作系统相关）。</li>\n<li>这里就有一个约定，用户的标识，要和推送服务达成一致，例如使用Chrome浏览器，那么推送服务就是谷歌的推送服务<a href=\"https://firebase.google.cn/docs/cloud-messaging/concept-options?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">(FCM)</a>。</li>\n</ol>\n<h3 id=\"开始改造现有的SPA应用\"><a href=\"#开始改造现有的SPA应用\" class=\"headerlink\" title=\"开始改造现有的SPA应用\"></a>开始改造现有的SPA应用</h3><p>本章节会将一个基于Vue.js2.6版本的SPA项目进行PWA改造，原有项目的开发过程就不再讲解，各位读者可以到<a href=\"https://github.com/lvming6816077/wecircleCode/tree/master/app\" target=\"_blank\" rel=\"noopener\">Github</a>来看源码，最终的体验地址：<a href=\"https://app.nihaoshijie.com.cn，请使用Safari或者Android\" target=\"_blank\" rel=\"noopener\">https://app.nihaoshijie.com.cn，请使用Safari或者Android</a> Chrome打开体验。</p>\n<h4 id=\"添加manifest-json配置页面参数：\"><a href=\"#添加manifest-json配置页面参数：\" class=\"headerlink\" title=\"添加manifest.json配置页面参数：\"></a>添加manifest.json配置页面参数：</h4><p>添加到桌面快捷方式功能本身是PWA应用的一部分，他让我们的应用看起来更像是一个Web App，我们在前端项目的 public 文件夹下新建 manifest.json 文件：<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"WECIRCLE\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"short_name\"</span>: <span class=\"string\">\"WECIRCLE\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"icons\"</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"attr\">\"src\"</span>: <span class=\"string\">\"./img/icons/android-chrome-192x192.png\"</span>,</span><br><span class=\"line\">          <span class=\"attr\">\"sizes\"</span>: <span class=\"string\">\"192x192\"</span>,</span><br><span class=\"line\">          <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"image/png\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"attr\">\"src\"</span>: <span class=\"string\">\"./img/icons/android-chrome-512x512.png\"</span>,</span><br><span class=\"line\">          <span class=\"attr\">\"sizes\"</span>: <span class=\"string\">\"512x512\"</span>,</span><br><span class=\"line\">          <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"image/png\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"attr\">\"start_url\"</span>: <span class=\"string\">\"./index.html\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"display\"</span>: <span class=\"string\">\"standalone\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"background_color\"</span>: <span class=\"string\">\"#000000\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"theme_color\"</span>: <span class=\"string\">\"#181818\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中：</p>\n<ol>\n<li><strong>name</strong>：指定了 Web App 的名称，也就是保存到桌面图标的名称。</li>\n<li><strong>short_name</strong>：当 name 名称过长时，将会使用 short_name 来代替name显示，也就是 Web App 的简称。</li>\n<li><strong>start_url</strong>：指定了用户打开该 Web App 时加载的URL。相对URL会相对于 manifest.json 。这里我们指定了 index.html 作为 Web App 的启动页。</li>\n<li><strong>display</strong>：指定了应用的显示模式，它有四个值可以选择：<br><code>fullscreen</code>：全屏显示，会尽可能将所有的显示区域都占满。<br><code>standalone</code>：浏览器相关UI（如导航栏、工具栏等）将会被隐藏，因此看起来更像一个Native App。<br><code>minimal-ui</code>：显示形式与standalone类似，浏览器相关UI会最小化为一个按钮，不同浏览器在实现上略有不同。<br><code>browser</code>：一般来说，会和正常使用浏览器打开样式一致。<br>这里需要说明一下的是当一些系统的浏览器不支持fullscreen时将会显示成 standalone 的效果，当不支持 standalone 属性时，将会显示成 minimal-ui 的效果，以此类推。</li>\n<li><strong>icons</strong>：指定了应用的桌面图标和启动页图像，用数组表示：<br><code>sizes</code>：图标的大小。通过指定大小，系统会选取最合适的图标展示在相应位置上。<br><code>src</code>：图标的文件路径。相对路径是相对于 manifest.json 文件，也可以使用绝对路径例如<a href=\"http://xxx.png。\" target=\"_blank\" rel=\"noopener\">http://xxx.png。</a><br><code>type</code>：图标的图片类型。<br>浏览器会从 icons 中选择最接近 128dp(px = dp * (dpi / 160)) 的图片作为启动画面图像。</li>\n<li><strong>background_color</strong>：指定了启动画面的背景颜色，采用相同的颜色可以实现从启动画面到首页的平稳过渡，也可以用来改善页面资源正在加载时的用户体验，结合icons属性，可以定义背景颜色+图片icon的启动页效果，类似与Native App的splash screen效果。</li>\n<li><strong>theme_color</strong>：指定了 Web App 的主题颜色。可以通过该属性来控制浏览器 UI 的颜色。比如状态栏、内容页中状态栏、地址栏的颜色。</li>\n</ol>\n<p>当然，这里我们只是列举我我们项目中用到的 manifest.json 相关属性的讲解，更多的参数配置可以参考<a href=\"https://developer.mozilla.org/en-US/docs/Web/Manifest\" target=\"_blank\" rel=\"noopener\">MDN</a>，当然如果你觉得这些配置太过于繁琐，也可以用<a href=\"https://tomitm.github.io/appmanifest/\" target=\"_blank\" rel=\"noopener\">Web App Manifest Generator</a>来实现可视化的配置。</p>\n<h4 id=\"配置iOS系统的页面参数：\"><a href=\"#配置iOS系统的页面参数：\" class=\"headerlink\" title=\"配置iOS系统的页面参数：\"></a>配置iOS系统的页面参数：</h4><p>理想很丰满，现实却很骨感，manifest.json 那么强大但是也逃不过浏览器兼容性问题，正如下图 manifest.json 的兼容性：<img src=\"https://user-gold-cdn.xitu.io/2020/5/28/1725a24c19886826?w=2196&amp;h=980&amp;f=png&amp;s=241974\" alt=\"图片描述\"><br>由于iOS系统对 manifest.json 是属于部分支持，所以我们需要在head里给配置而外的 meta 属性才能让iOS系统更加完善：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"apple-mobile-web-app-capable\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"yes\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"apple-mobile-web-app-title\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"WECIRCLE\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"apple-touch-icon\"</span> <span class=\"attr\">sizes</span>=<span class=\"string\">\"76x76\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"./img/icons/apple-touch-icon-76x76-1.png\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"apple-touch-icon\"</span> <span class=\"attr\">sizes</span>=<span class=\"string\">\"152x152\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"./img/icons/apple-touch-icon-152x152.png-1\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"apple-touch-icon\"</span> <span class=\"attr\">sizes</span>=<span class=\"string\">\"180x180\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"./img/icons/apple-touch-icon-180x180.png-1\"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>apple-touch-icon</strong>:指定了应用的图标，类似与manifest.json文件的icons配置，也是支持sizes属性，来供不同场景的选择。</li>\n<li><strong>apple-mobile-web-app-capable</strong>：类似于 manifest.json 中的display的功能，通过设置为yes可以进入standalone模式，目前来说iOS系统还支持这个模式。</li>\n<li><strong>apple-mobile-web-app-title</strong>：指定了应用的名称。</li>\n<li><strong>apple-mobile-web-app-status-bar-style</strong>：指定了iOS移动设备的状态栏(status bar)的样式，有Default，Black，Black-translucent可以设置。</li>\n</ul>\n<p>采用iOS12.0测试下来看，<code>apple-touch-icon</code>，<code>apple-mobile-web-app-status-bar-style</code>是真实生效的，而 manifest.json 的 icons 则不会被iOS系统识别，下面是iOS系统safari保存到桌面操作的截图：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/5/29/1725f7380af29bc7?w=332&amp;h=589&amp;f=jpeg&amp;s=22168\" alt=\"\"><br>在Android的Chrome中：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/5/29/1725f7440dbf5b42?w=332&amp;h=590&amp;f=jpeg&amp;s=30936\" alt=\"\"><br>最后，别忘了将manifest.json文件在html中进行引入：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"manifest\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"manifest.json\"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"注册和使用Service-Worker的缓存功能：\"><a href=\"#注册和使用Service-Worker的缓存功能：\" class=\"headerlink\" title=\"注册和使用Service Worker的缓存功能：\"></a>注册和使用Service Worker的缓存功能：</h4><h5 id=\"1-要将Service-Worker进行注册：\"><a href=\"#1-要将Service-Worker进行注册：\" class=\"headerlink\" title=\"1. 要将Service Worker进行注册：\"></a>1. 要将Service Worker进行注册：</h5><p>在前端项目public文件夹下的index.html中添加如下代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"string\">'serviceWorker'</span> <span class=\"keyword\">in</span> navigator) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'load'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    navigator.serviceWorker.register(<span class=\"string\">'/sw-my.js'</span>, &#123;<span class=\"attr\">scope</span>: <span class=\"string\">'/'</span>&#125;)</span><br><span class=\"line\">      .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">registration</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 注册成功</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'ServiceWorker registration successful with scope: '</span>, registration.scope)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 注册失败:(</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'ServiceWorker registration failed: '</span>, err)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>采用<code>serviceWorkerContainer.register()</code>来注册Service Worker，这里要做好容错判断，保证某些机型在不支持Service Worker的情况下可以正常运行，而不会报错。</p>\n<p>另外需要注意的是只有在https下，navigator里才会有serviceWorker这个对象。</p>\n<h5 id=\"2-在前端项目public文件夹下新建sw-my-js，并定义需要缓存的文件路径：\"><a href=\"#2-在前端项目public文件夹下新建sw-my-js，并定义需要缓存的文件路径：\" class=\"headerlink\" title=\"2. 在前端项目public文件夹下新建sw-my.js，并定义需要缓存的文件路径：\"></a>2. 在前端项目public文件夹下新建<code>sw-my.js</code>，并定义需要缓存的文件路径：</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义需要缓存的文件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cacheFiles = [</span><br><span class=\"line\">  <span class=\"string\">'./lib/weui/weui.min.js'</span>,</span><br><span class=\"line\">  <span class=\"string\">'./lib/slider/slider.js'</span>,</span><br><span class=\"line\">  <span class=\"string\">'./lib/weui/weui.min.css'</span></span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"comment\">// 定义缓存的key值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cacheName = <span class=\"string\">'20190301'</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"3-监听install事件，来进行相关文件的缓存操作：\"><a href=\"#3-监听install事件，来进行相关文件的缓存操作：\" class=\"headerlink\" title=\"3. 监听install事件，来进行相关文件的缓存操作：\"></a>3. 监听install事件，来进行相关文件的缓存操作：</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 监听install事件，安装完成后，进行文件缓存</span></span><br><span class=\"line\">self.addEventListener(<span class=\"string\">'install'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Service Worker 状态： install'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 找到key对应的缓存并且获得可以操作的cache对象</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> cacheOpenPromise = caches.open(cacheName).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">cache</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将需要缓存的文件加进来</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cache.addAll(cacheFiles)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"comment\">// 将promise对象传给event</span></span><br><span class=\"line\">  e.waitUntil(cacheOpenPromise)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>我们在<code>sw-my.js</code>里面采用的标准的web worker的编程方式，由于运行在另一个全局上下文中（<code>self</code>），这个全局上下文不同于window，所以我们采用<code>self.addEventListener()</code>。</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Cache\" target=\"_blank\" rel=\"noopener\">Cache API</a>是由Service Worker提供用来操作缓存的的接口，这些接口基于Promise来实现，包括了<code>Cache</code>和<code>Cache Storage</code>，Cache直接和请求打交道，为缓存的 Request / Response  对象对提供存储机制，CacheStorage 表示 Cache 对象的存储实例，我们可以直接使用全局的caches属性访问Cache API。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/5/29/1725f76349d16f00?w=332&amp;h=534&amp;f=png&amp;s=45159\" alt=\"\"></p>\n<p>Cache相关API说明：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache.match(request, options) 返回一个 Promise对象，resolve的结果是跟 Cache 对象匹配的第一个已经缓存的请求。</span><br><span class=\"line\">Cache.matchAll(request, options) 返回一个Promise 对象，resolve的结果是跟Cache对象匹配的所有请求组成的数组。</span><br><span class=\"line\">Cache.addAll(requests)接收一个URL数组，检索并把返回的response对象添加到给定的Cache对象。</span><br><span class=\"line\">Cache.delete(request, options)搜索key值为request的Cache 条目。如果找到，则删除该Cache 条目，并且返回一个resolve为true的Promise对象；如果未找到，则返回一个resolve为false的Promise对象。</span><br><span class=\"line\">Cache.keys(request, options)返回一个Promise对象，resolve的结果是Cache对象key值组成的数组。</span><br></pre></td></tr></table></figure>\n<h5 id=\"4-监听fetch事件来使用缓存数据：\"><a href=\"#4-监听fetch事件来使用缓存数据：\" class=\"headerlink\" title=\"4. 监听fetch事件来使用缓存数据：\"></a>4. 监听fetch事件来使用缓存数据：</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.addEventListener(<span class=\"string\">'fetch'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'现在正在请求：'</span> + e.request.url)</span><br><span class=\"line\"></span><br><span class=\"line\">  e.respondWith(</span><br><span class=\"line\">    <span class=\"comment\">// 判断当前请求是否需要缓存</span></span><br><span class=\"line\">    caches.match(e.request).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">cache</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 有缓存就用缓存，没有就从新发请求获取</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> cache || fetch(e.request)</span><br><span class=\"line\">    &#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">      <span class=\"comment\">// 缓存报错还直接从新发请求获取</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> fetch(e.request)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>上一步我们将相关的资源进行了缓存，那么接下来就要使用这些缓存，这里同样要做好容错逻辑，记住一旦请求被Service Worker接管，浏览器的默认请求就不再生效了，意思就是请求的发与不发，出错与否全部由自己的代码控制，这里一定要做好兼容，当缓存失效或者发生内部错误时，及时调用fetch重新在发起请求。<br>正如上面提到的Service Worker的生命周期，fetch事件的触发，必须依赖Service Worker进入<code>activated</code>状态，于是来到第五步。</p>\n<h5 id=\"5-监听activate事件来更新缓存数据：\"><a href=\"#5-监听activate事件来更新缓存数据：\" class=\"headerlink\" title=\"5. 监听activate事件来更新缓存数据：\"></a>5. 监听activate事件来更新缓存数据：</h5><p>使用缓存一个必不可少的步骤就是更新缓存，如果缓存无法更新，那么将毫无意义。<br>我们在<code>sw-my.js</code>中添加如下代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 监听activate事件，激活后通过cache的key来判断是否更新cache中的静态资源</span></span><br><span class=\"line\">self.addEventListener(<span class=\"string\">'activate'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Service Worker 状态： activate'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> cachePromise = caches.keys().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">keys</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历当前scope使用的key值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.all(keys.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果新获取到的key和之前缓存的key不一致，就删除之前版本的缓存</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (key !== cacheName) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> caches.delete(key)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  e.waitUntil(cachePromise)</span><br><span class=\"line\">  <span class=\"comment\">// 保证第一次加载fetch触发</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> self.clients.claim()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>每当已安装的Service Worker页面被打开时，便会触发Service Worker脚本更新。</li>\n<li>当上次脚本更新写入Service Worker数据库的时间戳与本次更新超过24小时，便会触发Service Worker脚本更新。</li>\n<li>当sw-my.js文件改变时，便会触发Service Worker脚本更新。</li>\n</ul>\n<p>更新流程与安装类似，只是在更新安装成功后不会立即进入<code>active</code>状态，更新后的Service Worker会和原始的Service Worker共同存在，并运行它的<code>install</code>，一旦新Service Worker安装成功，它会进入wait状态，需要等待旧版本的Service Worker进/线程终止。<br><code>self.skipWaiting()</code>可以阻止等待，让新Service Worker安装成功后立即激活。<br><code>self.clients.claim()</code>方法来让没被控制的 clients 受控，也就是设置本身为activate的Service Worker。<br><img src=\"https://user-gold-cdn.xitu.io/2020/5/28/1725a24c24d512ec?w=866&amp;h=383&amp;f=png&amp;s=34142\" alt=\"图片描述\"></p>\n<p>打开Chrome控制台，点击Application，查看Service Worker状态：<br><img src=\"https://user-gold-cdn.xitu.io/2020/5/28/1725a24c3d74638e?w=1556&amp;h=976&amp;f=png&amp;s=236331\" alt=\"图片描述\"></p>\n<ul>\n<li>status表示当前Service Worker的状态。</li>\n<li>clients表示当前几个窗口连接这个Service Worker。</li>\n</ul>\n<p>这里需要说明是，如果你的浏览器开了多个窗口，那么如果在不调用<code>self.skipWaiting()</code>的情况下，必须将窗口关闭在打开才能使Service Worker更新成功。</p>\n<h4 id=\"采用offline-plugin插件完善Service-Worker：\"><a href=\"#采用offline-plugin插件完善Service-Worker：\" class=\"headerlink\" title=\"采用offline-plugin插件完善Service Worker：\"></a>采用offline-plugin插件完善Service Worker：</h4><p>上面的我们写的Service Worker逻辑虽然已经完成，但是还有一些不完善的地方，比如，我们每次构建完之后，每个文件的md5都会改变，所以我们每次在写缓存文件列表时，都需要手动的的修改:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cacheFiles = [</span><br><span class=\"line\">  <span class=\"string\">'./static/js/vendor.d70d8829.js'</span></span><br><span class=\"line\">  <span class=\"string\">'./static/js/app.d70d8869.js'</span></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<p>这带来的一定的复杂性，那么接下来就利用webpack的<a href=\"https://github.com/NekR/offline-plugin\" target=\"_blank\" rel=\"noopener\">offline-plugin</a>插件来帮助我们完善这些事情，自动生成sw-my.js。</p>\n<h5 id=\"1-安装offline-plugin插件：\"><a href=\"#1-安装offline-plugin插件：\" class=\"headerlink\" title=\"1. 安装offline-plugin插件：\"></a>1. 安装offline-plugin插件：</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install offline-plugin --save</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-在vue-config-js里配置：\"><a href=\"#2-在vue-config-js里配置：\" class=\"headerlink\" title=\"2. 在vue.config.js里配置：\"></a>2. 在<code>vue.config.js</code>里配置：</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> configureWebpack: &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> OfflinePlugin(&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 要求触发ServiceWorker事件回调</span></span><br><span class=\"line\">      ServiceWorker: &#123;</span><br><span class=\"line\">        events: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"comment\">// 更更新策略选择全部更新</span></span><br><span class=\"line\">      updateStrategy: <span class=\"string\">'all'</span>,</span><br><span class=\"line\">      <span class=\"comment\">// 除去一些不需要缓存的文件</span></span><br><span class=\"line\">      excludes: [<span class=\"string\">'**/.*'</span>, <span class=\"string\">'**/*.map'</span>, <span class=\"string\">'**/*.gz'</span>, <span class=\"string\">'**/*.png'</span>, <span class=\"string\">'**/*.jpg'</span>],</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 添加index.html的更新</span></span><br><span class=\"line\">      rewrites (asset) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (asset.indexOf(<span class=\"string\">'index.html'</span>) &gt; <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"string\">'./index.html'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> asset</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"3-在前端项目src目录新建registerServiceWorker-js里面对Service-Worker进行注册：\"><a href=\"#3-在前端项目src目录新建registerServiceWorker-js里面对Service-Worker进行注册：\" class=\"headerlink\" title=\"3. 在前端项目src目录新建registerServiceWorker.js里面对Service Worker进行注册：\"></a>3. 在前端项目src目录新建<code>registerServiceWorker.js</code>里面对Service Worker进行注册：</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> OfflinePluginRuntime <span class=\"keyword\">from</span> <span class=\"string\">'offline-plugin/runtime'</span></span><br><span class=\"line\">OfflinePluginRuntime.install(&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  onUpdateReady: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 更新完成之后，调用applyUpdate即skipwaiting()方法</span></span><br><span class=\"line\">    OfflinePluginRuntime.applyUpdate()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  onUpdated: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//弹一个确认框</span></span><br><span class=\"line\">    weui.confirm(<span class=\"string\">'发现新版本，是否更新？'</span>, ()=&gt;&#123; </span><br><span class=\"line\">      <span class=\"comment\">// 刷新一下页面</span></span><br><span class=\"line\">      <span class=\"built_in\">window</span>.location.reload()</span><br><span class=\"line\">    &#125;, ()=&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        title: <span class=\"string\">''</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>当发现Service Worker更新后，弹窗来确认是否更新，如下图：<br><img src=\"https://user-gold-cdn.xitu.io/2020/5/29/1725f76fc0001021?w=332&amp;h=590&amp;f=jpeg&amp;s=29318\" alt=\"\"></p>\n<p>这里说明一下：</p>\n<ul>\n<li>选择了offline-plugin插件之后呢，之前我们手写的注册Service Worker和Service Worker缓存相关逻辑都可以去掉了，因为offline-plugin会帮我们做这些事情。</li>\n<li>offline-plugin插件会自动扫描webpack构建出来的dist目录里的文件，对这些文件配置缓存列表，正如上面插件里面的配置。</li>\n<li><code>excludes</code>：指定了一些不需要缓存的文件列表，例如我们不希望对图片资源进行缓存，并且支持正则表达式的方式。</li>\n<li><code>updateStrategy</code>：指定了缓存策略选择全部更新，另外一种是增量更新<code>changed</code>。</li>\n<li><code>event：true</code>指定了要触发Service Worker事件的回调，这个<code>main.js</code>里的配置是相对应的，只有这里设置成true，那边的回调才会触发。</li>\n<li>我们在<code>main.js</code>里的配置是为了，当Service Worker有更新时，立刻进行更新，而不让Service Worker进入wait状态，这和上面我们讲到的Service Worker更新流程相对应。</li>\n</ul>\n<p>当让更多的offline-plugin相关配置，也可以去官网看<a href=\"https://github.com/NekR/offline-plugin/blob/master/docs/options.md\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n<p>在执行npm run build命令之后，就会生成对应<code>的sw.js</code>文件，部署之后就可以替换我们之前手写的<code>sw-my.js</code>了。</p>\n<p>除此之外，我们在PC端的Chrome也可以选择使用安装到桌面的功能，这让我们的程序应用看起来更像是一个桌面应用：<br><img src=\"https://user-gold-cdn.xitu.io/2020/5/28/1725a24c41746b82?w=2408&amp;h=1450&amp;f=png&amp;s=671812\" alt=\"图片描述\"></p>\n<h4 id=\"添加消息推送逻辑：\"><a href=\"#添加消息推送逻辑：\" class=\"headerlink\" title=\"添加消息推送逻辑：\"></a>添加消息推送逻辑：</h4><p>消息推送逻辑，主要分为两种方案，一种的非常简单的使用PC的Chrome的开发者工具自带的Push功能，可以通过Application-&gt;Service Worker面板-&gt;Push按钮来实现，如下图：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/5/29/1725e6820c5e5538?w=880&amp;h=414&amp;f=png&amp;s=43113\" alt=\"\"><br>这种方式只能模拟简单的推送，并且依赖浏览器，大多数作为调试来使用，而真正的为APP添加消息推送，需要结合Web Push协议来实现，同时消息推送主要包括前端逻辑和后端逻辑，其中：</p>\n<p>前端逻辑包括：</p>\n<ul>\n<li>用户授权订阅逻辑</li>\n<li>收到推送后借助Notification通知逻辑</li>\n</ul>\n<p>后端逻辑包括：</p>\n<ul>\n<li>存储用户授权标识</li>\n<li>根据标识向推送服务器发送推送请求</li>\n</ul>\n<h5 id=\"1-前端订阅逻辑\"><a href=\"#1-前端订阅逻辑\" class=\"headerlink\" title=\"1.前端订阅逻辑\"></a>1.前端订阅逻辑</h5><p>获取到用户标识呢，要借助与Service Worker，基于Web Push的推送和通知相关全部要用到Service Worker。在之前创建的registerServiceWorker.js中，增加如下代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">navigator.serviceWorker.ready.then(<span class=\"function\">(<span class=\"params\">registration</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//publicKey和后台的publicKey对应保持一致</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> publicKey = <span class=\"string\">'BAWz0cMW0hw4yYH-DwPrwyIVU0ee3f4oMrt6YLGPaDn3k5MNZtqjpYwUkD7nLz3AJwtgo-kZhB_1pbcmzyTVAxA'</span>;<span class=\"comment\">//web-push定义的客户端的公钥，用来和后端的web-push对应</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//获取订阅请求（浏览器会弹出一个确认框，用户是否同意消息推送）</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.PushManager) &#123;</span><br><span class=\"line\">          registration.pushManager.getSubscription().then(<span class=\"function\"><span class=\"params\">subscription</span> =&gt;</span> &#123;</span><br><span class=\"line\">         </span><br><span class=\"line\">              <span class=\"comment\">// 如果用户没有订阅 并且是一个登录用户</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (subscription &amp;&amp; <span class=\"built_in\">window</span>.localStorage.getItem(<span class=\"string\">'cuser'</span>)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">const</span> subscription = registration.pushManager.subscribe(&#123;</span><br><span class=\"line\">                  userVisibleOnly: <span class=\"literal\">true</span>,<span class=\"comment\">//表明该推送是否需要显性地展示给用户，即推送时是否会有消息提醒。如果没有消息提醒就表明是进行“静默”推送。在Chrome中，必须要将其设置为true，否则浏览器就会在控制台报错</span></span><br><span class=\"line\">                  applicationServerKey: urlBase64ToUint8Array(publicKey)<span class=\"comment\">//web-push定义的客户端的公钥，用来和后端的web-push对应</span></span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//用户同意</span></span><br><span class=\"line\">                .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">subscription</span>) </span>&#123;</span><br><span class=\"line\">                  <span class=\"built_in\">console</span>.log(subscription)</span><br><span class=\"line\">                  alert(subscription)</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (subscription &amp;&amp; subscription.endpoint) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 存入数据库</span></span><br><span class=\"line\">                    <span class=\"keyword\">let</span> resp = service.post(<span class=\"string\">'users/addsubscription'</span>, &#123;</span><br><span class=\"line\">                      subscription: <span class=\"built_in\">JSON</span>.stringify(subscription)</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//用户不同意或者生成失败</span></span><br><span class=\"line\">                .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"No it didn't. This happened: \"</span>, err)</span><br><span class=\"line\">                  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">              &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//用户已经订阅过</span></span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"You have subscribed our notification\"</span>);</span><br><span class=\"line\">              &#125;       </span><br><span class=\"line\">          &#125;);   </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(e)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(e)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>上面代码的逻辑主要要如下：</p>\n<ol>\n<li>通过<code>registration.pushManager.getSubscription()</code>先要确定用户是否已经订阅过，就是是否已经获取过标识，然后得到的<code>subscription</code>就是我们要的标识。（后面将<code>subscription</code>代替标识）。</li>\n<li>如果用户没有订阅过，通过<code>registration.pushManager.subscribe()</code>可以拿到<code>subscription</code>，在调用这个方法的时候，浏览器就会询问用户是否接受订阅，也就是会弹一个框：<br><img src=\"https://user-gold-cdn.xitu.io/2020/5/29/1725f77e1f609acc?w=332&amp;h=164&amp;f=png&amp;s=25576\" alt=\"\"><br>如果是在手机端，前提是使用Android的Chrome，会收到这样的提示，如图：<br><img src=\"https://user-gold-cdn.xitu.io/2020/5/29/1725f78946c2423f?w=332&amp;h=689&amp;f=jpeg&amp;s=33684\" alt=\"\"></li>\n<li>当我们点击同意，就会获取到<code>subscription</code>，然后通过 service 发请求到后台存储。这个<code>subscription</code>其实是一个对象，长这样：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"endpoint\"</span>: <span class=\"string\">\"https://fcm.googleapis.com/fcm/send/eekuJ6272vI:APA91bEdnUY1cpyTfRFVMUJBx2CNQdA6Qg2FwP0oPibqltHxgZz__2ggmgSpE5bGRoI81cginuT2clRDuqmmmtiqgYiG_WXQtvw83Mv41bJxJj89y1rglr5mvyiyHpBRml_y07uq1pVIc\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"expirationTime\"</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"string\">\"keys\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"p256dh\"</span>: <span class=\"string\">\"BLcOaaco6_dIjfIo3uiR6nDqERiCUwOuVT1mD5W45V99hvuYoqJxJZzKrKLsgE16zI_DA7o5PXXa8HVZvNz8PHg1\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"auth\"</span>: <span class=\"string\">\"vRqwuyij2AR9qkzUOwP3Pwx\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>对于每一个客户端来说<code>subscription</code>都是唯一的。</p>\n<h5 id=\"2-后端推送逻辑\"><a href=\"#2-后端推送逻辑\" class=\"headerlink\" title=\"2.后端推送逻辑\"></a>2.后端推送逻辑</h5><p>后端是基于Node.js的Express框架开发的接口服务，其中推送逻辑包括在内，其他逻辑就不再文章里说明，各位可以直接浏览源码，这里只讲解Web Push的这块推送逻辑。<br>由于要存储前端发送的用户标识，所以需要采用数据库来持久化数据，这里使用MongoDB来存储，需要新建一张表<code>Subscription</code>。<br>在后端项目的models文件夹下新建<code>Subscription.js</code>代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'mongoose'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Schema = mongoose.Schema;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> SubscriptionSchema = <span class=\"keyword\">new</span> mongoose.Schema(&#123;</span><br><span class=\"line\">  subscription: &#123; <span class=\"attr\">type</span>: <span class=\"built_in\">String</span>,<span class=\"attr\">required</span>:<span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">  userid:&#123; <span class=\"attr\">type</span>: <span class=\"built_in\">String</span>, <span class=\"attr\">unique</span>: <span class=\"literal\">true</span> &#125;,<span class=\"comment\">//注意这里不用ref外键</span></span><br><span class=\"line\">  update: &#123; <span class=\"attr\">type</span>: <span class=\"built_in\">Date</span>, <span class=\"attr\">default</span>: <span class=\"built_in\">Date</span>.now &#125;,</span><br><span class=\"line\">  create: &#123; <span class=\"attr\">type</span>: <span class=\"built_in\">Date</span>, <span class=\"attr\">default</span>: <span class=\"built_in\">Date</span>.now &#125;,</span><br><span class=\"line\">&#125;,&#123;<span class=\"attr\">timestamps</span>:&#123;<span class=\"attr\">createdAt</span>: <span class=\"string\">'create'</span>,<span class=\"attr\">updatedAt</span>:<span class=\"string\">'update'</span>&#125;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = mongoose.model(<span class=\"string\">'Subscription'</span>, SubscriptionSchema);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>subscription</strong>:字段是一个字符串，我们会将前端传的对象<code>JSON.stringify()</code>一下。</li>\n<li><strong>userid</strong>：这个字段是标识那个用户，采用<code>unique:true</code>表明唯一性，这里不用 ref 外键是为了该字段可空，为了后续可能会给没登录过的用户也推送一些消息。</li>\n</ul>\n<p>然后在后端项目中，新增一个基于Express的路由方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 添加订阅信息</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">router.post(<span class=\"string\">'/addsubscription'</span>, <span class=\"keyword\">async</span> (req, res, next)=&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> userid = req.user ? req.user._id : <span class=\"string\">''</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = <span class=\"keyword\">await</span> Subscription.create(&#123;</span><br><span class=\"line\">      subscription: req.body.subscription,</span><br><span class=\"line\">      userid:userid</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    res.json(&#123;</span><br><span class=\"line\">      code:<span class=\"number\">0</span>,</span><br><span class=\"line\">      data:result</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;<span class=\"keyword\">catch</span>(e)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// console.log(e)</span></span><br><span class=\"line\">    res.json(&#123;</span><br><span class=\"line\">      code:<span class=\"number\">0</span>,</span><br><span class=\"line\">      data: e.errmsg.indexOf(<span class=\"string\">'dup key'</span>) ? <span class=\"string\">'has scription'</span> : e.errmsg <span class=\"comment\">// 说明用户已经订阅过</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>上面代码通过<code>Subscription.create()</code>就完成了对一个<code>subscription</code>的存储。当存储时发现 userid 已经有过，就会抛出一个错误，就说明这个用户已经订阅过了。</p>\n<p>然后，在后端项目的 utils 文件夹下新建<code>push.js</code>工具方法，来实现后台推送逻辑，首先安装<a href=\"https://www.npmjs.com/package/web-push\" target=\"_blank\" rel=\"noopener\">web-push</a>，是一个基于Node.js的web-push封装，当然还有基于<a href=\"https://github.com/web-push-libs/web-push-java\" target=\"_blank\" rel=\"noopener\">Java</a>或者<a href=\"https://github.com/web-push-libs/web-push-php\" target=\"_blank\" rel=\"noopener\">Php</a>的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install web-push --save</span><br></pre></td></tr></table></figure>\n<p>然后在<code>push.js</code>新增代码，首先需要生成<code>vapidKeys</code>，这个就是我们在前端用的那个key，要和这里保持一致，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vapidKeys = webpush.generateVAPIDKeys();</span><br></pre></td></tr></table></figure></p>\n<p>只需要生成一次，然后设置一下，得到之后后面一只用这个就可以，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vapidKeys = &#123; <span class=\"attr\">publicKey</span>:</span><br><span class=\"line\">   <span class=\"string\">'BAWz0cMW0hw4yYH-DwPrwyIVU0ee3f4oMrt6YLGPaDn3k5MNZ1tqjpYwUkD7nLz3AJwtgo-kZhB_1pbcmzyTVAxA'</span>,</span><br><span class=\"line\">  privateKey: <span class=\"string\">'BJ_V2wtPYaVCl7Ef2GAkVxXB2ft9cTgw-b5lM2ggc8lo'</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  webpush.setVapidDetails(</span><br><span class=\"line\">  <span class=\"string\">'mailto:example@yourdomain.org'</span>,<span class=\"comment\">//不需要邮箱通知的话这里可以随意填</span></span><br><span class=\"line\">  vapidKeys.publicKey,</span><br><span class=\"line\">  vapidKeys.privateKey</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>完成这些设置之后，就可以和Push Service通信，来实现推送了，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">userid,data</span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//国内使用的话，需要设置代理才行</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> option = &#123;</span><br><span class=\"line\">    proxy: <span class=\"string\">'http://113.10.152.92:3128'</span>   <span class=\"comment\">//http://www.freeproxylists.net/zh/hk.html</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//从数据库中找到subscription</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> obj = <span class=\"keyword\">await</span> Subscription.findOne(&#123;</span><br><span class=\"line\">    userid: userid</span><br><span class=\"line\">  &#125;).exec();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'检查是否有可推送的subscription'</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(obj)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj &amp;&amp; obj.subscription) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'找到subscription 可以推送'</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 调用webpush的sendNotification来发起推送通知</span></span><br><span class=\"line\">    webpush.sendNotification(<span class=\"built_in\">JSON</span>.parse(obj.subscription), <span class=\"built_in\">JSON</span>.stringify(data),option).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(err)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里解释一下，由于我们使用的推送服务器是基于谷歌的FCM，这个服务在国内是无法使用的（或者说有时可用有时不可用），所以我们需要设置一个代理，当然网上有很多免费的国外代理，可以在<a href=\"http://www.freeproxylists.net/zh/hk.html\" target=\"_blank\" rel=\"noopener\">http://www.freeproxylists.net/zh/hk.html</a>找找，如果想要稳定一点的可以掏钱买一个 VPN 服务。</p>\n<h5 id=\"3-收到推送后弹出通知\"><a href=\"#3-收到推送后弹出通知\" class=\"headerlink\" title=\"3.收到推送后弹出通知\"></a>3.收到推送后弹出通知</h5><p>在收到Push之后如何通知提示呢，这就涉及到<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/notification\" target=\"_blank\" rel=\"noopener\">Notification</a>相关的API了。</p>\n<p>接下来，在Service Worker里注册<code>push</code>事件来接收<code>push</code>请求，在前端项目的public目录下新建一个<code>sw-push.js</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加service worker对push的监听</span></span><br><span class=\"line\">self.addEventListener(<span class=\"string\">'push'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> data = e.data</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (e.data) &#123;</span><br><span class=\"line\">    data = data.json()</span><br><span class=\"line\">      e.waitUntil(</span><br><span class=\"line\">        self.registration.showNotification(data.title, &#123;</span><br><span class=\"line\">          body: data.body || <span class=\"string\">''</span>,</span><br><span class=\"line\">          icon: data.img || <span class=\"string\">\"https://app.nihaoshijie.com.cn/img/icons/apple-touch-icon-180x180-1-touming.png\"</span>,</span><br><span class=\"line\">          actions: [&#123;</span><br><span class=\"line\">              action: <span class=\"string\">'go-in'</span>,</span><br><span class=\"line\">              title: <span class=\"string\">'进入程序'</span></span><br><span class=\"line\">          &#125;]</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      );</span><br><span class=\"line\">    ;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'push没有任何数据'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>当浏览器收到推送通知时，就会进入这个事件里，我们通过<code>self.registration.showNotification()</code></p>\n<ul>\n<li>title：消息的标题，属于必传的值。</li>\n<li>body：消息的实体，可以不传。</li>\n<li>icon：配置消息的图片，会出现在消息里面。</li>\n<li>actions：配置消息的操作项，在结合<code>notificationclick</code>事件可以实现消息的点击交互。</li>\n</ul>\n<p>就可以弹出一个通知框，前提是你在之前的通知允许中点击了确定：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/5/29/1725f79f0c22be2b?w=332&amp;h=66&amp;f=png&amp;s=17326\" alt=\"\"><br>在手机端是这个样子：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/5/29/1725f7a53080ea29?w=332&amp;h=590&amp;f=jpeg&amp;s=49461\" alt=\"\"></p>\n<p>如果想要在手机端或者是PC端收到提示，前端必须满足下面条件：</p>\n<ol>\n<li>PC端的Chrome要可以翻墙，也就是能够使用谷歌相关的服务。</li>\n<li>手机端的Chrome要内置了Chrome服务(GMS)，据笔者实验国内的华为，vivo，小米系列基本是没有内置Chrome服务的，而<a href=\"https://www.baidu.com/link?url=nZuqraAz78j_tPKufmQifMOaS7DGYRM_9iQdh6L_l2kWnEwum0kdJcJiRuTidFSw3Dn5rv4ws-FD6Ny9Uv6Pxa&amp;wd=&amp;eqid=8b2ed65c0001716b000000025cfe8839\" target=\"_blank\" rel=\"noopener\">Nexus</a>系列的手机则可以正常使用。能够连接Google Play则代表可以。</li>\n</ol>\n<p>你要问我为什么这么多条件？原因是web-push是基于谷歌的<a href=\"https://firebase.google.cn/docs/cloud-messaging/concept-options?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">FCM</a>(云消息机制)实现的推送，而<a href=\"https://firebase.google.cn/docs/cloud-messaging/concept-options?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">FCM</a>包含在GMS里面。知道谷歌禁止国外的华为手机使用谷歌服务有多大影响了吧，连消息都收不到啊。</p>\n<p>在 Notification 添加点击事件实现完整消息流程，在<code>sw-push.js</code>增加如下代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.addEventListener(<span class=\"string\">'notificationclick'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> action = e.action;</span><br><span class=\"line\">    e.waitUntil(</span><br><span class=\"line\">        <span class=\"comment\">// 获取所有clients</span></span><br><span class=\"line\">        self.clients.matchAll().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">clientList</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (clientList.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> clientList[<span class=\"number\">0</span>].focus();</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (action === <span class=\"string\">'go-in'</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.clients.openWindow(<span class=\"string\">'https://app.nihaoshijie.com.cn/index.html#/mypage'</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    );</span><br><span class=\"line\">    e.notification.close();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>在<code>self.registration.showNotification()</code>中，我们传了一个action，这里就对应了消息弹出时，有选项可以选择：<br>在PC端：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/5/29/1725f7b4de068f20?w=332&amp;h=139&amp;f=png&amp;s=36416\" alt=\"\"><br>在手机端：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/5/29/1725f7c0c77a0d43?w=332&amp;h=600&amp;f=png&amp;s=126650\" alt=\"\"></p>\n<p>根据上节我们讲的离线APP，收到消息通知的条件不限于你必须打开着APP，经过验证，即使APP已经关闭，同样可以收到推送消息，调用<code>self.clients.openWindow()</code>可以将APP呼起来，可以看下图的流程：<img src=\"https://user-gold-cdn.xitu.io/2020/5/29/1725f56d771b11b7?w=314&amp;h=595&amp;f=gif&amp;s=893266\" alt=\"图片描述\"></p>\n<p>最后，我们的<code>sw-push.js</code>需要配置在 offline-plugin 插件里面进行合并，最终对于Service Worker 只有一个<code>sw.js</code>，在<code>vue.config.js</code>里修改代码，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">  ServiceWorker: &#123;</span><br><span class=\"line\">    events: true,</span><br><span class=\"line\">    // push事件逻辑写在另外一个文件里面</span><br><span class=\"line\">    entry: &apos;./public/sw-push.js&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文主要讨论了PWA的相关知识，以及如何将SPA项目改成成一个PWA应用。<br>相关知识点：</p>\n<ol>\n<li>PWA应用的概念以及PWA应用的特性。</li>\n<li>Service Worker的兼容性以及生命周期和事件等基本概念。</li>\n<li>Web Push的概念和基本流程。</li>\n<li>manifest.json文件的各个配置项作用。</li>\n<li>拦截<code>fetch</code>事件，缓存前端静态资源文件的原理。</li>\n<li>结合offline-plugin插件，将项目改造成PWA应用。</li>\n<li>在Node.js里使用Web Push，并推送给前端。</li>\n<li>Web Notification的API及相关的配置来提示消息。</li>\n</ol>\n<p>本文改造的SPA项目完整源代码地址：<a href=\"https://github.com/lvming6816077/wecircleCode\" target=\"_blank\" rel=\"noopener\">Github</a>，<br>更多关于PWA技术可关注《HTML5移动web+Vue.js应用开发实战》，新书刚出版感谢支持！</p>\n<p><strong>码字不易，如果本文对你有帮助，动手点个赞！</strong></p>"},{"title":"Proxy API--Vue3响应式对象reactive初探","date":"2020-05-26T09:26:17.000Z","_content":"\n`Proxy API`对应的`Proxy`对象是[ES2015](https://www.ecma-international.org/ecma-262/6.0/#sec-proxy-objects)就已引入的一个原生对象，用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。\n\n从字面意思来理解，`Proxy`对象是目标对象的一个代理器，任何对目标对象的操作（实例化，添加/删除/修改属性等等），都必须通过该代理器。因此我们可以把来自外界的所有操作进行拦截和过滤或者修改等操作。\n\n基于`Proxy`的这些特性，常用于：\n* 创建一个可“响应式”的对象，例如Vue3.0中的reactive方法。\n* 创建可隔离的JavaScript“沙箱”。\n\n<!--more-->\n## Proxy常见用法\n\nProxy语法：\n```javascript\nconst p = new Proxy(target, handler)\n```\n\n* target：要使用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。\n* handler：以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。\n\n例如下面一个很简单的用法：\n```javascript\nlet foo = {\n  a: 1,\n  b: 2\n}\nlet handler = {\n    get:(obj,key)=>{\n        console.log('get')\n        return key in obj ? obj[key] : undefined\n    }\n}\nlet p = new Proxy(foo,handler)\nconsole.log(p.a) // 1\n```\n上面代码中p就是foo的代理对象，对p对象的相关操作都会同步到foo对象上。\n\n同时Proxy也提供了另一种生成代理对象的方法`Proxy.revocable()`：\n```javascript\nconst { proxy,revoke } = Proxy.revocable(target, handler)\n```\n该方法的返回值是一个对象，其结构为： `{\"proxy\": proxy, \"revoke\": revoke}`，其中:\n* proxy：表示新生成的代理对象本身，和用一般方式`new Proxy(target, handler)` 创建的代理对象没什么不同，只是它可以被撤销掉。\n* revoke：撤销方法，调用的时候不需要加任何参数，就可以撤销掉和它一起生成的那个代理对象。\n\n例如：\n```javascript\nlet foo = {\n  a: 1,\n  b: 2\n}\nlet handler = {\n    get:(obj,key)=>{\n        console.log('get')\n        return key in obj ? obj[key] : undefined\n    }\n}\nlet { proxy,revoke } = Proxy.revocable(foo,handler)\n\nconsole.log(proxy.a) // 1\n\nrevoke()\n\nconsole.log(proxy.a) // Uncaught TypeError: Cannot perform 'get' on a proxy that has been revoked\n```\n需要注意的是，一旦某个代理对象被撤销，它将变得几乎完全不可调用，在它身上执行任何的可代理操作都会抛出 TypeError 异常。\n\n## Proxy的handler\n上面代码中，我们只使用了get操作的handler，即当尝试获取对象的某个属性时会进入这个方法，除此之外Proxy共有接近14个handler也可以称作为钩子，它们分别是：\n```\nhandler.getPrototypeOf()：\n在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy) 时。\n\nhandler.setPrototypeOf()：\n在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。\n\nhandler.isExtensible()：\n在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时。\n\nhandler.preventExtensions()：\n在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时。\n\nhandler.getOwnPropertyDescriptor()：\n在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, \"foo\") 时。\n\nhandler.defineProperty()：\n在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, \"foo\", {}) 时。\n\nhandler.has()：\n在判断代理对象是否拥有某个属性时触发该操作，比如在执行 \"foo\" in proxy 时。\n\nhandler.get()：\n在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。\n\nhandler.set()：\n在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。\n\nhandler.deleteProperty()：\n在删除代理对象的某个属性时触发该操作，即使用 delete 运算符，比如在执行 delete proxy.foo 时。\n\nhandler.ownKeys()：\n当执行Object.getOwnPropertyNames(proxy) 和Object.getOwnPropertySymbols(proxy)时触发。\n\nhandler.apply()：\n当代理对象是一个function函数时，调用apply()方法时触发，比如proxy.apply()。\n\nhandler.construct()：\n当代理对象是一个function函数时，通过new关键字实例化时触发，比如new proxy()。\n```\n结合这些handler，我们可以实现一些针对对象的限制操作，例如：\n\n* 禁止删除和修改对象的某个属性\n\n```javascript\nlet foo = {\n    a:1,\n    b:2\n}\nlet handler = {\n    set:(obj,key,value,receiver)=>{\n        console.log('set')\n        if (key == 'a') throw new Error('can not change property:'+key)\n        obj[key] = value\n        return true\n    },\n    deleteProperty:(obj,key)=>{\n        console.log('delete')\n        if (key == 'a') throw new Error('can not delete property:'+key)\n        delete obj[key]\n        return true\n    }\n}\n\nlet p = new Proxy(foo,handler)\n\np.a = 3 // Uncaught Error\n\ndelete p.a  // Uncaught Error\n```\n\n其中，set方法的receiver通常是 Proxy 本即 p，但是当有一段代码执行 obj.name = \"jen\"， obj 不是一个 proxy，且自身不含 name 属性，但是它的原型链上有一个 proxy，那么，那个proxy的handler里的set方法会被调用，而此时obj会作为 receiver 这个参数传进来。\n\n* 对属性的修改进行校验\n```javascript\nlet foo = {\n    a:1,\n    b:2\n}\nlet handler = {\n    set:(obj,key,value)=>{\n        console.log('set')\n        if (typeof(value) !== 'number') throw new Error('can not change property:'+key)\n        obj[key] = value\n        return true\n    }\n}\n\nlet p = new Proxy(foo,handler)\n\np.a = 'hello' // Uncaught Error\n```\n\n## Proxy和响应式对象reactive\nVue3中的响应式对象：\n```javascript\nimport {ref,reactive} from 'vue'\n...\nsetup(){\n  const name = ref('test')\n  const state = reactive({\n    list: []\n  })\n  return {\n      name,\n      state\n  }\n}\n...\n```\n在Vue3中，composition-api提供了一种创建响应式对象的方法reactive，其内部就是利用了Proxy API来实现的，特别是借助handler的set方法，可以实现双向数据绑定相关的逻辑，这对于Vue2.x中的`Object.defineProperty()`是很大的改变。\n\n* `Object.defineProperty()`只能单一的监听已有属性的修改或者变化，无法检测到对象属性的新增或删除，而Proxy则可以轻松实现。\n\n* `Object.defineProperty()`无法监听属性值是数组类型的变化，而Proxy则可以轻松实现。\n\n例如监听数组的变化：\n\n```javascript\nlet arr = [1]\nlet handler = {\n    set:(obj,key,value)=>{\n        console.log('set')\n        return Reflect.set(obj, key, value);\n    }\n}\n\nlet p = new Proxy(arr,handler)\np.push(2)\n```\n\n上面代码中`Reflect.set()`用于修改数组的值，可以参考[Reflect](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect)，但是目前对于多层对象嵌套问题，需要经过一定的处理：\n\n```javascript\nlet foo = {\n    a:1,\n    b:2\n}\nlet handler = {\n    set:(obj,key,value)=>{\n        console.log('set')\n        // 双向绑定相关逻辑\n        obj[key] = value\n        return true\n    }\n}\n\nlet p = new Proxy(foo,handler)\n\np.a = 3\n```\n\n上面代码中，对于简单的对象foo是完全没问题的，但是如果foo是一个复杂对象，里面嵌套的很多对象，那么当去尝试修改里层对象的值时，set方法就不会触发，为了解决这种场景，在Vue3中，采用了**递归**的方式来解决这个问题：\n\n```javascript\nlet foo = {a:{c:3,d:{e:4}},b:2}\nconst isObject = (val)=>{\n    return val !== null && typeof val === 'object'\n}\nconst createProxy = (target)=>{\n    let p = new Proxy(target,{\n        get:(obj,key)=>{\n            let res = obj[key] ? obj[key] : undefined\n\n            // 判断类型，避免死循环\n            if (isObject(res)) {\n                return createProxy(res)\n            } else {\n                return res\n            }\n        },\n        set: (obj, key, value)=> {\n          console.log('set')\n          obj[key] = value;\n\n        }\n    })\n\n    return p\n}\n\nlet result = createProxy(foo)\n\nresult.a.d.e = 6 // 打印出set\n```\n\n**当尝试去修改一个多层嵌套的对象的属性时，会触发该属性的上一级对象的get方法**，利用这个就可以对每个层级的对象添加Proxy代理，这样就实现了多层嵌套对象的属性修改问题。\n\n当然，上面这段代码只是Vue3中reactive的一个缩影，更多的细节可以浏览相关[源码](https://github.com/vuejs/vue-next/tree/a5b4332c69146de569ad328cac9224c3cded15c9/packages/reactivity/src)来了解。\n\n就目前来看，Porxy API相关内容是从ES2015才引入的标准，并且业界相关的polyfill也不是很完善，所以使用此API相关的框架要慎重的考虑兼容性问题。\n\n\n","source":"_posts/Proxy API--Vue3响应式对象reactive初探.md","raw":"---\ntitle: Proxy API--Vue3响应式对象reactive初探\ndate: 2020-05-26 17:26:17\ntags:\n- Vue3\n- Vue.js\ncategories:\n- 1209\n\n---\n\n`Proxy API`对应的`Proxy`对象是[ES2015](https://www.ecma-international.org/ecma-262/6.0/#sec-proxy-objects)就已引入的一个原生对象，用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。\n\n从字面意思来理解，`Proxy`对象是目标对象的一个代理器，任何对目标对象的操作（实例化，添加/删除/修改属性等等），都必须通过该代理器。因此我们可以把来自外界的所有操作进行拦截和过滤或者修改等操作。\n\n基于`Proxy`的这些特性，常用于：\n* 创建一个可“响应式”的对象，例如Vue3.0中的reactive方法。\n* 创建可隔离的JavaScript“沙箱”。\n\n<!--more-->\n## Proxy常见用法\n\nProxy语法：\n```javascript\nconst p = new Proxy(target, handler)\n```\n\n* target：要使用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。\n* handler：以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。\n\n例如下面一个很简单的用法：\n```javascript\nlet foo = {\n  a: 1,\n  b: 2\n}\nlet handler = {\n    get:(obj,key)=>{\n        console.log('get')\n        return key in obj ? obj[key] : undefined\n    }\n}\nlet p = new Proxy(foo,handler)\nconsole.log(p.a) // 1\n```\n上面代码中p就是foo的代理对象，对p对象的相关操作都会同步到foo对象上。\n\n同时Proxy也提供了另一种生成代理对象的方法`Proxy.revocable()`：\n```javascript\nconst { proxy,revoke } = Proxy.revocable(target, handler)\n```\n该方法的返回值是一个对象，其结构为： `{\"proxy\": proxy, \"revoke\": revoke}`，其中:\n* proxy：表示新生成的代理对象本身，和用一般方式`new Proxy(target, handler)` 创建的代理对象没什么不同，只是它可以被撤销掉。\n* revoke：撤销方法，调用的时候不需要加任何参数，就可以撤销掉和它一起生成的那个代理对象。\n\n例如：\n```javascript\nlet foo = {\n  a: 1,\n  b: 2\n}\nlet handler = {\n    get:(obj,key)=>{\n        console.log('get')\n        return key in obj ? obj[key] : undefined\n    }\n}\nlet { proxy,revoke } = Proxy.revocable(foo,handler)\n\nconsole.log(proxy.a) // 1\n\nrevoke()\n\nconsole.log(proxy.a) // Uncaught TypeError: Cannot perform 'get' on a proxy that has been revoked\n```\n需要注意的是，一旦某个代理对象被撤销，它将变得几乎完全不可调用，在它身上执行任何的可代理操作都会抛出 TypeError 异常。\n\n## Proxy的handler\n上面代码中，我们只使用了get操作的handler，即当尝试获取对象的某个属性时会进入这个方法，除此之外Proxy共有接近14个handler也可以称作为钩子，它们分别是：\n```\nhandler.getPrototypeOf()：\n在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy) 时。\n\nhandler.setPrototypeOf()：\n在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。\n\nhandler.isExtensible()：\n在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时。\n\nhandler.preventExtensions()：\n在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时。\n\nhandler.getOwnPropertyDescriptor()：\n在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, \"foo\") 时。\n\nhandler.defineProperty()：\n在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, \"foo\", {}) 时。\n\nhandler.has()：\n在判断代理对象是否拥有某个属性时触发该操作，比如在执行 \"foo\" in proxy 时。\n\nhandler.get()：\n在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。\n\nhandler.set()：\n在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。\n\nhandler.deleteProperty()：\n在删除代理对象的某个属性时触发该操作，即使用 delete 运算符，比如在执行 delete proxy.foo 时。\n\nhandler.ownKeys()：\n当执行Object.getOwnPropertyNames(proxy) 和Object.getOwnPropertySymbols(proxy)时触发。\n\nhandler.apply()：\n当代理对象是一个function函数时，调用apply()方法时触发，比如proxy.apply()。\n\nhandler.construct()：\n当代理对象是一个function函数时，通过new关键字实例化时触发，比如new proxy()。\n```\n结合这些handler，我们可以实现一些针对对象的限制操作，例如：\n\n* 禁止删除和修改对象的某个属性\n\n```javascript\nlet foo = {\n    a:1,\n    b:2\n}\nlet handler = {\n    set:(obj,key,value,receiver)=>{\n        console.log('set')\n        if (key == 'a') throw new Error('can not change property:'+key)\n        obj[key] = value\n        return true\n    },\n    deleteProperty:(obj,key)=>{\n        console.log('delete')\n        if (key == 'a') throw new Error('can not delete property:'+key)\n        delete obj[key]\n        return true\n    }\n}\n\nlet p = new Proxy(foo,handler)\n\np.a = 3 // Uncaught Error\n\ndelete p.a  // Uncaught Error\n```\n\n其中，set方法的receiver通常是 Proxy 本即 p，但是当有一段代码执行 obj.name = \"jen\"， obj 不是一个 proxy，且自身不含 name 属性，但是它的原型链上有一个 proxy，那么，那个proxy的handler里的set方法会被调用，而此时obj会作为 receiver 这个参数传进来。\n\n* 对属性的修改进行校验\n```javascript\nlet foo = {\n    a:1,\n    b:2\n}\nlet handler = {\n    set:(obj,key,value)=>{\n        console.log('set')\n        if (typeof(value) !== 'number') throw new Error('can not change property:'+key)\n        obj[key] = value\n        return true\n    }\n}\n\nlet p = new Proxy(foo,handler)\n\np.a = 'hello' // Uncaught Error\n```\n\n## Proxy和响应式对象reactive\nVue3中的响应式对象：\n```javascript\nimport {ref,reactive} from 'vue'\n...\nsetup(){\n  const name = ref('test')\n  const state = reactive({\n    list: []\n  })\n  return {\n      name,\n      state\n  }\n}\n...\n```\n在Vue3中，composition-api提供了一种创建响应式对象的方法reactive，其内部就是利用了Proxy API来实现的，特别是借助handler的set方法，可以实现双向数据绑定相关的逻辑，这对于Vue2.x中的`Object.defineProperty()`是很大的改变。\n\n* `Object.defineProperty()`只能单一的监听已有属性的修改或者变化，无法检测到对象属性的新增或删除，而Proxy则可以轻松实现。\n\n* `Object.defineProperty()`无法监听属性值是数组类型的变化，而Proxy则可以轻松实现。\n\n例如监听数组的变化：\n\n```javascript\nlet arr = [1]\nlet handler = {\n    set:(obj,key,value)=>{\n        console.log('set')\n        return Reflect.set(obj, key, value);\n    }\n}\n\nlet p = new Proxy(arr,handler)\np.push(2)\n```\n\n上面代码中`Reflect.set()`用于修改数组的值，可以参考[Reflect](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect)，但是目前对于多层对象嵌套问题，需要经过一定的处理：\n\n```javascript\nlet foo = {\n    a:1,\n    b:2\n}\nlet handler = {\n    set:(obj,key,value)=>{\n        console.log('set')\n        // 双向绑定相关逻辑\n        obj[key] = value\n        return true\n    }\n}\n\nlet p = new Proxy(foo,handler)\n\np.a = 3\n```\n\n上面代码中，对于简单的对象foo是完全没问题的，但是如果foo是一个复杂对象，里面嵌套的很多对象，那么当去尝试修改里层对象的值时，set方法就不会触发，为了解决这种场景，在Vue3中，采用了**递归**的方式来解决这个问题：\n\n```javascript\nlet foo = {a:{c:3,d:{e:4}},b:2}\nconst isObject = (val)=>{\n    return val !== null && typeof val === 'object'\n}\nconst createProxy = (target)=>{\n    let p = new Proxy(target,{\n        get:(obj,key)=>{\n            let res = obj[key] ? obj[key] : undefined\n\n            // 判断类型，避免死循环\n            if (isObject(res)) {\n                return createProxy(res)\n            } else {\n                return res\n            }\n        },\n        set: (obj, key, value)=> {\n          console.log('set')\n          obj[key] = value;\n\n        }\n    })\n\n    return p\n}\n\nlet result = createProxy(foo)\n\nresult.a.d.e = 6 // 打印出set\n```\n\n**当尝试去修改一个多层嵌套的对象的属性时，会触发该属性的上一级对象的get方法**，利用这个就可以对每个层级的对象添加Proxy代理，这样就实现了多层嵌套对象的属性修改问题。\n\n当然，上面这段代码只是Vue3中reactive的一个缩影，更多的细节可以浏览相关[源码](https://github.com/vuejs/vue-next/tree/a5b4332c69146de569ad328cac9224c3cded15c9/packages/reactivity/src)来了解。\n\n就目前来看，Porxy API相关内容是从ES2015才引入的标准，并且业界相关的polyfill也不是很完善，所以使用此API相关的框架要慎重的考虑兼容性问题。\n\n\n","slug":"Proxy API--Vue3响应式对象reactive初探","published":1,"updated":"2021-12-10T15:30:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434q00000w2wvjxgpu292e","content":"<p><code>Proxy API</code>对应的<code>Proxy</code>对象是<a href=\"https://www.ecma-international.org/ecma-262/6.0/#sec-proxy-objects\" target=\"_blank\" rel=\"noopener\">ES2015</a>就已引入的一个原生对象，用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。</p>\n<p>从字面意思来理解，<code>Proxy</code>对象是目标对象的一个代理器，任何对目标对象的操作（实例化，添加/删除/修改属性等等），都必须通过该代理器。因此我们可以把来自外界的所有操作进行拦截和过滤或者修改等操作。</p>\n<p>基于<code>Proxy</code>的这些特性，常用于：</p>\n<ul>\n<li>创建一个可“响应式”的对象，例如Vue3.0中的reactive方法。</li>\n<li>创建可隔离的JavaScript“沙箱”。</li>\n</ul>\n<a id=\"more\"></a>\n<h2><span id=\"proxy常见用法\">Proxy常见用法</span></h2><p>Proxy语法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>target：要使用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</li>\n<li>handler：以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。</li>\n</ul>\n<p>例如下面一个很简单的用法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> foo = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span>,</span><br><span class=\"line\">  b: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> handler = &#123;</span><br><span class=\"line\">    get:<span class=\"function\">(<span class=\"params\">obj,key</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'get'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> key <span class=\"keyword\">in</span> obj ? obj[key] : <span class=\"literal\">undefined</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(foo,handler)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p.a) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码中p就是foo的代理对象，对p对象的相关操作都会同步到foo对象上。</p>\n<p>同时Proxy也提供了另一种生成代理对象的方法<code>Proxy.revocable()</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; proxy,revoke &#125; = <span class=\"built_in\">Proxy</span>.revocable(target, handler)</span><br></pre></td></tr></table></figure></p>\n<p>该方法的返回值是一个对象，其结构为： <code>{&quot;proxy&quot;: proxy, &quot;revoke&quot;: revoke}</code>，其中:</p>\n<ul>\n<li>proxy：表示新生成的代理对象本身，和用一般方式<code>new Proxy(target, handler)</code> 创建的代理对象没什么不同，只是它可以被撤销掉。</li>\n<li>revoke：撤销方法，调用的时候不需要加任何参数，就可以撤销掉和它一起生成的那个代理对象。</li>\n</ul>\n<p>例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> foo = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span>,</span><br><span class=\"line\">  b: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> handler = &#123;</span><br><span class=\"line\">    get:<span class=\"function\">(<span class=\"params\">obj,key</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'get'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> key <span class=\"keyword\">in</span> obj ? obj[key] : <span class=\"literal\">undefined</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; proxy,revoke &#125; = <span class=\"built_in\">Proxy</span>.revocable(foo,handler)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(proxy.a) <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">revoke()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(proxy.a) <span class=\"comment\">// Uncaught TypeError: Cannot perform 'get' on a proxy that has been revoked</span></span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是，一旦某个代理对象被撤销，它将变得几乎完全不可调用，在它身上执行任何的可代理操作都会抛出 TypeError 异常。</p>\n<h2><span id=\"proxy的handler\">Proxy的handler</span></h2><p>上面代码中，我们只使用了get操作的handler，即当尝试获取对象的某个属性时会进入这个方法，除此之外Proxy共有接近14个handler也可以称作为钩子，它们分别是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handler.getPrototypeOf()：</span><br><span class=\"line\">在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy) 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.setPrototypeOf()：</span><br><span class=\"line\">在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.isExtensible()：</span><br><span class=\"line\">在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.preventExtensions()：</span><br><span class=\"line\">在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.getOwnPropertyDescriptor()：</span><br><span class=\"line\">在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, &quot;foo&quot;) 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.defineProperty()：</span><br><span class=\"line\">在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, &quot;foo&quot;, &#123;&#125;) 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.has()：</span><br><span class=\"line\">在判断代理对象是否拥有某个属性时触发该操作，比如在执行 &quot;foo&quot; in proxy 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.get()：</span><br><span class=\"line\">在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.set()：</span><br><span class=\"line\">在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.deleteProperty()：</span><br><span class=\"line\">在删除代理对象的某个属性时触发该操作，即使用 delete 运算符，比如在执行 delete proxy.foo 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.ownKeys()：</span><br><span class=\"line\">当执行Object.getOwnPropertyNames(proxy) 和Object.getOwnPropertySymbols(proxy)时触发。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.apply()：</span><br><span class=\"line\">当代理对象是一个function函数时，调用apply()方法时触发，比如proxy.apply()。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.construct()：</span><br><span class=\"line\">当代理对象是一个function函数时，通过new关键字实例化时触发，比如new proxy()。</span><br></pre></td></tr></table></figure></p>\n<p>结合这些handler，我们可以实现一些针对对象的限制操作，例如：</p>\n<ul>\n<li>禁止删除和修改对象的某个属性</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> foo = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">1</span>,</span><br><span class=\"line\">    b:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> handler = &#123;</span><br><span class=\"line\">    set:<span class=\"function\">(<span class=\"params\">obj,key,value,receiver</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'set'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"string\">'a'</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'can not change property:'</span>+key)</span><br><span class=\"line\">        obj[key] = value</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    deleteProperty:<span class=\"function\">(<span class=\"params\">obj,key</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'delete'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"string\">'a'</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'can not delete property:'</span>+key)</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> obj[key]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(foo,handler)</span><br><span class=\"line\"></span><br><span class=\"line\">p.a = <span class=\"number\">3</span> <span class=\"comment\">// Uncaught Error</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span> p.a  <span class=\"comment\">// Uncaught Error</span></span><br></pre></td></tr></table></figure>\n<p>其中，set方法的receiver通常是 Proxy 本即 p，但是当有一段代码执行 obj.name = “jen”， obj 不是一个 proxy，且自身不含 name 属性，但是它的原型链上有一个 proxy，那么，那个proxy的handler里的set方法会被调用，而此时obj会作为 receiver 这个参数传进来。</p>\n<ul>\n<li>对属性的修改进行校验<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> foo = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">1</span>,</span><br><span class=\"line\">    b:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> handler = &#123;</span><br><span class=\"line\">    set:<span class=\"function\">(<span class=\"params\">obj,key,value</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'set'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span>(value) !== <span class=\"string\">'number'</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'can not change property:'</span>+key)</span><br><span class=\"line\">        obj[key] = value</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(foo,handler)</span><br><span class=\"line\"></span><br><span class=\"line\">p.a = <span class=\"string\">'hello'</span> <span class=\"comment\">// Uncaught Error</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2><span id=\"proxy和响应式对象reactive\">Proxy和响应式对象reactive</span></h2><p>Vue3中的响应式对象：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;ref,reactive&#125; <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\">...</span><br><span class=\"line\">setup()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> name = ref(<span class=\"string\">'test'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> state = reactive(&#123;</span><br><span class=\"line\">    list: []</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      name,</span><br><span class=\"line\">      state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>在Vue3中，composition-api提供了一种创建响应式对象的方法reactive，其内部就是利用了Proxy API来实现的，特别是借助handler的set方法，可以实现双向数据绑定相关的逻辑，这对于Vue2.x中的<code>Object.defineProperty()</code>是很大的改变。</p>\n<ul>\n<li><p><code>Object.defineProperty()</code>只能单一的监听已有属性的修改或者变化，无法检测到对象属性的新增或删除，而Proxy则可以轻松实现。</p>\n</li>\n<li><p><code>Object.defineProperty()</code>无法监听属性值是数组类型的变化，而Proxy则可以轻松实现。</p>\n</li>\n</ul>\n<p>例如监听数组的变化：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> handler = &#123;</span><br><span class=\"line\">    set:<span class=\"function\">(<span class=\"params\">obj,key,value</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'set'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.set(obj, key, value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(arr,handler)</span><br><span class=\"line\">p.push(<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p>上面代码中<code>Reflect.set()</code>用于修改数组的值，可以参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect\" target=\"_blank\" rel=\"noopener\">Reflect</a>，但是目前对于多层对象嵌套问题，需要经过一定的处理：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> foo = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">1</span>,</span><br><span class=\"line\">    b:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> handler = &#123;</span><br><span class=\"line\">    set:<span class=\"function\">(<span class=\"params\">obj,key,value</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'set'</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 双向绑定相关逻辑</span></span><br><span class=\"line\">        obj[key] = value</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(foo,handler)</span><br><span class=\"line\"></span><br><span class=\"line\">p.a = <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，对于简单的对象foo是完全没问题的，但是如果foo是一个复杂对象，里面嵌套的很多对象，那么当去尝试修改里层对象的值时，set方法就不会触发，为了解决这种场景，在Vue3中，采用了<strong>递归</strong>的方式来解决这个问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> foo = &#123;<span class=\"attr\">a</span>:&#123;<span class=\"attr\">c</span>:<span class=\"number\">3</span>,<span class=\"attr\">d</span>:&#123;<span class=\"attr\">e</span>:<span class=\"number\">4</span>&#125;&#125;,<span class=\"attr\">b</span>:<span class=\"number\">2</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> isObject = <span class=\"function\">(<span class=\"params\">val</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> val !== <span class=\"literal\">null</span> &amp;&amp; <span class=\"keyword\">typeof</span> val === <span class=\"string\">'object'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> createProxy = <span class=\"function\">(<span class=\"params\">target</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target,&#123;</span><br><span class=\"line\">        get:<span class=\"function\">(<span class=\"params\">obj,key</span>)=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> res = obj[key] ? obj[key] : <span class=\"literal\">undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 判断类型，避免死循环</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isObject(res)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> createProxy(res)</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> res</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        set: <span class=\"function\">(<span class=\"params\">obj, key, value</span>)=&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'set'</span>)</span><br><span class=\"line\">          obj[key] = value;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> p</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = createProxy(foo)</span><br><span class=\"line\"></span><br><span class=\"line\">result.a.d.e = <span class=\"number\">6</span> <span class=\"comment\">// 打印出set</span></span><br></pre></td></tr></table></figure>\n<p><strong>当尝试去修改一个多层嵌套的对象的属性时，会触发该属性的上一级对象的get方法</strong>，利用这个就可以对每个层级的对象添加Proxy代理，这样就实现了多层嵌套对象的属性修改问题。</p>\n<p>当然，上面这段代码只是Vue3中reactive的一个缩影，更多的细节可以浏览相关<a href=\"https://github.com/vuejs/vue-next/tree/a5b4332c69146de569ad328cac9224c3cded15c9/packages/reactivity/src\" target=\"_blank\" rel=\"noopener\">源码</a>来了解。</p>\n<p>就目前来看，Porxy API相关内容是从ES2015才引入的标准，并且业界相关的polyfill也不是很完善，所以使用此API相关的框架要慎重的考虑兼容性问题。</p>\n","site":{"data":{}},"excerpt":"<p><code>Proxy API</code>对应的<code>Proxy</code>对象是<a href=\"https://www.ecma-international.org/ecma-262/6.0/#sec-proxy-objects\" target=\"_blank\" rel=\"noopener\">ES2015</a>就已引入的一个原生对象，用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。</p>\n<p>从字面意思来理解，<code>Proxy</code>对象是目标对象的一个代理器，任何对目标对象的操作（实例化，添加/删除/修改属性等等），都必须通过该代理器。因此我们可以把来自外界的所有操作进行拦截和过滤或者修改等操作。</p>\n<p>基于<code>Proxy</code>的这些特性，常用于：</p>\n<ul>\n<li>创建一个可“响应式”的对象，例如Vue3.0中的reactive方法。</li>\n<li>创建可隔离的JavaScript“沙箱”。</li>\n</ul>","more":"<h2 id=\"Proxy常见用法\"><a href=\"#Proxy常见用法\" class=\"headerlink\" title=\"Proxy常见用法\"></a>Proxy常见用法</h2><p>Proxy语法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>target：要使用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</li>\n<li>handler：以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。</li>\n</ul>\n<p>例如下面一个很简单的用法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> foo = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span>,</span><br><span class=\"line\">  b: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> handler = &#123;</span><br><span class=\"line\">    get:<span class=\"function\">(<span class=\"params\">obj,key</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'get'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> key <span class=\"keyword\">in</span> obj ? obj[key] : <span class=\"literal\">undefined</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(foo,handler)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p.a) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码中p就是foo的代理对象，对p对象的相关操作都会同步到foo对象上。</p>\n<p>同时Proxy也提供了另一种生成代理对象的方法<code>Proxy.revocable()</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; proxy,revoke &#125; = <span class=\"built_in\">Proxy</span>.revocable(target, handler)</span><br></pre></td></tr></table></figure></p>\n<p>该方法的返回值是一个对象，其结构为： <code>{&quot;proxy&quot;: proxy, &quot;revoke&quot;: revoke}</code>，其中:</p>\n<ul>\n<li>proxy：表示新生成的代理对象本身，和用一般方式<code>new Proxy(target, handler)</code> 创建的代理对象没什么不同，只是它可以被撤销掉。</li>\n<li>revoke：撤销方法，调用的时候不需要加任何参数，就可以撤销掉和它一起生成的那个代理对象。</li>\n</ul>\n<p>例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> foo = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span>,</span><br><span class=\"line\">  b: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> handler = &#123;</span><br><span class=\"line\">    get:<span class=\"function\">(<span class=\"params\">obj,key</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'get'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> key <span class=\"keyword\">in</span> obj ? obj[key] : <span class=\"literal\">undefined</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; proxy,revoke &#125; = <span class=\"built_in\">Proxy</span>.revocable(foo,handler)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(proxy.a) <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">revoke()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(proxy.a) <span class=\"comment\">// Uncaught TypeError: Cannot perform 'get' on a proxy that has been revoked</span></span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是，一旦某个代理对象被撤销，它将变得几乎完全不可调用，在它身上执行任何的可代理操作都会抛出 TypeError 异常。</p>\n<h2 id=\"Proxy的handler\"><a href=\"#Proxy的handler\" class=\"headerlink\" title=\"Proxy的handler\"></a>Proxy的handler</h2><p>上面代码中，我们只使用了get操作的handler，即当尝试获取对象的某个属性时会进入这个方法，除此之外Proxy共有接近14个handler也可以称作为钩子，它们分别是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handler.getPrototypeOf()：</span><br><span class=\"line\">在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy) 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.setPrototypeOf()：</span><br><span class=\"line\">在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.isExtensible()：</span><br><span class=\"line\">在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.preventExtensions()：</span><br><span class=\"line\">在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.getOwnPropertyDescriptor()：</span><br><span class=\"line\">在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, &quot;foo&quot;) 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.defineProperty()：</span><br><span class=\"line\">在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, &quot;foo&quot;, &#123;&#125;) 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.has()：</span><br><span class=\"line\">在判断代理对象是否拥有某个属性时触发该操作，比如在执行 &quot;foo&quot; in proxy 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.get()：</span><br><span class=\"line\">在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.set()：</span><br><span class=\"line\">在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.deleteProperty()：</span><br><span class=\"line\">在删除代理对象的某个属性时触发该操作，即使用 delete 运算符，比如在执行 delete proxy.foo 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.ownKeys()：</span><br><span class=\"line\">当执行Object.getOwnPropertyNames(proxy) 和Object.getOwnPropertySymbols(proxy)时触发。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.apply()：</span><br><span class=\"line\">当代理对象是一个function函数时，调用apply()方法时触发，比如proxy.apply()。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.construct()：</span><br><span class=\"line\">当代理对象是一个function函数时，通过new关键字实例化时触发，比如new proxy()。</span><br></pre></td></tr></table></figure></p>\n<p>结合这些handler，我们可以实现一些针对对象的限制操作，例如：</p>\n<ul>\n<li>禁止删除和修改对象的某个属性</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> foo = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">1</span>,</span><br><span class=\"line\">    b:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> handler = &#123;</span><br><span class=\"line\">    set:<span class=\"function\">(<span class=\"params\">obj,key,value,receiver</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'set'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"string\">'a'</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'can not change property:'</span>+key)</span><br><span class=\"line\">        obj[key] = value</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    deleteProperty:<span class=\"function\">(<span class=\"params\">obj,key</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'delete'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"string\">'a'</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'can not delete property:'</span>+key)</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> obj[key]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(foo,handler)</span><br><span class=\"line\"></span><br><span class=\"line\">p.a = <span class=\"number\">3</span> <span class=\"comment\">// Uncaught Error</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span> p.a  <span class=\"comment\">// Uncaught Error</span></span><br></pre></td></tr></table></figure>\n<p>其中，set方法的receiver通常是 Proxy 本即 p，但是当有一段代码执行 obj.name = “jen”， obj 不是一个 proxy，且自身不含 name 属性，但是它的原型链上有一个 proxy，那么，那个proxy的handler里的set方法会被调用，而此时obj会作为 receiver 这个参数传进来。</p>\n<ul>\n<li>对属性的修改进行校验<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> foo = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">1</span>,</span><br><span class=\"line\">    b:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> handler = &#123;</span><br><span class=\"line\">    set:<span class=\"function\">(<span class=\"params\">obj,key,value</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'set'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span>(value) !== <span class=\"string\">'number'</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'can not change property:'</span>+key)</span><br><span class=\"line\">        obj[key] = value</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(foo,handler)</span><br><span class=\"line\"></span><br><span class=\"line\">p.a = <span class=\"string\">'hello'</span> <span class=\"comment\">// Uncaught Error</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Proxy和响应式对象reactive\"><a href=\"#Proxy和响应式对象reactive\" class=\"headerlink\" title=\"Proxy和响应式对象reactive\"></a>Proxy和响应式对象reactive</h2><p>Vue3中的响应式对象：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;ref,reactive&#125; <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\">...</span><br><span class=\"line\">setup()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> name = ref(<span class=\"string\">'test'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> state = reactive(&#123;</span><br><span class=\"line\">    list: []</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      name,</span><br><span class=\"line\">      state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>在Vue3中，composition-api提供了一种创建响应式对象的方法reactive，其内部就是利用了Proxy API来实现的，特别是借助handler的set方法，可以实现双向数据绑定相关的逻辑，这对于Vue2.x中的<code>Object.defineProperty()</code>是很大的改变。</p>\n<ul>\n<li><p><code>Object.defineProperty()</code>只能单一的监听已有属性的修改或者变化，无法检测到对象属性的新增或删除，而Proxy则可以轻松实现。</p>\n</li>\n<li><p><code>Object.defineProperty()</code>无法监听属性值是数组类型的变化，而Proxy则可以轻松实现。</p>\n</li>\n</ul>\n<p>例如监听数组的变化：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> handler = &#123;</span><br><span class=\"line\">    set:<span class=\"function\">(<span class=\"params\">obj,key,value</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'set'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.set(obj, key, value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(arr,handler)</span><br><span class=\"line\">p.push(<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p>上面代码中<code>Reflect.set()</code>用于修改数组的值，可以参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect\" target=\"_blank\" rel=\"noopener\">Reflect</a>，但是目前对于多层对象嵌套问题，需要经过一定的处理：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> foo = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">1</span>,</span><br><span class=\"line\">    b:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> handler = &#123;</span><br><span class=\"line\">    set:<span class=\"function\">(<span class=\"params\">obj,key,value</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'set'</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 双向绑定相关逻辑</span></span><br><span class=\"line\">        obj[key] = value</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(foo,handler)</span><br><span class=\"line\"></span><br><span class=\"line\">p.a = <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，对于简单的对象foo是完全没问题的，但是如果foo是一个复杂对象，里面嵌套的很多对象，那么当去尝试修改里层对象的值时，set方法就不会触发，为了解决这种场景，在Vue3中，采用了<strong>递归</strong>的方式来解决这个问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> foo = &#123;<span class=\"attr\">a</span>:&#123;<span class=\"attr\">c</span>:<span class=\"number\">3</span>,<span class=\"attr\">d</span>:&#123;<span class=\"attr\">e</span>:<span class=\"number\">4</span>&#125;&#125;,<span class=\"attr\">b</span>:<span class=\"number\">2</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> isObject = <span class=\"function\">(<span class=\"params\">val</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> val !== <span class=\"literal\">null</span> &amp;&amp; <span class=\"keyword\">typeof</span> val === <span class=\"string\">'object'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> createProxy = <span class=\"function\">(<span class=\"params\">target</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target,&#123;</span><br><span class=\"line\">        get:<span class=\"function\">(<span class=\"params\">obj,key</span>)=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> res = obj[key] ? obj[key] : <span class=\"literal\">undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 判断类型，避免死循环</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isObject(res)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> createProxy(res)</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> res</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        set: <span class=\"function\">(<span class=\"params\">obj, key, value</span>)=&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'set'</span>)</span><br><span class=\"line\">          obj[key] = value;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> p</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = createProxy(foo)</span><br><span class=\"line\"></span><br><span class=\"line\">result.a.d.e = <span class=\"number\">6</span> <span class=\"comment\">// 打印出set</span></span><br></pre></td></tr></table></figure>\n<p><strong>当尝试去修改一个多层嵌套的对象的属性时，会触发该属性的上一级对象的get方法</strong>，利用这个就可以对每个层级的对象添加Proxy代理，这样就实现了多层嵌套对象的属性修改问题。</p>\n<p>当然，上面这段代码只是Vue3中reactive的一个缩影，更多的细节可以浏览相关<a href=\"https://github.com/vuejs/vue-next/tree/a5b4332c69146de569ad328cac9224c3cded15c9/packages/reactivity/src\" target=\"_blank\" rel=\"noopener\">源码</a>来了解。</p>\n<p>就目前来看，Porxy API相关内容是从ES2015才引入的标准，并且业界相关的polyfill也不是很完善，所以使用此API相关的框架要慎重的考虑兼容性问题。</p>"},{"title":"React 16升级指南","date":"2018-01-15T12:23:10.000Z","_content":"\n\n# 先说一下升级带来的好处\n### 1. 更小的资源 \n\nreact+react dom打包之后 相较于上一个版本大小减少了约30%：如下图：\n<!--more-->\nReact 15：\n![](https://qiniu.nihaoshijie.com.cn/1513841084_41_w791_h51.png)\nReact 16：\n![](https://qiniu.nihaoshijie.com.cn/blog/1513841084_41_w791_h51.png)\n\n### 2. 更强的渲染性能\nReact 16是第一个对React核心代码进行了重构命名为React Fiber，Fiber 相较于之前最大的不同是它可以支持异步渲染，异步渲染的意义在于能够将渲染任务划分为多块。浏览器的渲染引擎是单线程的，这意味着几乎所有的行为都是同步发生的。React 16 使用原生的浏览器 API 来间歇性地检查当前是否还有其他任务需要完成，从而实现了对主线程和渲染过程的管理，这块具体的逻辑比较复杂，想要深入研究的可以参照React Fiber的源码。\n\n笔者尝试了将原来频繁setState的场景，例如拖动效果：\n\n```javascript\nonTouchMove(e) {\n   let po = this.getPosition(e);\n    this.setState({\n        top: po.y,\n        left: po.x\n    });\n}\n```\n切换到React 16之后在某些低端机型上的拖动体验要比之前好一些，关于前端的渲染性能有待进一步的数据验证。\n\n### 3. 服务端渲染性能的提升\n\nReact 16的SSR被完全重写，新的实现非常快，接近3倍性能于React 15，现在提供一种流模式streaming，可以更快地把渲染的字节发送到客户端。关于服务端性能渲染的数据有待和直出共同端统计：升级前后内存占用量对比 (蓝线升级后 绿线升级前)减低10% 的cpu内存使用量\n\n\n### 4. render方法支持返回数组\n\n之前使用React时，会经常遇到的一个问题就是在返回多余一个组件时要使用一个div包裹起来在升级之后就可以直接返回一个数组：\n\n```javascript\nrender(){\n  return [\n    <div key=\"1\">1</div>,\n    <span key=\"2\">2</span>,\n    <p key=\"3\">3</p>\n  ]\n}\n```\n\n### 5. 更强的错误处理机制\n\n在React 15的时候，react的错误处理机制借助unstable_handleError来处理异常，这个有局限性也不是很好用，React 16将这一功能进行了升级，新增了组件生命周期的`componentDidCatch`方法：\n\n我们可以新建一个错误处理的Component来处理react运行时的异常：\n\n```javascript\nimport React, { Component } from 'react';\nclass ErrorHandler extends Component {\n  constructor(props) {\n    super(props); \n    this.state = { error: false };\n  }\n  componentDidCatch(error, info) {\n    this.setState({ error, info });\n  }\n  render() {\n    if (this.state.error) {\n      return null;\n    }\n    return this.props.children;\n  }\n}\nmodule.exports = ErrorHandler;\n```\n\n如何使用这个ErrorHandler组件有两种方式：\n\n1) 包裹在页面根组件上，这样所有子组件发生异常时都会被这个组件捕获，在捕获异常的同时我们可以给与用户更友好的错误提示：\n\n```javascript\nrender() {\n    return (\n        <ErrorHandler>\n             <Main />\n         </ErrorHandler>\n    );\n}\n```\n\n2) 自定义错误可能发生的情况，以局部组件为例：\n我们将ErrorHandler包裹在Recommend上：\n\n```javascript\nrender() {\n    // <Main>\n     return (\n         <ErrorHandler><Recommend /></ErrorHandler>\n     );\n}\n```\n在ErrorHandler捕获到错误之后会采用错误的UI显示或者直接赋值为null，来保证页面其余的UI正常的加载。\n\n# 改造过程的采踩坑\n\n1.React 16依赖于`es6`的`Set`个`Map`，这些在android 4.4以下的机型是没有支持的，在笔者翻看源码后得知用的地方并不多，官方推荐是采用babel-polyfill来处理，但是对于部落并没有直接采用原因是：\n\n1) `bable-polyfill`如果都引入的话基本上会增加大概200k的代码量，其实很多的shim是用不到的，如果想要单独抽离Set和Map又比较麻烦，bable-polyfill的Set和Map需要引入collection，collection又需要引入其他的js，抽离起来比较麻烦。\n\n2) `Set`和`Map`的支持必须要优先于React引入，而部落的React是单独打包的，所以如果要引入babel-polyfill还要修改构建单独生成一份pollyfill的js放在react之前。\n\n解决办法：手写一份Set和Map的支持，大致原理就是利用数组进行改造，然后挂在window对象上，在打包时和React文件一起打包即可。\n\n2. React 16不再支持采用es5写法定义的Component例如：\n\n```javascript\nvar Main = React.createClass({\n    render: function () {\n        return null;\n    }\n});\n```\n\n解决办法有2个：\n\n1)  引入create-react-class：\n\n```javascript\nvar createReactClass = require('create-react-class');\n\nvar Main = createReactClass({\n    render: function() {\n        return null;\n    }\n});\n```\n\n2) 改造成es6的写法：\n\n```javascript\nclass Main extends React.Component {\n    constructor(props) {\n        super();\n }\n ```\n\n部落改造选择了后者，评估了一下工作量差不多有60多个组件要改，对于es6的趋势，所以基本上一次性改成es6最彻底。\n\n3. 改成es6之后this的指向问题：\n\n```javascript\n<Rank onTap={::this.onTap} ></Rank>\n```\n\n4.如果是采用的npm方式升级的话很简单，直接在npm上升级即可，如果是采用单独文件的方式升级要在[react官网](https://github.com/facebook/react/releases)下载对应版本号进行升级即可。\n\n## 备注：\n\n1. 目前部落采用的React版本是16.2.0\n2. 改造升级React 16工作量比较大，对于原先采用es5写的业务，需要一个一个组件的修改，还要关注`this`的问题避免报错。\n3. 如果代码中使用了`require.ensure`来懒加载组件，在修改的时候可以先将ensure注释掉，这样如果懒加载组件中有问题也可以立刻发现。\n\n","source":"_posts/React 16升级指南.md","raw":"---\ntitle: React 16升级指南\ndate: 2018-01-15 20:23:10\ntags:\n- react16 升级\ncategories:\n- 703\n---\n\n\n# 先说一下升级带来的好处\n### 1. 更小的资源 \n\nreact+react dom打包之后 相较于上一个版本大小减少了约30%：如下图：\n<!--more-->\nReact 15：\n![](https://qiniu.nihaoshijie.com.cn/1513841084_41_w791_h51.png)\nReact 16：\n![](https://qiniu.nihaoshijie.com.cn/blog/1513841084_41_w791_h51.png)\n\n### 2. 更强的渲染性能\nReact 16是第一个对React核心代码进行了重构命名为React Fiber，Fiber 相较于之前最大的不同是它可以支持异步渲染，异步渲染的意义在于能够将渲染任务划分为多块。浏览器的渲染引擎是单线程的，这意味着几乎所有的行为都是同步发生的。React 16 使用原生的浏览器 API 来间歇性地检查当前是否还有其他任务需要完成，从而实现了对主线程和渲染过程的管理，这块具体的逻辑比较复杂，想要深入研究的可以参照React Fiber的源码。\n\n笔者尝试了将原来频繁setState的场景，例如拖动效果：\n\n```javascript\nonTouchMove(e) {\n   let po = this.getPosition(e);\n    this.setState({\n        top: po.y,\n        left: po.x\n    });\n}\n```\n切换到React 16之后在某些低端机型上的拖动体验要比之前好一些，关于前端的渲染性能有待进一步的数据验证。\n\n### 3. 服务端渲染性能的提升\n\nReact 16的SSR被完全重写，新的实现非常快，接近3倍性能于React 15，现在提供一种流模式streaming，可以更快地把渲染的字节发送到客户端。关于服务端性能渲染的数据有待和直出共同端统计：升级前后内存占用量对比 (蓝线升级后 绿线升级前)减低10% 的cpu内存使用量\n\n\n### 4. render方法支持返回数组\n\n之前使用React时，会经常遇到的一个问题就是在返回多余一个组件时要使用一个div包裹起来在升级之后就可以直接返回一个数组：\n\n```javascript\nrender(){\n  return [\n    <div key=\"1\">1</div>,\n    <span key=\"2\">2</span>,\n    <p key=\"3\">3</p>\n  ]\n}\n```\n\n### 5. 更强的错误处理机制\n\n在React 15的时候，react的错误处理机制借助unstable_handleError来处理异常，这个有局限性也不是很好用，React 16将这一功能进行了升级，新增了组件生命周期的`componentDidCatch`方法：\n\n我们可以新建一个错误处理的Component来处理react运行时的异常：\n\n```javascript\nimport React, { Component } from 'react';\nclass ErrorHandler extends Component {\n  constructor(props) {\n    super(props); \n    this.state = { error: false };\n  }\n  componentDidCatch(error, info) {\n    this.setState({ error, info });\n  }\n  render() {\n    if (this.state.error) {\n      return null;\n    }\n    return this.props.children;\n  }\n}\nmodule.exports = ErrorHandler;\n```\n\n如何使用这个ErrorHandler组件有两种方式：\n\n1) 包裹在页面根组件上，这样所有子组件发生异常时都会被这个组件捕获，在捕获异常的同时我们可以给与用户更友好的错误提示：\n\n```javascript\nrender() {\n    return (\n        <ErrorHandler>\n             <Main />\n         </ErrorHandler>\n    );\n}\n```\n\n2) 自定义错误可能发生的情况，以局部组件为例：\n我们将ErrorHandler包裹在Recommend上：\n\n```javascript\nrender() {\n    // <Main>\n     return (\n         <ErrorHandler><Recommend /></ErrorHandler>\n     );\n}\n```\n在ErrorHandler捕获到错误之后会采用错误的UI显示或者直接赋值为null，来保证页面其余的UI正常的加载。\n\n# 改造过程的采踩坑\n\n1.React 16依赖于`es6`的`Set`个`Map`，这些在android 4.4以下的机型是没有支持的，在笔者翻看源码后得知用的地方并不多，官方推荐是采用babel-polyfill来处理，但是对于部落并没有直接采用原因是：\n\n1) `bable-polyfill`如果都引入的话基本上会增加大概200k的代码量，其实很多的shim是用不到的，如果想要单独抽离Set和Map又比较麻烦，bable-polyfill的Set和Map需要引入collection，collection又需要引入其他的js，抽离起来比较麻烦。\n\n2) `Set`和`Map`的支持必须要优先于React引入，而部落的React是单独打包的，所以如果要引入babel-polyfill还要修改构建单独生成一份pollyfill的js放在react之前。\n\n解决办法：手写一份Set和Map的支持，大致原理就是利用数组进行改造，然后挂在window对象上，在打包时和React文件一起打包即可。\n\n2. React 16不再支持采用es5写法定义的Component例如：\n\n```javascript\nvar Main = React.createClass({\n    render: function () {\n        return null;\n    }\n});\n```\n\n解决办法有2个：\n\n1)  引入create-react-class：\n\n```javascript\nvar createReactClass = require('create-react-class');\n\nvar Main = createReactClass({\n    render: function() {\n        return null;\n    }\n});\n```\n\n2) 改造成es6的写法：\n\n```javascript\nclass Main extends React.Component {\n    constructor(props) {\n        super();\n }\n ```\n\n部落改造选择了后者，评估了一下工作量差不多有60多个组件要改，对于es6的趋势，所以基本上一次性改成es6最彻底。\n\n3. 改成es6之后this的指向问题：\n\n```javascript\n<Rank onTap={::this.onTap} ></Rank>\n```\n\n4.如果是采用的npm方式升级的话很简单，直接在npm上升级即可，如果是采用单独文件的方式升级要在[react官网](https://github.com/facebook/react/releases)下载对应版本号进行升级即可。\n\n## 备注：\n\n1. 目前部落采用的React版本是16.2.0\n2. 改造升级React 16工作量比较大，对于原先采用es5写的业务，需要一个一个组件的修改，还要关注`this`的问题避免报错。\n3. 如果代码中使用了`require.ensure`来懒加载组件，在修改的时候可以先将ensure注释掉，这样如果懒加载组件中有问题也可以立刻发现。\n\n","slug":"React 16升级指南","published":1,"updated":"2019-04-02T16:49:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434q01000z2wvjl7hclgzm","content":"<h1><span id=\"先说一下升级带来的好处\">先说一下升级带来的好处</span></h1><h3><span id=\"1-更小的资源\">1. 更小的资源</span></h3><p>react+react dom打包之后 相较于上一个版本大小减少了约30%：如下图：<br><a id=\"more\"></a><br>React 15：<br><img src=\"https://qiniu.nihaoshijie.com.cn/1513841084_41_w791_h51.png\" alt><br>React 16：<br><img src=\"https://qiniu.nihaoshijie.com.cn/blog/1513841084_41_w791_h51.png\" alt></p>\n<h3><span id=\"2-更强的渲染性能\">2. 更强的渲染性能</span></h3><p>React 16是第一个对React核心代码进行了重构命名为React Fiber，Fiber 相较于之前最大的不同是它可以支持异步渲染，异步渲染的意义在于能够将渲染任务划分为多块。浏览器的渲染引擎是单线程的，这意味着几乎所有的行为都是同步发生的。React 16 使用原生的浏览器 API 来间歇性地检查当前是否还有其他任务需要完成，从而实现了对主线程和渲染过程的管理，这块具体的逻辑比较复杂，想要深入研究的可以参照React Fiber的源码。</p>\n<p>笔者尝试了将原来频繁setState的场景，例如拖动效果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onTouchMove(e) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">let</span> po = <span class=\"keyword\">this</span>.getPosition(e);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">        top: po.y,</span><br><span class=\"line\">        left: po.x</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>切换到React 16之后在某些低端机型上的拖动体验要比之前好一些，关于前端的渲染性能有待进一步的数据验证。</p>\n<h3><span id=\"3-服务端渲染性能的提升\">3. 服务端渲染性能的提升</span></h3><p>React 16的SSR被完全重写，新的实现非常快，接近3倍性能于React 15，现在提供一种流模式streaming，可以更快地把渲染的字节发送到客户端。关于服务端性能渲染的数据有待和直出共同端统计：升级前后内存占用量对比 (蓝线升级后 绿线升级前)减低10% 的cpu内存使用量</p>\n<h3><span id=\"4-render方法支持返回数组\">4. render方法支持返回数组</span></h3><p>之前使用React时，会经常遇到的一个问题就是在返回多余一个组件时要使用一个div包裹起来在升级之后就可以直接返回一个数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [</span><br><span class=\"line\">    &lt;div key=<span class=\"string\">\"1\"</span>&gt;<span class=\"number\">1</span>&lt;<span class=\"regexp\">/div&gt;,</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;span key=\"2\"&gt;2&lt;/</span>span&gt;,</span><br><span class=\"line\">    &lt;p key=<span class=\"string\">\"3\"</span>&gt;<span class=\"number\">3</span>&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  ]</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"5-更强的错误处理机制\">5. 更强的错误处理机制</span></h3><p>在React 15的时候，react的错误处理机制借助unstable_handleError来处理异常，这个有局限性也不是很好用，React 16将这一功能进行了升级，新增了组件生命周期的<code>componentDidCatch</code>方法：</p>\n<p>我们可以新建一个错误处理的Component来处理react运行时的异常：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ErrorHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props); </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123; <span class=\"attr\">error</span>: <span class=\"literal\">false</span> &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentDidCatch(error, info) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123; error, info &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state.error) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.props.children;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = ErrorHandler;</span><br></pre></td></tr></table></figure>\n<p>如何使用这个ErrorHandler组件有两种方式：</p>\n<p>1) 包裹在页面根组件上，这样所有子组件发生异常时都会被这个组件捕获，在捕获异常的同时我们可以给与用户更友好的错误提示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;ErrorHandler&gt;</span><br><span class=\"line\">             &lt;Main /&gt;</span><br><span class=\"line\">         &lt;<span class=\"regexp\">/ErrorHandler&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>2) 自定义错误可能发生的情况，以局部组件为例：<br>我们将ErrorHandler包裹在Recommend上：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &lt;Main&gt;</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> (</span><br><span class=\"line\">         &lt;ErrorHandler&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Recommend</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ErrorHandler</span>&gt;</span></span></span><br><span class=\"line\">     );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在ErrorHandler捕获到错误之后会采用错误的UI显示或者直接赋值为null，来保证页面其余的UI正常的加载。</p>\n<h1><span id=\"改造过程的采踩坑\">改造过程的采踩坑</span></h1><p>1.React 16依赖于<code>es6</code>的<code>Set</code>个<code>Map</code>，这些在android 4.4以下的机型是没有支持的，在笔者翻看源码后得知用的地方并不多，官方推荐是采用babel-polyfill来处理，但是对于部落并没有直接采用原因是：</p>\n<p>1) <code>bable-polyfill</code>如果都引入的话基本上会增加大概200k的代码量，其实很多的shim是用不到的，如果想要单独抽离Set和Map又比较麻烦，bable-polyfill的Set和Map需要引入collection，collection又需要引入其他的js，抽离起来比较麻烦。</p>\n<p>2) <code>Set</code>和<code>Map</code>的支持必须要优先于React引入，而部落的React是单独打包的，所以如果要引入babel-polyfill还要修改构建单独生成一份pollyfill的js放在react之前。</p>\n<p>解决办法：手写一份Set和Map的支持，大致原理就是利用数组进行改造，然后挂在window对象上，在打包时和React文件一起打包即可。</p>\n<ol>\n<li>React 16不再支持采用es5写法定义的Component例如：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Main = React.createClass(&#123;</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>解决办法有2个：</p>\n<p>1)  引入create-react-class：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> createReactClass = <span class=\"built_in\">require</span>(<span class=\"string\">'create-react-class'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Main = createReactClass(&#123;</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>2) 改造成es6的写法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>部落改造选择了后者，评估了一下工作量差不多有60多个组件要改，对于es6的趋势，所以基本上一次性改成es6最彻底。</p>\n<ol>\n<li>改成es6之后this的指向问题：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Rank onTap=&#123;::<span class=\"keyword\">this</span>.onTap&#125; &gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">Rank</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>4.如果是采用的npm方式升级的话很简单，直接在npm上升级即可，如果是采用单独文件的方式升级要在<a href=\"https://github.com/facebook/react/releases\" target=\"_blank\" rel=\"noopener\">react官网</a>下载对应版本号进行升级即可。</p>\n<h2><span id=\"备注\">备注：</span></h2><ol>\n<li>目前部落采用的React版本是16.2.0</li>\n<li>改造升级React 16工作量比较大，对于原先采用es5写的业务，需要一个一个组件的修改，还要关注<code>this</code>的问题避免报错。</li>\n<li>如果代码中使用了<code>require.ensure</code>来懒加载组件，在修改的时候可以先将ensure注释掉，这样如果懒加载组件中有问题也可以立刻发现。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"先说一下升级带来的好处\"><a href=\"#先说一下升级带来的好处\" class=\"headerlink\" title=\"先说一下升级带来的好处\"></a>先说一下升级带来的好处</h1><h3 id=\"1-更小的资源\"><a href=\"#1-更小的资源\" class=\"headerlink\" title=\"1. 更小的资源\"></a>1. 更小的资源</h3><p>react+react dom打包之后 相较于上一个版本大小减少了约30%：如下图：<br>","more":"<br>React 15：<br><img src=\"https://qiniu.nihaoshijie.com.cn/1513841084_41_w791_h51.png\" alt=\"\"><br>React 16：<br><img src=\"https://qiniu.nihaoshijie.com.cn/blog/1513841084_41_w791_h51.png\" alt=\"\"></p>\n<h3 id=\"2-更强的渲染性能\"><a href=\"#2-更强的渲染性能\" class=\"headerlink\" title=\"2. 更强的渲染性能\"></a>2. 更强的渲染性能</h3><p>React 16是第一个对React核心代码进行了重构命名为React Fiber，Fiber 相较于之前最大的不同是它可以支持异步渲染，异步渲染的意义在于能够将渲染任务划分为多块。浏览器的渲染引擎是单线程的，这意味着几乎所有的行为都是同步发生的。React 16 使用原生的浏览器 API 来间歇性地检查当前是否还有其他任务需要完成，从而实现了对主线程和渲染过程的管理，这块具体的逻辑比较复杂，想要深入研究的可以参照React Fiber的源码。</p>\n<p>笔者尝试了将原来频繁setState的场景，例如拖动效果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onTouchMove(e) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">let</span> po = <span class=\"keyword\">this</span>.getPosition(e);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">        top: po.y,</span><br><span class=\"line\">        left: po.x</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>切换到React 16之后在某些低端机型上的拖动体验要比之前好一些，关于前端的渲染性能有待进一步的数据验证。</p>\n<h3 id=\"3-服务端渲染性能的提升\"><a href=\"#3-服务端渲染性能的提升\" class=\"headerlink\" title=\"3. 服务端渲染性能的提升\"></a>3. 服务端渲染性能的提升</h3><p>React 16的SSR被完全重写，新的实现非常快，接近3倍性能于React 15，现在提供一种流模式streaming，可以更快地把渲染的字节发送到客户端。关于服务端性能渲染的数据有待和直出共同端统计：升级前后内存占用量对比 (蓝线升级后 绿线升级前)减低10% 的cpu内存使用量</p>\n<h3 id=\"4-render方法支持返回数组\"><a href=\"#4-render方法支持返回数组\" class=\"headerlink\" title=\"4. render方法支持返回数组\"></a>4. render方法支持返回数组</h3><p>之前使用React时，会经常遇到的一个问题就是在返回多余一个组件时要使用一个div包裹起来在升级之后就可以直接返回一个数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [</span><br><span class=\"line\">    &lt;div key=<span class=\"string\">\"1\"</span>&gt;<span class=\"number\">1</span>&lt;<span class=\"regexp\">/div&gt;,</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;span key=\"2\"&gt;2&lt;/</span>span&gt;,</span><br><span class=\"line\">    &lt;p key=<span class=\"string\">\"3\"</span>&gt;<span class=\"number\">3</span>&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  ]</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"5-更强的错误处理机制\"><a href=\"#5-更强的错误处理机制\" class=\"headerlink\" title=\"5. 更强的错误处理机制\"></a>5. 更强的错误处理机制</h3><p>在React 15的时候，react的错误处理机制借助unstable_handleError来处理异常，这个有局限性也不是很好用，React 16将这一功能进行了升级，新增了组件生命周期的<code>componentDidCatch</code>方法：</p>\n<p>我们可以新建一个错误处理的Component来处理react运行时的异常：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ErrorHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props); </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123; <span class=\"attr\">error</span>: <span class=\"literal\">false</span> &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentDidCatch(error, info) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123; error, info &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state.error) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.props.children;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = ErrorHandler;</span><br></pre></td></tr></table></figure>\n<p>如何使用这个ErrorHandler组件有两种方式：</p>\n<p>1) 包裹在页面根组件上，这样所有子组件发生异常时都会被这个组件捕获，在捕获异常的同时我们可以给与用户更友好的错误提示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;ErrorHandler&gt;</span><br><span class=\"line\">             &lt;Main /&gt;</span><br><span class=\"line\">         &lt;<span class=\"regexp\">/ErrorHandler&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>2) 自定义错误可能发生的情况，以局部组件为例：<br>我们将ErrorHandler包裹在Recommend上：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &lt;Main&gt;</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> (</span><br><span class=\"line\">         &lt;ErrorHandler&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Recommend</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ErrorHandler</span>&gt;</span></span></span><br><span class=\"line\">     );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在ErrorHandler捕获到错误之后会采用错误的UI显示或者直接赋值为null，来保证页面其余的UI正常的加载。</p>\n<h1 id=\"改造过程的采踩坑\"><a href=\"#改造过程的采踩坑\" class=\"headerlink\" title=\"改造过程的采踩坑\"></a>改造过程的采踩坑</h1><p>1.React 16依赖于<code>es6</code>的<code>Set</code>个<code>Map</code>，这些在android 4.4以下的机型是没有支持的，在笔者翻看源码后得知用的地方并不多，官方推荐是采用babel-polyfill来处理，但是对于部落并没有直接采用原因是：</p>\n<p>1) <code>bable-polyfill</code>如果都引入的话基本上会增加大概200k的代码量，其实很多的shim是用不到的，如果想要单独抽离Set和Map又比较麻烦，bable-polyfill的Set和Map需要引入collection，collection又需要引入其他的js，抽离起来比较麻烦。</p>\n<p>2) <code>Set</code>和<code>Map</code>的支持必须要优先于React引入，而部落的React是单独打包的，所以如果要引入babel-polyfill还要修改构建单独生成一份pollyfill的js放在react之前。</p>\n<p>解决办法：手写一份Set和Map的支持，大致原理就是利用数组进行改造，然后挂在window对象上，在打包时和React文件一起打包即可。</p>\n<ol>\n<li>React 16不再支持采用es5写法定义的Component例如：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Main = React.createClass(&#123;</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>解决办法有2个：</p>\n<p>1)  引入create-react-class：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> createReactClass = <span class=\"built_in\">require</span>(<span class=\"string\">'create-react-class'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Main = createReactClass(&#123;</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>2) 改造成es6的写法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>部落改造选择了后者，评估了一下工作量差不多有60多个组件要改，对于es6的趋势，所以基本上一次性改成es6最彻底。</p>\n<ol>\n<li>改成es6之后this的指向问题：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Rank onTap=&#123;::<span class=\"keyword\">this</span>.onTap&#125; &gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">Rank</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>4.如果是采用的npm方式升级的话很简单，直接在npm上升级即可，如果是采用单独文件的方式升级要在<a href=\"https://github.com/facebook/react/releases\" target=\"_blank\" rel=\"noopener\">react官网</a>下载对应版本号进行升级即可。</p>\n<h2 id=\"备注：\"><a href=\"#备注：\" class=\"headerlink\" title=\"备注：\"></a>备注：</h2><ol>\n<li>目前部落采用的React版本是16.2.0</li>\n<li>改造升级React 16工作量比较大，对于原先采用es5写的业务，需要一个一个组件的修改，还要关注<code>this</code>的问题避免报错。</li>\n<li>如果代码中使用了<code>require.ensure</code>来懒加载组件，在修改的时候可以先将ensure注释掉，这样如果懒加载组件中有问题也可以立刻发现。</li>\n</ol>"},{"title":"React Native Android 踩坑之旅","date":"2015-10-22T13:31:07.000Z","photos":["https://qiniu.nihaoshijie.com.cn/xx.png"],"_content":"<span style=\"color: #008000;\"><strong>前言</strong></span>\n\nFacebook 在2015.9.15发布了 React Native for Android，把 JavaScript 开发技术扩展到了移动Android平台。基于React的React Native 让前端开发者使用 JavaScript 和 React 编写应用，利用相同的核心代码就可以创建 基于Web，iOS 和 Android 平台的原生应用。在React Native for Android出来之后，本人花了些时间从环境搭建到做出几个demo，从体验来看都挺流畅，具体将此间遇到和问题和具体的新的体会，向大家分享一下。\n<!--more-->\n&nbsp;\n\n<span style=\"color: #008000;\"><strong>原理简介</strong></span>\n\n<strong>1 </strong>React Native for Android 和 for IOS的基本原理是一致的，通过android的JavaScriptCore来异步解析js代码(jsbundle文件)，然后根据引入的支持和配置，渲染成原生native组件。\n\n<strong>2 </strong>复用React系统，也减少了一定学习和开发成本，更重要的是利用了React里面的分层和diff机制。js层传给Native层的是一个diff后的json，然后由Native将这个数据映射成真正的布局视图。\n\n&nbsp;\n\n&nbsp;\n\n<span style=\"color: #008000;\"><strong>环境搭建</strong></span>\n\n环境搭建的话，在网上也找到过很多教程，但是还是推荐还是去看官方文档<a href=\"https://facebook.github.io/react-native/docs/android-setup.html#content\" data-cke-saved-href=\"https://facebook.github.io/react-native/docs/android-setup.html#content\">https://facebook.github.io/react-native/docs/android-setup.html#content</a>，在搭建的过程中可能会遇到一些问题。\n\n&nbsp;\n\n<strong>1 </strong>在React Native for Android刚出来的时候，官方称是不支持在windows 系统上安装的，只有在mac上才可以使用<img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/1.png\" alt=\"\" data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/1.png\" />，但是最新版的React Native for Android已经支持在windows上使用，<img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/2.png\" alt=\"\" data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/2.png\" />更新React Native的方法：下载最新版的react-native-cli即npm install -g react-native-cli，并且保证node是最新版的即&gt;4.0。\n\n&nbsp;\n\n<strong>2 </strong>在执行react-native init AwesomeProject 命令时，由于这个命令会去下载一些node module所以要根据自己的实际情况设置npm的代理和镜像，本人就曾经因为这个问题搞了很久才成功，可以安装nrm(npm install -g nrm)来便捷设置npm的代理和镜像，其次是执行这个命令必须现在机器上装有git，并且设置好git的环境变量，另外这个命令需要等待一些时间，不要提前取消。\n\n&nbsp;\n\n<strong>3 </strong>在调用react-native run-android的命令时，有时会报出找不到android-sdk环境变量的错误（自己确实已经正确设置环境变量）提示例如<img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/33.png\" alt=\"\" data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/33.png\" />\n\n的错误时，可以单独在项目根目录下，也就是AwesomeProject/新建一个local.propertites文件，添加sdk.dir=你的android的sdk目录，然后在运行react-native run-android。\n\n&nbsp;\n\n<strong>4 </strong>在调用react-native run-android命令时，其实这个命令就是执行的两部分操作1是构建你的android项目并生成apk，另外一个是打开react-native的package管理工具同时编译你的js文件，其实可以在项目根目录的package.json下找到\n\n<img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/44.png\" alt=\"\" data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/44.png\" />\n\n其实是执行了另外一条命令node node_modules\\react-native\\packager\\packager.js来打开package的管理工具，有些可能没打开一个新的命令行窗口，自己手动执行这条node命令也是可以的。在这条命令执行完之后，node就会开启一个服务，同时把js文件编译成jsbundle文件，我们可以通过<a href=\"http://localhost:8081/index.android.bundle?platform=android\" data-cke-saved-href=\"http://localhost:8081/index.android.bundle?platform=android\">http://localhost:8081/index.android.bundle?platform=android</a>来访问到这个文件，可以简单将这个文件理解成一个html，android就是通过解析这个html来达到渲染的目的，将该文件部署到CDN可供android app从网络获取，即可实现不用发版本让app的UI随时更新，并且可获得接近native的体验，这也是react-native最吸引开发者的亮点之一。\n\n&nbsp;\n\n<strong>5 </strong>用react native命令生成的android项目是基于gradle构建和部署的(不清楚gradle的可以google)，这个以前一些搞用eclipse来android开发的可能不太一样，gradle是用在google主推的一款android开发IDE，android statio里面默认的项目构建方式，所以我们的项目里会看到一些build.gradle的文件，这些都是配置文件。\n\n&nbsp;\n\n<strong>6</strong> 我们在根据教程搭环境时会碰到需要安装android模拟器的步骤，这个步骤会提示你安装一个HAXM的东西<img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/55.png\" alt=\"\" data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/55.png\" />可以看到这个安装不是必须的，其实这个是一个android模拟器的加速程序，按了这个你的模拟器可能会跑的更快，但是在安装这个程序时，会遇到<img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/66.png\" alt=\"\" data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/66.png\" />的错误是由于CPU的虚拟化未开启，需要重新开机在bios上设置一下，具体怎么设置，可以自行google。\n\n&nbsp;\n\n<strong>7 </strong>react-native android在本地调试开发时，你只需要修改js文件，然后刷新你的项目，所以在创建android模拟器时要记得选择带有android键盘的模拟器，这样才能在模拟器上刷新你的更改。\n\n&nbsp;\n\n<strong>与现有的android项目集成</strong>\n\n<strong>1 </strong>想要在现有的android项目里添加react native支持，你必须要先创建一个基于gradle的android项目，推荐使用android studio来创建项目，要记得创建的项目要高于Android 4.1 (API 16)的android项目。\n\n&nbsp;\n\n<strong>2 </strong>用android studio创建一个项目 并且能跑起来，这段教程可以直接去网上少，一般配置无误的情况下，很容易跑出一个android helloword来，你只需要保持之前的node package服务开启，程序依然会去寻找<a href=\"http://localhost:8081/index.android.bundle?platform=android\" data-cke-saved-href=\"http://localhost:8081/index.android.bundle?platform=android\">http://localhost:8081/index.android.bundle?platform=android</a>这个文件的。只是你的android模拟器是通过android studio来管理了。\n<strong>3 </strong>在按照<a href=\"http://facebook.github.io/react-native/docs/embedded-app-android.html#content\" data-cke-saved-href=\"http://facebook.github.io/react-native/docs/embedded-app-android.html#content\">http://facebook.github.io/react-native/docs/embedded-app-android.html#content</a>配置你的结合项目时，还要注意在AndroidManifest.xml文件里面添加&lt;activity android:name=\"com.facebook.react.devsupport.DevSettingsActivity\" /&gt; 这样才能开启调试模式。\n\n&nbsp;\n\n<strong>4 </strong>对于android项目来说，react native的支持也是就在Activity里面创建了一个ReactRootView<img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/77.png\" alt=\"\" data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/77.png\" />，对这不是webview，然后将Activity的其他事件生命周期等等都交给react manager来管理，所以对于react native的android页面，就可以简单理解成一个activety里面套一个reactrootview这个view去加载并jsbundle文件，渲染出原生native的ui组件。\n\n&nbsp;\n\n<span style=\"color: #008000;\"><strong>远程加载jsbundle文件</strong></span>\n\n<strong>1 </strong>目前在react android的官方文档里面，还没有找到如何远程加载jsbundle文件的地方，只能是事先把jsbundle文件放在assets目录下面，一起打包成apk，也就是release apk文件，可以参考<a href=\"https://facebook.github.io/react-native/docs/signed-apk-android.html\" data-cke-saved-href=\"https://facebook.github.io/react-native/docs/signed-apk-android.html\">https://facebook.github.io/react-native/docs/signed-apk-android.html</a>。\n\n&nbsp;\n\n<span style=\"color: #008000;\"><strong>样式和布局</strong></span>\n\n<strong>1 </strong>react native的代码和react基本一样，组件的生命周期，jsx语法都支持，只是在使用jsx时要经常调用官方提供的组件。\n\n<strong>2 </strong>react native里面的样式大部分是可以利用css语法来写的，只有文档里面有的属性才能用，不是所有的css都可以在react native里面用的，采用obj的形式将css属性横杠后面的第一个字母大写即可。\n\n<img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/88.png\" alt=\"\" data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/88.png\" />\n\n<strong>3 </strong>react的宽高度不支持百分比，设置宽高度时不需要带单位，在react native里面默认使用pt为单位，注意在给image设置大小时要根据<a href=\"https://facebook.github.io/react-native/docs/pixelratio.html#content\" data-cke-saved-href=\"https://facebook.github.io/react-native/docs/pixelratio.html#content\">PixelRatio</a>设置合适的值。\n\n<strong>4 </strong>使用dimensions.get(\"window\")可以获取到当前viewport的大小，这个值可能会根据屏幕横竖来动态改变。\n\n<strong>5 </strong>react native里面没有float的用法，是根据flex来布局，alignItems和justifyContent分别决定子元素的布局，而flexDirection决定子元素的排列方式垂直还是水平，flex:number决定子元素所占的比例，alignSelf决定元素本事的布局，子view会默认根据父view来absolute，这里有个技巧，如果想让子view实现100%的效果可以设置left：0 ,right :0,同理height可以用top:0,bottom:0。\n\n<strong>6 </strong>使用text的numberOfLines可以实现文本截取省略号，即css的text-overflow属性。\n\n<strong>7 </strong>默认情况下如果元素超过了父元素，是不可以滚动的，必须在外部套一个&lt;ScrollView&gt;才可以。\n\n<strong>8 </strong>react native里面没有z-index的概念，是根据jsx语法里面定义组件的顺序来实现的，后写的组件会覆盖在先写的组件上。\n\n&nbsp;\n\n<span style=\"color: #008000;\"><strong>总结</strong></span>\n\n<strong>1 </strong>react native android和ios相比，由于出现的还比较晚一些功能还没有非常完善，所以一些文档里面没有写的东西还需要自己摸索。\n\n<strong>2 </strong>react native android在性能上要比web来的好很多，毕竟渲染出来的是原生的组件，尤其是在一些低端android机型上，但是跟真正的native相比还是要逊色一些，但是react native的优势在于一套代码可以跨平台复用，而且可以通过更新远端JS，直接更新app，并且对于前端工程师来说用js的语法写native的组件也并没有很难。\n\n<strong>3 </strong>本人用react native android做出的demo，大家可以体验一下。","source":"_posts/React Native Android 踩坑之旅.md","raw":"---\ntitle: React Native Android 踩坑之旅\ndate: 2015-10-22 21:31:07\ntags:\n- React Native\n- android\ncategories:\n- 550\nphotos:\n- https://qiniu.nihaoshijie.com.cn/xx.png\n---\n<span style=\"color: #008000;\"><strong>前言</strong></span>\n\nFacebook 在2015.9.15发布了 React Native for Android，把 JavaScript 开发技术扩展到了移动Android平台。基于React的React Native 让前端开发者使用 JavaScript 和 React 编写应用，利用相同的核心代码就可以创建 基于Web，iOS 和 Android 平台的原生应用。在React Native for Android出来之后，本人花了些时间从环境搭建到做出几个demo，从体验来看都挺流畅，具体将此间遇到和问题和具体的新的体会，向大家分享一下。\n<!--more-->\n&nbsp;\n\n<span style=\"color: #008000;\"><strong>原理简介</strong></span>\n\n<strong>1 </strong>React Native for Android 和 for IOS的基本原理是一致的，通过android的JavaScriptCore来异步解析js代码(jsbundle文件)，然后根据引入的支持和配置，渲染成原生native组件。\n\n<strong>2 </strong>复用React系统，也减少了一定学习和开发成本，更重要的是利用了React里面的分层和diff机制。js层传给Native层的是一个diff后的json，然后由Native将这个数据映射成真正的布局视图。\n\n&nbsp;\n\n&nbsp;\n\n<span style=\"color: #008000;\"><strong>环境搭建</strong></span>\n\n环境搭建的话，在网上也找到过很多教程，但是还是推荐还是去看官方文档<a href=\"https://facebook.github.io/react-native/docs/android-setup.html#content\" data-cke-saved-href=\"https://facebook.github.io/react-native/docs/android-setup.html#content\">https://facebook.github.io/react-native/docs/android-setup.html#content</a>，在搭建的过程中可能会遇到一些问题。\n\n&nbsp;\n\n<strong>1 </strong>在React Native for Android刚出来的时候，官方称是不支持在windows 系统上安装的，只有在mac上才可以使用<img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/1.png\" alt=\"\" data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/1.png\" />，但是最新版的React Native for Android已经支持在windows上使用，<img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/2.png\" alt=\"\" data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/2.png\" />更新React Native的方法：下载最新版的react-native-cli即npm install -g react-native-cli，并且保证node是最新版的即&gt;4.0。\n\n&nbsp;\n\n<strong>2 </strong>在执行react-native init AwesomeProject 命令时，由于这个命令会去下载一些node module所以要根据自己的实际情况设置npm的代理和镜像，本人就曾经因为这个问题搞了很久才成功，可以安装nrm(npm install -g nrm)来便捷设置npm的代理和镜像，其次是执行这个命令必须现在机器上装有git，并且设置好git的环境变量，另外这个命令需要等待一些时间，不要提前取消。\n\n&nbsp;\n\n<strong>3 </strong>在调用react-native run-android的命令时，有时会报出找不到android-sdk环境变量的错误（自己确实已经正确设置环境变量）提示例如<img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/33.png\" alt=\"\" data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/33.png\" />\n\n的错误时，可以单独在项目根目录下，也就是AwesomeProject/新建一个local.propertites文件，添加sdk.dir=你的android的sdk目录，然后在运行react-native run-android。\n\n&nbsp;\n\n<strong>4 </strong>在调用react-native run-android命令时，其实这个命令就是执行的两部分操作1是构建你的android项目并生成apk，另外一个是打开react-native的package管理工具同时编译你的js文件，其实可以在项目根目录的package.json下找到\n\n<img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/44.png\" alt=\"\" data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/44.png\" />\n\n其实是执行了另外一条命令node node_modules\\react-native\\packager\\packager.js来打开package的管理工具，有些可能没打开一个新的命令行窗口，自己手动执行这条node命令也是可以的。在这条命令执行完之后，node就会开启一个服务，同时把js文件编译成jsbundle文件，我们可以通过<a href=\"http://localhost:8081/index.android.bundle?platform=android\" data-cke-saved-href=\"http://localhost:8081/index.android.bundle?platform=android\">http://localhost:8081/index.android.bundle?platform=android</a>来访问到这个文件，可以简单将这个文件理解成一个html，android就是通过解析这个html来达到渲染的目的，将该文件部署到CDN可供android app从网络获取，即可实现不用发版本让app的UI随时更新，并且可获得接近native的体验，这也是react-native最吸引开发者的亮点之一。\n\n&nbsp;\n\n<strong>5 </strong>用react native命令生成的android项目是基于gradle构建和部署的(不清楚gradle的可以google)，这个以前一些搞用eclipse来android开发的可能不太一样，gradle是用在google主推的一款android开发IDE，android statio里面默认的项目构建方式，所以我们的项目里会看到一些build.gradle的文件，这些都是配置文件。\n\n&nbsp;\n\n<strong>6</strong> 我们在根据教程搭环境时会碰到需要安装android模拟器的步骤，这个步骤会提示你安装一个HAXM的东西<img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/55.png\" alt=\"\" data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/55.png\" />可以看到这个安装不是必须的，其实这个是一个android模拟器的加速程序，按了这个你的模拟器可能会跑的更快，但是在安装这个程序时，会遇到<img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/66.png\" alt=\"\" data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/66.png\" />的错误是由于CPU的虚拟化未开启，需要重新开机在bios上设置一下，具体怎么设置，可以自行google。\n\n&nbsp;\n\n<strong>7 </strong>react-native android在本地调试开发时，你只需要修改js文件，然后刷新你的项目，所以在创建android模拟器时要记得选择带有android键盘的模拟器，这样才能在模拟器上刷新你的更改。\n\n&nbsp;\n\n<strong>与现有的android项目集成</strong>\n\n<strong>1 </strong>想要在现有的android项目里添加react native支持，你必须要先创建一个基于gradle的android项目，推荐使用android studio来创建项目，要记得创建的项目要高于Android 4.1 (API 16)的android项目。\n\n&nbsp;\n\n<strong>2 </strong>用android studio创建一个项目 并且能跑起来，这段教程可以直接去网上少，一般配置无误的情况下，很容易跑出一个android helloword来，你只需要保持之前的node package服务开启，程序依然会去寻找<a href=\"http://localhost:8081/index.android.bundle?platform=android\" data-cke-saved-href=\"http://localhost:8081/index.android.bundle?platform=android\">http://localhost:8081/index.android.bundle?platform=android</a>这个文件的。只是你的android模拟器是通过android studio来管理了。\n<strong>3 </strong>在按照<a href=\"http://facebook.github.io/react-native/docs/embedded-app-android.html#content\" data-cke-saved-href=\"http://facebook.github.io/react-native/docs/embedded-app-android.html#content\">http://facebook.github.io/react-native/docs/embedded-app-android.html#content</a>配置你的结合项目时，还要注意在AndroidManifest.xml文件里面添加&lt;activity android:name=\"com.facebook.react.devsupport.DevSettingsActivity\" /&gt; 这样才能开启调试模式。\n\n&nbsp;\n\n<strong>4 </strong>对于android项目来说，react native的支持也是就在Activity里面创建了一个ReactRootView<img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/77.png\" alt=\"\" data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/77.png\" />，对这不是webview，然后将Activity的其他事件生命周期等等都交给react manager来管理，所以对于react native的android页面，就可以简单理解成一个activety里面套一个reactrootview这个view去加载并jsbundle文件，渲染出原生native的ui组件。\n\n&nbsp;\n\n<span style=\"color: #008000;\"><strong>远程加载jsbundle文件</strong></span>\n\n<strong>1 </strong>目前在react android的官方文档里面，还没有找到如何远程加载jsbundle文件的地方，只能是事先把jsbundle文件放在assets目录下面，一起打包成apk，也就是release apk文件，可以参考<a href=\"https://facebook.github.io/react-native/docs/signed-apk-android.html\" data-cke-saved-href=\"https://facebook.github.io/react-native/docs/signed-apk-android.html\">https://facebook.github.io/react-native/docs/signed-apk-android.html</a>。\n\n&nbsp;\n\n<span style=\"color: #008000;\"><strong>样式和布局</strong></span>\n\n<strong>1 </strong>react native的代码和react基本一样，组件的生命周期，jsx语法都支持，只是在使用jsx时要经常调用官方提供的组件。\n\n<strong>2 </strong>react native里面的样式大部分是可以利用css语法来写的，只有文档里面有的属性才能用，不是所有的css都可以在react native里面用的，采用obj的形式将css属性横杠后面的第一个字母大写即可。\n\n<img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/88.png\" alt=\"\" data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/88.png\" />\n\n<strong>3 </strong>react的宽高度不支持百分比，设置宽高度时不需要带单位，在react native里面默认使用pt为单位，注意在给image设置大小时要根据<a href=\"https://facebook.github.io/react-native/docs/pixelratio.html#content\" data-cke-saved-href=\"https://facebook.github.io/react-native/docs/pixelratio.html#content\">PixelRatio</a>设置合适的值。\n\n<strong>4 </strong>使用dimensions.get(\"window\")可以获取到当前viewport的大小，这个值可能会根据屏幕横竖来动态改变。\n\n<strong>5 </strong>react native里面没有float的用法，是根据flex来布局，alignItems和justifyContent分别决定子元素的布局，而flexDirection决定子元素的排列方式垂直还是水平，flex:number决定子元素所占的比例，alignSelf决定元素本事的布局，子view会默认根据父view来absolute，这里有个技巧，如果想让子view实现100%的效果可以设置left：0 ,right :0,同理height可以用top:0,bottom:0。\n\n<strong>6 </strong>使用text的numberOfLines可以实现文本截取省略号，即css的text-overflow属性。\n\n<strong>7 </strong>默认情况下如果元素超过了父元素，是不可以滚动的，必须在外部套一个&lt;ScrollView&gt;才可以。\n\n<strong>8 </strong>react native里面没有z-index的概念，是根据jsx语法里面定义组件的顺序来实现的，后写的组件会覆盖在先写的组件上。\n\n&nbsp;\n\n<span style=\"color: #008000;\"><strong>总结</strong></span>\n\n<strong>1 </strong>react native android和ios相比，由于出现的还比较晚一些功能还没有非常完善，所以一些文档里面没有写的东西还需要自己摸索。\n\n<strong>2 </strong>react native android在性能上要比web来的好很多，毕竟渲染出来的是原生的组件，尤其是在一些低端android机型上，但是跟真正的native相比还是要逊色一些，但是react native的优势在于一套代码可以跨平台复用，而且可以通过更新远端JS，直接更新app，并且对于前端工程师来说用js的语法写native的组件也并没有很难。\n\n<strong>3 </strong>本人用react native android做出的demo，大家可以体验一下。","slug":"React Native Android 踩坑之旅","published":1,"updated":"2019-04-02T16:49:54.000Z","comments":1,"layout":"post","link":"","_id":"ckx434q0300132wvj8g4f2apl","content":"<p><span style=\"color: #008000;\"><strong>前言</strong></span></p>\n<p>Facebook 在2015.9.15发布了 React Native for Android，把 JavaScript 开发技术扩展到了移动Android平台。基于React的React Native 让前端开发者使用 JavaScript 和 React 编写应用，利用相同的核心代码就可以创建 基于Web，iOS 和 Android 平台的原生应用。在React Native for Android出来之后，本人花了些时间从环境搭建到做出几个demo，从体验来看都挺流畅，具体将此间遇到和问题和具体的新的体会，向大家分享一下。<br><a id=\"more\"></a><br>&nbsp;</p>\n<p><span style=\"color: #008000;\"><strong>原理简介</strong></span></p>\n<p><strong>1 </strong>React Native for Android 和 for IOS的基本原理是一致的，通过android的JavaScriptCore来异步解析js代码(jsbundle文件)，然后根据引入的支持和配置，渲染成原生native组件。</p>\n<p><strong>2 </strong>复用React系统，也减少了一定学习和开发成本，更重要的是利用了React里面的分层和diff机制。js层传给Native层的是一个diff后的json，然后由Native将这个数据映射成真正的布局视图。</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><span style=\"color: #008000;\"><strong>环境搭建</strong></span></p>\n<p>环境搭建的话，在网上也找到过很多教程，但是还是推荐还是去看官方文档<a href=\"https://facebook.github.io/react-native/docs/android-setup.html#content\" data-cke-saved-href=\"https://facebook.github.io/react-native/docs/android-setup.html#content\" target=\"_blank\" rel=\"noopener\">https://facebook.github.io/react-native/docs/android-setup.html#content</a>，在搭建的过程中可能会遇到一些问题。</p>\n<p>&nbsp;</p>\n<p><strong>1 </strong>在React Native for Android刚出来的时候，官方称是不支持在windows 系统上安装的，只有在mac上才可以使用<img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/1.png\" alt data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/1.png\">，但是最新版的React Native for Android已经支持在windows上使用，<img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/2.png\" alt data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/2.png\">更新React Native的方法：下载最新版的react-native-cli即npm install -g react-native-cli，并且保证node是最新版的即&gt;4.0。</p>\n<p>&nbsp;</p>\n<p><strong>2 </strong>在执行react-native init AwesomeProject 命令时，由于这个命令会去下载一些node module所以要根据自己的实际情况设置npm的代理和镜像，本人就曾经因为这个问题搞了很久才成功，可以安装nrm(npm install -g nrm)来便捷设置npm的代理和镜像，其次是执行这个命令必须现在机器上装有git，并且设置好git的环境变量，另外这个命令需要等待一些时间，不要提前取消。</p>\n<p>&nbsp;</p>\n<p><strong>3 </strong>在调用react-native run-android的命令时，有时会报出找不到android-sdk环境变量的错误（自己确实已经正确设置环境变量）提示例如<img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/33.png\" alt data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/33.png\"></p>\n<p>的错误时，可以单独在项目根目录下，也就是AwesomeProject/新建一个local.propertites文件，添加sdk.dir=你的android的sdk目录，然后在运行react-native run-android。</p>\n<p>&nbsp;</p>\n<p><strong>4 </strong>在调用react-native run-android命令时，其实这个命令就是执行的两部分操作1是构建你的android项目并生成apk，另外一个是打开react-native的package管理工具同时编译你的js文件，其实可以在项目根目录的package.json下找到</p>\n<p><img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/44.png\" alt data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/44.png\"></p>\n<p>其实是执行了另外一条命令node node_modules\\react-native\\packager\\packager.js来打开package的管理工具，有些可能没打开一个新的命令行窗口，自己手动执行这条node命令也是可以的。在这条命令执行完之后，node就会开启一个服务，同时把js文件编译成jsbundle文件，我们可以通过<a href=\"http://localhost:8081/index.android.bundle?platform=android\" data-cke-saved-href=\"http://localhost:8081/index.android.bundle?platform=android\" target=\"_blank\" rel=\"noopener\">http://localhost:8081/index.android.bundle?platform=android</a>来访问到这个文件，可以简单将这个文件理解成一个html，android就是通过解析这个html来达到渲染的目的，将该文件部署到CDN可供android app从网络获取，即可实现不用发版本让app的UI随时更新，并且可获得接近native的体验，这也是react-native最吸引开发者的亮点之一。</p>\n<p>&nbsp;</p>\n<p><strong>5 </strong>用react native命令生成的android项目是基于gradle构建和部署的(不清楚gradle的可以google)，这个以前一些搞用eclipse来android开发的可能不太一样，gradle是用在google主推的一款android开发IDE，android statio里面默认的项目构建方式，所以我们的项目里会看到一些build.gradle的文件，这些都是配置文件。</p>\n<p>&nbsp;</p>\n<p><strong>6</strong> 我们在根据教程搭环境时会碰到需要安装android模拟器的步骤，这个步骤会提示你安装一个HAXM的东西<img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/55.png\" alt data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/55.png\">可以看到这个安装不是必须的，其实这个是一个android模拟器的加速程序，按了这个你的模拟器可能会跑的更快，但是在安装这个程序时，会遇到<img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/66.png\" alt data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/66.png\">的错误是由于CPU的虚拟化未开启，需要重新开机在bios上设置一下，具体怎么设置，可以自行google。</p>\n<p>&nbsp;</p>\n<p><strong>7 </strong>react-native android在本地调试开发时，你只需要修改js文件，然后刷新你的项目，所以在创建android模拟器时要记得选择带有android键盘的模拟器，这样才能在模拟器上刷新你的更改。</p>\n<p>&nbsp;</p>\n<p><strong>与现有的android项目集成</strong></p>\n<p><strong>1 </strong>想要在现有的android项目里添加react native支持，你必须要先创建一个基于gradle的android项目，推荐使用android studio来创建项目，要记得创建的项目要高于Android 4.1 (API 16)的android项目。</p>\n<p>&nbsp;</p>\n<p><strong>2 </strong>用android studio创建一个项目 并且能跑起来，这段教程可以直接去网上少，一般配置无误的情况下，很容易跑出一个android helloword来，你只需要保持之前的node package服务开启，程序依然会去寻找<a href=\"http://localhost:8081/index.android.bundle?platform=android\" data-cke-saved-href=\"http://localhost:8081/index.android.bundle?platform=android\" target=\"_blank\" rel=\"noopener\">http://localhost:8081/index.android.bundle?platform=android</a>这个文件的。只是你的android模拟器是通过android studio来管理了。<br><strong>3 </strong>在按照<a href=\"http://facebook.github.io/react-native/docs/embedded-app-android.html#content\" data-cke-saved-href=\"http://facebook.github.io/react-native/docs/embedded-app-android.html#content\" target=\"_blank\" rel=\"noopener\">http://facebook.github.io/react-native/docs/embedded-app-android.html#content</a>配置你的结合项目时，还要注意在AndroidManifest.xml文件里面添加&lt;activity android:name=”com.facebook.react.devsupport.DevSettingsActivity” /&gt; 这样才能开启调试模式。</p>\n<p>&nbsp;</p>\n<p><strong>4 </strong>对于android项目来说，react native的支持也是就在Activity里面创建了一个ReactRootView<img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/77.png\" alt data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/77.png\">，对这不是webview，然后将Activity的其他事件生命周期等等都交给react manager来管理，所以对于react native的android页面，就可以简单理解成一个activety里面套一个reactrootview这个view去加载并jsbundle文件，渲染出原生native的ui组件。</p>\n<p>&nbsp;</p>\n<p><span style=\"color: #008000;\"><strong>远程加载jsbundle文件</strong></span></p>\n<p><strong>1 </strong>目前在react android的官方文档里面，还没有找到如何远程加载jsbundle文件的地方，只能是事先把jsbundle文件放在assets目录下面，一起打包成apk，也就是release apk文件，可以参考<a href=\"https://facebook.github.io/react-native/docs/signed-apk-android.html\" data-cke-saved-href=\"https://facebook.github.io/react-native/docs/signed-apk-android.html\" target=\"_blank\" rel=\"noopener\">https://facebook.github.io/react-native/docs/signed-apk-android.html</a>。</p>\n<p>&nbsp;</p>\n<p><span style=\"color: #008000;\"><strong>样式和布局</strong></span></p>\n<p><strong>1 </strong>react native的代码和react基本一样，组件的生命周期，jsx语法都支持，只是在使用jsx时要经常调用官方提供的组件。</p>\n<p><strong>2 </strong>react native里面的样式大部分是可以利用css语法来写的，只有文档里面有的属性才能用，不是所有的css都可以在react native里面用的，采用obj的形式将css属性横杠后面的第一个字母大写即可。</p>\n<p><img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/88.png\" alt data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/88.png\"></p>\n<p><strong>3 </strong>react的宽高度不支持百分比，设置宽高度时不需要带单位，在react native里面默认使用pt为单位，注意在给image设置大小时要根据<a href=\"https://facebook.github.io/react-native/docs/pixelratio.html#content\" data-cke-saved-href=\"https://facebook.github.io/react-native/docs/pixelratio.html#content\" target=\"_blank\" rel=\"noopener\">PixelRatio</a>设置合适的值。</p>\n<p><strong>4 </strong>使用dimensions.get(“window”)可以获取到当前viewport的大小，这个值可能会根据屏幕横竖来动态改变。</p>\n<p><strong>5 </strong>react native里面没有float的用法，是根据flex来布局，alignItems和justifyContent分别决定子元素的布局，而flexDirection决定子元素的排列方式垂直还是水平，flex:number决定子元素所占的比例，alignSelf决定元素本事的布局，子view会默认根据父view来absolute，这里有个技巧，如果想让子view实现100%的效果可以设置left：0 ,right :0,同理height可以用top:0,bottom:0。</p>\n<p><strong>6 </strong>使用text的numberOfLines可以实现文本截取省略号，即css的text-overflow属性。</p>\n<p><strong>7 </strong>默认情况下如果元素超过了父元素，是不可以滚动的，必须在外部套一个&lt;ScrollView&gt;才可以。</p>\n<p><strong>8 </strong>react native里面没有z-index的概念，是根据jsx语法里面定义组件的顺序来实现的，后写的组件会覆盖在先写的组件上。</p>\n<p>&nbsp;</p>\n<p><span style=\"color: #008000;\"><strong>总结</strong></span></p>\n<p><strong>1 </strong>react native android和ios相比，由于出现的还比较晚一些功能还没有非常完善，所以一些文档里面没有写的东西还需要自己摸索。</p>\n<p><strong>2 </strong>react native android在性能上要比web来的好很多，毕竟渲染出来的是原生的组件，尤其是在一些低端android机型上，但是跟真正的native相比还是要逊色一些，但是react native的优势在于一套代码可以跨平台复用，而且可以通过更新远端JS，直接更新app，并且对于前端工程师来说用js的语法写native的组件也并没有很难。</p>\n<p><strong>3 </strong>本人用react native android做出的demo，大家可以体验一下。</p>\n","site":{"data":{}},"excerpt":"<p><span style=\"color: #008000;\"><strong>前言</strong></span></p>\n<p>Facebook 在2015.9.15发布了 React Native for Android，把 JavaScript 开发技术扩展到了移动Android平台。基于React的React Native 让前端开发者使用 JavaScript 和 React 编写应用，利用相同的核心代码就可以创建 基于Web，iOS 和 Android 平台的原生应用。在React Native for Android出来之后，本人花了些时间从环境搭建到做出几个demo，从体验来看都挺流畅，具体将此间遇到和问题和具体的新的体会，向大家分享一下。<br>","more":"<br>&nbsp;</p>\n<p><span style=\"color: #008000;\"><strong>原理简介</strong></span></p>\n<p><strong>1 </strong>React Native for Android 和 for IOS的基本原理是一致的，通过android的JavaScriptCore来异步解析js代码(jsbundle文件)，然后根据引入的支持和配置，渲染成原生native组件。</p>\n<p><strong>2 </strong>复用React系统，也减少了一定学习和开发成本，更重要的是利用了React里面的分层和diff机制。js层传给Native层的是一个diff后的json，然后由Native将这个数据映射成真正的布局视图。</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><span style=\"color: #008000;\"><strong>环境搭建</strong></span></p>\n<p>环境搭建的话，在网上也找到过很多教程，但是还是推荐还是去看官方文档<a href=\"https://facebook.github.io/react-native/docs/android-setup.html#content\" data-cke-saved-href=\"https://facebook.github.io/react-native/docs/android-setup.html#content\" target=\"_blank\" rel=\"noopener\">https://facebook.github.io/react-native/docs/android-setup.html#content</a>，在搭建的过程中可能会遇到一些问题。</p>\n<p>&nbsp;</p>\n<p><strong>1 </strong>在React Native for Android刚出来的时候，官方称是不支持在windows 系统上安装的，只有在mac上才可以使用<img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/1.png\" alt=\"\" data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/1.png\">，但是最新版的React Native for Android已经支持在windows上使用，<img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/2.png\" alt=\"\" data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/2.png\">更新React Native的方法：下载最新版的react-native-cli即npm install -g react-native-cli，并且保证node是最新版的即&gt;4.0。</p>\n<p>&nbsp;</p>\n<p><strong>2 </strong>在执行react-native init AwesomeProject 命令时，由于这个命令会去下载一些node module所以要根据自己的实际情况设置npm的代理和镜像，本人就曾经因为这个问题搞了很久才成功，可以安装nrm(npm install -g nrm)来便捷设置npm的代理和镜像，其次是执行这个命令必须现在机器上装有git，并且设置好git的环境变量，另外这个命令需要等待一些时间，不要提前取消。</p>\n<p>&nbsp;</p>\n<p><strong>3 </strong>在调用react-native run-android的命令时，有时会报出找不到android-sdk环境变量的错误（自己确实已经正确设置环境变量）提示例如<img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/33.png\" alt=\"\" data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/33.png\"></p>\n<p>的错误时，可以单独在项目根目录下，也就是AwesomeProject/新建一个local.propertites文件，添加sdk.dir=你的android的sdk目录，然后在运行react-native run-android。</p>\n<p>&nbsp;</p>\n<p><strong>4 </strong>在调用react-native run-android命令时，其实这个命令就是执行的两部分操作1是构建你的android项目并生成apk，另外一个是打开react-native的package管理工具同时编译你的js文件，其实可以在项目根目录的package.json下找到</p>\n<p><img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/44.png\" alt=\"\" data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/44.png\"></p>\n<p>其实是执行了另外一条命令node node_modules\\react-native\\packager\\packager.js来打开package的管理工具，有些可能没打开一个新的命令行窗口，自己手动执行这条node命令也是可以的。在这条命令执行完之后，node就会开启一个服务，同时把js文件编译成jsbundle文件，我们可以通过<a href=\"http://localhost:8081/index.android.bundle?platform=android\" data-cke-saved-href=\"http://localhost:8081/index.android.bundle?platform=android\" target=\"_blank\" rel=\"noopener\">http://localhost:8081/index.android.bundle?platform=android</a>来访问到这个文件，可以简单将这个文件理解成一个html，android就是通过解析这个html来达到渲染的目的，将该文件部署到CDN可供android app从网络获取，即可实现不用发版本让app的UI随时更新，并且可获得接近native的体验，这也是react-native最吸引开发者的亮点之一。</p>\n<p>&nbsp;</p>\n<p><strong>5 </strong>用react native命令生成的android项目是基于gradle构建和部署的(不清楚gradle的可以google)，这个以前一些搞用eclipse来android开发的可能不太一样，gradle是用在google主推的一款android开发IDE，android statio里面默认的项目构建方式，所以我们的项目里会看到一些build.gradle的文件，这些都是配置文件。</p>\n<p>&nbsp;</p>\n<p><strong>6</strong> 我们在根据教程搭环境时会碰到需要安装android模拟器的步骤，这个步骤会提示你安装一个HAXM的东西<img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/55.png\" alt=\"\" data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/55.png\">可以看到这个安装不是必须的，其实这个是一个android模拟器的加速程序，按了这个你的模拟器可能会跑的更快，但是在安装这个程序时，会遇到<img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/66.png\" alt=\"\" data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/66.png\">的错误是由于CPU的虚拟化未开启，需要重新开机在bios上设置一下，具体怎么设置，可以自行google。</p>\n<p>&nbsp;</p>\n<p><strong>7 </strong>react-native android在本地调试开发时，你只需要修改js文件，然后刷新你的项目，所以在创建android模拟器时要记得选择带有android键盘的模拟器，这样才能在模拟器上刷新你的更改。</p>\n<p>&nbsp;</p>\n<p><strong>与现有的android项目集成</strong></p>\n<p><strong>1 </strong>想要在现有的android项目里添加react native支持，你必须要先创建一个基于gradle的android项目，推荐使用android studio来创建项目，要记得创建的项目要高于Android 4.1 (API 16)的android项目。</p>\n<p>&nbsp;</p>\n<p><strong>2 </strong>用android studio创建一个项目 并且能跑起来，这段教程可以直接去网上少，一般配置无误的情况下，很容易跑出一个android helloword来，你只需要保持之前的node package服务开启，程序依然会去寻找<a href=\"http://localhost:8081/index.android.bundle?platform=android\" data-cke-saved-href=\"http://localhost:8081/index.android.bundle?platform=android\" target=\"_blank\" rel=\"noopener\">http://localhost:8081/index.android.bundle?platform=android</a>这个文件的。只是你的android模拟器是通过android studio来管理了。<br><strong>3 </strong>在按照<a href=\"http://facebook.github.io/react-native/docs/embedded-app-android.html#content\" data-cke-saved-href=\"http://facebook.github.io/react-native/docs/embedded-app-android.html#content\" target=\"_blank\" rel=\"noopener\">http://facebook.github.io/react-native/docs/embedded-app-android.html#content</a>配置你的结合项目时，还要注意在AndroidManifest.xml文件里面添加&lt;activity android:name=”com.facebook.react.devsupport.DevSettingsActivity” /&gt; 这样才能开启调试模式。</p>\n<p>&nbsp;</p>\n<p><strong>4 </strong>对于android项目来说，react native的支持也是就在Activity里面创建了一个ReactRootView<img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/77.png\" alt=\"\" data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/77.png\">，对这不是webview，然后将Activity的其他事件生命周期等等都交给react manager来管理，所以对于react native的android页面，就可以简单理解成一个activety里面套一个reactrootview这个view去加载并jsbundle文件，渲染出原生native的ui组件。</p>\n<p>&nbsp;</p>\n<p><span style=\"color: #008000;\"><strong>远程加载jsbundle文件</strong></span></p>\n<p><strong>1 </strong>目前在react android的官方文档里面，还没有找到如何远程加载jsbundle文件的地方，只能是事先把jsbundle文件放在assets目录下面，一起打包成apk，也就是release apk文件，可以参考<a href=\"https://facebook.github.io/react-native/docs/signed-apk-android.html\" data-cke-saved-href=\"https://facebook.github.io/react-native/docs/signed-apk-android.html\" target=\"_blank\" rel=\"noopener\">https://facebook.github.io/react-native/docs/signed-apk-android.html</a>。</p>\n<p>&nbsp;</p>\n<p><span style=\"color: #008000;\"><strong>样式和布局</strong></span></p>\n<p><strong>1 </strong>react native的代码和react基本一样，组件的生命周期，jsx语法都支持，只是在使用jsx时要经常调用官方提供的组件。</p>\n<p><strong>2 </strong>react native里面的样式大部分是可以利用css语法来写的，只有文档里面有的属性才能用，不是所有的css都可以在react native里面用的，采用obj的形式将css属性横杠后面的第一个字母大写即可。</p>\n<p><img src=\"http://7jpp2v.com1.z0.glb.clouddn.com/88.png\" alt=\"\" data-cke-saved-src=\"http://7jpp2v.com1.z0.glb.clouddn.com/88.png\"></p>\n<p><strong>3 </strong>react的宽高度不支持百分比，设置宽高度时不需要带单位，在react native里面默认使用pt为单位，注意在给image设置大小时要根据<a href=\"https://facebook.github.io/react-native/docs/pixelratio.html#content\" data-cke-saved-href=\"https://facebook.github.io/react-native/docs/pixelratio.html#content\" target=\"_blank\" rel=\"noopener\">PixelRatio</a>设置合适的值。</p>\n<p><strong>4 </strong>使用dimensions.get(“window”)可以获取到当前viewport的大小，这个值可能会根据屏幕横竖来动态改变。</p>\n<p><strong>5 </strong>react native里面没有float的用法，是根据flex来布局，alignItems和justifyContent分别决定子元素的布局，而flexDirection决定子元素的排列方式垂直还是水平，flex:number决定子元素所占的比例，alignSelf决定元素本事的布局，子view会默认根据父view来absolute，这里有个技巧，如果想让子view实现100%的效果可以设置left：0 ,right :0,同理height可以用top:0,bottom:0。</p>\n<p><strong>6 </strong>使用text的numberOfLines可以实现文本截取省略号，即css的text-overflow属性。</p>\n<p><strong>7 </strong>默认情况下如果元素超过了父元素，是不可以滚动的，必须在外部套一个&lt;ScrollView&gt;才可以。</p>\n<p><strong>8 </strong>react native里面没有z-index的概念，是根据jsx语法里面定义组件的顺序来实现的，后写的组件会覆盖在先写的组件上。</p>\n<p>&nbsp;</p>\n<p><span style=\"color: #008000;\"><strong>总结</strong></span></p>\n<p><strong>1 </strong>react native android和ios相比，由于出现的还比较晚一些功能还没有非常完善，所以一些文档里面没有写的东西还需要自己摸索。</p>\n<p><strong>2 </strong>react native android在性能上要比web来的好很多，毕竟渲染出来的是原生的组件，尤其是在一些低端android机型上，但是跟真正的native相比还是要逊色一些，但是react native的优势在于一套代码可以跨平台复用，而且可以通过更新远端JS，直接更新app，并且对于前端工程师来说用js的语法写native的组件也并没有很难。</p>\n<p><strong>3 </strong>本人用react native android做出的demo，大家可以体验一下。</p>"},{"title":"React Native IOS集成与原理简析","date":"2015-12-11T13:31:07.000Z","photos":["https://qiniu.nihaoshijie.com.cn/xx.png"],"_content":"自从facebook开源了react native之后，许多关于react native实现机制和原理的文章层出不穷，但是大部分主要是从native的角度去写，本文以一个web开发者ios初学者的角度去看react native在ios平台上实现的原理，如有不对之处还望指点。\n<h3 style=\"font-weight: bolder;\"><span style=\"font-weight: bolder;\">一，整体流程</span></h3>\n<!--more-->\n\n首先，明确一点的是React Native是基于react的，react.js提供了一套组件化机制来让我们写基于dom的react组件，而React Native是基于react组件的基础上提供了一个native的react组件，可以看做js-&gt;react.js-&gt;react native-&gt;native这个过程。\n\n然后是生成native的大致流程，先看一张大致的流程图\n<div><img alt=\"\" /><img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/oc1.png\" alt=\"\" width=\"529\" height=\"678\" /></div>\n<div></div>\n<div>1 首先，我们在写react native时，默认的入口就是index.ios.js,无论我们怎么分文件夹，项目根目录下的js文件都会被打包一份jsbundle文件，只是index.ios.js调用的是主程序的入口即AppRegistry注册的入口。</div>\n<div>2 前面说到了打包，对于前端构建来说，就是利用node处理文件合并压缩等等，跟前端使用的一些打包工具例如grunt webpack不同的是，react native自己实现了一个打包方式<a style=\"color: #336699;\" href=\"https://github.com/facebook/react-native/tree/master/packager\" target=\"_blank\">packger</a>，但是实现的效果都是一样的，另外网上已经有了webpack打包react native的<a style=\"color: #336699;\" href=\"https://github.com/mjohnston/react-native-webpack-server\" target=\"_blank\">库</a>。</div>\n<div>3 打包之后，我们的js代码包括react native的js源码都被打包压缩成了一个.jsbundle文件，我们在index.ios.js里面可以写es6的语法，这些都会在打包的时候去编译解析，生成这个jsbundle文件里面的代码是基于commonJS规范的，便于javascriptcore解析。</div>\n<div>4 <a style=\"color: #336699;\" href=\"http://nshipster.cn/javascriptcore/\" target=\"_blank\">javascriptcore</a>是oc的一个能够解析js的库，这个在ios7以上才能支持，不过react native对于ios7以下也有兼容，就是利用UIWebView去实现通信，这个机制可以参考jsapi的实现机制。下图是两个javascriptexcutor的封装实现。</div>\n<div><img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/oc2.png\" alt=\"\" width=\"203\" height=\"110\" /></div>\n<div>5 能够解析javascript之后，就可以按照约定渲染出相应的native 的uikit组件了。</div>\n<div></div>\n<h3 style=\"font-weight: bolder;\"><span style=\"font-weight: bolder;\">二，通信机制</span></h3>\n&nbsp;\n<div>那么，究竟javascript和native是怎么通信和交互的呢？</div>\n<div>我们可以简单写一个native modules来举例，在oc定义一个person类，提供一个person的fetchName方法供js调用，js端使用person.fetchName()获得结果。</div>\n<div>oc代码：Person.m</div>\n<div>\n```c\n@implementation Person\nRCT_EXPORT_MODULE();\n\n\nRCT_EXPORT_METHOD(fetchName:(RCTResponseSenderBlock)callback) {\n    \n    <span class=\"built_in\" style=\"font-weight: bold;\">NSString</span> *name = @<span class=\"string\" style=\"color: #880000;\">\"hello\"</span>;\n    \n    callback(@[name]);\n\n}\n@end\n```\n\njs代码：\n\n```javascript\nvar rutil = React.NativeModules.Person;\nrutil.fetchName(function(name){\n      console.log(name);\n});\n```\n当我在js代码执行fetchName方法时，过程大概是这样的\n\n<img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/oc3.png\" alt=\"\" width=\"1205\" height=\"703\" />\n\n1 首先native这边会主要有两个线程来处理这些操作,主线程用来负责uikit的渲染和oc逻辑方法的执行，javascript线程用来负责执行js代码。\n\n2 图上的modulesConfig也就是模块配置表，包含了moduleID和methodID键值对的集合，这份配置表在会在程序初始化过程中，由oc遍历所有标识为接口的方法即(RCT_EXPORT)，由这些方法生成对应的moduleID和methodID并打包到modules中，形成一个config dictionary，最终转换成json格式注入(injectJSONConfiguration)到js的执行上下文中。\n\n3 图中执行和解析js代码的是RCTJavascriptExecutor这时一个javascriptCore的实现，他是用来执行我们的js代码。\n\n4 当js代码需要调用fetchName方法时，就可以通过配置表找到对应的oc方法，这时请求并没有立即去执行，而是放入到native call queue队列当中，当js代码执行完之后，oc这边会去遍历这个native call queue并找个它对应person.m里面定义的方法并执行，执行完成之后将执行结果和callback放入native call queue，接着js会去native call queue按照当时放进去的的id找到结果和callback，然后在通过enqueueJSCall执行js的代码callback来完成回调。\n\n5 oc端有专门的对参数进行转换的操作，来完成oc和javascript之间的数据类型转换。\n\n6 关于js模块配置表调用oc方法其实是利用oc的<a style=\"color: #336699;\" href=\"http://www.cnblogs.com/dyingbleed/archive/2013/05/05/3029547.html\" target=\"_blank\">反射机制</a>来实现的，简单来说就是，oc提供了方法名称的字符串，在调用时，直接传一个字符串就能运行这个字符串代表的方法。\n\n&nbsp;\n<h3 style=\"line-height: 28.8px;\"><span style=\"font-weight: bolder;\">三，react natvie集成到ios时踩过的坑</span></h3>\n1 将一个现有的ios项目添加react native支持时，有以下几个关键步骤：\n\n1）在项目里新建一个group，然后在node_modules下面找到React和Libraries两个文件夹，将这两个文件夹下的.xcodeproj文件引入到我们创建的group中。\n\n2）找到项目的build settings配置，在Header Search Paths下面新增一个地址，定位到node_modules/react-native/React目录下，选择递归(recursive)。\n\n3）找到项目的build phases配置，找到Link Binary With Libraries,将步骤1里面的.a文件全部引入即可完成配置。\n\n2 在引入reactRootView时，官网的代码里是少了一个参数，即initialProperties参数，我们要在自己的代码里添加这个参数，传nil即可。\n\nreact native内置的api毕竟还不能满足所有的需求，有时也会自己写一些接口来供js调用，下面列举一些需要注意的点：\n\n3 由于oc是多线程(<a style=\"color: #336699;\" href=\"https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/\" target=\"_blank\">GCD</a>)的,上文也说到在执行javascript时是在javascript的线程中进行的，所以在写接口时，如果需要调用非javascript线程的逻辑，就需要在主线程进行，即在业务代码前获取到主线程即：\n\n&nbsp;\n```c\ndispatch_async(dispatch_get_main_queue(),^ {\n        [nav pushViewController:cg animated:YES];\n    });\n```\n&nbsp;\n\n4 在自定义接口时，我们在oc端定义的方法时，如果有参数，那么js端一定要传这个参数，如果没有定义参数，js端也不能传参数，这可能和js以往的语法不太一样，即使定义的一个方法，我传不传都不会报错，但是在oc是不行的，必须严格按照定义方法时的格式来传递。\n\n</div>\n<h3 style=\"font-weight: bolder;\"><span style=\"font-weight: bolder;\">四，总结</span></h3>\n&nbsp;\n<div>1 react native实现的机制确实比较新颖，在设计模式和实现方法上有很多可以学习的地方。</div>\n<div>2 react native在渲染过程中，利用javascriptcore去执行js代码，并渲染出native组件，这个过程毕竟还是有很大的工作量的，对性能消耗也不小，设想一下，加入js解析如果能提前做好放在内存中，渲染时直接运行native的代码或许对性能和速度都有一定提升。</div>","source":"_posts/React Native IOS集成与原理简析.md","raw":"---\ntitle: React Native IOS集成与原理简析\ndate: 2015-12-11 21:31:07\ntags:\n- React Native\ncategories:\n- 560\nphotos:\n- https://qiniu.nihaoshijie.com.cn/xx.png\n---\n自从facebook开源了react native之后，许多关于react native实现机制和原理的文章层出不穷，但是大部分主要是从native的角度去写，本文以一个web开发者ios初学者的角度去看react native在ios平台上实现的原理，如有不对之处还望指点。\n<h3 style=\"font-weight: bolder;\"><span style=\"font-weight: bolder;\">一，整体流程</span></h3>\n<!--more-->\n\n首先，明确一点的是React Native是基于react的，react.js提供了一套组件化机制来让我们写基于dom的react组件，而React Native是基于react组件的基础上提供了一个native的react组件，可以看做js-&gt;react.js-&gt;react native-&gt;native这个过程。\n\n然后是生成native的大致流程，先看一张大致的流程图\n<div><img alt=\"\" /><img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/oc1.png\" alt=\"\" width=\"529\" height=\"678\" /></div>\n<div></div>\n<div>1 首先，我们在写react native时，默认的入口就是index.ios.js,无论我们怎么分文件夹，项目根目录下的js文件都会被打包一份jsbundle文件，只是index.ios.js调用的是主程序的入口即AppRegistry注册的入口。</div>\n<div>2 前面说到了打包，对于前端构建来说，就是利用node处理文件合并压缩等等，跟前端使用的一些打包工具例如grunt webpack不同的是，react native自己实现了一个打包方式<a style=\"color: #336699;\" href=\"https://github.com/facebook/react-native/tree/master/packager\" target=\"_blank\">packger</a>，但是实现的效果都是一样的，另外网上已经有了webpack打包react native的<a style=\"color: #336699;\" href=\"https://github.com/mjohnston/react-native-webpack-server\" target=\"_blank\">库</a>。</div>\n<div>3 打包之后，我们的js代码包括react native的js源码都被打包压缩成了一个.jsbundle文件，我们在index.ios.js里面可以写es6的语法，这些都会在打包的时候去编译解析，生成这个jsbundle文件里面的代码是基于commonJS规范的，便于javascriptcore解析。</div>\n<div>4 <a style=\"color: #336699;\" href=\"http://nshipster.cn/javascriptcore/\" target=\"_blank\">javascriptcore</a>是oc的一个能够解析js的库，这个在ios7以上才能支持，不过react native对于ios7以下也有兼容，就是利用UIWebView去实现通信，这个机制可以参考jsapi的实现机制。下图是两个javascriptexcutor的封装实现。</div>\n<div><img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/oc2.png\" alt=\"\" width=\"203\" height=\"110\" /></div>\n<div>5 能够解析javascript之后，就可以按照约定渲染出相应的native 的uikit组件了。</div>\n<div></div>\n<h3 style=\"font-weight: bolder;\"><span style=\"font-weight: bolder;\">二，通信机制</span></h3>\n&nbsp;\n<div>那么，究竟javascript和native是怎么通信和交互的呢？</div>\n<div>我们可以简单写一个native modules来举例，在oc定义一个person类，提供一个person的fetchName方法供js调用，js端使用person.fetchName()获得结果。</div>\n<div>oc代码：Person.m</div>\n<div>\n```c\n@implementation Person\nRCT_EXPORT_MODULE();\n\n\nRCT_EXPORT_METHOD(fetchName:(RCTResponseSenderBlock)callback) {\n    \n    <span class=\"built_in\" style=\"font-weight: bold;\">NSString</span> *name = @<span class=\"string\" style=\"color: #880000;\">\"hello\"</span>;\n    \n    callback(@[name]);\n\n}\n@end\n```\n\njs代码：\n\n```javascript\nvar rutil = React.NativeModules.Person;\nrutil.fetchName(function(name){\n      console.log(name);\n});\n```\n当我在js代码执行fetchName方法时，过程大概是这样的\n\n<img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/oc3.png\" alt=\"\" width=\"1205\" height=\"703\" />\n\n1 首先native这边会主要有两个线程来处理这些操作,主线程用来负责uikit的渲染和oc逻辑方法的执行，javascript线程用来负责执行js代码。\n\n2 图上的modulesConfig也就是模块配置表，包含了moduleID和methodID键值对的集合，这份配置表在会在程序初始化过程中，由oc遍历所有标识为接口的方法即(RCT_EXPORT)，由这些方法生成对应的moduleID和methodID并打包到modules中，形成一个config dictionary，最终转换成json格式注入(injectJSONConfiguration)到js的执行上下文中。\n\n3 图中执行和解析js代码的是RCTJavascriptExecutor这时一个javascriptCore的实现，他是用来执行我们的js代码。\n\n4 当js代码需要调用fetchName方法时，就可以通过配置表找到对应的oc方法，这时请求并没有立即去执行，而是放入到native call queue队列当中，当js代码执行完之后，oc这边会去遍历这个native call queue并找个它对应person.m里面定义的方法并执行，执行完成之后将执行结果和callback放入native call queue，接着js会去native call queue按照当时放进去的的id找到结果和callback，然后在通过enqueueJSCall执行js的代码callback来完成回调。\n\n5 oc端有专门的对参数进行转换的操作，来完成oc和javascript之间的数据类型转换。\n\n6 关于js模块配置表调用oc方法其实是利用oc的<a style=\"color: #336699;\" href=\"http://www.cnblogs.com/dyingbleed/archive/2013/05/05/3029547.html\" target=\"_blank\">反射机制</a>来实现的，简单来说就是，oc提供了方法名称的字符串，在调用时，直接传一个字符串就能运行这个字符串代表的方法。\n\n&nbsp;\n<h3 style=\"line-height: 28.8px;\"><span style=\"font-weight: bolder;\">三，react natvie集成到ios时踩过的坑</span></h3>\n1 将一个现有的ios项目添加react native支持时，有以下几个关键步骤：\n\n1）在项目里新建一个group，然后在node_modules下面找到React和Libraries两个文件夹，将这两个文件夹下的.xcodeproj文件引入到我们创建的group中。\n\n2）找到项目的build settings配置，在Header Search Paths下面新增一个地址，定位到node_modules/react-native/React目录下，选择递归(recursive)。\n\n3）找到项目的build phases配置，找到Link Binary With Libraries,将步骤1里面的.a文件全部引入即可完成配置。\n\n2 在引入reactRootView时，官网的代码里是少了一个参数，即initialProperties参数，我们要在自己的代码里添加这个参数，传nil即可。\n\nreact native内置的api毕竟还不能满足所有的需求，有时也会自己写一些接口来供js调用，下面列举一些需要注意的点：\n\n3 由于oc是多线程(<a style=\"color: #336699;\" href=\"https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/\" target=\"_blank\">GCD</a>)的,上文也说到在执行javascript时是在javascript的线程中进行的，所以在写接口时，如果需要调用非javascript线程的逻辑，就需要在主线程进行，即在业务代码前获取到主线程即：\n\n&nbsp;\n```c\ndispatch_async(dispatch_get_main_queue(),^ {\n        [nav pushViewController:cg animated:YES];\n    });\n```\n&nbsp;\n\n4 在自定义接口时，我们在oc端定义的方法时，如果有参数，那么js端一定要传这个参数，如果没有定义参数，js端也不能传参数，这可能和js以往的语法不太一样，即使定义的一个方法，我传不传都不会报错，但是在oc是不行的，必须严格按照定义方法时的格式来传递。\n\n</div>\n<h3 style=\"font-weight: bolder;\"><span style=\"font-weight: bolder;\">四，总结</span></h3>\n&nbsp;\n<div>1 react native实现的机制确实比较新颖，在设计模式和实现方法上有很多可以学习的地方。</div>\n<div>2 react native在渲染过程中，利用javascriptcore去执行js代码，并渲染出native组件，这个过程毕竟还是有很大的工作量的，对性能消耗也不小，设想一下，加入js解析如果能提前做好放在内存中，渲染时直接运行native的代码或许对性能和速度都有一定提升。</div>","slug":"React Native IOS集成与原理简析","published":1,"updated":"2019-04-02T16:49:52.000Z","comments":1,"layout":"post","link":"","_id":"ckx434q0400142wvj6tb0zszd","content":"<p>自从facebook开源了react native之后，许多关于react native实现机制和原理的文章层出不穷，但是大部分主要是从native的角度去写，本文以一个web开发者ios初学者的角度去看react native在ios平台上实现的原理，如有不对之处还望指点。</p>\n<p></p><h3 style=\"font-weight: bolder;\"><span id=\"一整体流程\"><span style=\"font-weight: bolder;\">一，整体流程</span></span></h3><br><a id=\"more\"></a><p></p>\n<p>首先，明确一点的是React Native是基于react的，react.js提供了一套组件化机制来让我们写基于dom的react组件，而React Native是基于react组件的基础上提供了一个native的react组件，可以看做js-&gt;react.js-&gt;react native-&gt;native这个过程。</p>\n<p>然后是生成native的大致流程，先看一张大致的流程图</p>\n<div><img alt><img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/oc1.png\" alt width=\"529\" height=\"678\"></div><br><div></div><br><div>1 首先，我们在写react native时，默认的入口就是index.ios.js,无论我们怎么分文件夹，项目根目录下的js文件都会被打包一份jsbundle文件，只是index.ios.js调用的是主程序的入口即AppRegistry注册的入口。</div><br><div>2 前面说到了打包，对于前端构建来说，就是利用node处理文件合并压缩等等，跟前端使用的一些打包工具例如grunt webpack不同的是，react native自己实现了一个打包方式<a style=\"color: #336699;\" href=\"https://github.com/facebook/react-native/tree/master/packager\" target=\"_blank\">packger</a>，但是实现的效果都是一样的，另外网上已经有了webpack打包react native的<a style=\"color: #336699;\" href=\"https://github.com/mjohnston/react-native-webpack-server\" target=\"_blank\">库</a>。</div><br><div>3 打包之后，我们的js代码包括react native的js源码都被打包压缩成了一个.jsbundle文件，我们在index.ios.js里面可以写es6的语法，这些都会在打包的时候去编译解析，生成这个jsbundle文件里面的代码是基于commonJS规范的，便于javascriptcore解析。</div><br><div>4 <a style=\"color: #336699;\" href=\"http://nshipster.cn/javascriptcore/\" target=\"_blank\">javascriptcore</a>是oc的一个能够解析js的库，这个在ios7以上才能支持，不过react native对于ios7以下也有兼容，就是利用UIWebView去实现通信，这个机制可以参考jsapi的实现机制。下图是两个javascriptexcutor的封装实现。</div><br><div><img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/oc2.png\" alt width=\"203\" height=\"110\"></div><br><div>5 能够解析javascript之后，就可以按照约定渲染出相应的native 的uikit组件了。</div><br><div></div><br><h3 style=\"font-weight: bolder;\"><span id=\"二通信机制\"><span style=\"font-weight: bolder;\">二，通信机制</span></span></h3><br>&nbsp;<br><div>那么，究竟javascript和native是怎么通信和交互的呢？</div><br><div>我们可以简单写一个native modules来举例，在oc定义一个person类，提供一个person的fetchName方法供js调用，js端使用person.fetchName()获得结果。</div><br><div>oc代码：Person.m</div><br><div><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation Person</span><br><span class=\"line\">RCT_EXPORT_MODULE();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">RCT_EXPORT_METHOD(fetchName:(RCTResponseSenderBlock)callback) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;span <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">built_in</span>\" <span class=\"title\">style</span>=\"<span class=\"title\">font</span>-<span class=\"title\">weight</span>:</span> bold;<span class=\"string\">\"&gt;NSString&lt;/span&gt; *name = @&lt;span class=\"</span><span class=\"built_in\">string</span><span class=\"string\">\" style=\"</span>color: #<span class=\"number\">880000</span>;<span class=\"string\">\"&gt;\"</span>hello<span class=\"string\">\"&lt;/span&gt;;</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">    callback(@[name]);</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">@end</span></span><br></pre></td></tr></table></figure><br><br>js代码：<br><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> rutil = React.NativeModules.Person;</span><br><span class=\"line\">rutil.fetchName(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure><br><br>当我在js代码执行fetchName方法时，过程大概是这样的<br><br><img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/oc3.png\" alt width=\"1205\" height=\"703\"><br><br>1 首先native这边会主要有两个线程来处理这些操作,主线程用来负责uikit的渲染和oc逻辑方法的执行，javascript线程用来负责执行js代码。<br><br>2 图上的modulesConfig也就是模块配置表，包含了moduleID和methodID键值对的集合，这份配置表在会在程序初始化过程中，由oc遍历所有标识为接口的方法即(RCT_EXPORT)，由这些方法生成对应的moduleID和methodID并打包到modules中，形成一个config dictionary，最终转换成json格式注入(injectJSONConfiguration)到js的执行上下文中。<br><br>3 图中执行和解析js代码的是RCTJavascriptExecutor这时一个javascriptCore的实现，他是用来执行我们的js代码。<br><br>4 当js代码需要调用fetchName方法时，就可以通过配置表找到对应的oc方法，这时请求并没有立即去执行，而是放入到native call queue队列当中，当js代码执行完之后，oc这边会去遍历这个native call queue并找个它对应person.m里面定义的方法并执行，执行完成之后将执行结果和callback放入native call queue，接着js会去native call queue按照当时放进去的的id找到结果和callback，然后在通过enqueueJSCall执行js的代码callback来完成回调。<br><br>5 oc端有专门的对参数进行转换的操作，来完成oc和javascript之间的数据类型转换。<br><br>6 关于js模块配置表调用oc方法其实是利用oc的<a style=\"color: #336699;\" href=\"http://www.cnblogs.com/dyingbleed/archive/2013/05/05/3029547.html\" target=\"_blank\">反射机制</a>来实现的，简单来说就是，oc提供了方法名称的字符串，在调用时，直接传一个字符串就能运行这个字符串代表的方法。<br><br>&nbsp;<br><h3 style=\"line-height: 28.8px;\"><span id=\"三react-natvie集成到ios时踩过的坑\"><span style=\"font-weight: bolder;\">三，react natvie集成到ios时踩过的坑</span></span></h3><br>1 将一个现有的ios项目添加react native支持时，有以下几个关键步骤：<br><br>1）在项目里新建一个group，然后在node_modules下面找到React和Libraries两个文件夹，将这两个文件夹下的.xcodeproj文件引入到我们创建的group中。<br><br>2）找到项目的build settings配置，在Header Search Paths下面新增一个地址，定位到node_modules/react-native/React目录下，选择递归(recursive)。<br><br>3）找到项目的build phases配置，找到Link Binary With Libraries,将步骤1里面的.a文件全部引入即可完成配置。<br><br>2 在引入reactRootView时，官网的代码里是少了一个参数，即initialProperties参数，我们要在自己的代码里添加这个参数，传nil即可。<br><br>react native内置的api毕竟还不能满足所有的需求，有时也会自己写一些接口来供js调用，下面列举一些需要注意的点：<br><br>3 由于oc是多线程(<a style=\"color: #336699;\" href=\"https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/\" target=\"_blank\">GCD</a>)的,上文也说到在执行javascript时是在javascript的线程中进行的，所以在写接口时，如果需要调用非javascript线程的逻辑，就需要在主线程进行，即在业务代码前获取到主线程即：<br><br>&nbsp;<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_async(dispatch_get_main_queue(),^ &#123;</span><br><span class=\"line\">        [nav pushViewController:cg animated:YES];</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure><br><br>&nbsp;<br><br>4 在自定义接口时，我们在oc端定义的方法时，如果有参数，那么js端一定要传这个参数，如果没有定义参数，js端也不能传参数，这可能和js以往的语法不太一样，即使定义的一个方法，我传不传都不会报错，但是在oc是不行的，必须严格按照定义方法时的格式来传递。<br><br></div><br><h3 style=\"font-weight: bolder;\"><span id=\"四总结\"><span style=\"font-weight: bolder;\">四，总结</span></span></h3><br>&nbsp;<br><div>1 react native实现的机制确实比较新颖，在设计模式和实现方法上有很多可以学习的地方。</div><br><div>2 react native在渲染过程中，利用javascriptcore去执行js代码，并渲染出native组件，这个过程毕竟还是有很大的工作量的，对性能消耗也不小，设想一下，加入js解析如果能提前做好放在内存中，渲染时直接运行native的代码或许对性能和速度都有一定提升。</div>","site":{"data":{}},"excerpt":"<p>自从facebook开源了react native之后，许多关于react native实现机制和原理的文章层出不穷，但是大部分主要是从native的角度去写，本文以一个web开发者ios初学者的角度去看react native在ios平台上实现的原理，如有不对之处还望指点。</p>\n<p></p><h3 style=\"font-weight: bolder;\"><span style=\"font-weight: bolder;\">一，整体流程</span></h3><br>","more":"<p></p>\n<p>首先，明确一点的是React Native是基于react的，react.js提供了一套组件化机制来让我们写基于dom的react组件，而React Native是基于react组件的基础上提供了一个native的react组件，可以看做js-&gt;react.js-&gt;react native-&gt;native这个过程。</p>\n<p>然后是生成native的大致流程，先看一张大致的流程图</p>\n<div><img alt=\"\"><img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/oc1.png\" alt=\"\" width=\"529\" height=\"678\"></div><br><div></div><br><div>1 首先，我们在写react native时，默认的入口就是index.ios.js,无论我们怎么分文件夹，项目根目录下的js文件都会被打包一份jsbundle文件，只是index.ios.js调用的是主程序的入口即AppRegistry注册的入口。</div><br><div>2 前面说到了打包，对于前端构建来说，就是利用node处理文件合并压缩等等，跟前端使用的一些打包工具例如grunt webpack不同的是，react native自己实现了一个打包方式<a style=\"color: #336699;\" href=\"https://github.com/facebook/react-native/tree/master/packager\" target=\"_blank\">packger</a>，但是实现的效果都是一样的，另外网上已经有了webpack打包react native的<a style=\"color: #336699;\" href=\"https://github.com/mjohnston/react-native-webpack-server\" target=\"_blank\">库</a>。</div><br><div>3 打包之后，我们的js代码包括react native的js源码都被打包压缩成了一个.jsbundle文件，我们在index.ios.js里面可以写es6的语法，这些都会在打包的时候去编译解析，生成这个jsbundle文件里面的代码是基于commonJS规范的，便于javascriptcore解析。</div><br><div>4 <a style=\"color: #336699;\" href=\"http://nshipster.cn/javascriptcore/\" target=\"_blank\">javascriptcore</a>是oc的一个能够解析js的库，这个在ios7以上才能支持，不过react native对于ios7以下也有兼容，就是利用UIWebView去实现通信，这个机制可以参考jsapi的实现机制。下图是两个javascriptexcutor的封装实现。</div><br><div><img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/oc2.png\" alt=\"\" width=\"203\" height=\"110\"></div><br><div>5 能够解析javascript之后，就可以按照约定渲染出相应的native 的uikit组件了。</div><br><div></div><br><h3 style=\"font-weight: bolder;\"><span style=\"font-weight: bolder;\">二，通信机制</span></h3><br>&nbsp;<br><div>那么，究竟javascript和native是怎么通信和交互的呢？</div><br><div>我们可以简单写一个native modules来举例，在oc定义一个person类，提供一个person的fetchName方法供js调用，js端使用person.fetchName()获得结果。</div><br><div>oc代码：Person.m</div><br><div><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation Person</span><br><span class=\"line\">RCT_EXPORT_MODULE();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">RCT_EXPORT_METHOD(fetchName:(RCTResponseSenderBlock)callback) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;span <span class=\"class\"><span class=\"keyword\">class</span>=\"<span class=\"title\">built_in</span>\" <span class=\"title\">style</span>=\"<span class=\"title\">font</span>-<span class=\"title\">weight</span>:</span> bold;<span class=\"string\">\"&gt;NSString&lt;/span&gt; *name = @&lt;span class=\"</span><span class=\"built_in\">string</span><span class=\"string\">\" style=\"</span>color: #<span class=\"number\">880000</span>;<span class=\"string\">\"&gt;\"</span>hello<span class=\"string\">\"&lt;/span&gt;;</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">    callback(@[name]);</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">@end</span></span><br></pre></td></tr></table></figure><br><br>js代码：<br><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> rutil = React.NativeModules.Person;</span><br><span class=\"line\">rutil.fetchName(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure><br><br>当我在js代码执行fetchName方法时，过程大概是这样的<br><br><img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/oc3.png\" alt=\"\" width=\"1205\" height=\"703\"><br><br>1 首先native这边会主要有两个线程来处理这些操作,主线程用来负责uikit的渲染和oc逻辑方法的执行，javascript线程用来负责执行js代码。<br><br>2 图上的modulesConfig也就是模块配置表，包含了moduleID和methodID键值对的集合，这份配置表在会在程序初始化过程中，由oc遍历所有标识为接口的方法即(RCT_EXPORT)，由这些方法生成对应的moduleID和methodID并打包到modules中，形成一个config dictionary，最终转换成json格式注入(injectJSONConfiguration)到js的执行上下文中。<br><br>3 图中执行和解析js代码的是RCTJavascriptExecutor这时一个javascriptCore的实现，他是用来执行我们的js代码。<br><br>4 当js代码需要调用fetchName方法时，就可以通过配置表找到对应的oc方法，这时请求并没有立即去执行，而是放入到native call queue队列当中，当js代码执行完之后，oc这边会去遍历这个native call queue并找个它对应person.m里面定义的方法并执行，执行完成之后将执行结果和callback放入native call queue，接着js会去native call queue按照当时放进去的的id找到结果和callback，然后在通过enqueueJSCall执行js的代码callback来完成回调。<br><br>5 oc端有专门的对参数进行转换的操作，来完成oc和javascript之间的数据类型转换。<br><br>6 关于js模块配置表调用oc方法其实是利用oc的<a style=\"color: #336699;\" href=\"http://www.cnblogs.com/dyingbleed/archive/2013/05/05/3029547.html\" target=\"_blank\">反射机制</a>来实现的，简单来说就是，oc提供了方法名称的字符串，在调用时，直接传一个字符串就能运行这个字符串代表的方法。<br><br>&nbsp;<br><h3 style=\"line-height: 28.8px;\"><span style=\"font-weight: bolder;\">三，react natvie集成到ios时踩过的坑</span></h3><br>1 将一个现有的ios项目添加react native支持时，有以下几个关键步骤：<br><br>1）在项目里新建一个group，然后在node_modules下面找到React和Libraries两个文件夹，将这两个文件夹下的.xcodeproj文件引入到我们创建的group中。<br><br>2）找到项目的build settings配置，在Header Search Paths下面新增一个地址，定位到node_modules/react-native/React目录下，选择递归(recursive)。<br><br>3）找到项目的build phases配置，找到Link Binary With Libraries,将步骤1里面的.a文件全部引入即可完成配置。<br><br>2 在引入reactRootView时，官网的代码里是少了一个参数，即initialProperties参数，我们要在自己的代码里添加这个参数，传nil即可。<br><br>react native内置的api毕竟还不能满足所有的需求，有时也会自己写一些接口来供js调用，下面列举一些需要注意的点：<br><br>3 由于oc是多线程(<a style=\"color: #336699;\" href=\"https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/\" target=\"_blank\">GCD</a>)的,上文也说到在执行javascript时是在javascript的线程中进行的，所以在写接口时，如果需要调用非javascript线程的逻辑，就需要在主线程进行，即在业务代码前获取到主线程即：<br><br>&nbsp;<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_async(dispatch_get_main_queue(),^ &#123;</span><br><span class=\"line\">        [nav pushViewController:cg animated:YES];</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure><br><br>&nbsp;<br><br>4 在自定义接口时，我们在oc端定义的方法时，如果有参数，那么js端一定要传这个参数，如果没有定义参数，js端也不能传参数，这可能和js以往的语法不太一样，即使定义的一个方法，我传不传都不会报错，但是在oc是不行的，必须严格按照定义方法时的格式来传递。<br><br></div><br><h3 style=\"font-weight: bolder;\"><span style=\"font-weight: bolder;\">四，总结</span></h3><br>&nbsp;<br><div>1 react native实现的机制确实比较新颖，在设计模式和实现方法上有很多可以学习的地方。</div><br><div>2 react native在渲染过程中，利用javascriptcore去执行js代码，并渲染出native组件，这个过程毕竟还是有很大的工作量的，对性能消耗也不小，设想一下，加入js解析如果能提前做好放在内存中，渲染时直接运行native的代码或许对性能和速度都有一定提升。</div>"},{"title":"React Native下拉刷新组件react-native-pullRefreshScrollView","date":"2016-05-05T13:09:07.000Z","photos":["http://7jpp2v.com1.z0.glb.clouddn.com/xx.png"],"_content":"<strong>react-native-pullRefreshScrollView是一款React Native下拉刷新组件 </strong>\n<!--more-->\n<strong>目前支持ios 平台 </strong>\n\n<strong>支持ScrollView,ListView</strong>\n\n特点是高性能和高流畅性\n\n<img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/ListView.gif\" alt=\"\" width=\"318\" height=\"475\" />\n\n项目地址：https://github.com/lvming6816077/react-native-pullRefreshScrollView\n\n&nbsp;\n\n欢迎使用","source":"_posts/React-Native下拉刷新组件react-native-pullRefreshScrollView.md","raw":"---\ntitle: React Native下拉刷新组件react-native-pullRefreshScrollView\ndate: 2016-05-05 21:09:07\ntags:\n- React Native\n- 下拉刷新\ncategories:\n- 610\nphotos: http://7jpp2v.com1.z0.glb.clouddn.com/xx.png\n---\n<strong>react-native-pullRefreshScrollView是一款React Native下拉刷新组件 </strong>\n<!--more-->\n<strong>目前支持ios 平台 </strong>\n\n<strong>支持ScrollView,ListView</strong>\n\n特点是高性能和高流畅性\n\n<img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/ListView.gif\" alt=\"\" width=\"318\" height=\"475\" />\n\n项目地址：https://github.com/lvming6816077/react-native-pullRefreshScrollView\n\n&nbsp;\n\n欢迎使用","slug":"React-Native下拉刷新组件react-native-pullRefreshScrollView","published":1,"updated":"2017-04-27T13:12:36.000Z","comments":1,"layout":"post","link":"","_id":"ckx434q0600182wvjmrg4wlz4","content":"<p><strong>react-native-pullRefreshScrollView是一款React Native下拉刷新组件 </strong><br><a id=\"more\"></a><br><strong>目前支持ios 平台 </strong></p>\n<p><strong>支持ScrollView,ListView</strong></p>\n<p>特点是高性能和高流畅性</p>\n<p><img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/ListView.gif\" alt width=\"318\" height=\"475\"></p>\n<p>项目地址：<a href=\"https://github.com/lvming6816077/react-native-pullRefreshScrollView\" target=\"_blank\" rel=\"noopener\">https://github.com/lvming6816077/react-native-pullRefreshScrollView</a></p>\n<p>&nbsp;</p>\n<p>欢迎使用</p>\n","site":{"data":{}},"excerpt":"<p><strong>react-native-pullRefreshScrollView是一款React Native下拉刷新组件 </strong><br>","more":"<br><strong>目前支持ios 平台 </strong></p>\n<p><strong>支持ScrollView,ListView</strong></p>\n<p>特点是高性能和高流畅性</p>\n<p><img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/ListView.gif\" alt=\"\" width=\"318\" height=\"475\"></p>\n<p>项目地址：<a href=\"https://github.com/lvming6816077/react-native-pullRefreshScrollView\" target=\"_blank\" rel=\"noopener\">https://github.com/lvming6816077/react-native-pullRefreshScrollView</a></p>\n<p>&nbsp;</p>\n<p>欢迎使用</p>"},{"title":"Tabs Store保存你所有标签页的Chrome插件","date":"2014-07-26T09:21:29.000Z","photos":["https://qiniu.nihaoshijie.com.cn/banner4.png"],"_content":"<h3><strong>Tabs Store插件测试版给力上线！</strong></h3>\n<em>有了它，你不必在为了收藏夹而烦恼，也不必在茫茫多的历史记录里寻找你的页面，只需把你的favorite存到这里，它会帮你管理你的tab。</em>\n\n使用方法：<a href=\"https://github.com/lvming6816077/chrome-extension-tabs-store/blob/master/README.md\" target=\"_blank\">https://github.com/lvming6816077/chrome-extension-tabs-store/blob/master/README.md</a>\n\n下载地址：<a href=\"http://qiniu.nihaoshijie.com.cn/chrome-extension-tabs-store-1.0.1.crx.zip\" target=\"_blank\">http://qiniu.nihaoshijie.com.cn/chrome-extension-tabs-store.zip</a>\n\n反馈：<a href=\"441403517@qq.com\" target=\"_blank\">441403517@qq.com</a>\n\n\n更新记录：\n<ul class=\"task-list\">\n\t<li><a style=\"color: #4183c4;\" href=\"https://github.com/lvming6816077/chrome-extension-tabs-store/blob/master\">1.0.1</a> 增加删除url功能，在细节展开之后，长按链可以弹出删除当url的按，点击即可删。</li>\n</ul>\n\n<strong><em>尽情的下载吧！</em></strong>","source":"_posts/Tabs-Store保存你所有标签页的Chrome插件.md","raw":"---\ntitle: Tabs Store保存你所有标签页的Chrome插件\ndate: 2014-07-26 17:21:29\ntags:\n- chrome插件\ncategories:\n- 326\nphotos: https://qiniu.nihaoshijie.com.cn/banner4.png\n---\n<h3><strong>Tabs Store插件测试版给力上线！</strong></h3>\n<em>有了它，你不必在为了收藏夹而烦恼，也不必在茫茫多的历史记录里寻找你的页面，只需把你的favorite存到这里，它会帮你管理你的tab。</em>\n\n使用方法：<a href=\"https://github.com/lvming6816077/chrome-extension-tabs-store/blob/master/README.md\" target=\"_blank\">https://github.com/lvming6816077/chrome-extension-tabs-store/blob/master/README.md</a>\n\n下载地址：<a href=\"http://qiniu.nihaoshijie.com.cn/chrome-extension-tabs-store-1.0.1.crx.zip\" target=\"_blank\">http://qiniu.nihaoshijie.com.cn/chrome-extension-tabs-store.zip</a>\n\n反馈：<a href=\"441403517@qq.com\" target=\"_blank\">441403517@qq.com</a>\n\n\n更新记录：\n<ul class=\"task-list\">\n\t<li><a style=\"color: #4183c4;\" href=\"https://github.com/lvming6816077/chrome-extension-tabs-store/blob/master\">1.0.1</a> 增加删除url功能，在细节展开之后，长按链可以弹出删除当url的按，点击即可删。</li>\n</ul>\n\n<strong><em>尽情的下载吧！</em></strong>","slug":"Tabs-Store保存你所有标签页的Chrome插件","published":1,"updated":"2019-04-02T16:52:20.000Z","comments":1,"layout":"post","link":"","_id":"ckx434q0700192wvj3orp030v","content":"<p></p><h3><span id=\"tabs-store插件测试版给力上线\"><strong>Tabs Store插件测试版给力上线！</strong></span></h3><br><em>有了它，你不必在为了收藏夹而烦恼，也不必在茫茫多的历史记录里寻找你的页面，只需把你的favorite存到这里，它会帮你管理你的tab。</em><p></p>\n<p>使用方法：<a href=\"https://github.com/lvming6816077/chrome-extension-tabs-store/blob/master/README.md\" target=\"_blank\">https://github.com/lvming6816077/chrome-extension-tabs-store/blob/master/README.md</a></p>\n<p>下载地址：<a href=\"http://qiniu.nihaoshijie.com.cn/chrome-extension-tabs-store-1.0.1.crx.zip\" target=\"_blank\">http://qiniu.nihaoshijie.com.cn/chrome-extension-tabs-store.zip</a></p>\n<p>反馈：<a href=\"441403517@qq.com\" target=\"_blank\">441403517@qq.com</a></p>\n<p>更新记录：</p>\n<ul class=\"task-list\"><br>    <li><a style=\"color: #4183c4;\" href=\"https://github.com/lvming6816077/chrome-extension-tabs-store/blob/master\" target=\"_blank\" rel=\"noopener\">1.0.1</a> 增加删除url功能，在细节展开之后，长按链可以弹出删除当url的按，点击即可删。</li><br></ul>\n\n<p><strong><em>尽情的下载吧！</em></strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p></p><h3><strong>Tabs Store插件测试版给力上线！</strong></h3><br><em>有了它，你不必在为了收藏夹而烦恼，也不必在茫茫多的历史记录里寻找你的页面，只需把你的favorite存到这里，它会帮你管理你的tab。</em><p></p>\n<p>使用方法：<a href=\"https://github.com/lvming6816077/chrome-extension-tabs-store/blob/master/README.md\" target=\"_blank\">https://github.com/lvming6816077/chrome-extension-tabs-store/blob/master/README.md</a></p>\n<p>下载地址：<a href=\"http://qiniu.nihaoshijie.com.cn/chrome-extension-tabs-store-1.0.1.crx.zip\" target=\"_blank\">http://qiniu.nihaoshijie.com.cn/chrome-extension-tabs-store.zip</a></p>\n<p>反馈：<a href=\"441403517@qq.com\" target=\"_blank\">441403517@qq.com</a></p>\n<p>更新记录：</p>\n<ul class=\"task-list\"><br>    <li><a style=\"color: #4183c4;\" href=\"https://github.com/lvming6816077/chrome-extension-tabs-store/blob/master\" target=\"_blank\" rel=\"noopener\">1.0.1</a> 增加删除url功能，在细节展开之后，长按链可以弹出删除当url的按，点击即可删。</li><br></ul>\n\n<p><strong><em>尽情的下载吧！</em></strong></p>\n"},{"title":"Vue.js Composition API","date":"2021-11-26T09:26:17.000Z","_content":"\n\n在Vue 3引入的Composition API翻译过来就叫做组合式API，所谓组合式就是我们可以自由的组合逻辑，即剥离公共逻辑，差异化个性逻辑，维护整体逻辑。我们知道一个大型的Vue应用就是业务逻辑的综合体，而Vue组件就是组成这个综合体的个体。\n<!--more-->\n通过创建Vue组件，我们可以将界面中重复的部分连同其功能一起提取为可重用的代码段。仅此一项就可以使我们的应用在可维护性和灵活性方面走得相当远。然而，我们的经验已经证明，光靠这一点可能并不够，尤其是当你的应用变得非常大的时候——想想几百个组件。处理这样的大型应用时，共享和重用代码变得尤为重要。\n\nComposition API给我们提供了更加高效的代码逻辑组合能力，整体提示项目的可维护性，是函数式编程的重要体现。\n\n## Composition API 基础\n\n通常，一个Vue组件对象大概是包括一些data属性，生命周期钩子函数，methods，components，props等等的配置项的Object对象，如示例代码所示。\n\n```javascript\nexport default {\n  name: 'test',\n  components: {},\n  props: {},\n  data () {\n    return {}\n  },\n  created(){},\n  mounted () {},\n  watch:{},\n  methods: {}\n}\n```\n\n这种通过选项来配置Vue组件的方式称作配置式API，我们大部分的业务逻辑都是写在这些配置对应的方法或者配置里，这种方式使得每个配置各司其职，data、computed、methods、watch每个组件选项都有自己的业务逻辑。然而，当我们的组件开始变得更大时，逻辑关注点的列表也会增长。尤其对于那些一开始没有编写这些组件的人来说，这会导致组件难以阅读和理解，如图所示。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f9f354a4b414d1c9b70e83eb41a098a~tplv-k3u1fbpfcp-watermark.image?)\n\n如上图是一个大型组件，其逻辑是很复杂的，其中的逻辑关注点按颜色进行分组，当我们关注一条流程逻辑时，可能需要来回的在data、computed、methods、watch之间切换滚动这些代码块，这种碎片化使得理解和维护复杂组件变得困难，虽然在之前章节讲到过Mixin在一定程度上可以抽离出一些组件中的代码，但始终不是最高效的。\n\n为了能够将同一个逻辑关注点相关代码更好的收集在一起，Vue 3引入了与配置式API相对应的Composition组合式API，将上面的配置式API代码转换成组合式API，\n\n```\nimport {onMounted,reactive,watch} from 'vue'\nexport default {\n    props: {\n      name: String,\n    },\n    name: 'test',\n    components: {},\n    setup(props,ctx) {\n      console.log(props.name)\n      console.log('created')\n      const data = reactive({\n        a: 1\n      })\n      watch(\n        () => data.a,\n        (val, oldVal) => {\n          console.log(val)\n        }\n      )\n      onMounted(()=>{\n        \n      })\n      const myMethod = (obj) =>{\n\n      }\n\n      retrun {\n          data,\n          myMethod\n      }\n    }\n}\n```\n\n\n\n如上所示可以看到，组合式API的代码逻辑都可以写在setup方法中，这使得逻辑更加集中，更加原子化，从而提示可维护性。\n\n## setup 方法\n\n为了开始使用组合式 API，我们首先需要一个可以实际使用它的地方。在Vue 3的组件中，我们将此位置称为setup方法，如示例代码所示。\n\n```\n<div id=\"app\">\n  <component-b user=\"John\" />\n</div>\nconst componentB = {\n  props: {\n    user: {\n      type: String,\n      required: true\n    }\n  },\n  template:'<div></div>',\n  setup(props,context) {\n    console.log(props.user) // 打印'John'\n    return {} // 这里返回的任何内容都可以用于组件的其余部分\n  }\n}\nVue.createApp({\n  components: {\n    'component-b': componentB\n  }\n}).mount(\"#app\")\n```\n\n\n\n### setup方法参数\n\nsetup方法中接收两个参数，第一个参数式props，它和之前讲解组件通信中的props一样，可以接收到父组件传递的数据，同样，如果props是一个动态值，那么它就是响应式的，会随着父组件的改变而更新。\n\n但是，因为props是响应式的，你不能使用ES6解构，它会消除prop的响应性。如果需要解构prop，可以在setup方法中使用toRefs函数来完成此操作，如下代码所示：\n\n```\nsetup(props,context) {\n    const { user } = Vue.toRefs(props)\n    console.log(user.value) // 打印'John'\n}\n```\n\n注意，如果是采用npm来管理的项目，可以采用如下import方式引入toRefs，包括后续的Composition API相关的方法：\n\n`import { toRefs } from 'vue'`\n\n如果user是可选的prop，则传入的props中可能没有user。在这种情况下，需要使用toRef替代它，代码如下：\n\n```\nsetup(props,context) {\n    const { user } = Vue.toRef(props,'user')\n    console.log(user.value) // 打印'John'\n}\n```\n\nsetup方法的第二个参数是context对象，context是一个普通的JavaScript对象，它暴露组件的三个属性，分别是attrs，slots，emit，并且由于是普通的JavaScript对象，可以之间采用ES6解构，如示例代码所示。\n\n```\n<div id=\"app\">\n  <component-b attrone=\"one\" @emitcallback=\"emitcallback\">\n    <template v-slot:slotone>\n      <span>slot</span>\n    </template>\n  </component>\n</div>\nconst componentB = {\n\n  template:'<div></div>',\n  setup(props, { attrs, slots, emit }) {\n\n    // Attribute (非响应式对象)\n    console.log(attrs) // 打印 { attrone: 'one' } 相当于this.$attrs\n\n    // 插槽 (非响应式对象)\n    console.log(slots.slotone) // 打印{ slotone: function(){} } 相当于this.$slots\n\n    // 触发事件 (方法)\n    console.log(emit) // 可调用emit('emitcallback')相当于this.$emit\n\n  },\n\n}\nconst vm = Vue.createApp({\n  components: {\n    'component-b': componentB\n  },\n  methods:{\n    emitcallback(){\n      console.log('emitcallback')\n    }\n  }\n}).mount(\"#app\")\n```\n\n其中，attrs对象是父组件传递给子组件且不在props中定义的的静态数据，它是非响应式的，相当于在没有使用setup方法时之外调用的this.\\$attrs效果。\n\nslots对象主要是父组件传递的插槽内容，注意v-slot:slotone需要配置插槽名字，这样slots才能接收到，它是非响应式的，相当于在没有使用setup方法时之外调用的this.\\$slots效果。\n\nemit对象主要用来和父组件通信，相当于在没有使用setup方法时之外调用的this.\\$emit效果。\n\n### setup方法结合模板使用\n\n如果setup方法返回一个对象，那么该对象的属性以及传递给setup的props参数中的属性就都可以在模板template中访问到，如示例代码所示。\n\n```\n<div id=\"app\">\n  <component-b user=\"John\" />\n</div>\nconst componentB = {\n  props: {\n    user: {\n      type: String,\n      required: true\n    }\n  },\n  template:'<div>{{user}} {{person.name}}</div>',\n  setup(props) {\n\n    const person = Vue.reactive({ name: 'Son' })\n    // 暴露给 template\n    return {\n        person\n    }\n  },\n\n}\nVue.createApp({\n  components: {\n    'component-b': componentB\n  }\n}).mount(\"#app\")\n```\n\n注意，props中的数据我们不必在setup中返回，Vue会自动的暴露给模板template中使用。\n\n### setup方法执行时机和getCurrentInstance方法\n\nsetup方法在组件的beforeCreate之前执行，此时由于组件还没有实例化，是无法之间像配置式API一样直接使用this.xx访问当前实例的上下文对象的，例如data，computed和methods都没法访问到，所以setup在和其它配置式API一起使用时可能会导致混淆，需要格外注意。\n\n但是，Vue在还是在Composition API中提供了getCurrentInstance方法来访问组件实例的上下文对象，如示例代码所示。\n\n```\nVue.createApp({\n  setup() {\n    Vue.onMounted(()=>{\n      const internalInstance = Vue.getCurrentInstance()\n      internalInstance.ctx.add()// 打印'methods add'\n    })\n  },\n  methods:{\n    add(){\n      console.log('methods add')\n    }\n  }\n}).mount(\"#app\")\n```\n\n需要注意的是请不要把它当作在像在配置式API中的this的替代方案来随意使用，另外getCurrentInstance只能在setup或生命周期钩子中调用，并且不建议在业务逻辑中使用该方法，可以一些开发第三方库中使用。\n\n## 响应式类方法\n\n在配置式API中，我们一般将需要有响应式的变量定义在data选项的属性里面，而在Vue 3的Composition API的setup方法里面，由于还无法访问到data属性，但是也可以定义响应式变量，主要用到toRef，toRefs，ref，reactive和一些其他方法，其中有些我们之前代码中已经用到过了，下面就来详细介绍一下他们的用法和区别。\n\n### ref和reactive\n\n1\\. ref方法\n\nref方法用于为数据添加响应式状态，可以支持基本的数据类型，也可以支持复杂的对象数据类型，是Vue 3中推荐的定义响应式数据的方法，也是最基本的响应式方法，需要注意的是：\n\n-   获取数据值的时候需要加.value。\n\n-   ref的本质是原始数据的拷贝，改变简单类型数据的值不会同时改变原始数据。\n\n使用方法如实例代码所示。\n\n```\n<div id=\"app\">\n  <component-b  />\n</div>\nconst componentB = {\n  template:'<div>{{name}}</div>',\n  setup(props) {\n\n    // 为基本数据类型添加响应式状态\n    const name = Vue.ref('John')\n\n    let obj = {count : 0};\n\n    // 为复杂数据类型添加响应式状态\n    const state = Vue.ref(obj)\n\n    console.log(name.value) // 打印John\n\n    console.log(state.value.count)// 打印0\n\n    let newobj = Vue.ref(obj.count)\n\n    // 修改响应式数据不会影响原数据\n    newobj.value = 1\n\n    console.log(obj.count)// 打印0\n\n    return {\n      name\n    }\n  }\n}\nVue.createApp({\n  components: {\n    'component-b': componentB\n  }\n}).mount(\"#app\")\n```\n\n需要注意的是，改变的这个数据必须是简单数据类型，一个具体的值，这样才不会影响到原始数据，如上面的代码中的obj.count。\n\n2\\. reactive方法\n\nref方法用于为复杂数据添加响应式状态，只支持对象数据类型，需要注意的是：\n\n-   获取数据值的时候不需要加.value。\n\n-   reactive的参数必须是一个对象，包括JSON数据和数组都可以，否则不具有响应式。\n\n-   和ref一样，reactive的本质也是原始数据的拷贝。\n\nref本质也是reactive，ref(obj)等价于reactive({value:obj})，使用方法如示例代码所示。\n\n```\n<div id=\"app\">\n  <component-b  />\n</div>\nconst componentB = {\n  template:'<div>{{state.count}}</div>',\n  setup(props) {\n\n    // 为复杂数据类型添加响应式状态\n    const state = Vue.reactive({count : 0})\n\n    console.log(state.count)// 打印0\n\n    return {\n      state\n    }\n  }\n}\nVue.createApp({\n  components: {\n    'component-b': componentB\n  }\n}).mount(\"#app\")\n```\n\nreactive和ref都是用来定义响应式数据的。reactive更推荐去定义复杂的数据类型，不能直接解构，ref更推荐定义基本类型。ref可以简单地理解为是对reactive的二次包装，ref定义的数据访问的时候要多一个.value。\n\n### toRef和toRefs\n\n1\\. toRef方法\n\ntoRef方法我们在之前的setup方法中对props的操作已经使用过了，其第一种使用场景用于为原响应式对象上的属性新建单个响应式ref，从而保持对其源对象属性的响应式连接。接收两个参数：原响应式对象和属性名，返回一个ref数据。例如使用父组件传递的props数据时，要引用props的某个属性且要保持响应式连接时就很有用，其第二种使用场景是，接收两个参数：原普通对象和属性名，此时可以对单个属性添加响应式ref，但是这个响应式ref的改变不会更新界面，需要注意的是：\n\n-   获取数据值的时候需要加.value。\n\n-   toRef后的ref数据不是原始数据的拷贝，而是引用，改变结果数据的值也会同时改变原始数据。\n\n-   对于原始普通数据来说，新增加的单个ref改变，数据会更新，但是界面不会自动更新。\n\n使用方法如实例代码所示。\n\n```\n<div id=\"app\">\n  <component-b user=\"John\" />\n</div>\nconst componentB = {\n\n  template:'<div>{{statecount.count}}</div>',\n  setup(props) {\n\n    const state = Vue.reactive({\n      foo: 1,\n      bar: 2\n    })\n\n    const fooRef = Vue.toRef(state, 'foo')\n\n    fooRef.value++\n    console.log(state.foo) // 打印2会影响原始数据\n\n    state.foo++\n    console.log(fooRef.value) // 打印3会影响fooRef数据\n\n    const statecount = {// 普通数据\n      count: 0,\n    }\n\n    const stateRef = Vue.toRef(statecount,'count')\n\n    setTimeout(()=>{\n      stateRef.value = 1 // 界面不会更新\n      console.log(statecount.count) // 打印1 会影响原始数据\n    },1000)\n\n    return {\n      statecount,\n    }\n  }\n}\nVue.createApp({\n  components: {\n    'component-b': componentB\n  }\n}).mount(\"#app\")\n```\n\ntoRef更多的使用场景是对象添加单个响应式属性，而toRefs则是对完整的响应式对象进行转换。\n\n2\\. toRefs方法\n\ntoRefs方法将原响应式对象转换为普通对象，其中结果对象的每个属性都是指向原始对象相应\n属性的ref，另外一个重要使用场景是可以将reactive方法返回的复杂响应式数据ES6解构，需要注意的是：\n\n-   获取数据值的时候需要加.value。\n\n-   toRefs后的ref数据不是原始数据的拷贝，而是引用，改变结果数据的值也会同时改变原始数据。\n\n-   toRefs只接受响应式对象参数，不可接收普通对象参数，否则会警告。\n\n使用方法如实例代码所示。\n\n```\n<div id=\"app\">\n  <component-b  />\n</div>\nconst componentB = {\n  template:'<div>{{max}},{{count}}</div>',\n  setup(props) {\n\n    let obj = {\n      count: 0,\n      max: 100\n    }\n\n    const statecount = Vue.reactive(obj)\n\n    const {count,max} = Vue.toRefs(statecount) // 方便解构\n\n    setTimeout(()=>{\n\n      statecount.max++\n      console.log(obj.max) // 打印101 会影响原始数据，同时界面更新\n    },1000)\n\n    return {\n      count,\n      max\n    }\n  }\n}\nVue.createApp({\n  components: {\n    'component-b': componentB\n  }\n}).mount(\"#app\")\n```\n\n目前用的最多的还是ref和reactive来创建响应式对象，使用toRefs来转换成可以方便使用的解构的对象。\n\n### 其他响应式类方法\n\n1.  shallowRef方法和shallowReactive方法triggerRef方法\n\n对于复杂对象而言，ref和reactive都属于递归嵌套监听，也就是数据的每一层都是响应式的，如果数据量比较大，非常消耗性能，shallowRef和shallowReactive则是非递归监听只会监听数据的第一层。如实例代码所示。\n\n```\n<div id=\"app\">\n  <component-b />\n</div>\nconst componentB = {\n  template:'<div>{{shallow.person.name}}</div>',\n  setup(props) {\n\n    const shallow = Vue.shallowRef({\n      greet: 'Hello, world',\n      person:{\n        name:'John'\n      }\n    })\n\n    setTimeout(()=>{\n      // 这不会触发更新，因为 ref 是浅层的\n      shallow.value.person.name = 'Ted' \n      // 当调用triggerRef强制更新\n      Vue.triggerRef(shallow)\n    },1000)\n\n    return {shallow}\n\n  }\n}\nVue.createApp({\n  components: {\n    'component-b': componentB\n  }\n}).mount(\"#app\")\n```\n\ntriggerRef可以强制触发之前没有被监听到的更新，另外shallowReactive没有类似triggerRef的方法。\n\n2. readonly方法和shallowReadonly和isReadonly\n\n从字面意思上来理解，readonly表示只读可以将响应式对象标识成只读，当尝试修改时则会抛出警告，同样shallowReadonly方法设置第一层只读，isReadonly方法判断是否为只读对象，如示例代码所示。\n\n```\n<div id=\"app\">\n  <component-b />\n</div>\nconst componentB = {\n  template:'<div></div>',\n  setup(props) {\n\n    const obj = Vue.readonly({ foo: { bar: 1 } })\n\n    console.log(Vue.isReadonly(obj)) // true\n\n    obj.foo.bar = 2 // 失败警告：Set operation on key \"bar\" failed: target is readonly.\n    const sobj = Vue.shallowReadonly({ foo: { bar: 1 } })\n\n    sobj.foo.bar = 2 // 第二层可以修改\n\n    return {}\n\n  }\n}\nVue.createApp({\n  components: {\n    'component-b': componentB\n  }\n}).mount(\"#app\")\n```\n\n\n\n3. isRef方法和isReactive方法和isProxy\n\nisRef方法判断是否是ref方法返回对象，isReactive方法判断是否是reactive方法返回对象，isProxy用于判断是否是reactive方法或者ref方法返回对象。\n\n4. toRaw方法和makeRaw方法\n\ntoRaw方法可以返回一个响应式对象的原始普通对象，可用于临时读取数据而无需承担代理访问/跟踪的开销，也可用于写入数据而避免触发更改。\n\nmakeRaw方法，可以标记并返回一个对象，使其永远不会成为响应式对象。如示例代码所示。\n\n```\n<div id=\"app\">\n  <component-b />\n</div>\nconst componentB = {\n  template:'<div>{{reactivecobj.bar}}</div>',\n  setup(props) {\n    const obj = { foo : 1}\n    const reactivecobj = Vue.reactive(obj)\n    const rawobj = Vue.toRaw(reactivecobj)\n\n    console.log(obj === rawobj) // true\n\n    setTimeout(()=>{\n      rawobj.bar = 2 // 不会触发响应式更新\n    },1000)\n\n    const foo = {a:1} // foo无法通过reactive成为响应式对象\n\n    console.log(isReactive(reactive(foo))) // false\n\n    return {reactivecobj}\n  }\n}\nVue.createApp({\n  components: {\n    'component-b': componentB\n  }\n}).mount(\"#app\")\n```\n\n\n\n## 监听类方法\n\n之所以叫做监听（侦听）类方法，主要是这章我们介绍的方法其作用类似于配置式API中使用的watch方法，computed方法等等。监听类方法主要使用场景是提供对于响应式数据改变的追踪和影响，并提供一些钩子函数。本章我们主要介绍Composition API 中的computed和watch方法。\n\n### computed方法\n\n在配置式API中，computed是指计算属性，计算属性里可以完成各种复杂的逻辑，包括运算、函数调用等，只要最终返回一个结果就可以。计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。Composition API 中的computed也是类似的，使用方法如实例代码所示。\n\n```\n<div id=\"app\">\n  {{info}}\n</div>\nVue.createApp({\n  setup() {\n    const state = Vue.reactive({\n      name: \"John\",\n      age: 18\n    });\n    const info = Vue.computed(() => { // 创建一个计算属性，依赖name和age\n      console.log('computed')\n      return state.name + ',' + state.age\n    });\n\n    info.value = 1 // 抛出警告\nsetTimeout(()=>{\n      state.age = 20 // info动态修改\n    },1000)\n\n    setTimeout(()=>{\n      state.age = 20 // 第二次走缓存\n    },2000)\n\n    return {info}\n\n  }\n}).mount(\"#app\")\n```\n\n\n\n上面代码中，计算属性info依赖state中的age和name，当他们发生变化时，会导致info变化，同时如果每次变化的值相同，则走缓存，不会再次执行computed里的方法，这和配置式API里的computed是一致的。同时info是也是一个不可变的响应式对象，尝试修改会抛出警告。\n\ncomputed方法也可以接收一个对象，分别配置get和set方法，这样返回的可被修改，对应调用set方法，如下代码所示：\n\n```\nconst info = Vue.computed({\n  get: () => state.name + ',' + state.age,\n  set: val => {\n    state.age = val - 1\n  }\n});\ninfo.value = 21\n```\n\n\n\n12.5.3 watchEffect方法\n\nwatchEffect方法可以显示的监听这些变化，参数是一个函数，这个函数里所依赖的响应式对象如果发生变化，都会触发到这个函数，如示例代码所示。\n\n```\n<div id=\"app\">\n  {{info}}\n</div>\nVue.createApp({\n  setup() {\n    const state = Vue.reactive({\n      name: \"John\",\n      age: 18\n    });\n    const count = Vue.ref(0)\n    const countNo = Vue.ref(0)\n    const info = Vue.computed(() => { // 创建一个计算属性，依赖name和age\n      return state.name + ',' + state.age\n    });\n\n    Vue.watchEffect(()=>{\n      console.log('watchEffect')\n      console.log(info.value) // 依赖了info\n      console.log(count.value) // 依赖了count\n      \n    })\n    setTimeout(()=>{\n      state.age = 20 // 触发watchEffect\n    },1000)\n    setTimeout(()=>{\n      count.value = 3 // 触发watchEffect\n    },2000)\n    setTimeout(()=>{\n      countNo.value = 5 // 不触发watchEffect\n    },3000)\n\n    return {info}\n  }\n}).mount(\"#app\")\n```\n\n\n\n当watchEffect在组件的setup方法或生命周期钩子被调用时，侦听器会被链接到该组件的生命周期，并在组件卸载时自动停止在，一些情况下，也可以显式调用返回值以停止侦听，如下代码所示：\n\n```\nconst stop = watchEffect(() => {\n  /* ... */\n})\n\n...\nstop()\n```\n\n\n\n### watch方法\n\n在配置式API中，watch是指监听器，Composition\nAPI中同样提供了watch方法，其使用场景和用法是一致的，主要是对响应式对象变化的监听。但是和watchEffect相比有些类似，主要区别是：\n\n-   watch需要侦听特定的数据源，并在回调函数中执行副作用。\n\n-   默认情况下，它也是惰性的，即只有当被侦听的源发生变化时才执行回调。\n\n-   可以访问侦听状态变化前后的值。\n\nwatch监听单个数据源，第一个参数可以是返回值的getter函数，也可以是一个响应式对象，第二个参数是触发变化的回调函数。\n\n```\nVue.createApp({\n  setup() {\n    // 侦听一个 getter\n    const state = Vue.reactive({ count: 0 })\n\n    Vue.watch(() => state.count,\n      (count, prevCount) => {\n        console.log(count, prevCount)\n      }\n    )\n    // 直接侦听ref\n    const count = Vue.ref(0)\n    Vue.watch(count, (count, prevCount) => {\n      console.log(count, prevCount)\n    })\n\n    setTimeout(()=>{\n      state.count = 1\n      count.value = 2\n    })\n\n    return {}\n  }\n}).mount(\"#app\")\n```\n\n\n\nwatch监听多个数据源，第一个参数为多个响应式对象的数组，第二个参数是触发变化的回调函数。\n\n```\nVue.createApp({\n  setup() {\n    const state = Vue.reactive({ name: 'John' })\n    const count = Vue.ref(0)\n\n    Vue.watch([count,state], (count, prevCount) => {\n      console.log(count, prevCount)\n      // [2,{name:\"Ted\"}]   [0,{name:\"John\"}]\n    })\n\n    setTimeout(()=>{\n      state.name = 'Ted'\n      count.value = 2\n    })\n\n    return {}\n  }\n}).mount(\"#app\")\n```\n\n\n\nwatch监听复杂响应式对象时，如果要完全深度监听，需要添加deep:true配置，同时第一个参数需要为一个\ngetter方法，同时采用深度复制，如示例代码所示。\n\n```\nVue.createApp({\n  setup() {\n    const state = Vue.reactive({\n      name: \"John\",\n      age: 18,\n      attributes: { \n        attr: 'efg',\n      }\n    });\n\nVue.watch(()=>JSON.parse(JSON.stringify(state)),// 利用深度复制\n(currentState, prevState) => {\n        console.log(currentState.attributes.attr)// abc\n        console.log(prevState.attributes.attr)// efg\n      },{ deep: true })\n\n    setTimeout(()=>{\n        state.attributes.attr = 'abc'\n    },1000)\n\n    return {}\n  }\n}).mount(\"#app\")\n```\n\n\n\n需要注意，深度监听需要对原始state进行深度复制并返回，可以采用JSON.parse()，JSON.stringify()的方法进行复制，也可以采用一些第三方库，例如lodash.cloneDeep方法。\n\n## 生命周期类方法\n\n生命周期方法，通常叫做生命周期钩子，在配置式API中我们已经了解了具体的生命周期方法，在Composition API的setup方法里面同样有对应的生命周期方法，他们的对应关系如下所示：\n\n```\nbeforeCreate -> 使用 setup()\n\ncreated -> 使用 setup()\n\nbeforeMount -> onBeforeMount\n\nmounted -> onMounted\n\nbeforeUpdate -> onBeforeUpdate\n\nupdated -> onUpdated\n\nbeforeUnmount -> onBeforeUnmount\n\nunmounted -> onUnmounted\n\nerrorCaptured -> onErrorCaptured\n\nrenderTracked -> onRenderTracked\n\nrenderTriggered -> onRenderTriggered\n\nactivated -> onActivated\n\ndeactivated -> onDeactivated\n```\n\n由于setup方法在组件的beforeCreate和created之前执行，所以不在提供对应的钩子方法，这些生命周期钩子注册函数只能在setup方法内同步使用，因为它们依赖于内部的全局状态来定位当前活动的实例\n(此时正在调用其setup的组件实例)，在没有当前活动实例的情况下，调用它们将会出错。同时，在这些生命周期钩子内同步创建的侦听器和计算属性也会在组件卸载时自动删除，这点和配置式API式一致的。如示例代码所示。\n\n```\nconst MyComponent = {\n  setup() {\n    Vue.onMounted(() => {\n      console.log('mounted!')\n    })\n    Vue.onUpdated(() => {\n      console.log('updated!')\n    })\n    Vue.onUnmounted(() => {\n      console.log('unmounted!')\n    })\n  }\n}\n```\n\n\n\n## methods方法\n\n除了上面所讲解的方法之外，还有一类就是使用最多的对应配置式API中的methods类方法了，这类方法主要结合模板template中的一些回调事件使用，如示例代码所示。\n\n```\n<div id=\"app\">\n  {{count}}\n  <button @click=\"add\">点我+1</button>\n</div>\nVue.createApp({\n  setup() {\n    const count = Vue.ref(0)\n\n    const add = ()=>{\n      count.value++\n    }\n\n    return { count,add }\n  }\n}).mount(\"#app\")\n```\n\n\n\n上面代码中，在setup方法中返回了add方法，这样在模板template中就可以进行绑定，当click事件触发时，会进入这个方法。\n\n当结合配置式API使用时，如果在组件的methods中也配置了同名的方法，那么会优先执行setup中定义的，methods中定义的方法将不会执行，如下代码：\n\n```\nVue.createApp({\n  setup() {\n    const count = Vue.ref(0)\n\n    const add = ()=>{\n      count.value++\n    }\n\n    return { count,add }\n  },\n  methods:{\n    add(){} // 不会触发\n  }\n}).mount(\"#app\")\n```\n\n\n\n同样，在进行组件通信时，如果遇到同名的方法，优先以setup中定义并返回的方法为主，如示例代码所示。\n\n```\n<div id=\"app\">\n  <component-b @add=\"add\"/>\n</div>\nconst componentB = {\n  template:'<div></div>',\n  setup(props,{emit}) {\n    emit('add') // 通知父组件\n  }\n}\nVue.createApp({\n  components: {\n    'component-b': componentB\n  },\n  setup() {\n    const add = ()=>{\n      console.log('setup add')\n    }\n    return { add }\n  },\n  methods:{\n    add(){\n      console.log('methods add') // 不会触发\n    }\n  }\n}).mount(\"#app\")\n```\n\n\n\n上面代码中，当子组件调用emit通知父组件时，会调用父组件setup方法中的add方法，而不会调用methods中定义的。\n\n## Provide / Inject\n\nprovide（提供）和inject（注入）也可以在Composition API的setup方法里面使用，来实现跨越层级的组件通信。\n\nprovide方法接受两个参数，第一个参数是提供数据的key，第二个参数是值value，可以是对象，方法等等，如示例代码所示。\n\n```\n<div id=\"app\">\n  <component-b />\n</div>\nVue.createApp({\n  components: {\n    'component-b': componentB\n  },\n  setup() {\n    Vue.provide('location', 'North Pole')\n    Vue.provide('geolocation', {\n      longitude: 90,\n      latitude: 135\n    })\n  }\n}).mount(\"#app\")\n```\n\n\n\ninject方法接受两个参数，第一个参数是需要注入的数据的key，第二个参数是默认值（可选），如示例代码所示。\n\n```\nconst componentB = {\n  template:'<div>{{userLocation}}</div>',\n  setup() {\n    const userLocation = Vue.inject('location', 'The Universe')\n    const userGeolocation = Vue.inject('geolocation')\n    \nconsole.log(userGeolocation)\n    return {\n      userLocation,\n      userGeolocation\n    }\n  },\n}\n```\n\n\n\n和之前配置式API不同的是，我们可以在provide值时使用ref或reactive方法，来增加provide值和inject值之间的响应性，这样，当provide的数据发生变化时，inject也能实时接收到。如示例代码所示。\n\n```\nconst componentB = {\n\n  template:'<div>{{userLocation}}</div>',\n  setup() {\n\n    const userLocation = Vue.inject('location', 'The Universe')\n    const userGeolocation = Vue.inject('geolocation')\n\n    console.log(userGeolocation)\n\n    return {\n      userLocation,\n      userGeolocation\n    }\n  },\n\n}\nVue.createApp({\n  components: {\n    'component-b': componentB\n  },\n  setup() {\n    const location = Vue.ref('North Pole')\n    const geolocation = Vue.reactive({\n      longitude: 90,\n      latitude: 135\n    })\n\n    Vue.provide('location', location)\n    Vue.provide('geolocation', geolocation)\n\n    setTimeout(()=>{\n      location.value = 'China'\n    },1000)\n  }\n}).mount(\"#app\")\n```\n\n\n\n通常情况下，只允许在provide的组件内去修改响应式的provide数据，但是如果需要在被inject里面修改provide的值，则需要provide一个回调方法，然后在被inject的组件内调用。如示例代码所示。\n\n```\nconst componentB = {\n  template:'<div>{{userLocation}}</div>',\n  setup() {\n    const userLocation = Vue.inject('location', 'The Universe')\n    const updateLocation = Vue.inject('updateLocation')\n\n    setTimeout(()=>{\n      updateLocation('China')\n    },1000)\n\n    return {\n      userLocation,\n    }\n  },\n\n}\nVue.createApp({\n  components: {\n    'component-b': componentB\n  },\n  setup() {\n    const location = Vue.ref('North Pole')\n\n    const updateLocation = (v) => {\n      location.value = v\n    }\n\n    Vue.provide('location', location)\n    Vue.provide('updateLocation', updateLocation)\n\n  }\n}).mount(\"#app\")\n```\n\n\n\n最后，如果要确保通过provide传递的数据不会被inject的组件更改，可以使用readonly方法，如下所示：\n\n```\nconst location = Vue.ref('North Pole')\n\nVue.provide('location', Vue.readonly(location))\n```\n\n\n\n## 本章小结\n\n在本章中，讲解了Vue 3引入的Composition API相关知识，主要内容包括：Composition\nAPI基础，setup方法，响应式类方法，监听类方法，生命周期类方法，methods方法，Provide和Inject。其中setup方法是Composition API的重点，所有相关Composition API新提供的接口都需要在setup中来使用，而响应式类方法中ref方法和reactive方法常被用来定义响应式对象，监听类方法中的computed方法和watch方法则提供了监听到响应式对象变化的时机，生命周期类方法基本和配置式API的使用类似，methods方法则需要注意同名的情况，最后Provide和Inject也是在setup方法中实现组件通信的重要工具。\n\n在后续的实战项目中，我们会大量的使用Composition API，所以学好本章内容非常重要。\n\n下面来检验一下读者对本章内容的掌握程度：\n\n-   setup方法中接受的两个参数，他们的作用分别是什么？Vue.js中父子组件如何通信？\n\n-   如果需要定义基本类型数据为响应式，应该调用哪个方法。\n\n-   watch和watchEffect的区别和各自的使用场景是什么？\n\n-   如何在被inject的组件中修改provide的数据。\n\n-   如果在模板中调用setup方法和配置式API中methods定义的方法同名会怎么样？\n\n\n\n\n\n","source":"_posts/Vue.js Composition API.md","raw":"---\ntitle: Vue.js Composition API\ndate: 2021-11-26 17:26:17\ntags:\n- vue3\n- Composition API\ncategories:\n- 1914\n\n---\n\n\n在Vue 3引入的Composition API翻译过来就叫做组合式API，所谓组合式就是我们可以自由的组合逻辑，即剥离公共逻辑，差异化个性逻辑，维护整体逻辑。我们知道一个大型的Vue应用就是业务逻辑的综合体，而Vue组件就是组成这个综合体的个体。\n<!--more-->\n通过创建Vue组件，我们可以将界面中重复的部分连同其功能一起提取为可重用的代码段。仅此一项就可以使我们的应用在可维护性和灵活性方面走得相当远。然而，我们的经验已经证明，光靠这一点可能并不够，尤其是当你的应用变得非常大的时候——想想几百个组件。处理这样的大型应用时，共享和重用代码变得尤为重要。\n\nComposition API给我们提供了更加高效的代码逻辑组合能力，整体提示项目的可维护性，是函数式编程的重要体现。\n\n## Composition API 基础\n\n通常，一个Vue组件对象大概是包括一些data属性，生命周期钩子函数，methods，components，props等等的配置项的Object对象，如示例代码所示。\n\n```javascript\nexport default {\n  name: 'test',\n  components: {},\n  props: {},\n  data () {\n    return {}\n  },\n  created(){},\n  mounted () {},\n  watch:{},\n  methods: {}\n}\n```\n\n这种通过选项来配置Vue组件的方式称作配置式API，我们大部分的业务逻辑都是写在这些配置对应的方法或者配置里，这种方式使得每个配置各司其职，data、computed、methods、watch每个组件选项都有自己的业务逻辑。然而，当我们的组件开始变得更大时，逻辑关注点的列表也会增长。尤其对于那些一开始没有编写这些组件的人来说，这会导致组件难以阅读和理解，如图所示。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f9f354a4b414d1c9b70e83eb41a098a~tplv-k3u1fbpfcp-watermark.image?)\n\n如上图是一个大型组件，其逻辑是很复杂的，其中的逻辑关注点按颜色进行分组，当我们关注一条流程逻辑时，可能需要来回的在data、computed、methods、watch之间切换滚动这些代码块，这种碎片化使得理解和维护复杂组件变得困难，虽然在之前章节讲到过Mixin在一定程度上可以抽离出一些组件中的代码，但始终不是最高效的。\n\n为了能够将同一个逻辑关注点相关代码更好的收集在一起，Vue 3引入了与配置式API相对应的Composition组合式API，将上面的配置式API代码转换成组合式API，\n\n```\nimport {onMounted,reactive,watch} from 'vue'\nexport default {\n    props: {\n      name: String,\n    },\n    name: 'test',\n    components: {},\n    setup(props,ctx) {\n      console.log(props.name)\n      console.log('created')\n      const data = reactive({\n        a: 1\n      })\n      watch(\n        () => data.a,\n        (val, oldVal) => {\n          console.log(val)\n        }\n      )\n      onMounted(()=>{\n        \n      })\n      const myMethod = (obj) =>{\n\n      }\n\n      retrun {\n          data,\n          myMethod\n      }\n    }\n}\n```\n\n\n\n如上所示可以看到，组合式API的代码逻辑都可以写在setup方法中，这使得逻辑更加集中，更加原子化，从而提示可维护性。\n\n## setup 方法\n\n为了开始使用组合式 API，我们首先需要一个可以实际使用它的地方。在Vue 3的组件中，我们将此位置称为setup方法，如示例代码所示。\n\n```\n<div id=\"app\">\n  <component-b user=\"John\" />\n</div>\nconst componentB = {\n  props: {\n    user: {\n      type: String,\n      required: true\n    }\n  },\n  template:'<div></div>',\n  setup(props,context) {\n    console.log(props.user) // 打印'John'\n    return {} // 这里返回的任何内容都可以用于组件的其余部分\n  }\n}\nVue.createApp({\n  components: {\n    'component-b': componentB\n  }\n}).mount(\"#app\")\n```\n\n\n\n### setup方法参数\n\nsetup方法中接收两个参数，第一个参数式props，它和之前讲解组件通信中的props一样，可以接收到父组件传递的数据，同样，如果props是一个动态值，那么它就是响应式的，会随着父组件的改变而更新。\n\n但是，因为props是响应式的，你不能使用ES6解构，它会消除prop的响应性。如果需要解构prop，可以在setup方法中使用toRefs函数来完成此操作，如下代码所示：\n\n```\nsetup(props,context) {\n    const { user } = Vue.toRefs(props)\n    console.log(user.value) // 打印'John'\n}\n```\n\n注意，如果是采用npm来管理的项目，可以采用如下import方式引入toRefs，包括后续的Composition API相关的方法：\n\n`import { toRefs } from 'vue'`\n\n如果user是可选的prop，则传入的props中可能没有user。在这种情况下，需要使用toRef替代它，代码如下：\n\n```\nsetup(props,context) {\n    const { user } = Vue.toRef(props,'user')\n    console.log(user.value) // 打印'John'\n}\n```\n\nsetup方法的第二个参数是context对象，context是一个普通的JavaScript对象，它暴露组件的三个属性，分别是attrs，slots，emit，并且由于是普通的JavaScript对象，可以之间采用ES6解构，如示例代码所示。\n\n```\n<div id=\"app\">\n  <component-b attrone=\"one\" @emitcallback=\"emitcallback\">\n    <template v-slot:slotone>\n      <span>slot</span>\n    </template>\n  </component>\n</div>\nconst componentB = {\n\n  template:'<div></div>',\n  setup(props, { attrs, slots, emit }) {\n\n    // Attribute (非响应式对象)\n    console.log(attrs) // 打印 { attrone: 'one' } 相当于this.$attrs\n\n    // 插槽 (非响应式对象)\n    console.log(slots.slotone) // 打印{ slotone: function(){} } 相当于this.$slots\n\n    // 触发事件 (方法)\n    console.log(emit) // 可调用emit('emitcallback')相当于this.$emit\n\n  },\n\n}\nconst vm = Vue.createApp({\n  components: {\n    'component-b': componentB\n  },\n  methods:{\n    emitcallback(){\n      console.log('emitcallback')\n    }\n  }\n}).mount(\"#app\")\n```\n\n其中，attrs对象是父组件传递给子组件且不在props中定义的的静态数据，它是非响应式的，相当于在没有使用setup方法时之外调用的this.\\$attrs效果。\n\nslots对象主要是父组件传递的插槽内容，注意v-slot:slotone需要配置插槽名字，这样slots才能接收到，它是非响应式的，相当于在没有使用setup方法时之外调用的this.\\$slots效果。\n\nemit对象主要用来和父组件通信，相当于在没有使用setup方法时之外调用的this.\\$emit效果。\n\n### setup方法结合模板使用\n\n如果setup方法返回一个对象，那么该对象的属性以及传递给setup的props参数中的属性就都可以在模板template中访问到，如示例代码所示。\n\n```\n<div id=\"app\">\n  <component-b user=\"John\" />\n</div>\nconst componentB = {\n  props: {\n    user: {\n      type: String,\n      required: true\n    }\n  },\n  template:'<div>{{user}} {{person.name}}</div>',\n  setup(props) {\n\n    const person = Vue.reactive({ name: 'Son' })\n    // 暴露给 template\n    return {\n        person\n    }\n  },\n\n}\nVue.createApp({\n  components: {\n    'component-b': componentB\n  }\n}).mount(\"#app\")\n```\n\n注意，props中的数据我们不必在setup中返回，Vue会自动的暴露给模板template中使用。\n\n### setup方法执行时机和getCurrentInstance方法\n\nsetup方法在组件的beforeCreate之前执行，此时由于组件还没有实例化，是无法之间像配置式API一样直接使用this.xx访问当前实例的上下文对象的，例如data，computed和methods都没法访问到，所以setup在和其它配置式API一起使用时可能会导致混淆，需要格外注意。\n\n但是，Vue在还是在Composition API中提供了getCurrentInstance方法来访问组件实例的上下文对象，如示例代码所示。\n\n```\nVue.createApp({\n  setup() {\n    Vue.onMounted(()=>{\n      const internalInstance = Vue.getCurrentInstance()\n      internalInstance.ctx.add()// 打印'methods add'\n    })\n  },\n  methods:{\n    add(){\n      console.log('methods add')\n    }\n  }\n}).mount(\"#app\")\n```\n\n需要注意的是请不要把它当作在像在配置式API中的this的替代方案来随意使用，另外getCurrentInstance只能在setup或生命周期钩子中调用，并且不建议在业务逻辑中使用该方法，可以一些开发第三方库中使用。\n\n## 响应式类方法\n\n在配置式API中，我们一般将需要有响应式的变量定义在data选项的属性里面，而在Vue 3的Composition API的setup方法里面，由于还无法访问到data属性，但是也可以定义响应式变量，主要用到toRef，toRefs，ref，reactive和一些其他方法，其中有些我们之前代码中已经用到过了，下面就来详细介绍一下他们的用法和区别。\n\n### ref和reactive\n\n1\\. ref方法\n\nref方法用于为数据添加响应式状态，可以支持基本的数据类型，也可以支持复杂的对象数据类型，是Vue 3中推荐的定义响应式数据的方法，也是最基本的响应式方法，需要注意的是：\n\n-   获取数据值的时候需要加.value。\n\n-   ref的本质是原始数据的拷贝，改变简单类型数据的值不会同时改变原始数据。\n\n使用方法如实例代码所示。\n\n```\n<div id=\"app\">\n  <component-b  />\n</div>\nconst componentB = {\n  template:'<div>{{name}}</div>',\n  setup(props) {\n\n    // 为基本数据类型添加响应式状态\n    const name = Vue.ref('John')\n\n    let obj = {count : 0};\n\n    // 为复杂数据类型添加响应式状态\n    const state = Vue.ref(obj)\n\n    console.log(name.value) // 打印John\n\n    console.log(state.value.count)// 打印0\n\n    let newobj = Vue.ref(obj.count)\n\n    // 修改响应式数据不会影响原数据\n    newobj.value = 1\n\n    console.log(obj.count)// 打印0\n\n    return {\n      name\n    }\n  }\n}\nVue.createApp({\n  components: {\n    'component-b': componentB\n  }\n}).mount(\"#app\")\n```\n\n需要注意的是，改变的这个数据必须是简单数据类型，一个具体的值，这样才不会影响到原始数据，如上面的代码中的obj.count。\n\n2\\. reactive方法\n\nref方法用于为复杂数据添加响应式状态，只支持对象数据类型，需要注意的是：\n\n-   获取数据值的时候不需要加.value。\n\n-   reactive的参数必须是一个对象，包括JSON数据和数组都可以，否则不具有响应式。\n\n-   和ref一样，reactive的本质也是原始数据的拷贝。\n\nref本质也是reactive，ref(obj)等价于reactive({value:obj})，使用方法如示例代码所示。\n\n```\n<div id=\"app\">\n  <component-b  />\n</div>\nconst componentB = {\n  template:'<div>{{state.count}}</div>',\n  setup(props) {\n\n    // 为复杂数据类型添加响应式状态\n    const state = Vue.reactive({count : 0})\n\n    console.log(state.count)// 打印0\n\n    return {\n      state\n    }\n  }\n}\nVue.createApp({\n  components: {\n    'component-b': componentB\n  }\n}).mount(\"#app\")\n```\n\nreactive和ref都是用来定义响应式数据的。reactive更推荐去定义复杂的数据类型，不能直接解构，ref更推荐定义基本类型。ref可以简单地理解为是对reactive的二次包装，ref定义的数据访问的时候要多一个.value。\n\n### toRef和toRefs\n\n1\\. toRef方法\n\ntoRef方法我们在之前的setup方法中对props的操作已经使用过了，其第一种使用场景用于为原响应式对象上的属性新建单个响应式ref，从而保持对其源对象属性的响应式连接。接收两个参数：原响应式对象和属性名，返回一个ref数据。例如使用父组件传递的props数据时，要引用props的某个属性且要保持响应式连接时就很有用，其第二种使用场景是，接收两个参数：原普通对象和属性名，此时可以对单个属性添加响应式ref，但是这个响应式ref的改变不会更新界面，需要注意的是：\n\n-   获取数据值的时候需要加.value。\n\n-   toRef后的ref数据不是原始数据的拷贝，而是引用，改变结果数据的值也会同时改变原始数据。\n\n-   对于原始普通数据来说，新增加的单个ref改变，数据会更新，但是界面不会自动更新。\n\n使用方法如实例代码所示。\n\n```\n<div id=\"app\">\n  <component-b user=\"John\" />\n</div>\nconst componentB = {\n\n  template:'<div>{{statecount.count}}</div>',\n  setup(props) {\n\n    const state = Vue.reactive({\n      foo: 1,\n      bar: 2\n    })\n\n    const fooRef = Vue.toRef(state, 'foo')\n\n    fooRef.value++\n    console.log(state.foo) // 打印2会影响原始数据\n\n    state.foo++\n    console.log(fooRef.value) // 打印3会影响fooRef数据\n\n    const statecount = {// 普通数据\n      count: 0,\n    }\n\n    const stateRef = Vue.toRef(statecount,'count')\n\n    setTimeout(()=>{\n      stateRef.value = 1 // 界面不会更新\n      console.log(statecount.count) // 打印1 会影响原始数据\n    },1000)\n\n    return {\n      statecount,\n    }\n  }\n}\nVue.createApp({\n  components: {\n    'component-b': componentB\n  }\n}).mount(\"#app\")\n```\n\ntoRef更多的使用场景是对象添加单个响应式属性，而toRefs则是对完整的响应式对象进行转换。\n\n2\\. toRefs方法\n\ntoRefs方法将原响应式对象转换为普通对象，其中结果对象的每个属性都是指向原始对象相应\n属性的ref，另外一个重要使用场景是可以将reactive方法返回的复杂响应式数据ES6解构，需要注意的是：\n\n-   获取数据值的时候需要加.value。\n\n-   toRefs后的ref数据不是原始数据的拷贝，而是引用，改变结果数据的值也会同时改变原始数据。\n\n-   toRefs只接受响应式对象参数，不可接收普通对象参数，否则会警告。\n\n使用方法如实例代码所示。\n\n```\n<div id=\"app\">\n  <component-b  />\n</div>\nconst componentB = {\n  template:'<div>{{max}},{{count}}</div>',\n  setup(props) {\n\n    let obj = {\n      count: 0,\n      max: 100\n    }\n\n    const statecount = Vue.reactive(obj)\n\n    const {count,max} = Vue.toRefs(statecount) // 方便解构\n\n    setTimeout(()=>{\n\n      statecount.max++\n      console.log(obj.max) // 打印101 会影响原始数据，同时界面更新\n    },1000)\n\n    return {\n      count,\n      max\n    }\n  }\n}\nVue.createApp({\n  components: {\n    'component-b': componentB\n  }\n}).mount(\"#app\")\n```\n\n目前用的最多的还是ref和reactive来创建响应式对象，使用toRefs来转换成可以方便使用的解构的对象。\n\n### 其他响应式类方法\n\n1.  shallowRef方法和shallowReactive方法triggerRef方法\n\n对于复杂对象而言，ref和reactive都属于递归嵌套监听，也就是数据的每一层都是响应式的，如果数据量比较大，非常消耗性能，shallowRef和shallowReactive则是非递归监听只会监听数据的第一层。如实例代码所示。\n\n```\n<div id=\"app\">\n  <component-b />\n</div>\nconst componentB = {\n  template:'<div>{{shallow.person.name}}</div>',\n  setup(props) {\n\n    const shallow = Vue.shallowRef({\n      greet: 'Hello, world',\n      person:{\n        name:'John'\n      }\n    })\n\n    setTimeout(()=>{\n      // 这不会触发更新，因为 ref 是浅层的\n      shallow.value.person.name = 'Ted' \n      // 当调用triggerRef强制更新\n      Vue.triggerRef(shallow)\n    },1000)\n\n    return {shallow}\n\n  }\n}\nVue.createApp({\n  components: {\n    'component-b': componentB\n  }\n}).mount(\"#app\")\n```\n\ntriggerRef可以强制触发之前没有被监听到的更新，另外shallowReactive没有类似triggerRef的方法。\n\n2. readonly方法和shallowReadonly和isReadonly\n\n从字面意思上来理解，readonly表示只读可以将响应式对象标识成只读，当尝试修改时则会抛出警告，同样shallowReadonly方法设置第一层只读，isReadonly方法判断是否为只读对象，如示例代码所示。\n\n```\n<div id=\"app\">\n  <component-b />\n</div>\nconst componentB = {\n  template:'<div></div>',\n  setup(props) {\n\n    const obj = Vue.readonly({ foo: { bar: 1 } })\n\n    console.log(Vue.isReadonly(obj)) // true\n\n    obj.foo.bar = 2 // 失败警告：Set operation on key \"bar\" failed: target is readonly.\n    const sobj = Vue.shallowReadonly({ foo: { bar: 1 } })\n\n    sobj.foo.bar = 2 // 第二层可以修改\n\n    return {}\n\n  }\n}\nVue.createApp({\n  components: {\n    'component-b': componentB\n  }\n}).mount(\"#app\")\n```\n\n\n\n3. isRef方法和isReactive方法和isProxy\n\nisRef方法判断是否是ref方法返回对象，isReactive方法判断是否是reactive方法返回对象，isProxy用于判断是否是reactive方法或者ref方法返回对象。\n\n4. toRaw方法和makeRaw方法\n\ntoRaw方法可以返回一个响应式对象的原始普通对象，可用于临时读取数据而无需承担代理访问/跟踪的开销，也可用于写入数据而避免触发更改。\n\nmakeRaw方法，可以标记并返回一个对象，使其永远不会成为响应式对象。如示例代码所示。\n\n```\n<div id=\"app\">\n  <component-b />\n</div>\nconst componentB = {\n  template:'<div>{{reactivecobj.bar}}</div>',\n  setup(props) {\n    const obj = { foo : 1}\n    const reactivecobj = Vue.reactive(obj)\n    const rawobj = Vue.toRaw(reactivecobj)\n\n    console.log(obj === rawobj) // true\n\n    setTimeout(()=>{\n      rawobj.bar = 2 // 不会触发响应式更新\n    },1000)\n\n    const foo = {a:1} // foo无法通过reactive成为响应式对象\n\n    console.log(isReactive(reactive(foo))) // false\n\n    return {reactivecobj}\n  }\n}\nVue.createApp({\n  components: {\n    'component-b': componentB\n  }\n}).mount(\"#app\")\n```\n\n\n\n## 监听类方法\n\n之所以叫做监听（侦听）类方法，主要是这章我们介绍的方法其作用类似于配置式API中使用的watch方法，computed方法等等。监听类方法主要使用场景是提供对于响应式数据改变的追踪和影响，并提供一些钩子函数。本章我们主要介绍Composition API 中的computed和watch方法。\n\n### computed方法\n\n在配置式API中，computed是指计算属性，计算属性里可以完成各种复杂的逻辑，包括运算、函数调用等，只要最终返回一个结果就可以。计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。Composition API 中的computed也是类似的，使用方法如实例代码所示。\n\n```\n<div id=\"app\">\n  {{info}}\n</div>\nVue.createApp({\n  setup() {\n    const state = Vue.reactive({\n      name: \"John\",\n      age: 18\n    });\n    const info = Vue.computed(() => { // 创建一个计算属性，依赖name和age\n      console.log('computed')\n      return state.name + ',' + state.age\n    });\n\n    info.value = 1 // 抛出警告\nsetTimeout(()=>{\n      state.age = 20 // info动态修改\n    },1000)\n\n    setTimeout(()=>{\n      state.age = 20 // 第二次走缓存\n    },2000)\n\n    return {info}\n\n  }\n}).mount(\"#app\")\n```\n\n\n\n上面代码中，计算属性info依赖state中的age和name，当他们发生变化时，会导致info变化，同时如果每次变化的值相同，则走缓存，不会再次执行computed里的方法，这和配置式API里的computed是一致的。同时info是也是一个不可变的响应式对象，尝试修改会抛出警告。\n\ncomputed方法也可以接收一个对象，分别配置get和set方法，这样返回的可被修改，对应调用set方法，如下代码所示：\n\n```\nconst info = Vue.computed({\n  get: () => state.name + ',' + state.age,\n  set: val => {\n    state.age = val - 1\n  }\n});\ninfo.value = 21\n```\n\n\n\n12.5.3 watchEffect方法\n\nwatchEffect方法可以显示的监听这些变化，参数是一个函数，这个函数里所依赖的响应式对象如果发生变化，都会触发到这个函数，如示例代码所示。\n\n```\n<div id=\"app\">\n  {{info}}\n</div>\nVue.createApp({\n  setup() {\n    const state = Vue.reactive({\n      name: \"John\",\n      age: 18\n    });\n    const count = Vue.ref(0)\n    const countNo = Vue.ref(0)\n    const info = Vue.computed(() => { // 创建一个计算属性，依赖name和age\n      return state.name + ',' + state.age\n    });\n\n    Vue.watchEffect(()=>{\n      console.log('watchEffect')\n      console.log(info.value) // 依赖了info\n      console.log(count.value) // 依赖了count\n      \n    })\n    setTimeout(()=>{\n      state.age = 20 // 触发watchEffect\n    },1000)\n    setTimeout(()=>{\n      count.value = 3 // 触发watchEffect\n    },2000)\n    setTimeout(()=>{\n      countNo.value = 5 // 不触发watchEffect\n    },3000)\n\n    return {info}\n  }\n}).mount(\"#app\")\n```\n\n\n\n当watchEffect在组件的setup方法或生命周期钩子被调用时，侦听器会被链接到该组件的生命周期，并在组件卸载时自动停止在，一些情况下，也可以显式调用返回值以停止侦听，如下代码所示：\n\n```\nconst stop = watchEffect(() => {\n  /* ... */\n})\n\n...\nstop()\n```\n\n\n\n### watch方法\n\n在配置式API中，watch是指监听器，Composition\nAPI中同样提供了watch方法，其使用场景和用法是一致的，主要是对响应式对象变化的监听。但是和watchEffect相比有些类似，主要区别是：\n\n-   watch需要侦听特定的数据源，并在回调函数中执行副作用。\n\n-   默认情况下，它也是惰性的，即只有当被侦听的源发生变化时才执行回调。\n\n-   可以访问侦听状态变化前后的值。\n\nwatch监听单个数据源，第一个参数可以是返回值的getter函数，也可以是一个响应式对象，第二个参数是触发变化的回调函数。\n\n```\nVue.createApp({\n  setup() {\n    // 侦听一个 getter\n    const state = Vue.reactive({ count: 0 })\n\n    Vue.watch(() => state.count,\n      (count, prevCount) => {\n        console.log(count, prevCount)\n      }\n    )\n    // 直接侦听ref\n    const count = Vue.ref(0)\n    Vue.watch(count, (count, prevCount) => {\n      console.log(count, prevCount)\n    })\n\n    setTimeout(()=>{\n      state.count = 1\n      count.value = 2\n    })\n\n    return {}\n  }\n}).mount(\"#app\")\n```\n\n\n\nwatch监听多个数据源，第一个参数为多个响应式对象的数组，第二个参数是触发变化的回调函数。\n\n```\nVue.createApp({\n  setup() {\n    const state = Vue.reactive({ name: 'John' })\n    const count = Vue.ref(0)\n\n    Vue.watch([count,state], (count, prevCount) => {\n      console.log(count, prevCount)\n      // [2,{name:\"Ted\"}]   [0,{name:\"John\"}]\n    })\n\n    setTimeout(()=>{\n      state.name = 'Ted'\n      count.value = 2\n    })\n\n    return {}\n  }\n}).mount(\"#app\")\n```\n\n\n\nwatch监听复杂响应式对象时，如果要完全深度监听，需要添加deep:true配置，同时第一个参数需要为一个\ngetter方法，同时采用深度复制，如示例代码所示。\n\n```\nVue.createApp({\n  setup() {\n    const state = Vue.reactive({\n      name: \"John\",\n      age: 18,\n      attributes: { \n        attr: 'efg',\n      }\n    });\n\nVue.watch(()=>JSON.parse(JSON.stringify(state)),// 利用深度复制\n(currentState, prevState) => {\n        console.log(currentState.attributes.attr)// abc\n        console.log(prevState.attributes.attr)// efg\n      },{ deep: true })\n\n    setTimeout(()=>{\n        state.attributes.attr = 'abc'\n    },1000)\n\n    return {}\n  }\n}).mount(\"#app\")\n```\n\n\n\n需要注意，深度监听需要对原始state进行深度复制并返回，可以采用JSON.parse()，JSON.stringify()的方法进行复制，也可以采用一些第三方库，例如lodash.cloneDeep方法。\n\n## 生命周期类方法\n\n生命周期方法，通常叫做生命周期钩子，在配置式API中我们已经了解了具体的生命周期方法，在Composition API的setup方法里面同样有对应的生命周期方法，他们的对应关系如下所示：\n\n```\nbeforeCreate -> 使用 setup()\n\ncreated -> 使用 setup()\n\nbeforeMount -> onBeforeMount\n\nmounted -> onMounted\n\nbeforeUpdate -> onBeforeUpdate\n\nupdated -> onUpdated\n\nbeforeUnmount -> onBeforeUnmount\n\nunmounted -> onUnmounted\n\nerrorCaptured -> onErrorCaptured\n\nrenderTracked -> onRenderTracked\n\nrenderTriggered -> onRenderTriggered\n\nactivated -> onActivated\n\ndeactivated -> onDeactivated\n```\n\n由于setup方法在组件的beforeCreate和created之前执行，所以不在提供对应的钩子方法，这些生命周期钩子注册函数只能在setup方法内同步使用，因为它们依赖于内部的全局状态来定位当前活动的实例\n(此时正在调用其setup的组件实例)，在没有当前活动实例的情况下，调用它们将会出错。同时，在这些生命周期钩子内同步创建的侦听器和计算属性也会在组件卸载时自动删除，这点和配置式API式一致的。如示例代码所示。\n\n```\nconst MyComponent = {\n  setup() {\n    Vue.onMounted(() => {\n      console.log('mounted!')\n    })\n    Vue.onUpdated(() => {\n      console.log('updated!')\n    })\n    Vue.onUnmounted(() => {\n      console.log('unmounted!')\n    })\n  }\n}\n```\n\n\n\n## methods方法\n\n除了上面所讲解的方法之外，还有一类就是使用最多的对应配置式API中的methods类方法了，这类方法主要结合模板template中的一些回调事件使用，如示例代码所示。\n\n```\n<div id=\"app\">\n  {{count}}\n  <button @click=\"add\">点我+1</button>\n</div>\nVue.createApp({\n  setup() {\n    const count = Vue.ref(0)\n\n    const add = ()=>{\n      count.value++\n    }\n\n    return { count,add }\n  }\n}).mount(\"#app\")\n```\n\n\n\n上面代码中，在setup方法中返回了add方法，这样在模板template中就可以进行绑定，当click事件触发时，会进入这个方法。\n\n当结合配置式API使用时，如果在组件的methods中也配置了同名的方法，那么会优先执行setup中定义的，methods中定义的方法将不会执行，如下代码：\n\n```\nVue.createApp({\n  setup() {\n    const count = Vue.ref(0)\n\n    const add = ()=>{\n      count.value++\n    }\n\n    return { count,add }\n  },\n  methods:{\n    add(){} // 不会触发\n  }\n}).mount(\"#app\")\n```\n\n\n\n同样，在进行组件通信时，如果遇到同名的方法，优先以setup中定义并返回的方法为主，如示例代码所示。\n\n```\n<div id=\"app\">\n  <component-b @add=\"add\"/>\n</div>\nconst componentB = {\n  template:'<div></div>',\n  setup(props,{emit}) {\n    emit('add') // 通知父组件\n  }\n}\nVue.createApp({\n  components: {\n    'component-b': componentB\n  },\n  setup() {\n    const add = ()=>{\n      console.log('setup add')\n    }\n    return { add }\n  },\n  methods:{\n    add(){\n      console.log('methods add') // 不会触发\n    }\n  }\n}).mount(\"#app\")\n```\n\n\n\n上面代码中，当子组件调用emit通知父组件时，会调用父组件setup方法中的add方法，而不会调用methods中定义的。\n\n## Provide / Inject\n\nprovide（提供）和inject（注入）也可以在Composition API的setup方法里面使用，来实现跨越层级的组件通信。\n\nprovide方法接受两个参数，第一个参数是提供数据的key，第二个参数是值value，可以是对象，方法等等，如示例代码所示。\n\n```\n<div id=\"app\">\n  <component-b />\n</div>\nVue.createApp({\n  components: {\n    'component-b': componentB\n  },\n  setup() {\n    Vue.provide('location', 'North Pole')\n    Vue.provide('geolocation', {\n      longitude: 90,\n      latitude: 135\n    })\n  }\n}).mount(\"#app\")\n```\n\n\n\ninject方法接受两个参数，第一个参数是需要注入的数据的key，第二个参数是默认值（可选），如示例代码所示。\n\n```\nconst componentB = {\n  template:'<div>{{userLocation}}</div>',\n  setup() {\n    const userLocation = Vue.inject('location', 'The Universe')\n    const userGeolocation = Vue.inject('geolocation')\n    \nconsole.log(userGeolocation)\n    return {\n      userLocation,\n      userGeolocation\n    }\n  },\n}\n```\n\n\n\n和之前配置式API不同的是，我们可以在provide值时使用ref或reactive方法，来增加provide值和inject值之间的响应性，这样，当provide的数据发生变化时，inject也能实时接收到。如示例代码所示。\n\n```\nconst componentB = {\n\n  template:'<div>{{userLocation}}</div>',\n  setup() {\n\n    const userLocation = Vue.inject('location', 'The Universe')\n    const userGeolocation = Vue.inject('geolocation')\n\n    console.log(userGeolocation)\n\n    return {\n      userLocation,\n      userGeolocation\n    }\n  },\n\n}\nVue.createApp({\n  components: {\n    'component-b': componentB\n  },\n  setup() {\n    const location = Vue.ref('North Pole')\n    const geolocation = Vue.reactive({\n      longitude: 90,\n      latitude: 135\n    })\n\n    Vue.provide('location', location)\n    Vue.provide('geolocation', geolocation)\n\n    setTimeout(()=>{\n      location.value = 'China'\n    },1000)\n  }\n}).mount(\"#app\")\n```\n\n\n\n通常情况下，只允许在provide的组件内去修改响应式的provide数据，但是如果需要在被inject里面修改provide的值，则需要provide一个回调方法，然后在被inject的组件内调用。如示例代码所示。\n\n```\nconst componentB = {\n  template:'<div>{{userLocation}}</div>',\n  setup() {\n    const userLocation = Vue.inject('location', 'The Universe')\n    const updateLocation = Vue.inject('updateLocation')\n\n    setTimeout(()=>{\n      updateLocation('China')\n    },1000)\n\n    return {\n      userLocation,\n    }\n  },\n\n}\nVue.createApp({\n  components: {\n    'component-b': componentB\n  },\n  setup() {\n    const location = Vue.ref('North Pole')\n\n    const updateLocation = (v) => {\n      location.value = v\n    }\n\n    Vue.provide('location', location)\n    Vue.provide('updateLocation', updateLocation)\n\n  }\n}).mount(\"#app\")\n```\n\n\n\n最后，如果要确保通过provide传递的数据不会被inject的组件更改，可以使用readonly方法，如下所示：\n\n```\nconst location = Vue.ref('North Pole')\n\nVue.provide('location', Vue.readonly(location))\n```\n\n\n\n## 本章小结\n\n在本章中，讲解了Vue 3引入的Composition API相关知识，主要内容包括：Composition\nAPI基础，setup方法，响应式类方法，监听类方法，生命周期类方法，methods方法，Provide和Inject。其中setup方法是Composition API的重点，所有相关Composition API新提供的接口都需要在setup中来使用，而响应式类方法中ref方法和reactive方法常被用来定义响应式对象，监听类方法中的computed方法和watch方法则提供了监听到响应式对象变化的时机，生命周期类方法基本和配置式API的使用类似，methods方法则需要注意同名的情况，最后Provide和Inject也是在setup方法中实现组件通信的重要工具。\n\n在后续的实战项目中，我们会大量的使用Composition API，所以学好本章内容非常重要。\n\n下面来检验一下读者对本章内容的掌握程度：\n\n-   setup方法中接受的两个参数，他们的作用分别是什么？Vue.js中父子组件如何通信？\n\n-   如果需要定义基本类型数据为响应式，应该调用哪个方法。\n\n-   watch和watchEffect的区别和各自的使用场景是什么？\n\n-   如何在被inject的组件中修改provide的数据。\n\n-   如果在模板中调用setup方法和配置式API中methods定义的方法同名会怎么样？\n\n\n\n\n\n","slug":"Vue.js Composition API","published":1,"updated":"2021-12-13T01:32:23.843Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434q08001d2wvjux4387b4","content":"<p>在Vue 3引入的Composition API翻译过来就叫做组合式API，所谓组合式就是我们可以自由的组合逻辑，即剥离公共逻辑，差异化个性逻辑，维护整体逻辑。我们知道一个大型的Vue应用就是业务逻辑的综合体，而Vue组件就是组成这个综合体的个体。<br><a id=\"more\"></a><br>通过创建Vue组件，我们可以将界面中重复的部分连同其功能一起提取为可重用的代码段。仅此一项就可以使我们的应用在可维护性和灵活性方面走得相当远。然而，我们的经验已经证明，光靠这一点可能并不够，尤其是当你的应用变得非常大的时候——想想几百个组件。处理这样的大型应用时，共享和重用代码变得尤为重要。</p>\n<p>Composition API给我们提供了更加高效的代码逻辑组合能力，整体提示项目的可维护性，是函数式编程的重要体现。</p>\n<h2><span id=\"composition-api-基础\">Composition API 基础</span></h2><p>通常，一个Vue组件对象大概是包括一些data属性，生命周期钩子函数，methods，components，props等等的配置项的Object对象，如示例代码所示。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'test'</span>,</span><br><span class=\"line\">  components: &#123;&#125;,</span><br><span class=\"line\">  props: &#123;&#125;,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;&#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  created()&#123;&#125;,</span><br><span class=\"line\">  mounted () &#123;&#125;,</span><br><span class=\"line\">  watch:&#123;&#125;,</span><br><span class=\"line\">  methods: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种通过选项来配置Vue组件的方式称作配置式API，我们大部分的业务逻辑都是写在这些配置对应的方法或者配置里，这种方式使得每个配置各司其职，data、computed、methods、watch每个组件选项都有自己的业务逻辑。然而，当我们的组件开始变得更大时，逻辑关注点的列表也会增长。尤其对于那些一开始没有编写这些组件的人来说，这会导致组件难以阅读和理解，如图所示。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f9f354a4b414d1c9b70e83eb41a098a~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>如上图是一个大型组件，其逻辑是很复杂的，其中的逻辑关注点按颜色进行分组，当我们关注一条流程逻辑时，可能需要来回的在data、computed、methods、watch之间切换滚动这些代码块，这种碎片化使得理解和维护复杂组件变得困难，虽然在之前章节讲到过Mixin在一定程度上可以抽离出一些组件中的代码，但始终不是最高效的。</p>\n<p>为了能够将同一个逻辑关注点相关代码更好的收集在一起，Vue 3引入了与配置式API相对应的Composition组合式API，将上面的配置式API代码转换成组合式API，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;onMounted,reactive,watch&#125; from &apos;vue&apos;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">      name: String,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    name: &apos;test&apos;,</span><br><span class=\"line\">    components: &#123;&#125;,</span><br><span class=\"line\">    setup(props,ctx) &#123;</span><br><span class=\"line\">      console.log(props.name)</span><br><span class=\"line\">      console.log(&apos;created&apos;)</span><br><span class=\"line\">      const data = reactive(&#123;</span><br><span class=\"line\">        a: 1</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      watch(</span><br><span class=\"line\">        () =&gt; data.a,</span><br><span class=\"line\">        (val, oldVal) =&gt; &#123;</span><br><span class=\"line\">          console.log(val)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      )</span><br><span class=\"line\">      onMounted(()=&gt;&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      const myMethod = (obj) =&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      retrun &#123;</span><br><span class=\"line\">          data,</span><br><span class=\"line\">          myMethod</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上所示可以看到，组合式API的代码逻辑都可以写在setup方法中，这使得逻辑更加集中，更加原子化，从而提示可维护性。</p>\n<h2><span id=\"setup-方法\">setup 方法</span></h2><p>为了开始使用组合式 API，我们首先需要一个可以实际使用它的地方。在Vue 3的组件中，我们将此位置称为setup方法，如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;component-b user=&quot;John&quot; /&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">const componentB = &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    user: &#123;</span><br><span class=\"line\">      type: String,</span><br><span class=\"line\">      required: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  template:&apos;&lt;div&gt;&lt;/div&gt;&apos;,</span><br><span class=\"line\">  setup(props,context) &#123;</span><br><span class=\"line\">    console.log(props.user) // 打印&apos;John&apos;</span><br><span class=\"line\">    return &#123;&#125; // 这里返回的任何内容都可以用于组件的其余部分</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &apos;component-b&apos;: componentB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<h3><span id=\"setup方法参数\">setup方法参数</span></h3><p>setup方法中接收两个参数，第一个参数式props，它和之前讲解组件通信中的props一样，可以接收到父组件传递的数据，同样，如果props是一个动态值，那么它就是响应式的，会随着父组件的改变而更新。</p>\n<p>但是，因为props是响应式的，你不能使用ES6解构，它会消除prop的响应性。如果需要解构prop，可以在setup方法中使用toRefs函数来完成此操作，如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setup(props,context) &#123;</span><br><span class=\"line\">    const &#123; user &#125; = Vue.toRefs(props)</span><br><span class=\"line\">    console.log(user.value) // 打印&apos;John&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意，如果是采用npm来管理的项目，可以采用如下import方式引入toRefs，包括后续的Composition API相关的方法：</p>\n<p><code>import { toRefs } from &#39;vue&#39;</code></p>\n<p>如果user是可选的prop，则传入的props中可能没有user。在这种情况下，需要使用toRef替代它，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setup(props,context) &#123;</span><br><span class=\"line\">    const &#123; user &#125; = Vue.toRef(props,&apos;user&apos;)</span><br><span class=\"line\">    console.log(user.value) // 打印&apos;John&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>setup方法的第二个参数是context对象，context是一个普通的JavaScript对象，它暴露组件的三个属性，分别是attrs，slots，emit，并且由于是普通的JavaScript对象，可以之间采用ES6解构，如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;component-b attrone=&quot;one&quot; @emitcallback=&quot;emitcallback&quot;&gt;</span><br><span class=\"line\">    &lt;template v-slot:slotone&gt;</span><br><span class=\"line\">      &lt;span&gt;slot&lt;/span&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">  &lt;/component&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">const componentB = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  template:&apos;&lt;div&gt;&lt;/div&gt;&apos;,</span><br><span class=\"line\">  setup(props, &#123; attrs, slots, emit &#125;) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Attribute (非响应式对象)</span><br><span class=\"line\">    console.log(attrs) // 打印 &#123; attrone: &apos;one&apos; &#125; 相当于this.$attrs</span><br><span class=\"line\"></span><br><span class=\"line\">    // 插槽 (非响应式对象)</span><br><span class=\"line\">    console.log(slots.slotone) // 打印&#123; slotone: function()&#123;&#125; &#125; 相当于this.$slots</span><br><span class=\"line\"></span><br><span class=\"line\">    // 触发事件 (方法)</span><br><span class=\"line\">    console.log(emit) // 可调用emit(&apos;emitcallback&apos;)相当于this.$emit</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const vm = Vue.createApp(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &apos;component-b&apos;: componentB</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods:&#123;</span><br><span class=\"line\">    emitcallback()&#123;</span><br><span class=\"line\">      console.log(&apos;emitcallback&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>其中，attrs对象是父组件传递给子组件且不在props中定义的的静态数据，它是非响应式的，相当于在没有使用setup方法时之外调用的this.\\$attrs效果。</p>\n<p>slots对象主要是父组件传递的插槽内容，注意v-slot:slotone需要配置插槽名字，这样slots才能接收到，它是非响应式的，相当于在没有使用setup方法时之外调用的this.\\$slots效果。</p>\n<p>emit对象主要用来和父组件通信，相当于在没有使用setup方法时之外调用的this.\\$emit效果。</p>\n<h3><span id=\"setup方法结合模板使用\">setup方法结合模板使用</span></h3><p>如果setup方法返回一个对象，那么该对象的属性以及传递给setup的props参数中的属性就都可以在模板template中访问到，如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;component-b user=&quot;John&quot; /&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">const componentB = &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    user: &#123;</span><br><span class=\"line\">      type: String,</span><br><span class=\"line\">      required: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  template:&apos;&lt;div&gt;&#123;&#123;user&#125;&#125; &#123;&#123;person.name&#125;&#125;&lt;/div&gt;&apos;,</span><br><span class=\"line\">  setup(props) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    const person = Vue.reactive(&#123; name: &apos;Son&apos; &#125;)</span><br><span class=\"line\">    // 暴露给 template</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        person</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &apos;component-b&apos;: componentB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>注意，props中的数据我们不必在setup中返回，Vue会自动的暴露给模板template中使用。</p>\n<h3><span id=\"setup方法执行时机和getcurrentinstance方法\">setup方法执行时机和getCurrentInstance方法</span></h3><p>setup方法在组件的beforeCreate之前执行，此时由于组件还没有实例化，是无法之间像配置式API一样直接使用this.xx访问当前实例的上下文对象的，例如data，computed和methods都没法访问到，所以setup在和其它配置式API一起使用时可能会导致混淆，需要格外注意。</p>\n<p>但是，Vue在还是在Composition API中提供了getCurrentInstance方法来访问组件实例的上下文对象，如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    Vue.onMounted(()=&gt;&#123;</span><br><span class=\"line\">      const internalInstance = Vue.getCurrentInstance()</span><br><span class=\"line\">      internalInstance.ctx.add()// 打印&apos;methods add&apos;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods:&#123;</span><br><span class=\"line\">    add()&#123;</span><br><span class=\"line\">      console.log(&apos;methods add&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>需要注意的是请不要把它当作在像在配置式API中的this的替代方案来随意使用，另外getCurrentInstance只能在setup或生命周期钩子中调用，并且不建议在业务逻辑中使用该方法，可以一些开发第三方库中使用。</p>\n<h2><span id=\"响应式类方法\">响应式类方法</span></h2><p>在配置式API中，我们一般将需要有响应式的变量定义在data选项的属性里面，而在Vue 3的Composition API的setup方法里面，由于还无法访问到data属性，但是也可以定义响应式变量，主要用到toRef，toRefs，ref，reactive和一些其他方法，其中有些我们之前代码中已经用到过了，下面就来详细介绍一下他们的用法和区别。</p>\n<h3><span id=\"ref和reactive\">ref和reactive</span></h3><p>1. ref方法</p>\n<p>ref方法用于为数据添加响应式状态，可以支持基本的数据类型，也可以支持复杂的对象数据类型，是Vue 3中推荐的定义响应式数据的方法，也是最基本的响应式方法，需要注意的是：</p>\n<ul>\n<li><p>获取数据值的时候需要加.value。</p>\n</li>\n<li><p>ref的本质是原始数据的拷贝，改变简单类型数据的值不会同时改变原始数据。</p>\n</li>\n</ul>\n<p>使用方法如实例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;component-b  /&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">const componentB = &#123;</span><br><span class=\"line\">  template:&apos;&lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;&apos;,</span><br><span class=\"line\">  setup(props) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 为基本数据类型添加响应式状态</span><br><span class=\"line\">    const name = Vue.ref(&apos;John&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">    let obj = &#123;count : 0&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 为复杂数据类型添加响应式状态</span><br><span class=\"line\">    const state = Vue.ref(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(name.value) // 打印John</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(state.value.count)// 打印0</span><br><span class=\"line\"></span><br><span class=\"line\">    let newobj = Vue.ref(obj.count)</span><br><span class=\"line\"></span><br><span class=\"line\">    // 修改响应式数据不会影响原数据</span><br><span class=\"line\">    newobj.value = 1</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(obj.count)// 打印0</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &apos;component-b&apos;: componentB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，改变的这个数据必须是简单数据类型，一个具体的值，这样才不会影响到原始数据，如上面的代码中的obj.count。</p>\n<p>2. reactive方法</p>\n<p>ref方法用于为复杂数据添加响应式状态，只支持对象数据类型，需要注意的是：</p>\n<ul>\n<li><p>获取数据值的时候不需要加.value。</p>\n</li>\n<li><p>reactive的参数必须是一个对象，包括JSON数据和数组都可以，否则不具有响应式。</p>\n</li>\n<li><p>和ref一样，reactive的本质也是原始数据的拷贝。</p>\n</li>\n</ul>\n<p>ref本质也是reactive，ref(obj)等价于reactive({value:obj})，使用方法如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;component-b  /&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">const componentB = &#123;</span><br><span class=\"line\">  template:&apos;&lt;div&gt;&#123;&#123;state.count&#125;&#125;&lt;/div&gt;&apos;,</span><br><span class=\"line\">  setup(props) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 为复杂数据类型添加响应式状态</span><br><span class=\"line\">    const state = Vue.reactive(&#123;count : 0&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(state.count)// 打印0</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      state</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &apos;component-b&apos;: componentB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>reactive和ref都是用来定义响应式数据的。reactive更推荐去定义复杂的数据类型，不能直接解构，ref更推荐定义基本类型。ref可以简单地理解为是对reactive的二次包装，ref定义的数据访问的时候要多一个.value。</p>\n<h3><span id=\"toref和torefs\">toRef和toRefs</span></h3><p>1. toRef方法</p>\n<p>toRef方法我们在之前的setup方法中对props的操作已经使用过了，其第一种使用场景用于为原响应式对象上的属性新建单个响应式ref，从而保持对其源对象属性的响应式连接。接收两个参数：原响应式对象和属性名，返回一个ref数据。例如使用父组件传递的props数据时，要引用props的某个属性且要保持响应式连接时就很有用，其第二种使用场景是，接收两个参数：原普通对象和属性名，此时可以对单个属性添加响应式ref，但是这个响应式ref的改变不会更新界面，需要注意的是：</p>\n<ul>\n<li><p>获取数据值的时候需要加.value。</p>\n</li>\n<li><p>toRef后的ref数据不是原始数据的拷贝，而是引用，改变结果数据的值也会同时改变原始数据。</p>\n</li>\n<li><p>对于原始普通数据来说，新增加的单个ref改变，数据会更新，但是界面不会自动更新。</p>\n</li>\n</ul>\n<p>使用方法如实例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;component-b user=&quot;John&quot; /&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">const componentB = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  template:&apos;&lt;div&gt;&#123;&#123;statecount.count&#125;&#125;&lt;/div&gt;&apos;,</span><br><span class=\"line\">  setup(props) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    const state = Vue.reactive(&#123;</span><br><span class=\"line\">      foo: 1,</span><br><span class=\"line\">      bar: 2</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    const fooRef = Vue.toRef(state, &apos;foo&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">    fooRef.value++</span><br><span class=\"line\">    console.log(state.foo) // 打印2会影响原始数据</span><br><span class=\"line\"></span><br><span class=\"line\">    state.foo++</span><br><span class=\"line\">    console.log(fooRef.value) // 打印3会影响fooRef数据</span><br><span class=\"line\"></span><br><span class=\"line\">    const statecount = &#123;// 普通数据</span><br><span class=\"line\">      count: 0,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const stateRef = Vue.toRef(statecount,&apos;count&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">      stateRef.value = 1 // 界面不会更新</span><br><span class=\"line\">      console.log(statecount.count) // 打印1 会影响原始数据</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      statecount,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &apos;component-b&apos;: componentB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>toRef更多的使用场景是对象添加单个响应式属性，而toRefs则是对完整的响应式对象进行转换。</p>\n<p>2. toRefs方法</p>\n<p>toRefs方法将原响应式对象转换为普通对象，其中结果对象的每个属性都是指向原始对象相应<br>属性的ref，另外一个重要使用场景是可以将reactive方法返回的复杂响应式数据ES6解构，需要注意的是：</p>\n<ul>\n<li><p>获取数据值的时候需要加.value。</p>\n</li>\n<li><p>toRefs后的ref数据不是原始数据的拷贝，而是引用，改变结果数据的值也会同时改变原始数据。</p>\n</li>\n<li><p>toRefs只接受响应式对象参数，不可接收普通对象参数，否则会警告。</p>\n</li>\n</ul>\n<p>使用方法如实例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;component-b  /&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">const componentB = &#123;</span><br><span class=\"line\">  template:&apos;&lt;div&gt;&#123;&#123;max&#125;&#125;,&#123;&#123;count&#125;&#125;&lt;/div&gt;&apos;,</span><br><span class=\"line\">  setup(props) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    let obj = &#123;</span><br><span class=\"line\">      count: 0,</span><br><span class=\"line\">      max: 100</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const statecount = Vue.reactive(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">    const &#123;count,max&#125; = Vue.toRefs(statecount) // 方便解构</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      statecount.max++</span><br><span class=\"line\">      console.log(obj.max) // 打印101 会影响原始数据，同时界面更新</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      count,</span><br><span class=\"line\">      max</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &apos;component-b&apos;: componentB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>目前用的最多的还是ref和reactive来创建响应式对象，使用toRefs来转换成可以方便使用的解构的对象。</p>\n<h3><span id=\"其他响应式类方法\">其他响应式类方法</span></h3><ol>\n<li>shallowRef方法和shallowReactive方法triggerRef方法</li>\n</ol>\n<p>对于复杂对象而言，ref和reactive都属于递归嵌套监听，也就是数据的每一层都是响应式的，如果数据量比较大，非常消耗性能，shallowRef和shallowReactive则是非递归监听只会监听数据的第一层。如实例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;component-b /&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">const componentB = &#123;</span><br><span class=\"line\">  template:&apos;&lt;div&gt;&#123;&#123;shallow.person.name&#125;&#125;&lt;/div&gt;&apos;,</span><br><span class=\"line\">  setup(props) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    const shallow = Vue.shallowRef(&#123;</span><br><span class=\"line\">      greet: &apos;Hello, world&apos;,</span><br><span class=\"line\">      person:&#123;</span><br><span class=\"line\">        name:&apos;John&apos;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">      // 这不会触发更新，因为 ref 是浅层的</span><br><span class=\"line\">      shallow.value.person.name = &apos;Ted&apos; </span><br><span class=\"line\">      // 当调用triggerRef强制更新</span><br><span class=\"line\">      Vue.triggerRef(shallow)</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;shallow&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &apos;component-b&apos;: componentB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>triggerRef可以强制触发之前没有被监听到的更新，另外shallowReactive没有类似triggerRef的方法。</p>\n<ol>\n<li>readonly方法和shallowReadonly和isReadonly</li>\n</ol>\n<p>从字面意思上来理解，readonly表示只读可以将响应式对象标识成只读，当尝试修改时则会抛出警告，同样shallowReadonly方法设置第一层只读，isReadonly方法判断是否为只读对象，如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;component-b /&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">const componentB = &#123;</span><br><span class=\"line\">  template:&apos;&lt;div&gt;&lt;/div&gt;&apos;,</span><br><span class=\"line\">  setup(props) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    const obj = Vue.readonly(&#123; foo: &#123; bar: 1 &#125; &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(Vue.isReadonly(obj)) // true</span><br><span class=\"line\"></span><br><span class=\"line\">    obj.foo.bar = 2 // 失败警告：Set operation on key &quot;bar&quot; failed: target is readonly.</span><br><span class=\"line\">    const sobj = Vue.shallowReadonly(&#123; foo: &#123; bar: 1 &#125; &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    sobj.foo.bar = 2 // 第二层可以修改</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &apos;component-b&apos;: componentB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<ol>\n<li>isRef方法和isReactive方法和isProxy</li>\n</ol>\n<p>isRef方法判断是否是ref方法返回对象，isReactive方法判断是否是reactive方法返回对象，isProxy用于判断是否是reactive方法或者ref方法返回对象。</p>\n<ol>\n<li>toRaw方法和makeRaw方法</li>\n</ol>\n<p>toRaw方法可以返回一个响应式对象的原始普通对象，可用于临时读取数据而无需承担代理访问/跟踪的开销，也可用于写入数据而避免触发更改。</p>\n<p>makeRaw方法，可以标记并返回一个对象，使其永远不会成为响应式对象。如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;component-b /&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">const componentB = &#123;</span><br><span class=\"line\">  template:&apos;&lt;div&gt;&#123;&#123;reactivecobj.bar&#125;&#125;&lt;/div&gt;&apos;,</span><br><span class=\"line\">  setup(props) &#123;</span><br><span class=\"line\">    const obj = &#123; foo : 1&#125;</span><br><span class=\"line\">    const reactivecobj = Vue.reactive(obj)</span><br><span class=\"line\">    const rawobj = Vue.toRaw(reactivecobj)</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(obj === rawobj) // true</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">      rawobj.bar = 2 // 不会触发响应式更新</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\"></span><br><span class=\"line\">    const foo = &#123;a:1&#125; // foo无法通过reactive成为响应式对象</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(isReactive(reactive(foo))) // false</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;reactivecobj&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &apos;component-b&apos;: componentB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<h2><span id=\"监听类方法\">监听类方法</span></h2><p>之所以叫做监听（侦听）类方法，主要是这章我们介绍的方法其作用类似于配置式API中使用的watch方法，computed方法等等。监听类方法主要使用场景是提供对于响应式数据改变的追踪和影响，并提供一些钩子函数。本章我们主要介绍Composition API 中的computed和watch方法。</p>\n<h3><span id=\"computed方法\">computed方法</span></h3><p>在配置式API中，computed是指计算属性，计算属性里可以完成各种复杂的逻辑，包括运算、函数调用等，只要最终返回一个结果就可以。计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。Composition API 中的computed也是类似的，使用方法如实例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &#123;&#123;info&#125;&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    const state = Vue.reactive(&#123;</span><br><span class=\"line\">      name: &quot;John&quot;,</span><br><span class=\"line\">      age: 18</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    const info = Vue.computed(() =&gt; &#123; // 创建一个计算属性，依赖name和age</span><br><span class=\"line\">      console.log(&apos;computed&apos;)</span><br><span class=\"line\">      return state.name + &apos;,&apos; + state.age</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    info.value = 1 // 抛出警告</span><br><span class=\"line\">setTimeout(()=&gt;&#123;</span><br><span class=\"line\">      state.age = 20 // info动态修改</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">      state.age = 20 // 第二次走缓存</span><br><span class=\"line\">    &#125;,2000)</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;info&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>上面代码中，计算属性info依赖state中的age和name，当他们发生变化时，会导致info变化，同时如果每次变化的值相同，则走缓存，不会再次执行computed里的方法，这和配置式API里的computed是一致的。同时info是也是一个不可变的响应式对象，尝试修改会抛出警告。</p>\n<p>computed方法也可以接收一个对象，分别配置get和set方法，这样返回的可被修改，对应调用set方法，如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const info = Vue.computed(&#123;</span><br><span class=\"line\">  get: () =&gt; state.name + &apos;,&apos; + state.age,</span><br><span class=\"line\">  set: val =&gt; &#123;</span><br><span class=\"line\">    state.age = val - 1</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">info.value = 21</span><br></pre></td></tr></table></figure>\n<p>12.5.3 watchEffect方法</p>\n<p>watchEffect方法可以显示的监听这些变化，参数是一个函数，这个函数里所依赖的响应式对象如果发生变化，都会触发到这个函数，如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &#123;&#123;info&#125;&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    const state = Vue.reactive(&#123;</span><br><span class=\"line\">      name: &quot;John&quot;,</span><br><span class=\"line\">      age: 18</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    const count = Vue.ref(0)</span><br><span class=\"line\">    const countNo = Vue.ref(0)</span><br><span class=\"line\">    const info = Vue.computed(() =&gt; &#123; // 创建一个计算属性，依赖name和age</span><br><span class=\"line\">      return state.name + &apos;,&apos; + state.age</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Vue.watchEffect(()=&gt;&#123;</span><br><span class=\"line\">      console.log(&apos;watchEffect&apos;)</span><br><span class=\"line\">      console.log(info.value) // 依赖了info</span><br><span class=\"line\">      console.log(count.value) // 依赖了count</span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">      state.age = 20 // 触发watchEffect</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">      count.value = 3 // 触发watchEffect</span><br><span class=\"line\">    &#125;,2000)</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">      countNo.value = 5 // 不触发watchEffect</span><br><span class=\"line\">    &#125;,3000)</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;info&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>当watchEffect在组件的setup方法或生命周期钩子被调用时，侦听器会被链接到该组件的生命周期，并在组件卸载时自动停止在，一些情况下，也可以显式调用返回值以停止侦听，如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const stop = watchEffect(() =&gt; &#123;</span><br><span class=\"line\">  /* ... */</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\">stop()</span><br></pre></td></tr></table></figure>\n<h3><span id=\"watch方法\">watch方法</span></h3><p>在配置式API中，watch是指监听器，Composition<br>API中同样提供了watch方法，其使用场景和用法是一致的，主要是对响应式对象变化的监听。但是和watchEffect相比有些类似，主要区别是：</p>\n<ul>\n<li><p>watch需要侦听特定的数据源，并在回调函数中执行副作用。</p>\n</li>\n<li><p>默认情况下，它也是惰性的，即只有当被侦听的源发生变化时才执行回调。</p>\n</li>\n<li><p>可以访问侦听状态变化前后的值。</p>\n</li>\n</ul>\n<p>watch监听单个数据源，第一个参数可以是返回值的getter函数，也可以是一个响应式对象，第二个参数是触发变化的回调函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    // 侦听一个 getter</span><br><span class=\"line\">    const state = Vue.reactive(&#123; count: 0 &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    Vue.watch(() =&gt; state.count,</span><br><span class=\"line\">      (count, prevCount) =&gt; &#123;</span><br><span class=\"line\">        console.log(count, prevCount)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    // 直接侦听ref</span><br><span class=\"line\">    const count = Vue.ref(0)</span><br><span class=\"line\">    Vue.watch(count, (count, prevCount) =&gt; &#123;</span><br><span class=\"line\">      console.log(count, prevCount)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">      state.count = 1</span><br><span class=\"line\">      count.value = 2</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>watch监听多个数据源，第一个参数为多个响应式对象的数组，第二个参数是触发变化的回调函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    const state = Vue.reactive(&#123; name: &apos;John&apos; &#125;)</span><br><span class=\"line\">    const count = Vue.ref(0)</span><br><span class=\"line\"></span><br><span class=\"line\">    Vue.watch([count,state], (count, prevCount) =&gt; &#123;</span><br><span class=\"line\">      console.log(count, prevCount)</span><br><span class=\"line\">      // [2,&#123;name:&quot;Ted&quot;&#125;]   [0,&#123;name:&quot;John&quot;&#125;]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">      state.name = &apos;Ted&apos;</span><br><span class=\"line\">      count.value = 2</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>watch监听复杂响应式对象时，如果要完全深度监听，需要添加deep:true配置，同时第一个参数需要为一个<br>getter方法，同时采用深度复制，如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    const state = Vue.reactive(&#123;</span><br><span class=\"line\">      name: &quot;John&quot;,</span><br><span class=\"line\">      age: 18,</span><br><span class=\"line\">      attributes: &#123; </span><br><span class=\"line\">        attr: &apos;efg&apos;,</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.watch(()=&gt;JSON.parse(JSON.stringify(state)),// 利用深度复制</span><br><span class=\"line\">(currentState, prevState) =&gt; &#123;</span><br><span class=\"line\">        console.log(currentState.attributes.attr)// abc</span><br><span class=\"line\">        console.log(prevState.attributes.attr)// efg</span><br><span class=\"line\">      &#125;,&#123; deep: true &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">        state.attributes.attr = &apos;abc&apos;</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>需要注意，深度监听需要对原始state进行深度复制并返回，可以采用JSON.parse()，JSON.stringify()的方法进行复制，也可以采用一些第三方库，例如lodash.cloneDeep方法。</p>\n<h2><span id=\"生命周期类方法\">生命周期类方法</span></h2><p>生命周期方法，通常叫做生命周期钩子，在配置式API中我们已经了解了具体的生命周期方法，在Composition API的setup方法里面同样有对应的生命周期方法，他们的对应关系如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beforeCreate -&gt; 使用 setup()</span><br><span class=\"line\"></span><br><span class=\"line\">created -&gt; 使用 setup()</span><br><span class=\"line\"></span><br><span class=\"line\">beforeMount -&gt; onBeforeMount</span><br><span class=\"line\"></span><br><span class=\"line\">mounted -&gt; onMounted</span><br><span class=\"line\"></span><br><span class=\"line\">beforeUpdate -&gt; onBeforeUpdate</span><br><span class=\"line\"></span><br><span class=\"line\">updated -&gt; onUpdated</span><br><span class=\"line\"></span><br><span class=\"line\">beforeUnmount -&gt; onBeforeUnmount</span><br><span class=\"line\"></span><br><span class=\"line\">unmounted -&gt; onUnmounted</span><br><span class=\"line\"></span><br><span class=\"line\">errorCaptured -&gt; onErrorCaptured</span><br><span class=\"line\"></span><br><span class=\"line\">renderTracked -&gt; onRenderTracked</span><br><span class=\"line\"></span><br><span class=\"line\">renderTriggered -&gt; onRenderTriggered</span><br><span class=\"line\"></span><br><span class=\"line\">activated -&gt; onActivated</span><br><span class=\"line\"></span><br><span class=\"line\">deactivated -&gt; onDeactivated</span><br></pre></td></tr></table></figure>\n<p>由于setup方法在组件的beforeCreate和created之前执行，所以不在提供对应的钩子方法，这些生命周期钩子注册函数只能在setup方法内同步使用，因为它们依赖于内部的全局状态来定位当前活动的实例<br>(此时正在调用其setup的组件实例)，在没有当前活动实例的情况下，调用它们将会出错。同时，在这些生命周期钩子内同步创建的侦听器和计算属性也会在组件卸载时自动删除，这点和配置式API式一致的。如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const MyComponent = &#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    Vue.onMounted(() =&gt; &#123;</span><br><span class=\"line\">      console.log(&apos;mounted!&apos;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    Vue.onUpdated(() =&gt; &#123;</span><br><span class=\"line\">      console.log(&apos;updated!&apos;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    Vue.onUnmounted(() =&gt; &#123;</span><br><span class=\"line\">      console.log(&apos;unmounted!&apos;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"methods方法\">methods方法</span></h2><p>除了上面所讲解的方法之外，还有一类就是使用最多的对应配置式API中的methods类方法了，这类方法主要结合模板template中的一些回调事件使用，如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &#123;&#123;count&#125;&#125;</span><br><span class=\"line\">  &lt;button @click=&quot;add&quot;&gt;点我+1&lt;/button&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    const count = Vue.ref(0)</span><br><span class=\"line\"></span><br><span class=\"line\">    const add = ()=&gt;&#123;</span><br><span class=\"line\">      count.value++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123; count,add &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>上面代码中，在setup方法中返回了add方法，这样在模板template中就可以进行绑定，当click事件触发时，会进入这个方法。</p>\n<p>当结合配置式API使用时，如果在组件的methods中也配置了同名的方法，那么会优先执行setup中定义的，methods中定义的方法将不会执行，如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    const count = Vue.ref(0)</span><br><span class=\"line\"></span><br><span class=\"line\">    const add = ()=&gt;&#123;</span><br><span class=\"line\">      count.value++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123; count,add &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods:&#123;</span><br><span class=\"line\">    add()&#123;&#125; // 不会触发</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>同样，在进行组件通信时，如果遇到同名的方法，优先以setup中定义并返回的方法为主，如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;component-b @add=&quot;add&quot;/&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">const componentB = &#123;</span><br><span class=\"line\">  template:&apos;&lt;div&gt;&lt;/div&gt;&apos;,</span><br><span class=\"line\">  setup(props,&#123;emit&#125;) &#123;</span><br><span class=\"line\">    emit(&apos;add&apos;) // 通知父组件</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &apos;component-b&apos;: componentB</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    const add = ()=&gt;&#123;</span><br><span class=\"line\">      console.log(&apos;setup add&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return &#123; add &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods:&#123;</span><br><span class=\"line\">    add()&#123;</span><br><span class=\"line\">      console.log(&apos;methods add&apos;) // 不会触发</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>上面代码中，当子组件调用emit通知父组件时，会调用父组件setup方法中的add方法，而不会调用methods中定义的。</p>\n<h2><span id=\"provide-inject\">Provide / Inject</span></h2><p>provide（提供）和inject（注入）也可以在Composition API的setup方法里面使用，来实现跨越层级的组件通信。</p>\n<p>provide方法接受两个参数，第一个参数是提供数据的key，第二个参数是值value，可以是对象，方法等等，如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;component-b /&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &apos;component-b&apos;: componentB</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    Vue.provide(&apos;location&apos;, &apos;North Pole&apos;)</span><br><span class=\"line\">    Vue.provide(&apos;geolocation&apos;, &#123;</span><br><span class=\"line\">      longitude: 90,</span><br><span class=\"line\">      latitude: 135</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>inject方法接受两个参数，第一个参数是需要注入的数据的key，第二个参数是默认值（可选），如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const componentB = &#123;</span><br><span class=\"line\">  template:&apos;&lt;div&gt;&#123;&#123;userLocation&#125;&#125;&lt;/div&gt;&apos;,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    const userLocation = Vue.inject(&apos;location&apos;, &apos;The Universe&apos;)</span><br><span class=\"line\">    const userGeolocation = Vue.inject(&apos;geolocation&apos;)</span><br><span class=\"line\">    </span><br><span class=\"line\">console.log(userGeolocation)</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      userLocation,</span><br><span class=\"line\">      userGeolocation</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和之前配置式API不同的是，我们可以在provide值时使用ref或reactive方法，来增加provide值和inject值之间的响应性，这样，当provide的数据发生变化时，inject也能实时接收到。如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const componentB = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  template:&apos;&lt;div&gt;&#123;&#123;userLocation&#125;&#125;&lt;/div&gt;&apos;,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    const userLocation = Vue.inject(&apos;location&apos;, &apos;The Universe&apos;)</span><br><span class=\"line\">    const userGeolocation = Vue.inject(&apos;geolocation&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(userGeolocation)</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      userLocation,</span><br><span class=\"line\">      userGeolocation</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &apos;component-b&apos;: componentB</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    const location = Vue.ref(&apos;North Pole&apos;)</span><br><span class=\"line\">    const geolocation = Vue.reactive(&#123;</span><br><span class=\"line\">      longitude: 90,</span><br><span class=\"line\">      latitude: 135</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    Vue.provide(&apos;location&apos;, location)</span><br><span class=\"line\">    Vue.provide(&apos;geolocation&apos;, geolocation)</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">      location.value = &apos;China&apos;</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>通常情况下，只允许在provide的组件内去修改响应式的provide数据，但是如果需要在被inject里面修改provide的值，则需要provide一个回调方法，然后在被inject的组件内调用。如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const componentB = &#123;</span><br><span class=\"line\">  template:&apos;&lt;div&gt;&#123;&#123;userLocation&#125;&#125;&lt;/div&gt;&apos;,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    const userLocation = Vue.inject(&apos;location&apos;, &apos;The Universe&apos;)</span><br><span class=\"line\">    const updateLocation = Vue.inject(&apos;updateLocation&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">      updateLocation(&apos;China&apos;)</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      userLocation,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &apos;component-b&apos;: componentB</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    const location = Vue.ref(&apos;North Pole&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">    const updateLocation = (v) =&gt; &#123;</span><br><span class=\"line\">      location.value = v</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Vue.provide(&apos;location&apos;, location)</span><br><span class=\"line\">    Vue.provide(&apos;updateLocation&apos;, updateLocation)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>最后，如果要确保通过provide传递的数据不会被inject的组件更改，可以使用readonly方法，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const location = Vue.ref(&apos;North Pole&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.provide(&apos;location&apos;, Vue.readonly(location))</span><br></pre></td></tr></table></figure>\n<h2><span id=\"本章小结\">本章小结</span></h2><p>在本章中，讲解了Vue 3引入的Composition API相关知识，主要内容包括：Composition<br>API基础，setup方法，响应式类方法，监听类方法，生命周期类方法，methods方法，Provide和Inject。其中setup方法是Composition API的重点，所有相关Composition API新提供的接口都需要在setup中来使用，而响应式类方法中ref方法和reactive方法常被用来定义响应式对象，监听类方法中的computed方法和watch方法则提供了监听到响应式对象变化的时机，生命周期类方法基本和配置式API的使用类似，methods方法则需要注意同名的情况，最后Provide和Inject也是在setup方法中实现组件通信的重要工具。</p>\n<p>在后续的实战项目中，我们会大量的使用Composition API，所以学好本章内容非常重要。</p>\n<p>下面来检验一下读者对本章内容的掌握程度：</p>\n<ul>\n<li><p>setup方法中接受的两个参数，他们的作用分别是什么？Vue.js中父子组件如何通信？</p>\n</li>\n<li><p>如果需要定义基本类型数据为响应式，应该调用哪个方法。</p>\n</li>\n<li><p>watch和watchEffect的区别和各自的使用场景是什么？</p>\n</li>\n<li><p>如何在被inject的组件中修改provide的数据。</p>\n</li>\n<li><p>如果在模板中调用setup方法和配置式API中methods定义的方法同名会怎么样？</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>在Vue 3引入的Composition API翻译过来就叫做组合式API，所谓组合式就是我们可以自由的组合逻辑，即剥离公共逻辑，差异化个性逻辑，维护整体逻辑。我们知道一个大型的Vue应用就是业务逻辑的综合体，而Vue组件就是组成这个综合体的个体。<br>","more":"<br>通过创建Vue组件，我们可以将界面中重复的部分连同其功能一起提取为可重用的代码段。仅此一项就可以使我们的应用在可维护性和灵活性方面走得相当远。然而，我们的经验已经证明，光靠这一点可能并不够，尤其是当你的应用变得非常大的时候——想想几百个组件。处理这样的大型应用时，共享和重用代码变得尤为重要。</p>\n<p>Composition API给我们提供了更加高效的代码逻辑组合能力，整体提示项目的可维护性，是函数式编程的重要体现。</p>\n<h2 id=\"Composition-API-基础\"><a href=\"#Composition-API-基础\" class=\"headerlink\" title=\"Composition API 基础\"></a>Composition API 基础</h2><p>通常，一个Vue组件对象大概是包括一些data属性，生命周期钩子函数，methods，components，props等等的配置项的Object对象，如示例代码所示。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'test'</span>,</span><br><span class=\"line\">  components: &#123;&#125;,</span><br><span class=\"line\">  props: &#123;&#125;,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;&#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  created()&#123;&#125;,</span><br><span class=\"line\">  mounted () &#123;&#125;,</span><br><span class=\"line\">  watch:&#123;&#125;,</span><br><span class=\"line\">  methods: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种通过选项来配置Vue组件的方式称作配置式API，我们大部分的业务逻辑都是写在这些配置对应的方法或者配置里，这种方式使得每个配置各司其职，data、computed、methods、watch每个组件选项都有自己的业务逻辑。然而，当我们的组件开始变得更大时，逻辑关注点的列表也会增长。尤其对于那些一开始没有编写这些组件的人来说，这会导致组件难以阅读和理解，如图所示。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f9f354a4b414d1c9b70e83eb41a098a~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>如上图是一个大型组件，其逻辑是很复杂的，其中的逻辑关注点按颜色进行分组，当我们关注一条流程逻辑时，可能需要来回的在data、computed、methods、watch之间切换滚动这些代码块，这种碎片化使得理解和维护复杂组件变得困难，虽然在之前章节讲到过Mixin在一定程度上可以抽离出一些组件中的代码，但始终不是最高效的。</p>\n<p>为了能够将同一个逻辑关注点相关代码更好的收集在一起，Vue 3引入了与配置式API相对应的Composition组合式API，将上面的配置式API代码转换成组合式API，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;onMounted,reactive,watch&#125; from &apos;vue&apos;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">      name: String,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    name: &apos;test&apos;,</span><br><span class=\"line\">    components: &#123;&#125;,</span><br><span class=\"line\">    setup(props,ctx) &#123;</span><br><span class=\"line\">      console.log(props.name)</span><br><span class=\"line\">      console.log(&apos;created&apos;)</span><br><span class=\"line\">      const data = reactive(&#123;</span><br><span class=\"line\">        a: 1</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      watch(</span><br><span class=\"line\">        () =&gt; data.a,</span><br><span class=\"line\">        (val, oldVal) =&gt; &#123;</span><br><span class=\"line\">          console.log(val)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      )</span><br><span class=\"line\">      onMounted(()=&gt;&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      const myMethod = (obj) =&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      retrun &#123;</span><br><span class=\"line\">          data,</span><br><span class=\"line\">          myMethod</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上所示可以看到，组合式API的代码逻辑都可以写在setup方法中，这使得逻辑更加集中，更加原子化，从而提示可维护性。</p>\n<h2 id=\"setup-方法\"><a href=\"#setup-方法\" class=\"headerlink\" title=\"setup 方法\"></a>setup 方法</h2><p>为了开始使用组合式 API，我们首先需要一个可以实际使用它的地方。在Vue 3的组件中，我们将此位置称为setup方法，如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;component-b user=&quot;John&quot; /&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">const componentB = &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    user: &#123;</span><br><span class=\"line\">      type: String,</span><br><span class=\"line\">      required: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  template:&apos;&lt;div&gt;&lt;/div&gt;&apos;,</span><br><span class=\"line\">  setup(props,context) &#123;</span><br><span class=\"line\">    console.log(props.user) // 打印&apos;John&apos;</span><br><span class=\"line\">    return &#123;&#125; // 这里返回的任何内容都可以用于组件的其余部分</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &apos;component-b&apos;: componentB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"setup方法参数\"><a href=\"#setup方法参数\" class=\"headerlink\" title=\"setup方法参数\"></a>setup方法参数</h3><p>setup方法中接收两个参数，第一个参数式props，它和之前讲解组件通信中的props一样，可以接收到父组件传递的数据，同样，如果props是一个动态值，那么它就是响应式的，会随着父组件的改变而更新。</p>\n<p>但是，因为props是响应式的，你不能使用ES6解构，它会消除prop的响应性。如果需要解构prop，可以在setup方法中使用toRefs函数来完成此操作，如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setup(props,context) &#123;</span><br><span class=\"line\">    const &#123; user &#125; = Vue.toRefs(props)</span><br><span class=\"line\">    console.log(user.value) // 打印&apos;John&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意，如果是采用npm来管理的项目，可以采用如下import方式引入toRefs，包括后续的Composition API相关的方法：</p>\n<p><code>import { toRefs } from &#39;vue&#39;</code></p>\n<p>如果user是可选的prop，则传入的props中可能没有user。在这种情况下，需要使用toRef替代它，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setup(props,context) &#123;</span><br><span class=\"line\">    const &#123; user &#125; = Vue.toRef(props,&apos;user&apos;)</span><br><span class=\"line\">    console.log(user.value) // 打印&apos;John&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>setup方法的第二个参数是context对象，context是一个普通的JavaScript对象，它暴露组件的三个属性，分别是attrs，slots，emit，并且由于是普通的JavaScript对象，可以之间采用ES6解构，如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;component-b attrone=&quot;one&quot; @emitcallback=&quot;emitcallback&quot;&gt;</span><br><span class=\"line\">    &lt;template v-slot:slotone&gt;</span><br><span class=\"line\">      &lt;span&gt;slot&lt;/span&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">  &lt;/component&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">const componentB = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  template:&apos;&lt;div&gt;&lt;/div&gt;&apos;,</span><br><span class=\"line\">  setup(props, &#123; attrs, slots, emit &#125;) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Attribute (非响应式对象)</span><br><span class=\"line\">    console.log(attrs) // 打印 &#123; attrone: &apos;one&apos; &#125; 相当于this.$attrs</span><br><span class=\"line\"></span><br><span class=\"line\">    // 插槽 (非响应式对象)</span><br><span class=\"line\">    console.log(slots.slotone) // 打印&#123; slotone: function()&#123;&#125; &#125; 相当于this.$slots</span><br><span class=\"line\"></span><br><span class=\"line\">    // 触发事件 (方法)</span><br><span class=\"line\">    console.log(emit) // 可调用emit(&apos;emitcallback&apos;)相当于this.$emit</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const vm = Vue.createApp(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &apos;component-b&apos;: componentB</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods:&#123;</span><br><span class=\"line\">    emitcallback()&#123;</span><br><span class=\"line\">      console.log(&apos;emitcallback&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>其中，attrs对象是父组件传递给子组件且不在props中定义的的静态数据，它是非响应式的，相当于在没有使用setup方法时之外调用的this.\\$attrs效果。</p>\n<p>slots对象主要是父组件传递的插槽内容，注意v-slot:slotone需要配置插槽名字，这样slots才能接收到，它是非响应式的，相当于在没有使用setup方法时之外调用的this.\\$slots效果。</p>\n<p>emit对象主要用来和父组件通信，相当于在没有使用setup方法时之外调用的this.\\$emit效果。</p>\n<h3 id=\"setup方法结合模板使用\"><a href=\"#setup方法结合模板使用\" class=\"headerlink\" title=\"setup方法结合模板使用\"></a>setup方法结合模板使用</h3><p>如果setup方法返回一个对象，那么该对象的属性以及传递给setup的props参数中的属性就都可以在模板template中访问到，如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;component-b user=&quot;John&quot; /&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">const componentB = &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    user: &#123;</span><br><span class=\"line\">      type: String,</span><br><span class=\"line\">      required: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  template:&apos;&lt;div&gt;&#123;&#123;user&#125;&#125; &#123;&#123;person.name&#125;&#125;&lt;/div&gt;&apos;,</span><br><span class=\"line\">  setup(props) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    const person = Vue.reactive(&#123; name: &apos;Son&apos; &#125;)</span><br><span class=\"line\">    // 暴露给 template</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        person</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &apos;component-b&apos;: componentB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>注意，props中的数据我们不必在setup中返回，Vue会自动的暴露给模板template中使用。</p>\n<h3 id=\"setup方法执行时机和getCurrentInstance方法\"><a href=\"#setup方法执行时机和getCurrentInstance方法\" class=\"headerlink\" title=\"setup方法执行时机和getCurrentInstance方法\"></a>setup方法执行时机和getCurrentInstance方法</h3><p>setup方法在组件的beforeCreate之前执行，此时由于组件还没有实例化，是无法之间像配置式API一样直接使用this.xx访问当前实例的上下文对象的，例如data，computed和methods都没法访问到，所以setup在和其它配置式API一起使用时可能会导致混淆，需要格外注意。</p>\n<p>但是，Vue在还是在Composition API中提供了getCurrentInstance方法来访问组件实例的上下文对象，如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    Vue.onMounted(()=&gt;&#123;</span><br><span class=\"line\">      const internalInstance = Vue.getCurrentInstance()</span><br><span class=\"line\">      internalInstance.ctx.add()// 打印&apos;methods add&apos;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods:&#123;</span><br><span class=\"line\">    add()&#123;</span><br><span class=\"line\">      console.log(&apos;methods add&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>需要注意的是请不要把它当作在像在配置式API中的this的替代方案来随意使用，另外getCurrentInstance只能在setup或生命周期钩子中调用，并且不建议在业务逻辑中使用该方法，可以一些开发第三方库中使用。</p>\n<h2 id=\"响应式类方法\"><a href=\"#响应式类方法\" class=\"headerlink\" title=\"响应式类方法\"></a>响应式类方法</h2><p>在配置式API中，我们一般将需要有响应式的变量定义在data选项的属性里面，而在Vue 3的Composition API的setup方法里面，由于还无法访问到data属性，但是也可以定义响应式变量，主要用到toRef，toRefs，ref，reactive和一些其他方法，其中有些我们之前代码中已经用到过了，下面就来详细介绍一下他们的用法和区别。</p>\n<h3 id=\"ref和reactive\"><a href=\"#ref和reactive\" class=\"headerlink\" title=\"ref和reactive\"></a>ref和reactive</h3><p>1. ref方法</p>\n<p>ref方法用于为数据添加响应式状态，可以支持基本的数据类型，也可以支持复杂的对象数据类型，是Vue 3中推荐的定义响应式数据的方法，也是最基本的响应式方法，需要注意的是：</p>\n<ul>\n<li><p>获取数据值的时候需要加.value。</p>\n</li>\n<li><p>ref的本质是原始数据的拷贝，改变简单类型数据的值不会同时改变原始数据。</p>\n</li>\n</ul>\n<p>使用方法如实例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;component-b  /&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">const componentB = &#123;</span><br><span class=\"line\">  template:&apos;&lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;&apos;,</span><br><span class=\"line\">  setup(props) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 为基本数据类型添加响应式状态</span><br><span class=\"line\">    const name = Vue.ref(&apos;John&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">    let obj = &#123;count : 0&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 为复杂数据类型添加响应式状态</span><br><span class=\"line\">    const state = Vue.ref(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(name.value) // 打印John</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(state.value.count)// 打印0</span><br><span class=\"line\"></span><br><span class=\"line\">    let newobj = Vue.ref(obj.count)</span><br><span class=\"line\"></span><br><span class=\"line\">    // 修改响应式数据不会影响原数据</span><br><span class=\"line\">    newobj.value = 1</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(obj.count)// 打印0</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &apos;component-b&apos;: componentB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，改变的这个数据必须是简单数据类型，一个具体的值，这样才不会影响到原始数据，如上面的代码中的obj.count。</p>\n<p>2. reactive方法</p>\n<p>ref方法用于为复杂数据添加响应式状态，只支持对象数据类型，需要注意的是：</p>\n<ul>\n<li><p>获取数据值的时候不需要加.value。</p>\n</li>\n<li><p>reactive的参数必须是一个对象，包括JSON数据和数组都可以，否则不具有响应式。</p>\n</li>\n<li><p>和ref一样，reactive的本质也是原始数据的拷贝。</p>\n</li>\n</ul>\n<p>ref本质也是reactive，ref(obj)等价于reactive({value:obj})，使用方法如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;component-b  /&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">const componentB = &#123;</span><br><span class=\"line\">  template:&apos;&lt;div&gt;&#123;&#123;state.count&#125;&#125;&lt;/div&gt;&apos;,</span><br><span class=\"line\">  setup(props) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 为复杂数据类型添加响应式状态</span><br><span class=\"line\">    const state = Vue.reactive(&#123;count : 0&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(state.count)// 打印0</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      state</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &apos;component-b&apos;: componentB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>reactive和ref都是用来定义响应式数据的。reactive更推荐去定义复杂的数据类型，不能直接解构，ref更推荐定义基本类型。ref可以简单地理解为是对reactive的二次包装，ref定义的数据访问的时候要多一个.value。</p>\n<h3 id=\"toRef和toRefs\"><a href=\"#toRef和toRefs\" class=\"headerlink\" title=\"toRef和toRefs\"></a>toRef和toRefs</h3><p>1. toRef方法</p>\n<p>toRef方法我们在之前的setup方法中对props的操作已经使用过了，其第一种使用场景用于为原响应式对象上的属性新建单个响应式ref，从而保持对其源对象属性的响应式连接。接收两个参数：原响应式对象和属性名，返回一个ref数据。例如使用父组件传递的props数据时，要引用props的某个属性且要保持响应式连接时就很有用，其第二种使用场景是，接收两个参数：原普通对象和属性名，此时可以对单个属性添加响应式ref，但是这个响应式ref的改变不会更新界面，需要注意的是：</p>\n<ul>\n<li><p>获取数据值的时候需要加.value。</p>\n</li>\n<li><p>toRef后的ref数据不是原始数据的拷贝，而是引用，改变结果数据的值也会同时改变原始数据。</p>\n</li>\n<li><p>对于原始普通数据来说，新增加的单个ref改变，数据会更新，但是界面不会自动更新。</p>\n</li>\n</ul>\n<p>使用方法如实例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;component-b user=&quot;John&quot; /&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">const componentB = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  template:&apos;&lt;div&gt;&#123;&#123;statecount.count&#125;&#125;&lt;/div&gt;&apos;,</span><br><span class=\"line\">  setup(props) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    const state = Vue.reactive(&#123;</span><br><span class=\"line\">      foo: 1,</span><br><span class=\"line\">      bar: 2</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    const fooRef = Vue.toRef(state, &apos;foo&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">    fooRef.value++</span><br><span class=\"line\">    console.log(state.foo) // 打印2会影响原始数据</span><br><span class=\"line\"></span><br><span class=\"line\">    state.foo++</span><br><span class=\"line\">    console.log(fooRef.value) // 打印3会影响fooRef数据</span><br><span class=\"line\"></span><br><span class=\"line\">    const statecount = &#123;// 普通数据</span><br><span class=\"line\">      count: 0,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const stateRef = Vue.toRef(statecount,&apos;count&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">      stateRef.value = 1 // 界面不会更新</span><br><span class=\"line\">      console.log(statecount.count) // 打印1 会影响原始数据</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      statecount,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &apos;component-b&apos;: componentB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>toRef更多的使用场景是对象添加单个响应式属性，而toRefs则是对完整的响应式对象进行转换。</p>\n<p>2. toRefs方法</p>\n<p>toRefs方法将原响应式对象转换为普通对象，其中结果对象的每个属性都是指向原始对象相应<br>属性的ref，另外一个重要使用场景是可以将reactive方法返回的复杂响应式数据ES6解构，需要注意的是：</p>\n<ul>\n<li><p>获取数据值的时候需要加.value。</p>\n</li>\n<li><p>toRefs后的ref数据不是原始数据的拷贝，而是引用，改变结果数据的值也会同时改变原始数据。</p>\n</li>\n<li><p>toRefs只接受响应式对象参数，不可接收普通对象参数，否则会警告。</p>\n</li>\n</ul>\n<p>使用方法如实例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;component-b  /&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">const componentB = &#123;</span><br><span class=\"line\">  template:&apos;&lt;div&gt;&#123;&#123;max&#125;&#125;,&#123;&#123;count&#125;&#125;&lt;/div&gt;&apos;,</span><br><span class=\"line\">  setup(props) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    let obj = &#123;</span><br><span class=\"line\">      count: 0,</span><br><span class=\"line\">      max: 100</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const statecount = Vue.reactive(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">    const &#123;count,max&#125; = Vue.toRefs(statecount) // 方便解构</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      statecount.max++</span><br><span class=\"line\">      console.log(obj.max) // 打印101 会影响原始数据，同时界面更新</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      count,</span><br><span class=\"line\">      max</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &apos;component-b&apos;: componentB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>目前用的最多的还是ref和reactive来创建响应式对象，使用toRefs来转换成可以方便使用的解构的对象。</p>\n<h3 id=\"其他响应式类方法\"><a href=\"#其他响应式类方法\" class=\"headerlink\" title=\"其他响应式类方法\"></a>其他响应式类方法</h3><ol>\n<li>shallowRef方法和shallowReactive方法triggerRef方法</li>\n</ol>\n<p>对于复杂对象而言，ref和reactive都属于递归嵌套监听，也就是数据的每一层都是响应式的，如果数据量比较大，非常消耗性能，shallowRef和shallowReactive则是非递归监听只会监听数据的第一层。如实例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;component-b /&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">const componentB = &#123;</span><br><span class=\"line\">  template:&apos;&lt;div&gt;&#123;&#123;shallow.person.name&#125;&#125;&lt;/div&gt;&apos;,</span><br><span class=\"line\">  setup(props) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    const shallow = Vue.shallowRef(&#123;</span><br><span class=\"line\">      greet: &apos;Hello, world&apos;,</span><br><span class=\"line\">      person:&#123;</span><br><span class=\"line\">        name:&apos;John&apos;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">      // 这不会触发更新，因为 ref 是浅层的</span><br><span class=\"line\">      shallow.value.person.name = &apos;Ted&apos; </span><br><span class=\"line\">      // 当调用triggerRef强制更新</span><br><span class=\"line\">      Vue.triggerRef(shallow)</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;shallow&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &apos;component-b&apos;: componentB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>triggerRef可以强制触发之前没有被监听到的更新，另外shallowReactive没有类似triggerRef的方法。</p>\n<ol>\n<li>readonly方法和shallowReadonly和isReadonly</li>\n</ol>\n<p>从字面意思上来理解，readonly表示只读可以将响应式对象标识成只读，当尝试修改时则会抛出警告，同样shallowReadonly方法设置第一层只读，isReadonly方法判断是否为只读对象，如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;component-b /&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">const componentB = &#123;</span><br><span class=\"line\">  template:&apos;&lt;div&gt;&lt;/div&gt;&apos;,</span><br><span class=\"line\">  setup(props) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    const obj = Vue.readonly(&#123; foo: &#123; bar: 1 &#125; &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(Vue.isReadonly(obj)) // true</span><br><span class=\"line\"></span><br><span class=\"line\">    obj.foo.bar = 2 // 失败警告：Set operation on key &quot;bar&quot; failed: target is readonly.</span><br><span class=\"line\">    const sobj = Vue.shallowReadonly(&#123; foo: &#123; bar: 1 &#125; &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    sobj.foo.bar = 2 // 第二层可以修改</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &apos;component-b&apos;: componentB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<ol>\n<li>isRef方法和isReactive方法和isProxy</li>\n</ol>\n<p>isRef方法判断是否是ref方法返回对象，isReactive方法判断是否是reactive方法返回对象，isProxy用于判断是否是reactive方法或者ref方法返回对象。</p>\n<ol>\n<li>toRaw方法和makeRaw方法</li>\n</ol>\n<p>toRaw方法可以返回一个响应式对象的原始普通对象，可用于临时读取数据而无需承担代理访问/跟踪的开销，也可用于写入数据而避免触发更改。</p>\n<p>makeRaw方法，可以标记并返回一个对象，使其永远不会成为响应式对象。如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;component-b /&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">const componentB = &#123;</span><br><span class=\"line\">  template:&apos;&lt;div&gt;&#123;&#123;reactivecobj.bar&#125;&#125;&lt;/div&gt;&apos;,</span><br><span class=\"line\">  setup(props) &#123;</span><br><span class=\"line\">    const obj = &#123; foo : 1&#125;</span><br><span class=\"line\">    const reactivecobj = Vue.reactive(obj)</span><br><span class=\"line\">    const rawobj = Vue.toRaw(reactivecobj)</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(obj === rawobj) // true</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">      rawobj.bar = 2 // 不会触发响应式更新</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\"></span><br><span class=\"line\">    const foo = &#123;a:1&#125; // foo无法通过reactive成为响应式对象</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(isReactive(reactive(foo))) // false</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;reactivecobj&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &apos;component-b&apos;: componentB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"监听类方法\"><a href=\"#监听类方法\" class=\"headerlink\" title=\"监听类方法\"></a>监听类方法</h2><p>之所以叫做监听（侦听）类方法，主要是这章我们介绍的方法其作用类似于配置式API中使用的watch方法，computed方法等等。监听类方法主要使用场景是提供对于响应式数据改变的追踪和影响，并提供一些钩子函数。本章我们主要介绍Composition API 中的computed和watch方法。</p>\n<h3 id=\"computed方法\"><a href=\"#computed方法\" class=\"headerlink\" title=\"computed方法\"></a>computed方法</h3><p>在配置式API中，computed是指计算属性，计算属性里可以完成各种复杂的逻辑，包括运算、函数调用等，只要最终返回一个结果就可以。计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。Composition API 中的computed也是类似的，使用方法如实例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &#123;&#123;info&#125;&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    const state = Vue.reactive(&#123;</span><br><span class=\"line\">      name: &quot;John&quot;,</span><br><span class=\"line\">      age: 18</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    const info = Vue.computed(() =&gt; &#123; // 创建一个计算属性，依赖name和age</span><br><span class=\"line\">      console.log(&apos;computed&apos;)</span><br><span class=\"line\">      return state.name + &apos;,&apos; + state.age</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    info.value = 1 // 抛出警告</span><br><span class=\"line\">setTimeout(()=&gt;&#123;</span><br><span class=\"line\">      state.age = 20 // info动态修改</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">      state.age = 20 // 第二次走缓存</span><br><span class=\"line\">    &#125;,2000)</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;info&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>上面代码中，计算属性info依赖state中的age和name，当他们发生变化时，会导致info变化，同时如果每次变化的值相同，则走缓存，不会再次执行computed里的方法，这和配置式API里的computed是一致的。同时info是也是一个不可变的响应式对象，尝试修改会抛出警告。</p>\n<p>computed方法也可以接收一个对象，分别配置get和set方法，这样返回的可被修改，对应调用set方法，如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const info = Vue.computed(&#123;</span><br><span class=\"line\">  get: () =&gt; state.name + &apos;,&apos; + state.age,</span><br><span class=\"line\">  set: val =&gt; &#123;</span><br><span class=\"line\">    state.age = val - 1</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">info.value = 21</span><br></pre></td></tr></table></figure>\n<p>12.5.3 watchEffect方法</p>\n<p>watchEffect方法可以显示的监听这些变化，参数是一个函数，这个函数里所依赖的响应式对象如果发生变化，都会触发到这个函数，如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &#123;&#123;info&#125;&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    const state = Vue.reactive(&#123;</span><br><span class=\"line\">      name: &quot;John&quot;,</span><br><span class=\"line\">      age: 18</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    const count = Vue.ref(0)</span><br><span class=\"line\">    const countNo = Vue.ref(0)</span><br><span class=\"line\">    const info = Vue.computed(() =&gt; &#123; // 创建一个计算属性，依赖name和age</span><br><span class=\"line\">      return state.name + &apos;,&apos; + state.age</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Vue.watchEffect(()=&gt;&#123;</span><br><span class=\"line\">      console.log(&apos;watchEffect&apos;)</span><br><span class=\"line\">      console.log(info.value) // 依赖了info</span><br><span class=\"line\">      console.log(count.value) // 依赖了count</span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">      state.age = 20 // 触发watchEffect</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">      count.value = 3 // 触发watchEffect</span><br><span class=\"line\">    &#125;,2000)</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">      countNo.value = 5 // 不触发watchEffect</span><br><span class=\"line\">    &#125;,3000)</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;info&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>当watchEffect在组件的setup方法或生命周期钩子被调用时，侦听器会被链接到该组件的生命周期，并在组件卸载时自动停止在，一些情况下，也可以显式调用返回值以停止侦听，如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const stop = watchEffect(() =&gt; &#123;</span><br><span class=\"line\">  /* ... */</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\">stop()</span><br></pre></td></tr></table></figure>\n<h3 id=\"watch方法\"><a href=\"#watch方法\" class=\"headerlink\" title=\"watch方法\"></a>watch方法</h3><p>在配置式API中，watch是指监听器，Composition<br>API中同样提供了watch方法，其使用场景和用法是一致的，主要是对响应式对象变化的监听。但是和watchEffect相比有些类似，主要区别是：</p>\n<ul>\n<li><p>watch需要侦听特定的数据源，并在回调函数中执行副作用。</p>\n</li>\n<li><p>默认情况下，它也是惰性的，即只有当被侦听的源发生变化时才执行回调。</p>\n</li>\n<li><p>可以访问侦听状态变化前后的值。</p>\n</li>\n</ul>\n<p>watch监听单个数据源，第一个参数可以是返回值的getter函数，也可以是一个响应式对象，第二个参数是触发变化的回调函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    // 侦听一个 getter</span><br><span class=\"line\">    const state = Vue.reactive(&#123; count: 0 &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    Vue.watch(() =&gt; state.count,</span><br><span class=\"line\">      (count, prevCount) =&gt; &#123;</span><br><span class=\"line\">        console.log(count, prevCount)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    // 直接侦听ref</span><br><span class=\"line\">    const count = Vue.ref(0)</span><br><span class=\"line\">    Vue.watch(count, (count, prevCount) =&gt; &#123;</span><br><span class=\"line\">      console.log(count, prevCount)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">      state.count = 1</span><br><span class=\"line\">      count.value = 2</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>watch监听多个数据源，第一个参数为多个响应式对象的数组，第二个参数是触发变化的回调函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    const state = Vue.reactive(&#123; name: &apos;John&apos; &#125;)</span><br><span class=\"line\">    const count = Vue.ref(0)</span><br><span class=\"line\"></span><br><span class=\"line\">    Vue.watch([count,state], (count, prevCount) =&gt; &#123;</span><br><span class=\"line\">      console.log(count, prevCount)</span><br><span class=\"line\">      // [2,&#123;name:&quot;Ted&quot;&#125;]   [0,&#123;name:&quot;John&quot;&#125;]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">      state.name = &apos;Ted&apos;</span><br><span class=\"line\">      count.value = 2</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>watch监听复杂响应式对象时，如果要完全深度监听，需要添加deep:true配置，同时第一个参数需要为一个<br>getter方法，同时采用深度复制，如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    const state = Vue.reactive(&#123;</span><br><span class=\"line\">      name: &quot;John&quot;,</span><br><span class=\"line\">      age: 18,</span><br><span class=\"line\">      attributes: &#123; </span><br><span class=\"line\">        attr: &apos;efg&apos;,</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.watch(()=&gt;JSON.parse(JSON.stringify(state)),// 利用深度复制</span><br><span class=\"line\">(currentState, prevState) =&gt; &#123;</span><br><span class=\"line\">        console.log(currentState.attributes.attr)// abc</span><br><span class=\"line\">        console.log(prevState.attributes.attr)// efg</span><br><span class=\"line\">      &#125;,&#123; deep: true &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">        state.attributes.attr = &apos;abc&apos;</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>需要注意，深度监听需要对原始state进行深度复制并返回，可以采用JSON.parse()，JSON.stringify()的方法进行复制，也可以采用一些第三方库，例如lodash.cloneDeep方法。</p>\n<h2 id=\"生命周期类方法\"><a href=\"#生命周期类方法\" class=\"headerlink\" title=\"生命周期类方法\"></a>生命周期类方法</h2><p>生命周期方法，通常叫做生命周期钩子，在配置式API中我们已经了解了具体的生命周期方法，在Composition API的setup方法里面同样有对应的生命周期方法，他们的对应关系如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beforeCreate -&gt; 使用 setup()</span><br><span class=\"line\"></span><br><span class=\"line\">created -&gt; 使用 setup()</span><br><span class=\"line\"></span><br><span class=\"line\">beforeMount -&gt; onBeforeMount</span><br><span class=\"line\"></span><br><span class=\"line\">mounted -&gt; onMounted</span><br><span class=\"line\"></span><br><span class=\"line\">beforeUpdate -&gt; onBeforeUpdate</span><br><span class=\"line\"></span><br><span class=\"line\">updated -&gt; onUpdated</span><br><span class=\"line\"></span><br><span class=\"line\">beforeUnmount -&gt; onBeforeUnmount</span><br><span class=\"line\"></span><br><span class=\"line\">unmounted -&gt; onUnmounted</span><br><span class=\"line\"></span><br><span class=\"line\">errorCaptured -&gt; onErrorCaptured</span><br><span class=\"line\"></span><br><span class=\"line\">renderTracked -&gt; onRenderTracked</span><br><span class=\"line\"></span><br><span class=\"line\">renderTriggered -&gt; onRenderTriggered</span><br><span class=\"line\"></span><br><span class=\"line\">activated -&gt; onActivated</span><br><span class=\"line\"></span><br><span class=\"line\">deactivated -&gt; onDeactivated</span><br></pre></td></tr></table></figure>\n<p>由于setup方法在组件的beforeCreate和created之前执行，所以不在提供对应的钩子方法，这些生命周期钩子注册函数只能在setup方法内同步使用，因为它们依赖于内部的全局状态来定位当前活动的实例<br>(此时正在调用其setup的组件实例)，在没有当前活动实例的情况下，调用它们将会出错。同时，在这些生命周期钩子内同步创建的侦听器和计算属性也会在组件卸载时自动删除，这点和配置式API式一致的。如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const MyComponent = &#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    Vue.onMounted(() =&gt; &#123;</span><br><span class=\"line\">      console.log(&apos;mounted!&apos;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    Vue.onUpdated(() =&gt; &#123;</span><br><span class=\"line\">      console.log(&apos;updated!&apos;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    Vue.onUnmounted(() =&gt; &#123;</span><br><span class=\"line\">      console.log(&apos;unmounted!&apos;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"methods方法\"><a href=\"#methods方法\" class=\"headerlink\" title=\"methods方法\"></a>methods方法</h2><p>除了上面所讲解的方法之外，还有一类就是使用最多的对应配置式API中的methods类方法了，这类方法主要结合模板template中的一些回调事件使用，如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &#123;&#123;count&#125;&#125;</span><br><span class=\"line\">  &lt;button @click=&quot;add&quot;&gt;点我+1&lt;/button&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    const count = Vue.ref(0)</span><br><span class=\"line\"></span><br><span class=\"line\">    const add = ()=&gt;&#123;</span><br><span class=\"line\">      count.value++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123; count,add &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>上面代码中，在setup方法中返回了add方法，这样在模板template中就可以进行绑定，当click事件触发时，会进入这个方法。</p>\n<p>当结合配置式API使用时，如果在组件的methods中也配置了同名的方法，那么会优先执行setup中定义的，methods中定义的方法将不会执行，如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    const count = Vue.ref(0)</span><br><span class=\"line\"></span><br><span class=\"line\">    const add = ()=&gt;&#123;</span><br><span class=\"line\">      count.value++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123; count,add &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods:&#123;</span><br><span class=\"line\">    add()&#123;&#125; // 不会触发</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>同样，在进行组件通信时，如果遇到同名的方法，优先以setup中定义并返回的方法为主，如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;component-b @add=&quot;add&quot;/&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">const componentB = &#123;</span><br><span class=\"line\">  template:&apos;&lt;div&gt;&lt;/div&gt;&apos;,</span><br><span class=\"line\">  setup(props,&#123;emit&#125;) &#123;</span><br><span class=\"line\">    emit(&apos;add&apos;) // 通知父组件</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &apos;component-b&apos;: componentB</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    const add = ()=&gt;&#123;</span><br><span class=\"line\">      console.log(&apos;setup add&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return &#123; add &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods:&#123;</span><br><span class=\"line\">    add()&#123;</span><br><span class=\"line\">      console.log(&apos;methods add&apos;) // 不会触发</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>上面代码中，当子组件调用emit通知父组件时，会调用父组件setup方法中的add方法，而不会调用methods中定义的。</p>\n<h2 id=\"Provide-Inject\"><a href=\"#Provide-Inject\" class=\"headerlink\" title=\"Provide / Inject\"></a>Provide / Inject</h2><p>provide（提供）和inject（注入）也可以在Composition API的setup方法里面使用，来实现跨越层级的组件通信。</p>\n<p>provide方法接受两个参数，第一个参数是提供数据的key，第二个参数是值value，可以是对象，方法等等，如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;component-b /&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &apos;component-b&apos;: componentB</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    Vue.provide(&apos;location&apos;, &apos;North Pole&apos;)</span><br><span class=\"line\">    Vue.provide(&apos;geolocation&apos;, &#123;</span><br><span class=\"line\">      longitude: 90,</span><br><span class=\"line\">      latitude: 135</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>inject方法接受两个参数，第一个参数是需要注入的数据的key，第二个参数是默认值（可选），如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const componentB = &#123;</span><br><span class=\"line\">  template:&apos;&lt;div&gt;&#123;&#123;userLocation&#125;&#125;&lt;/div&gt;&apos;,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    const userLocation = Vue.inject(&apos;location&apos;, &apos;The Universe&apos;)</span><br><span class=\"line\">    const userGeolocation = Vue.inject(&apos;geolocation&apos;)</span><br><span class=\"line\">    </span><br><span class=\"line\">console.log(userGeolocation)</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      userLocation,</span><br><span class=\"line\">      userGeolocation</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和之前配置式API不同的是，我们可以在provide值时使用ref或reactive方法，来增加provide值和inject值之间的响应性，这样，当provide的数据发生变化时，inject也能实时接收到。如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const componentB = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  template:&apos;&lt;div&gt;&#123;&#123;userLocation&#125;&#125;&lt;/div&gt;&apos;,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    const userLocation = Vue.inject(&apos;location&apos;, &apos;The Universe&apos;)</span><br><span class=\"line\">    const userGeolocation = Vue.inject(&apos;geolocation&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(userGeolocation)</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      userLocation,</span><br><span class=\"line\">      userGeolocation</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &apos;component-b&apos;: componentB</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    const location = Vue.ref(&apos;North Pole&apos;)</span><br><span class=\"line\">    const geolocation = Vue.reactive(&#123;</span><br><span class=\"line\">      longitude: 90,</span><br><span class=\"line\">      latitude: 135</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    Vue.provide(&apos;location&apos;, location)</span><br><span class=\"line\">    Vue.provide(&apos;geolocation&apos;, geolocation)</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">      location.value = &apos;China&apos;</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>通常情况下，只允许在provide的组件内去修改响应式的provide数据，但是如果需要在被inject里面修改provide的值，则需要provide一个回调方法，然后在被inject的组件内调用。如示例代码所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const componentB = &#123;</span><br><span class=\"line\">  template:&apos;&lt;div&gt;&#123;&#123;userLocation&#125;&#125;&lt;/div&gt;&apos;,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    const userLocation = Vue.inject(&apos;location&apos;, &apos;The Universe&apos;)</span><br><span class=\"line\">    const updateLocation = Vue.inject(&apos;updateLocation&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">      updateLocation(&apos;China&apos;)</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      userLocation,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &apos;component-b&apos;: componentB</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    const location = Vue.ref(&apos;North Pole&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">    const updateLocation = (v) =&gt; &#123;</span><br><span class=\"line\">      location.value = v</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Vue.provide(&apos;location&apos;, location)</span><br><span class=\"line\">    Vue.provide(&apos;updateLocation&apos;, updateLocation)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure>\n<p>最后，如果要确保通过provide传递的数据不会被inject的组件更改，可以使用readonly方法，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const location = Vue.ref(&apos;North Pole&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.provide(&apos;location&apos;, Vue.readonly(location))</span><br></pre></td></tr></table></figure>\n<h2 id=\"本章小结\"><a href=\"#本章小结\" class=\"headerlink\" title=\"本章小结\"></a>本章小结</h2><p>在本章中，讲解了Vue 3引入的Composition API相关知识，主要内容包括：Composition<br>API基础，setup方法，响应式类方法，监听类方法，生命周期类方法，methods方法，Provide和Inject。其中setup方法是Composition API的重点，所有相关Composition API新提供的接口都需要在setup中来使用，而响应式类方法中ref方法和reactive方法常被用来定义响应式对象，监听类方法中的computed方法和watch方法则提供了监听到响应式对象变化的时机，生命周期类方法基本和配置式API的使用类似，methods方法则需要注意同名的情况，最后Provide和Inject也是在setup方法中实现组件通信的重要工具。</p>\n<p>在后续的实战项目中，我们会大量的使用Composition API，所以学好本章内容非常重要。</p>\n<p>下面来检验一下读者对本章内容的掌握程度：</p>\n<ul>\n<li><p>setup方法中接受的两个参数，他们的作用分别是什么？Vue.js中父子组件如何通信？</p>\n</li>\n<li><p>如果需要定义基本类型数据为响应式，应该调用哪个方法。</p>\n</li>\n<li><p>watch和watchEffect的区别和各自的使用场景是什么？</p>\n</li>\n<li><p>如何在被inject的组件中修改provide的数据。</p>\n</li>\n<li><p>如果在模板中调用setup方法和配置式API中methods定义的方法同名会怎么样？</p>\n</li>\n</ul>"},{"title":"Vite与Vue Cli","date":"2021-11-22T09:26:17.000Z","_content":"\n\nVite和Vue Cli可以是师出同门，都属于Vue整个团队的产物，他们的功能也非常相似，都是一个提供基本项目脚手架和开发服务器的构建工具。那么在这里就有几个问题需要讨论：\n\n- Vite和Vue Cli的主要区别。\n- Vite和Vue Cli哪个性能更好。\n- 实际项目中如何选择。\n\n<!--more-->\n\n## Vite和Vue Cli的主要区别\n\nVite在开发环境下基于浏览器原生ES6 Modules提供功能支持，在生产环境下基于RollUp打包，Vue Cli不区分环境，都是基于Webpack。可以说在生产环境下，两者都是基于源码文件，RollUp和Webpack都是将代码进行处理，并提供出浏览器页面所需要的HTML，JavaScript，CSS，图片等静态文件。但是对于开发环境的处理，两者却有不同：\n\n- Vue Cli在开发环境下也是基于对源码文件的转换，即利用Webpack对代码打包，结合webpack-dev-server提供静态资源服务。\n\n- Vite在开发环境下基于浏览器原生ES6 Modules，无需对代码进行打包直接让浏览器使用。\n\nVite正是因为利用浏览器原生功能，而省略掉耗时的打包流程，才使得开发环境下体验非常快。而对于生产环境，他们各自所依赖的Webpack和RollUp这两个工具其实也各有优劣：\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9eddb1346e6b4390a0c723d5f9531ba9~tplv-k3u1fbpfcp-watermark.image?)\n- Webpack有着生态更加丰富的loader，可以处理各种各样的资源依赖，以及代码拆分(Code Splitting)和按需合并。RollUp的插件生态较Webpack弱一些，但是也可以满足基本的日常开发需要，且不能支持Code Splitting和热更新HMR。\n\n- RollUp对ES6 Modules的代码依赖方式天然支持，而对于类似CommonJS或者UMD方式的依赖却无法可靠的处理，Webpack借助于自己的__webpack_require__函数和Babel，对于各种类型代码都支持的比较好。\n\n- RollUp会静态分析代码中的import，并将排除任何未实际使用的代码即Tree Shaking支持很好，Webpack则从Webpack 2版本开始支持Tree Shaking，且要求使用原生的import和export语法并且不能被Babel转换过的代码。\n\n- RollUp编译的代码可读性更好（虽然基本不会去阅读这些代码），没有过多的冗余代码，而Webpack则会插入很多__webpack_require__函数影响代码的可读性。\n\n\n\n由于Webpack的支持性比较多，处理的场景更为广泛，而RollUp对源码的处理更加简洁，所以业界一般认为对于项目业务使用Webpack，对于类库使用RollUp，而之所以Vite使用RollUp，可能原因是整体上对浏览器ES6 Modules的使用，为了更加统一，并且摆脱Vue Cli那样对Webpack过于依赖吧。\n\n## Vite和Vue Cli哪个性能更好\n\n这个不用多说，必然是Vite的更快，在开发环境下体验更好。\n\nVue Cli的Webpack的工作方式是，它通过解析应用程序中的每一个JavaScript模块里面import或者require，借助各种loader将整个应用程序构建成一个基于JavaScript的捆绑包，并转换文件（例如Sass、.vue等）。这都是在webpack-dev-server服务器端提前完成的，文件越多，依赖越复杂，则消耗时间更多。\n\nVite不捆绑应用服务器端。相反，它依赖于浏览器对ES6 Modules的原生支持，浏览器直接通过HTTP请求JavaScript模块，并且在运行时处理，而对于例如Sass、.vue文件等则单独采用插件处理，并提供静态服务。这样耗时的大头JavaScript模块处理就被单独剥离了出来，利用浏览器高效处理，并且对于文件的多少，影响并不大，这样消耗的时间就更少。我们可以沿用之前章节中的图来总结这种模式区别，如图所示。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e1386bc85cf49139aa26cb8c5a12960~tplv-k3u1fbpfcp-watermark.image?)\n所以总结下来，在开发模式下，Vite显然要比Vue Cli性能强，生产模式下相差不大。\n## 实际项目中如何选择\n关于实际项目中如何选择Vite和Vue Cli，我们先来总结一下他们各自的优缺点，如下表格所示。\n\nVue Cli:\n\nVue Cli优点          | Vue Cli缺点 |\n| ------------------ | --------- |\n| 生态好，应用实际项目多        | 开发环境慢，体验差 |\n| 可以和Vue2.x，Vue3.x结合 | 只支持Vue    |\n| 直接解析各种类型代码依赖       | 产物冗余代码多   |\n| 构建配置项丰富，插件全\n\nVite:\n\nVite优点       | Vite缺点             |\n| ------------ | ------------------ |\n| 开发环境速度快，体验好  | 只针对ES6浏览器          |\n| 支持Vue，React等 | 脚手架不包括Vuex，Router等 |\n| 产物简洁清晰\n\nVite在开发环境下体验强，速度快是其核心优势，但是与Vue Cli/Webpack不同，Vite无法创建针对旧版浏览器，这对于一些用户来说是一个抉择点。另外，Vue Cli作为老牌构建工具，使用者众多，更加经得住实历史的考验，并且得益于使用者众多，所以在生态环境和插件数量方面更好。\n\nVite是一个新兴的产物，Vue团队更想把Vite做成一个通用的构建工具而不只限制于Vue，所以后面也会主推Vite，所以回到问题上来，Vue Cli和Vite到底怎么选笔者认为还是要根据自己实际的业务场景来，这里总结几条原则：\n\n\n- 当前已正在运行的Vue Cli项目，不建议切换Vite，维稳！\n\n- 企业大型项目，构建功能复杂需求多，建议Vue Cli，稳定坑少！\n\n- 小型项目，快应用，Vue3项目，建议Vite，体验好！\n\n \n\n以上原则仅供参考。\n\n\n\n\n\n","source":"_posts/Vite与Vue Cli.md","raw":"---\ntitle: Vite与Vue Cli\ndate: 2021-11-22 17:26:17\ntags:\n- Vite\n- Vue Cli\ncategories:\n- 1201\n\n---\n\n\nVite和Vue Cli可以是师出同门，都属于Vue整个团队的产物，他们的功能也非常相似，都是一个提供基本项目脚手架和开发服务器的构建工具。那么在这里就有几个问题需要讨论：\n\n- Vite和Vue Cli的主要区别。\n- Vite和Vue Cli哪个性能更好。\n- 实际项目中如何选择。\n\n<!--more-->\n\n## Vite和Vue Cli的主要区别\n\nVite在开发环境下基于浏览器原生ES6 Modules提供功能支持，在生产环境下基于RollUp打包，Vue Cli不区分环境，都是基于Webpack。可以说在生产环境下，两者都是基于源码文件，RollUp和Webpack都是将代码进行处理，并提供出浏览器页面所需要的HTML，JavaScript，CSS，图片等静态文件。但是对于开发环境的处理，两者却有不同：\n\n- Vue Cli在开发环境下也是基于对源码文件的转换，即利用Webpack对代码打包，结合webpack-dev-server提供静态资源服务。\n\n- Vite在开发环境下基于浏览器原生ES6 Modules，无需对代码进行打包直接让浏览器使用。\n\nVite正是因为利用浏览器原生功能，而省略掉耗时的打包流程，才使得开发环境下体验非常快。而对于生产环境，他们各自所依赖的Webpack和RollUp这两个工具其实也各有优劣：\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9eddb1346e6b4390a0c723d5f9531ba9~tplv-k3u1fbpfcp-watermark.image?)\n- Webpack有着生态更加丰富的loader，可以处理各种各样的资源依赖，以及代码拆分(Code Splitting)和按需合并。RollUp的插件生态较Webpack弱一些，但是也可以满足基本的日常开发需要，且不能支持Code Splitting和热更新HMR。\n\n- RollUp对ES6 Modules的代码依赖方式天然支持，而对于类似CommonJS或者UMD方式的依赖却无法可靠的处理，Webpack借助于自己的__webpack_require__函数和Babel，对于各种类型代码都支持的比较好。\n\n- RollUp会静态分析代码中的import，并将排除任何未实际使用的代码即Tree Shaking支持很好，Webpack则从Webpack 2版本开始支持Tree Shaking，且要求使用原生的import和export语法并且不能被Babel转换过的代码。\n\n- RollUp编译的代码可读性更好（虽然基本不会去阅读这些代码），没有过多的冗余代码，而Webpack则会插入很多__webpack_require__函数影响代码的可读性。\n\n\n\n由于Webpack的支持性比较多，处理的场景更为广泛，而RollUp对源码的处理更加简洁，所以业界一般认为对于项目业务使用Webpack，对于类库使用RollUp，而之所以Vite使用RollUp，可能原因是整体上对浏览器ES6 Modules的使用，为了更加统一，并且摆脱Vue Cli那样对Webpack过于依赖吧。\n\n## Vite和Vue Cli哪个性能更好\n\n这个不用多说，必然是Vite的更快，在开发环境下体验更好。\n\nVue Cli的Webpack的工作方式是，它通过解析应用程序中的每一个JavaScript模块里面import或者require，借助各种loader将整个应用程序构建成一个基于JavaScript的捆绑包，并转换文件（例如Sass、.vue等）。这都是在webpack-dev-server服务器端提前完成的，文件越多，依赖越复杂，则消耗时间更多。\n\nVite不捆绑应用服务器端。相反，它依赖于浏览器对ES6 Modules的原生支持，浏览器直接通过HTTP请求JavaScript模块，并且在运行时处理，而对于例如Sass、.vue文件等则单独采用插件处理，并提供静态服务。这样耗时的大头JavaScript模块处理就被单独剥离了出来，利用浏览器高效处理，并且对于文件的多少，影响并不大，这样消耗的时间就更少。我们可以沿用之前章节中的图来总结这种模式区别，如图所示。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e1386bc85cf49139aa26cb8c5a12960~tplv-k3u1fbpfcp-watermark.image?)\n所以总结下来，在开发模式下，Vite显然要比Vue Cli性能强，生产模式下相差不大。\n## 实际项目中如何选择\n关于实际项目中如何选择Vite和Vue Cli，我们先来总结一下他们各自的优缺点，如下表格所示。\n\nVue Cli:\n\nVue Cli优点          | Vue Cli缺点 |\n| ------------------ | --------- |\n| 生态好，应用实际项目多        | 开发环境慢，体验差 |\n| 可以和Vue2.x，Vue3.x结合 | 只支持Vue    |\n| 直接解析各种类型代码依赖       | 产物冗余代码多   |\n| 构建配置项丰富，插件全\n\nVite:\n\nVite优点       | Vite缺点             |\n| ------------ | ------------------ |\n| 开发环境速度快，体验好  | 只针对ES6浏览器          |\n| 支持Vue，React等 | 脚手架不包括Vuex，Router等 |\n| 产物简洁清晰\n\nVite在开发环境下体验强，速度快是其核心优势，但是与Vue Cli/Webpack不同，Vite无法创建针对旧版浏览器，这对于一些用户来说是一个抉择点。另外，Vue Cli作为老牌构建工具，使用者众多，更加经得住实历史的考验，并且得益于使用者众多，所以在生态环境和插件数量方面更好。\n\nVite是一个新兴的产物，Vue团队更想把Vite做成一个通用的构建工具而不只限制于Vue，所以后面也会主推Vite，所以回到问题上来，Vue Cli和Vite到底怎么选笔者认为还是要根据自己实际的业务场景来，这里总结几条原则：\n\n\n- 当前已正在运行的Vue Cli项目，不建议切换Vite，维稳！\n\n- 企业大型项目，构建功能复杂需求多，建议Vue Cli，稳定坑少！\n\n- 小型项目，快应用，Vue3项目，建议Vite，体验好！\n\n \n\n以上原则仅供参考。\n\n\n\n\n\n","slug":"Vite与Vue Cli","published":1,"updated":"2021-12-13T01:32:28.250Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434q0a001f2wvjnjr6344m","content":"<p>Vite和Vue Cli可以是师出同门，都属于Vue整个团队的产物，他们的功能也非常相似，都是一个提供基本项目脚手架和开发服务器的构建工具。那么在这里就有几个问题需要讨论：</p>\n<ul>\n<li>Vite和Vue Cli的主要区别。</li>\n<li>Vite和Vue Cli哪个性能更好。</li>\n<li>实际项目中如何选择。</li>\n</ul>\n<a id=\"more\"></a>\n<h2><span id=\"vite和vue-cli的主要区别\">Vite和Vue Cli的主要区别</span></h2><p>Vite在开发环境下基于浏览器原生ES6 Modules提供功能支持，在生产环境下基于RollUp打包，Vue Cli不区分环境，都是基于Webpack。可以说在生产环境下，两者都是基于源码文件，RollUp和Webpack都是将代码进行处理，并提供出浏览器页面所需要的HTML，JavaScript，CSS，图片等静态文件。但是对于开发环境的处理，两者却有不同：</p>\n<ul>\n<li><p>Vue Cli在开发环境下也是基于对源码文件的转换，即利用Webpack对代码打包，结合webpack-dev-server提供静态资源服务。</p>\n</li>\n<li><p>Vite在开发环境下基于浏览器原生ES6 Modules，无需对代码进行打包直接让浏览器使用。</p>\n</li>\n</ul>\n<p>Vite正是因为利用浏览器原生功能，而省略掉耗时的打包流程，才使得开发环境下体验非常快。而对于生产环境，他们各自所依赖的Webpack和RollUp这两个工具其实也各有优劣：<br><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9eddb1346e6b4390a0c723d5f9531ba9~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<ul>\n<li><p>Webpack有着生态更加丰富的loader，可以处理各种各样的资源依赖，以及代码拆分(Code Splitting)和按需合并。RollUp的插件生态较Webpack弱一些，但是也可以满足基本的日常开发需要，且不能支持Code Splitting和热更新HMR。</p>\n</li>\n<li><p>RollUp对ES6 Modules的代码依赖方式天然支持，而对于类似CommonJS或者UMD方式的依赖却无法可靠的处理，Webpack借助于自己的<strong>webpack_require</strong>函数和Babel，对于各种类型代码都支持的比较好。</p>\n</li>\n<li><p>RollUp会静态分析代码中的import，并将排除任何未实际使用的代码即Tree Shaking支持很好，Webpack则从Webpack 2版本开始支持Tree Shaking，且要求使用原生的import和export语法并且不能被Babel转换过的代码。</p>\n</li>\n<li><p>RollUp编译的代码可读性更好（虽然基本不会去阅读这些代码），没有过多的冗余代码，而Webpack则会插入很多<strong>webpack_require</strong>函数影响代码的可读性。</p>\n</li>\n</ul>\n<p>由于Webpack的支持性比较多，处理的场景更为广泛，而RollUp对源码的处理更加简洁，所以业界一般认为对于项目业务使用Webpack，对于类库使用RollUp，而之所以Vite使用RollUp，可能原因是整体上对浏览器ES6 Modules的使用，为了更加统一，并且摆脱Vue Cli那样对Webpack过于依赖吧。</p>\n<h2><span id=\"vite和vue-cli哪个性能更好\">Vite和Vue Cli哪个性能更好</span></h2><p>这个不用多说，必然是Vite的更快，在开发环境下体验更好。</p>\n<p>Vue Cli的Webpack的工作方式是，它通过解析应用程序中的每一个JavaScript模块里面import或者require，借助各种loader将整个应用程序构建成一个基于JavaScript的捆绑包，并转换文件（例如Sass、.vue等）。这都是在webpack-dev-server服务器端提前完成的，文件越多，依赖越复杂，则消耗时间更多。</p>\n<p>Vite不捆绑应用服务器端。相反，它依赖于浏览器对ES6 Modules的原生支持，浏览器直接通过HTTP请求JavaScript模块，并且在运行时处理，而对于例如Sass、.vue文件等则单独采用插件处理，并提供静态服务。这样耗时的大头JavaScript模块处理就被单独剥离了出来，利用浏览器高效处理，并且对于文件的多少，影响并不大，这样消耗的时间就更少。我们可以沿用之前章节中的图来总结这种模式区别，如图所示。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e1386bc85cf49139aa26cb8c5a12960~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"><br>所以总结下来，在开发模式下，Vite显然要比Vue Cli性能强，生产模式下相差不大。</p>\n<h2><span id=\"实际项目中如何选择\">实际项目中如何选择</span></h2><p>关于实际项目中如何选择Vite和Vue Cli，我们先来总结一下他们各自的优缺点，如下表格所示。</p>\n<p>Vue Cli:</p>\n<p>Vue Cli优点          | Vue Cli缺点 |<br>| —————— | ——— |<br>| 生态好，应用实际项目多        | 开发环境慢，体验差 |<br>| 可以和Vue2.x，Vue3.x结合 | 只支持Vue    |<br>| 直接解析各种类型代码依赖       | 产物冗余代码多   |<br>| 构建配置项丰富，插件全</p>\n<p>Vite:</p>\n<p>Vite优点       | Vite缺点             |<br>| ———— | —————— |<br>| 开发环境速度快，体验好  | 只针对ES6浏览器          |<br>| 支持Vue，React等 | 脚手架不包括Vuex，Router等 |<br>| 产物简洁清晰</p>\n<p>Vite在开发环境下体验强，速度快是其核心优势，但是与Vue Cli/Webpack不同，Vite无法创建针对旧版浏览器，这对于一些用户来说是一个抉择点。另外，Vue Cli作为老牌构建工具，使用者众多，更加经得住实历史的考验，并且得益于使用者众多，所以在生态环境和插件数量方面更好。</p>\n<p>Vite是一个新兴的产物，Vue团队更想把Vite做成一个通用的构建工具而不只限制于Vue，所以后面也会主推Vite，所以回到问题上来，Vue Cli和Vite到底怎么选笔者认为还是要根据自己实际的业务场景来，这里总结几条原则：</p>\n<ul>\n<li><p>当前已正在运行的Vue Cli项目，不建议切换Vite，维稳！</p>\n</li>\n<li><p>企业大型项目，构建功能复杂需求多，建议Vue Cli，稳定坑少！</p>\n</li>\n<li><p>小型项目，快应用，Vue3项目，建议Vite，体验好！</p>\n</li>\n</ul>\n<p>以上原则仅供参考。</p>\n","site":{"data":{}},"excerpt":"<p>Vite和Vue Cli可以是师出同门，都属于Vue整个团队的产物，他们的功能也非常相似，都是一个提供基本项目脚手架和开发服务器的构建工具。那么在这里就有几个问题需要讨论：</p>\n<ul>\n<li>Vite和Vue Cli的主要区别。</li>\n<li>Vite和Vue Cli哪个性能更好。</li>\n<li>实际项目中如何选择。</li>\n</ul>","more":"<h2 id=\"Vite和Vue-Cli的主要区别\"><a href=\"#Vite和Vue-Cli的主要区别\" class=\"headerlink\" title=\"Vite和Vue Cli的主要区别\"></a>Vite和Vue Cli的主要区别</h2><p>Vite在开发环境下基于浏览器原生ES6 Modules提供功能支持，在生产环境下基于RollUp打包，Vue Cli不区分环境，都是基于Webpack。可以说在生产环境下，两者都是基于源码文件，RollUp和Webpack都是将代码进行处理，并提供出浏览器页面所需要的HTML，JavaScript，CSS，图片等静态文件。但是对于开发环境的处理，两者却有不同：</p>\n<ul>\n<li><p>Vue Cli在开发环境下也是基于对源码文件的转换，即利用Webpack对代码打包，结合webpack-dev-server提供静态资源服务。</p>\n</li>\n<li><p>Vite在开发环境下基于浏览器原生ES6 Modules，无需对代码进行打包直接让浏览器使用。</p>\n</li>\n</ul>\n<p>Vite正是因为利用浏览器原生功能，而省略掉耗时的打包流程，才使得开发环境下体验非常快。而对于生产环境，他们各自所依赖的Webpack和RollUp这两个工具其实也各有优劣：<br><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9eddb1346e6b4390a0c723d5f9531ba9~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<ul>\n<li><p>Webpack有着生态更加丰富的loader，可以处理各种各样的资源依赖，以及代码拆分(Code Splitting)和按需合并。RollUp的插件生态较Webpack弱一些，但是也可以满足基本的日常开发需要，且不能支持Code Splitting和热更新HMR。</p>\n</li>\n<li><p>RollUp对ES6 Modules的代码依赖方式天然支持，而对于类似CommonJS或者UMD方式的依赖却无法可靠的处理，Webpack借助于自己的<strong>webpack_require</strong>函数和Babel，对于各种类型代码都支持的比较好。</p>\n</li>\n<li><p>RollUp会静态分析代码中的import，并将排除任何未实际使用的代码即Tree Shaking支持很好，Webpack则从Webpack 2版本开始支持Tree Shaking，且要求使用原生的import和export语法并且不能被Babel转换过的代码。</p>\n</li>\n<li><p>RollUp编译的代码可读性更好（虽然基本不会去阅读这些代码），没有过多的冗余代码，而Webpack则会插入很多<strong>webpack_require</strong>函数影响代码的可读性。</p>\n</li>\n</ul>\n<p>由于Webpack的支持性比较多，处理的场景更为广泛，而RollUp对源码的处理更加简洁，所以业界一般认为对于项目业务使用Webpack，对于类库使用RollUp，而之所以Vite使用RollUp，可能原因是整体上对浏览器ES6 Modules的使用，为了更加统一，并且摆脱Vue Cli那样对Webpack过于依赖吧。</p>\n<h2 id=\"Vite和Vue-Cli哪个性能更好\"><a href=\"#Vite和Vue-Cli哪个性能更好\" class=\"headerlink\" title=\"Vite和Vue Cli哪个性能更好\"></a>Vite和Vue Cli哪个性能更好</h2><p>这个不用多说，必然是Vite的更快，在开发环境下体验更好。</p>\n<p>Vue Cli的Webpack的工作方式是，它通过解析应用程序中的每一个JavaScript模块里面import或者require，借助各种loader将整个应用程序构建成一个基于JavaScript的捆绑包，并转换文件（例如Sass、.vue等）。这都是在webpack-dev-server服务器端提前完成的，文件越多，依赖越复杂，则消耗时间更多。</p>\n<p>Vite不捆绑应用服务器端。相反，它依赖于浏览器对ES6 Modules的原生支持，浏览器直接通过HTTP请求JavaScript模块，并且在运行时处理，而对于例如Sass、.vue文件等则单独采用插件处理，并提供静态服务。这样耗时的大头JavaScript模块处理就被单独剥离了出来，利用浏览器高效处理，并且对于文件的多少，影响并不大，这样消耗的时间就更少。我们可以沿用之前章节中的图来总结这种模式区别，如图所示。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e1386bc85cf49139aa26cb8c5a12960~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"><br>所以总结下来，在开发模式下，Vite显然要比Vue Cli性能强，生产模式下相差不大。</p>\n<h2 id=\"实际项目中如何选择\"><a href=\"#实际项目中如何选择\" class=\"headerlink\" title=\"实际项目中如何选择\"></a>实际项目中如何选择</h2><p>关于实际项目中如何选择Vite和Vue Cli，我们先来总结一下他们各自的优缺点，如下表格所示。</p>\n<p>Vue Cli:</p>\n<p>Vue Cli优点          | Vue Cli缺点 |<br>| —————— | ——— |<br>| 生态好，应用实际项目多        | 开发环境慢，体验差 |<br>| 可以和Vue2.x，Vue3.x结合 | 只支持Vue    |<br>| 直接解析各种类型代码依赖       | 产物冗余代码多   |<br>| 构建配置项丰富，插件全</p>\n<p>Vite:</p>\n<p>Vite优点       | Vite缺点             |<br>| ———— | —————— |<br>| 开发环境速度快，体验好  | 只针对ES6浏览器          |<br>| 支持Vue，React等 | 脚手架不包括Vuex，Router等 |<br>| 产物简洁清晰</p>\n<p>Vite在开发环境下体验强，速度快是其核心优势，但是与Vue Cli/Webpack不同，Vite无法创建针对旧版浏览器，这对于一些用户来说是一个抉择点。另外，Vue Cli作为老牌构建工具，使用者众多，更加经得住实历史的考验，并且得益于使用者众多，所以在生态环境和插件数量方面更好。</p>\n<p>Vite是一个新兴的产物，Vue团队更想把Vite做成一个通用的构建工具而不只限制于Vue，所以后面也会主推Vite，所以回到问题上来，Vue Cli和Vite到底怎么选笔者认为还是要根据自己实际的业务场景来，这里总结几条原则：</p>\n<ul>\n<li><p>当前已正在运行的Vue Cli项目，不建议切换Vite，维稳！</p>\n</li>\n<li><p>企业大型项目，构建功能复杂需求多，建议Vue Cli，稳定坑少！</p>\n</li>\n<li><p>小型项目，快应用，Vue3项目，建议Vite，体验好！</p>\n</li>\n</ul>\n<p>以上原则仅供参考。</p>"},{"title":"Vue3.0--Vue Composition API使用体验","date":"2020-05-22T09:26:17.000Z","photos":["https://pic3.zhimg.com/v2-74bf1c42b3eed22bb78c4a72eb1399c6_1440w.jpg?source=172ae18b"],"_content":"\nVue3.0目前已经出了beta版本,并在github上进行了开源，叫做[vue-next](https://github.com/vuejs/vue-next)，本文将之前采用Vue2.6开发的todoList小项目改造成为Vue3.0编写，并介绍一下2.x和3.x之间写法的不同之处。\n\n[点击体验](https://www.nihaoshijie.com.cn/mypro/vue3todo/index.html)\nGithub地址：[Vue.js2.6版本todoList](https://github.com/lvming6816077/vue-todo/)，[Vue.js3.0版本todoList](https://github.com/lvming6816077/vue3todo/)\n<!--more-->\n\nVue3.x适配大部分Vue2.x的组件配置，也就是说以前我们在Vue2.x针对组件的一些配置项，例如：\n```\nexport default {\n  name: 'test',\n  components: {},\n  props: {},\n  data () {\n    return {}\n  },\n  created(){},\n  mounted () {},\n  watch:{},\n  methods: {}\n}\n```\n在Vue3.x中也是可以适配的，对应的相关生命周期方法也可正常执行，但是Vue3.x的一大核心是引入了[Vue Composition API](https://composition-api.vuejs.org/zh/api.html)（组合式API）,这使得组件的大部分内容都可以通过`setup()`方法进行配置，同时Vue Composition API在Vue2.x也可以使用，需要通过安装@vue/composition-api来使用：\n```javascript\nnpm install @vue/composition-api\n...\nimport VueCompositionApi from '@vue/composition-api';\n\nVue.use(VueCompositionApi);\n```\n下面主要介绍一下采用Vue Composition API来改造采用2.x开发的todoList项目时的新老代码对比。\n\n### 如何创建一个Vue3.0的项目\n首先，安装vue cli的最新版本，一般是vue cli 4，安装成功后，调用：\n```bash\nvue create myapp\n```\n创建一个基于Vue2.x的项目，然后进入项目的根目录，执行：\n```bash\nvue add vue-next\n```\n然后就会自动安装[vue-cli-plugin-vue-next](https://github.com/vuejs/vue-cli-plugin-vue-next)插件，完毕之后，myapp项目就会变成一个基于Vue3.0Beta版本的项目框架。\n\n### 根实例初始化:\n在2.x中通过`new Vue()`的方法来初始化：\n```javascript\nimport App from './App.vue'\nnew Vue({\n  store,\n  render: h => h(App)\n}).$mount('#app')\n```\n在3.x中Vue不再是一个构造函数，通过createApp方法初始化：\n```javascript\nimport App from './App.vue'\ncreateApp(App).use(store).mount('#app')\n```\n\n\n### ref或者reactive代替data中的变量:\n在2.x中通过组件data的方法来定义一些当前组件的数据：\n```javascript\n...\ndata() {\n  return {\n    name: 'test',\n    list: [],\n  }\n},\n...\n```\n在3.x中通过ref或者reactive创建响应式对象：\n```javascript\nimport {ref,reactive} from 'vue'\n...\nsetup(){\n  const name = ref('test')\n  const state = reactive({\n    list: []\n  })\n  return {\n      name,\n      state\n  }\n}\n...\n```\nref将给定的值创建一个响应式的数据对象并赋值初始值（int或者string），reactive可以直接定义复杂响应式对象。\n### methods中定义的方法也可以写在setup()中:\n在2.x中methods来定义一些当前组件内部方法：\n```javascript\n...\nmethods: {\n  fetchData() {\n    \n  },\n}\n...\n```\n在3.x中直接在setup方法中定义并return：\n```javascript\n...\nsetup(){\n  const fetchData = ()=>{\n      console.log('fetchData')\n  }\n\n  return {\n      fetchData\n  }\n}\n...\n```\n### 无法使用EventBus:\n在2.x中通过EventBus的方法来实现组件通信：\n```javascript\nvar EventBus = new Vue()\nVue.prototype.$EventBus = EventBus\n...\nthis.$EventBus.$on()  this.$EventBus.$emit()\n```\n\n在3.x中移除了`$on, $off`等方法（参考[rfc](https://github.com/vuejs/rfcs/blob/master/active-rfcs/0020-events-api-change.md)），而是推荐使用[mitt](https://github.com/developit/mitt#examples--demos)方案来代替：\n```javascript\nimport mitt from 'mitt'\nconst emitter = mitt()\n// listen to an event\nemitter.on('foo', e => console.log('foo', e) )\n// fire an event\nemitter.emit('foo', { a: 'b' })\n```\n由于3.x中不再支持prototype的方式设置全局方法，可以通过`app.config.globalProperties.mitt = () => {}`方案。\n### setup()中使用props和this:\n在2.x中，组件的方法中可以通过this获取到当前组件的实例，并执行data变量的修改，方法的调用，组件的通信等等，但是在3.x中，setup()在beforeCreate和created时机就已调用，无法使用和2.x一样的this，但是可以通过接收`setup(props,ctx)`的方法，获取到当前组件的实例和props：\n```javascript\nexport default {\n  props: {\n    name: String,\n  },\n  setup(props,ctx) {\n    console.log(props.name)\n    ctx.emit('event')\n  },\n}\n```\n注意ctx和2.x中this并不完全一样，而是选择性地暴露了一些property，主要有`[attrs,emit,slots]`。\n### watch来监听对象改变\n2.x中，可以采用watch来监听一个对象属性是否有改动：\n```javascript\n...\ndata(){\n  return {\n    name: 'a'  \n  }\n},\nwatch: {\n  name(val) {\n    console.log(val)\n  }\n}\n...\n```\n3.x中，在setup()中，可以使用watch来监听：\n```javascript\n...\nimport {watch} from 'vue'\nsetup(){\n  let state = reactive({\n    name: 'a'\n  })\n  watch(\n    () => state.name,\n    (val, oldVal) => {\n      console.log(val)\n    }\n  )\n  state.name = 'b'\n  return {\n      state\n  }\n}\n...\n```\n在3.x中，如果watch的是一个数组array对象，那么如果调用array.push()方法添加一条数据，并不会触发watch方法，必须重新给array赋值：\n```javascript\n let state = reactive({\n    list: []\n })\n watch(\n    () => state.list,\n    (val, oldVal) => {\n      console.log(val)\n    }\n  )\n  \n  state.list.push(1) // 不会触发watch\n  \n  state.list = [1] // 会触发watch\n```\n此问题不知是否是Vue3.x特意加上的，有待正式版出来后在验证。\n\n### computed计算属性：\n2.x中：\n```javascript\n...\ncomputed: {\n    storeData () {\n      return this.$store.state.storeData\n    },\n},\n...\n```\n3.x中：\n```javascript\n...\nimport {computed} from 'vue'\nsetup(){\n  const storeData = computed(() => store.state.storeData)\n\n  return {\n      storeData\n  }\n}\n...\n```\n\n当然，对于完整的Vue Composition API，各位同学可以参考[文档](https://composition-api.vuejs.org/zh/api.html)。就目前来说Vue3.0还并没有发布正式版，所以很多用法和实现方式可能还是未知数，但是对于新版本提供的编码方式的新思路，还是很期待的。\n\n\n","source":"_posts/Vue3.0--Vue Composition API使用体验.md","raw":"---\ntitle: Vue3.0--Vue Composition API使用体验\ndate: 2020-05-22 17:26:17\ntags:\n- Vue3\n- Vue.js\ncategories:\n- 1210\nphotos: https://pic3.zhimg.com/v2-74bf1c42b3eed22bb78c4a72eb1399c6_1440w.jpg?source=172ae18b\n---\n\nVue3.0目前已经出了beta版本,并在github上进行了开源，叫做[vue-next](https://github.com/vuejs/vue-next)，本文将之前采用Vue2.6开发的todoList小项目改造成为Vue3.0编写，并介绍一下2.x和3.x之间写法的不同之处。\n\n[点击体验](https://www.nihaoshijie.com.cn/mypro/vue3todo/index.html)\nGithub地址：[Vue.js2.6版本todoList](https://github.com/lvming6816077/vue-todo/)，[Vue.js3.0版本todoList](https://github.com/lvming6816077/vue3todo/)\n<!--more-->\n\nVue3.x适配大部分Vue2.x的组件配置，也就是说以前我们在Vue2.x针对组件的一些配置项，例如：\n```\nexport default {\n  name: 'test',\n  components: {},\n  props: {},\n  data () {\n    return {}\n  },\n  created(){},\n  mounted () {},\n  watch:{},\n  methods: {}\n}\n```\n在Vue3.x中也是可以适配的，对应的相关生命周期方法也可正常执行，但是Vue3.x的一大核心是引入了[Vue Composition API](https://composition-api.vuejs.org/zh/api.html)（组合式API）,这使得组件的大部分内容都可以通过`setup()`方法进行配置，同时Vue Composition API在Vue2.x也可以使用，需要通过安装@vue/composition-api来使用：\n```javascript\nnpm install @vue/composition-api\n...\nimport VueCompositionApi from '@vue/composition-api';\n\nVue.use(VueCompositionApi);\n```\n下面主要介绍一下采用Vue Composition API来改造采用2.x开发的todoList项目时的新老代码对比。\n\n### 如何创建一个Vue3.0的项目\n首先，安装vue cli的最新版本，一般是vue cli 4，安装成功后，调用：\n```bash\nvue create myapp\n```\n创建一个基于Vue2.x的项目，然后进入项目的根目录，执行：\n```bash\nvue add vue-next\n```\n然后就会自动安装[vue-cli-plugin-vue-next](https://github.com/vuejs/vue-cli-plugin-vue-next)插件，完毕之后，myapp项目就会变成一个基于Vue3.0Beta版本的项目框架。\n\n### 根实例初始化:\n在2.x中通过`new Vue()`的方法来初始化：\n```javascript\nimport App from './App.vue'\nnew Vue({\n  store,\n  render: h => h(App)\n}).$mount('#app')\n```\n在3.x中Vue不再是一个构造函数，通过createApp方法初始化：\n```javascript\nimport App from './App.vue'\ncreateApp(App).use(store).mount('#app')\n```\n\n\n### ref或者reactive代替data中的变量:\n在2.x中通过组件data的方法来定义一些当前组件的数据：\n```javascript\n...\ndata() {\n  return {\n    name: 'test',\n    list: [],\n  }\n},\n...\n```\n在3.x中通过ref或者reactive创建响应式对象：\n```javascript\nimport {ref,reactive} from 'vue'\n...\nsetup(){\n  const name = ref('test')\n  const state = reactive({\n    list: []\n  })\n  return {\n      name,\n      state\n  }\n}\n...\n```\nref将给定的值创建一个响应式的数据对象并赋值初始值（int或者string），reactive可以直接定义复杂响应式对象。\n### methods中定义的方法也可以写在setup()中:\n在2.x中methods来定义一些当前组件内部方法：\n```javascript\n...\nmethods: {\n  fetchData() {\n    \n  },\n}\n...\n```\n在3.x中直接在setup方法中定义并return：\n```javascript\n...\nsetup(){\n  const fetchData = ()=>{\n      console.log('fetchData')\n  }\n\n  return {\n      fetchData\n  }\n}\n...\n```\n### 无法使用EventBus:\n在2.x中通过EventBus的方法来实现组件通信：\n```javascript\nvar EventBus = new Vue()\nVue.prototype.$EventBus = EventBus\n...\nthis.$EventBus.$on()  this.$EventBus.$emit()\n```\n\n在3.x中移除了`$on, $off`等方法（参考[rfc](https://github.com/vuejs/rfcs/blob/master/active-rfcs/0020-events-api-change.md)），而是推荐使用[mitt](https://github.com/developit/mitt#examples--demos)方案来代替：\n```javascript\nimport mitt from 'mitt'\nconst emitter = mitt()\n// listen to an event\nemitter.on('foo', e => console.log('foo', e) )\n// fire an event\nemitter.emit('foo', { a: 'b' })\n```\n由于3.x中不再支持prototype的方式设置全局方法，可以通过`app.config.globalProperties.mitt = () => {}`方案。\n### setup()中使用props和this:\n在2.x中，组件的方法中可以通过this获取到当前组件的实例，并执行data变量的修改，方法的调用，组件的通信等等，但是在3.x中，setup()在beforeCreate和created时机就已调用，无法使用和2.x一样的this，但是可以通过接收`setup(props,ctx)`的方法，获取到当前组件的实例和props：\n```javascript\nexport default {\n  props: {\n    name: String,\n  },\n  setup(props,ctx) {\n    console.log(props.name)\n    ctx.emit('event')\n  },\n}\n```\n注意ctx和2.x中this并不完全一样，而是选择性地暴露了一些property，主要有`[attrs,emit,slots]`。\n### watch来监听对象改变\n2.x中，可以采用watch来监听一个对象属性是否有改动：\n```javascript\n...\ndata(){\n  return {\n    name: 'a'  \n  }\n},\nwatch: {\n  name(val) {\n    console.log(val)\n  }\n}\n...\n```\n3.x中，在setup()中，可以使用watch来监听：\n```javascript\n...\nimport {watch} from 'vue'\nsetup(){\n  let state = reactive({\n    name: 'a'\n  })\n  watch(\n    () => state.name,\n    (val, oldVal) => {\n      console.log(val)\n    }\n  )\n  state.name = 'b'\n  return {\n      state\n  }\n}\n...\n```\n在3.x中，如果watch的是一个数组array对象，那么如果调用array.push()方法添加一条数据，并不会触发watch方法，必须重新给array赋值：\n```javascript\n let state = reactive({\n    list: []\n })\n watch(\n    () => state.list,\n    (val, oldVal) => {\n      console.log(val)\n    }\n  )\n  \n  state.list.push(1) // 不会触发watch\n  \n  state.list = [1] // 会触发watch\n```\n此问题不知是否是Vue3.x特意加上的，有待正式版出来后在验证。\n\n### computed计算属性：\n2.x中：\n```javascript\n...\ncomputed: {\n    storeData () {\n      return this.$store.state.storeData\n    },\n},\n...\n```\n3.x中：\n```javascript\n...\nimport {computed} from 'vue'\nsetup(){\n  const storeData = computed(() => store.state.storeData)\n\n  return {\n      storeData\n  }\n}\n...\n```\n\n当然，对于完整的Vue Composition API，各位同学可以参考[文档](https://composition-api.vuejs.org/zh/api.html)。就目前来说Vue3.0还并没有发布正式版，所以很多用法和实现方式可能还是未知数，但是对于新版本提供的编码方式的新思路，还是很期待的。\n\n\n","slug":"Vue3.0--Vue Composition API使用体验","published":1,"updated":"2020-07-26T04:15:32.000Z","comments":1,"layout":"post","link":"","_id":"ckx434q0c001k2wvjef5rrzv5","content":"<p>Vue3.0目前已经出了beta版本,并在github上进行了开源，叫做<a href=\"https://github.com/vuejs/vue-next\" target=\"_blank\" rel=\"noopener\">vue-next</a>，本文将之前采用Vue2.6开发的todoList小项目改造成为Vue3.0编写，并介绍一下2.x和3.x之间写法的不同之处。</p>\n<p><a href=\"https://www.nihaoshijie.com.cn/mypro/vue3todo/index.html\">点击体验</a><br>Github地址：<a href=\"https://github.com/lvming6816077/vue-todo/\" target=\"_blank\" rel=\"noopener\">Vue.js2.6版本todoList</a>，<a href=\"https://github.com/lvming6816077/vue3todo/\" target=\"_blank\" rel=\"noopener\">Vue.js3.0版本todoList</a><br><a id=\"more\"></a></p>\n<p>Vue3.x适配大部分Vue2.x的组件配置，也就是说以前我们在Vue2.x针对组件的一些配置项，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &apos;test&apos;,</span><br><span class=\"line\">  components: &#123;&#125;,</span><br><span class=\"line\">  props: &#123;&#125;,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;&#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  created()&#123;&#125;,</span><br><span class=\"line\">  mounted () &#123;&#125;,</span><br><span class=\"line\">  watch:&#123;&#125;,</span><br><span class=\"line\">  methods: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在Vue3.x中也是可以适配的，对应的相关生命周期方法也可正常执行，但是Vue3.x的一大核心是引入了<a href=\"https://composition-api.vuejs.org/zh/api.html\" target=\"_blank\" rel=\"noopener\">Vue Composition API</a>（组合式API）,这使得组件的大部分内容都可以通过<code>setup()</code>方法进行配置，同时Vue Composition API在Vue2.x也可以使用，需要通过安装@vue/composition-api来使用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install @vue/composition-api</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">import</span> VueCompositionApi <span class=\"keyword\">from</span> <span class=\"string\">'@vue/composition-api'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(VueCompositionApi);</span><br></pre></td></tr></table></figure></p>\n<p>下面主要介绍一下采用Vue Composition API来改造采用2.x开发的todoList项目时的新老代码对比。</p>\n<h3><span id=\"如何创建一个vue30的项目\">如何创建一个Vue3.0的项目</span></h3><p>首先，安装vue cli的最新版本，一般是vue cli 4，安装成功后，调用：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue create myapp</span><br></pre></td></tr></table></figure></p>\n<p>创建一个基于Vue2.x的项目，然后进入项目的根目录，执行：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue add vue-next</span><br></pre></td></tr></table></figure></p>\n<p>然后就会自动安装<a href=\"https://github.com/vuejs/vue-cli-plugin-vue-next\" target=\"_blank\" rel=\"noopener\">vue-cli-plugin-vue-next</a>插件，完毕之后，myapp项目就会变成一个基于Vue3.0Beta版本的项目框架。</p>\n<h3><span id=\"根实例初始化\">根实例初始化:</span></h3><p>在2.x中通过<code>new Vue()</code>的方法来初始化：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App.vue'</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  store,</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"params\">h</span> =&gt;</span> h(App)</span><br><span class=\"line\">&#125;).$mount(<span class=\"string\">'#app'</span>)</span><br></pre></td></tr></table></figure></p>\n<p>在3.x中Vue不再是一个构造函数，通过createApp方法初始化：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App.vue'</span></span><br><span class=\"line\">createApp(App).use(store).mount(<span class=\"string\">'#app'</span>)</span><br></pre></td></tr></table></figure></p>\n<h3><span id=\"ref或者reactive代替data中的变量\">ref或者reactive代替data中的变量:</span></h3><p>在2.x中通过组件data的方法来定义一些当前组件的数据：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">data() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'test'</span>,</span><br><span class=\"line\">    list: [],</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>在3.x中通过ref或者reactive创建响应式对象：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;ref,reactive&#125; <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\">...</span><br><span class=\"line\">setup()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> name = ref(<span class=\"string\">'test'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> state = reactive(&#123;</span><br><span class=\"line\">    list: []</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      name,</span><br><span class=\"line\">      state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>ref将给定的值创建一个响应式的数据对象并赋值初始值（int或者string），reactive可以直接定义复杂响应式对象。</p>\n<h3><span id=\"methods中定义的方法也可以写在setup中\">methods中定义的方法也可以写在setup()中:</span></h3><p>在2.x中methods来定义一些当前组件内部方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  fetchData() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>在3.x中直接在setup方法中定义并return：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">setup()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fetchData = <span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'fetchData'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      fetchData</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<h3><span id=\"无法使用eventbus\">无法使用EventBus:</span></h3><p>在2.x中通过EventBus的方法来实现组件通信：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> EventBus = <span class=\"keyword\">new</span> Vue()</span><br><span class=\"line\">Vue.prototype.$EventBus = EventBus</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">this</span>.$EventBus.$on()  <span class=\"keyword\">this</span>.$EventBus.$emit()</span><br></pre></td></tr></table></figure></p>\n<p>在3.x中移除了<code>$on, $off</code>等方法（参考<a href=\"https://github.com/vuejs/rfcs/blob/master/active-rfcs/0020-events-api-change.md\" target=\"_blank\" rel=\"noopener\">rfc</a>），而是推荐使用<a href=\"https://github.com/developit/mitt#examples--demos\" target=\"_blank\" rel=\"noopener\">mitt</a>方案来代替：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> mitt <span class=\"keyword\">from</span> <span class=\"string\">'mitt'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> emitter = mitt()</span><br><span class=\"line\"><span class=\"comment\">// listen to an event</span></span><br><span class=\"line\">emitter.on(<span class=\"string\">'foo'</span>, e =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">'foo'</span>, e) )</span><br><span class=\"line\"><span class=\"comment\">// fire an event</span></span><br><span class=\"line\">emitter.emit(<span class=\"string\">'foo'</span>, &#123; <span class=\"attr\">a</span>: <span class=\"string\">'b'</span> &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>由于3.x中不再支持prototype的方式设置全局方法，可以通过<code>app.config.globalProperties.mitt = () =&gt; {}</code>方案。</p>\n<h3><span id=\"setup中使用props和this\">setup()中使用props和this:</span></h3><p>在2.x中，组件的方法中可以通过this获取到当前组件的实例，并执行data变量的修改，方法的调用，组件的通信等等，但是在3.x中，setup()在beforeCreate和created时机就已调用，无法使用和2.x一样的this，但是可以通过接收<code>setup(props,ctx)</code>的方法，获取到当前组件的实例和props：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">String</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  setup(props,ctx) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(props.name)</span><br><span class=\"line\">    ctx.emit(<span class=\"string\">'event'</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意ctx和2.x中this并不完全一样，而是选择性地暴露了一些property，主要有<code>[attrs,emit,slots]</code>。</p>\n<h3><span id=\"watch来监听对象改变\">watch来监听对象改变</span></h3><p>2.x中，可以采用watch来监听一个对象属性是否有改动：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">data()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'a'</span>  </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">watch: &#123;</span><br><span class=\"line\">  name(val) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(val)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>3.x中，在setup()中，可以使用watch来监听：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;watch&#125; <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\">setup()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> state = reactive(&#123;</span><br><span class=\"line\">    name: <span class=\"string\">'a'</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  watch(</span><br><span class=\"line\">    () =&gt; state.name,</span><br><span class=\"line\">    (val, oldVal) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(val)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  )</span><br><span class=\"line\">  state.name = <span class=\"string\">'b'</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>在3.x中，如果watch的是一个数组array对象，那么如果调用array.push()方法添加一条数据，并不会触发watch方法，必须重新给array赋值：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> state = reactive(&#123;</span><br><span class=\"line\">   list: []</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">watch(</span><br><span class=\"line\">   () =&gt; state.list,</span><br><span class=\"line\">   (val, oldVal) =&gt; &#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log(val)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> )</span><br><span class=\"line\"> </span><br><span class=\"line\"> state.list.push(<span class=\"number\">1</span>) <span class=\"comment\">// 不会触发watch</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> state.list = [<span class=\"number\">1</span>] <span class=\"comment\">// 会触发watch</span></span><br></pre></td></tr></table></figure></p>\n<p>此问题不知是否是Vue3.x特意加上的，有待正式版出来后在验证。</p>\n<h3><span id=\"computed计算属性\">computed计算属性：</span></h3><p>2.x中：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">    storeData () &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.state.storeData</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>3.x中：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;computed&#125; <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\">setup()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> storeData = computed(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> store.state.storeData)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      storeData</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>当然，对于完整的Vue Composition API，各位同学可以参考<a href=\"https://composition-api.vuejs.org/zh/api.html\" target=\"_blank\" rel=\"noopener\">文档</a>。就目前来说Vue3.0还并没有发布正式版，所以很多用法和实现方式可能还是未知数，但是对于新版本提供的编码方式的新思路，还是很期待的。</p>\n","site":{"data":{}},"excerpt":"<p>Vue3.0目前已经出了beta版本,并在github上进行了开源，叫做<a href=\"https://github.com/vuejs/vue-next\" target=\"_blank\" rel=\"noopener\">vue-next</a>，本文将之前采用Vue2.6开发的todoList小项目改造成为Vue3.0编写，并介绍一下2.x和3.x之间写法的不同之处。</p>\n<p><a href=\"https://www.nihaoshijie.com.cn/mypro/vue3todo/index.html\">点击体验</a><br>Github地址：<a href=\"https://github.com/lvming6816077/vue-todo/\" target=\"_blank\" rel=\"noopener\">Vue.js2.6版本todoList</a>，<a href=\"https://github.com/lvming6816077/vue3todo/\" target=\"_blank\" rel=\"noopener\">Vue.js3.0版本todoList</a><br>","more":"</p>\n<p>Vue3.x适配大部分Vue2.x的组件配置，也就是说以前我们在Vue2.x针对组件的一些配置项，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &apos;test&apos;,</span><br><span class=\"line\">  components: &#123;&#125;,</span><br><span class=\"line\">  props: &#123;&#125;,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;&#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  created()&#123;&#125;,</span><br><span class=\"line\">  mounted () &#123;&#125;,</span><br><span class=\"line\">  watch:&#123;&#125;,</span><br><span class=\"line\">  methods: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在Vue3.x中也是可以适配的，对应的相关生命周期方法也可正常执行，但是Vue3.x的一大核心是引入了<a href=\"https://composition-api.vuejs.org/zh/api.html\" target=\"_blank\" rel=\"noopener\">Vue Composition API</a>（组合式API）,这使得组件的大部分内容都可以通过<code>setup()</code>方法进行配置，同时Vue Composition API在Vue2.x也可以使用，需要通过安装@vue/composition-api来使用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install @vue/composition-api</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">import</span> VueCompositionApi <span class=\"keyword\">from</span> <span class=\"string\">'@vue/composition-api'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(VueCompositionApi);</span><br></pre></td></tr></table></figure></p>\n<p>下面主要介绍一下采用Vue Composition API来改造采用2.x开发的todoList项目时的新老代码对比。</p>\n<h3 id=\"如何创建一个Vue3-0的项目\"><a href=\"#如何创建一个Vue3-0的项目\" class=\"headerlink\" title=\"如何创建一个Vue3.0的项目\"></a>如何创建一个Vue3.0的项目</h3><p>首先，安装vue cli的最新版本，一般是vue cli 4，安装成功后，调用：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue create myapp</span><br></pre></td></tr></table></figure></p>\n<p>创建一个基于Vue2.x的项目，然后进入项目的根目录，执行：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue add vue-next</span><br></pre></td></tr></table></figure></p>\n<p>然后就会自动安装<a href=\"https://github.com/vuejs/vue-cli-plugin-vue-next\" target=\"_blank\" rel=\"noopener\">vue-cli-plugin-vue-next</a>插件，完毕之后，myapp项目就会变成一个基于Vue3.0Beta版本的项目框架。</p>\n<h3 id=\"根实例初始化\"><a href=\"#根实例初始化\" class=\"headerlink\" title=\"根实例初始化:\"></a>根实例初始化:</h3><p>在2.x中通过<code>new Vue()</code>的方法来初始化：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App.vue'</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  store,</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"params\">h</span> =&gt;</span> h(App)</span><br><span class=\"line\">&#125;).$mount(<span class=\"string\">'#app'</span>)</span><br></pre></td></tr></table></figure></p>\n<p>在3.x中Vue不再是一个构造函数，通过createApp方法初始化：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App.vue'</span></span><br><span class=\"line\">createApp(App).use(store).mount(<span class=\"string\">'#app'</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ref或者reactive代替data中的变量\"><a href=\"#ref或者reactive代替data中的变量\" class=\"headerlink\" title=\"ref或者reactive代替data中的变量:\"></a>ref或者reactive代替data中的变量:</h3><p>在2.x中通过组件data的方法来定义一些当前组件的数据：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">data() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'test'</span>,</span><br><span class=\"line\">    list: [],</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>在3.x中通过ref或者reactive创建响应式对象：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;ref,reactive&#125; <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\">...</span><br><span class=\"line\">setup()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> name = ref(<span class=\"string\">'test'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> state = reactive(&#123;</span><br><span class=\"line\">    list: []</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      name,</span><br><span class=\"line\">      state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>ref将给定的值创建一个响应式的数据对象并赋值初始值（int或者string），reactive可以直接定义复杂响应式对象。</p>\n<h3 id=\"methods中定义的方法也可以写在setup-中\"><a href=\"#methods中定义的方法也可以写在setup-中\" class=\"headerlink\" title=\"methods中定义的方法也可以写在setup()中:\"></a>methods中定义的方法也可以写在setup()中:</h3><p>在2.x中methods来定义一些当前组件内部方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  fetchData() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>在3.x中直接在setup方法中定义并return：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">setup()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fetchData = <span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'fetchData'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      fetchData</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"无法使用EventBus\"><a href=\"#无法使用EventBus\" class=\"headerlink\" title=\"无法使用EventBus:\"></a>无法使用EventBus:</h3><p>在2.x中通过EventBus的方法来实现组件通信：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> EventBus = <span class=\"keyword\">new</span> Vue()</span><br><span class=\"line\">Vue.prototype.$EventBus = EventBus</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">this</span>.$EventBus.$on()  <span class=\"keyword\">this</span>.$EventBus.$emit()</span><br></pre></td></tr></table></figure></p>\n<p>在3.x中移除了<code>$on, $off</code>等方法（参考<a href=\"https://github.com/vuejs/rfcs/blob/master/active-rfcs/0020-events-api-change.md\" target=\"_blank\" rel=\"noopener\">rfc</a>），而是推荐使用<a href=\"https://github.com/developit/mitt#examples--demos\" target=\"_blank\" rel=\"noopener\">mitt</a>方案来代替：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> mitt <span class=\"keyword\">from</span> <span class=\"string\">'mitt'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> emitter = mitt()</span><br><span class=\"line\"><span class=\"comment\">// listen to an event</span></span><br><span class=\"line\">emitter.on(<span class=\"string\">'foo'</span>, e =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">'foo'</span>, e) )</span><br><span class=\"line\"><span class=\"comment\">// fire an event</span></span><br><span class=\"line\">emitter.emit(<span class=\"string\">'foo'</span>, &#123; <span class=\"attr\">a</span>: <span class=\"string\">'b'</span> &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>由于3.x中不再支持prototype的方式设置全局方法，可以通过<code>app.config.globalProperties.mitt = () =&gt; {}</code>方案。</p>\n<h3 id=\"setup-中使用props和this\"><a href=\"#setup-中使用props和this\" class=\"headerlink\" title=\"setup()中使用props和this:\"></a>setup()中使用props和this:</h3><p>在2.x中，组件的方法中可以通过this获取到当前组件的实例，并执行data变量的修改，方法的调用，组件的通信等等，但是在3.x中，setup()在beforeCreate和created时机就已调用，无法使用和2.x一样的this，但是可以通过接收<code>setup(props,ctx)</code>的方法，获取到当前组件的实例和props：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">String</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  setup(props,ctx) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(props.name)</span><br><span class=\"line\">    ctx.emit(<span class=\"string\">'event'</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意ctx和2.x中this并不完全一样，而是选择性地暴露了一些property，主要有<code>[attrs,emit,slots]</code>。</p>\n<h3 id=\"watch来监听对象改变\"><a href=\"#watch来监听对象改变\" class=\"headerlink\" title=\"watch来监听对象改变\"></a>watch来监听对象改变</h3><p>2.x中，可以采用watch来监听一个对象属性是否有改动：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">data()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'a'</span>  </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">watch: &#123;</span><br><span class=\"line\">  name(val) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(val)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>3.x中，在setup()中，可以使用watch来监听：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;watch&#125; <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\">setup()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> state = reactive(&#123;</span><br><span class=\"line\">    name: <span class=\"string\">'a'</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  watch(</span><br><span class=\"line\">    () =&gt; state.name,</span><br><span class=\"line\">    (val, oldVal) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(val)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  )</span><br><span class=\"line\">  state.name = <span class=\"string\">'b'</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>在3.x中，如果watch的是一个数组array对象，那么如果调用array.push()方法添加一条数据，并不会触发watch方法，必须重新给array赋值：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> state = reactive(&#123;</span><br><span class=\"line\">   list: []</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">watch(</span><br><span class=\"line\">   () =&gt; state.list,</span><br><span class=\"line\">   (val, oldVal) =&gt; &#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log(val)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> )</span><br><span class=\"line\"> </span><br><span class=\"line\"> state.list.push(<span class=\"number\">1</span>) <span class=\"comment\">// 不会触发watch</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> state.list = [<span class=\"number\">1</span>] <span class=\"comment\">// 会触发watch</span></span><br></pre></td></tr></table></figure></p>\n<p>此问题不知是否是Vue3.x特意加上的，有待正式版出来后在验证。</p>\n<h3 id=\"computed计算属性：\"><a href=\"#computed计算属性：\" class=\"headerlink\" title=\"computed计算属性：\"></a>computed计算属性：</h3><p>2.x中：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">    storeData () &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.state.storeData</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>3.x中：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;computed&#125; <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\">setup()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> storeData = computed(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> store.state.storeData)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      storeData</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>当然，对于完整的Vue Composition API，各位同学可以参考<a href=\"https://composition-api.vuejs.org/zh/api.html\" target=\"_blank\" rel=\"noopener\">文档</a>。就目前来说Vue3.0还并没有发布正式版，所以很多用法和实现方式可能还是未知数，但是对于新版本提供的编码方式的新思路，还是很期待的。</p>"},{"title":"Vue3源码解析--响应式原理","date":"2021-11-06T09:26:17.000Z","_content":"\n\n响应式reactivity是Vue 3相对于Vue 2改动比较大的一个模块，也是性能提升最多的一个模块。其核心改变是采用了ES 6的Proxy API来代替Vue2中Object.defineProperty方法来实现响应式，那么什么是Proxy API呢，Vue 3的响应式又是如何实现的，下面将会进行揭晓。\n<!--more-->\n## Proxy API\n\nProxy API对应的Proxy对象是ES6就已引入的一个原生对象，用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。 从字面意思来理解，Proxy对象是目标对象的一个代理器，任何对目标对象的操作（实例化，添加/删除/修改属性等等），都必须通过该代理器。因此我们可以把来自外界的所有操作进行拦截和过滤或者修改等操作。 基于Proxy的这些特性，常用于：\n\n-   创建一个可“响应式”的对象，例如Vue3.0中的reactive方法。\n-   创建可隔离的JavaScript“沙箱”。\n\nProxy的基本语法如下代码所示：\n\n```\nconst p = new Proxy(target, handler)\n```\n\n其中，target参数表示要使用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理），handler参数表示以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理p的行为。常见使用方法如下代码所示：\n\n```\nlet foo = {\n a: 1,\n b: 2\n}\nlet handler = {\n    get:(obj,key)=>{\n        console.log('get')\n        return key in obj ? obj[key] : undefined\n    }\n}\nlet p = new Proxy(foo,handler)\nconsole.log(p.a) // 打印1\n```\n\n上面代码中p就是foo的代理对象，对p对象的相关操作都会同步到foo对象上，同时Proxy也提供了另一种生成代理对象的方法Proxy.revocable()，如下代码所示：\n\n```\nconst { proxy,revoke } = Proxy.revocable(target, handler)\n```\n\n该方法的返回值是一个对象，其结构为： `{\"proxy\": proxy, \"revoke\": revoke}`，其中：proxy表示新生成的代理对象本身，和用一般方式`new Proxy(target, handler)`创建的代理对象没什么不同，只是它可以被撤销掉，revoke表示撤销方法，调用的时候不需要加任何参数，就可以撤销掉和它一起生成的那个代理对象，如下代码所示：\n\n```\nlet foo = {\n a: 1,\n b: 2\n}\nlet handler = {\n    get:(obj,key)=>{\n        console.log('get')\n        return key in obj ? obj[key] : undefined\n    }\n}\nlet { proxy,revoke } = Proxy.revocable(foo,handler)\nconsole.log(proxy.a) // 打印1\nrevoke()\nconsole.log(proxy.a) // 报错信息：Uncaught TypeError: Cannot perform 'get' on a proxy that has been revoked\n```\n\n需要注意的是，一旦某个代理对象被撤销，它将变得几乎完全不可调用，在它身上执行任何的可代理操作都会抛出TypeError异常。 在上面代码中，我们只使用了get操作的handler，即当尝试获取对象的某个属性时会进入这个方法，除此之外Proxy共有接近14个handler也可以称作为钩子，它们分别是：\n\n```\nhandler.getPrototypeOf()：\n在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy) 时。\n\nhandler.setPrototypeOf()：\n在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。\n\nhandler.isExtensible()：\n在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时。\n\nhandler.preventExtensions()：\n在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时。\n\nhandler.getOwnPropertyDescriptor()：\n在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, \"foo\") 时。\n\nhandler.defineProperty()：\n在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, \"foo\", {}) 时。\n\nhandler.has()：\n在判断代理对象是否拥有某个属性时触发该操作，比如在执行 \"foo\" in proxy 时。\n\nhandler.get()：\n在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。\n\nhandler.set()：\n在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。\n\nhandler.deleteProperty()：\n在删除代理对象的某个属性时触发该操作，即使用 delete 运算符，比如在执行 delete proxy.foo 时。\n\nhandler.ownKeys()：\n当执行Object.getOwnPropertyNames(proxy) 和Object.getOwnPropertySymbols(proxy)时触发。\n\nhandler.apply()：\n当代理对象是一个function函数时，调用apply()方法时触发，比如proxy.apply()。\n\nhandler.construct()：\n当代理对象是一个function函数时，通过new关键字实例化时触发，比如new proxy()。\n```\n\n结合这些handler，我们可以实现一些针对对象的限制操作，例如： 禁止删除和修改对象的某个属性，如下代码所示：\n\n```\nlet foo = {\n    a:1,\n    b:2\n}\nlet handler = {\n    set:(obj,key,value,receiver)=>{\n        console.log('set')\n        if (key == 'a') throw new Error('can not change property:'+key)\n        obj[key] = value\n        return true\n    },\n    deleteProperty:(obj,key)=>{\n        console.log('delete')\n        if (key == 'a') throw new Error('can not delete property:'+key)\n        delete obj[key]\n        return true\n    }\n}\n\nlet p = new Proxy(foo,handler)\n// 尝试修改属性a\np.a = 3 // 报错信息：Uncaught Error\n// 尝试删除属性a\ndelete p.a  // 报错信息：Uncaught Error\n```\n\n上面代码中，set方法多了一个receiver参数，这个参数通常是Proxy本身即p，场景是当有一段代码执行`obj.name=\"jen\"`，obj不是一个proxy，且自身不含name属性，但是它的原型链上有一个proxy，那么，那个proxy的handler里的set方法会被调用，而此时obj会作为receiver这个参数传进来。 对属性的修改进行校验，如下代码所示：\n\n```\nlet foo = {\n    a:1,\n    b:2\n}\nlet handler = {\n    set:(obj,key,value)=>{\n        console.log('set')\n        if (typeof(value) !== 'number') throw new Error('can not change property:'+key)\n        obj[key] = value\n        return true\n    }\n}\nlet p = new Proxy(foo,handler)\np.a = 'hello' // 报错信息：Uncaught Error\n```\n\nProxy也能监听到数组变化，如下代码所示：\n\n```\nlet arr = [1]\nlet handler = {\n    set:(obj,key,value)=>{\n        console.log('set') // 打印set\n        return Reflect.set(obj, key, value);\n    }\n}\n\nlet p = new Proxy(arr,handler)\np.push(2) // 改变数组\n```\n\n`Reflect.set()`用于修改数组的值，返回布尔类型，这也可以兼容修改数组原型上的方法对应场景，相当于`obj[key] = value`。\n\n## Proxy和响应式对象reactive\n\n在Vue 3中，使用响应式对象方法如下代码所示：\n\n```\nimport {ref,reactive} from 'vue'\n...\nsetup(){\n  const name = ref('test')\n  const state = reactive({\n    list: []\n  })\n  return {name,state}\n}\n...\n```\n\n在Vue 3中，Composition API中会经常使用创建响应式对象的方法ref/reactive，其内部就是利用了Proxy API来实现的，特别是借助handler的set方法，可以实现双向数据绑定相关的逻辑，这对于Vue 2中的Object.defineProperty()是很大的改变，主要提升如下：\n\n-   `Object.defineProperty()`只能单一的监听已有属性的修改或者变化，无法检测到对象属性的新增或删除（Vue 2中是采用$set()方法来解决），而Proxy则可以轻松实现。\n-   `Object.defineProperty()`无法监听响应式数据类型是数组的变化（主要是数组长度变化，Vue 2中采用重写数组相关方法并添加钩子来解决），而Proxy则可以轻松实现。\n\n正是由于Proxy的特性，在原本使用Object.defineProperty()需要很复杂的方式才能实现的上面两种能力，在Proxy无需任何配置，利用其原生的特性就可以轻松实现。\n\n## ref()方法运行原理\n\n在Vue 3的源码中，所有关于响应式的代码都在vue-next/package/reactivity下面，其中reactivity/src/index.ts里暴露了所有可以使用的方法。我们以常用的ref()方法举例，来看看Vue 3是如何利用Proxy的。 ref()方法的主要逻辑在reactivity/src/ref.ts中，其代码如下：\n\n```\n...\n// 入口方法\nexport function ref(value?: unknown) {\n  return createRef(value, false)\n}\nfunction createRef(rawValue: unknown, shallow: boolean) {\n  // rawValue表示原始对象，shallow表示是否递归\n  // 如果本身已经是ref对象，则直接返回\n  if (isRef(rawValue)) {\n    return rawValue\n  }\n  // 创建一个新的RefImpl对象\n  return new RefImpl(rawValue, shallow)\n}\n...\n```\n\ncreateRef这个方法接收的第二个参数是shallow，表示是否是递归监听响应式，这个和另外一个响应式方法shallowRef()是对应的。在RefImpl构造函数中，有一个value属性，这个属性是由toReactive()方法所返回，toReactive()方法则在reactivity/src/reactive.ts文件中，如下代码所示：\n\n```\nclass RefImpl<T> {\n  ...\n  constructor(value: T, public readonly _shallow: boolean) {\n    this._rawValue = _shallow ? value : toRaw(value)\n    // 如果是非递归，调用toReactive\n    this._value = _shallow ? value : toReactive(value)\n  }\n  ...\n}\n```\n\n在reactive.ts中，则开始真正创建一个响应式对象，如下代码所示：\n\n```\nexport function reactive(target: object) {\n  // 如果是readonly，则直接返回，就不添加响应式了\n  if (target && (target as Target)[ReactiveFlags.IS_READONLY]) {\n    return target\n  }\n  return createReactiveObject(\n    target,// 原始对象\n    false,// 是否readonly\n    mutableHandlers,// proxy的handler对象baseHandlers\n    mutableCollectionHandlers,// proxy的handler对象collectionHandlers\n    reactiveMap// proxy对象映射\n  )\n}\n```\n\n其中，`createReactiveObject()`方法传递了两种handler，分别是baseHandlers和collectionHandlers，如果target的类型是Map，Set，WeakMap，WeakSet则会使用collectionHandlers，类型是Object，Array则会是baseHandlers，如果是一个基础对象，也不会创建Proxy对象，reactiveMap则存储所有响应式对象的映射关系，用来避免同一个对象的重复创建响应式。我们在来看看createReactiveObject()方法的实现，如下代码所示：\n\n```\nfunction createReactiveObject(...) {\n  // 如果target不满足typeof val === 'object'，则直接返回target\n  if (!isObject(target)) {\n    if (__DEV__) {\n      console.warn(`value cannot be made reactive: ${String(target)}`)\n    }\n    return target\n  }\n  // 如果target已经是proxy对象或者只读,则直接返回\n  // exception: calling readonly() on a reactive object\n  if (\n    target[ReactiveFlags.RAW] &&\n    !(isReadonly && target[ReactiveFlags.IS_REACTIVE])\n  ) {\n    return target\n  }\n  // 如果target已经被创建过Proxy对象，则直接返回这个对象\n  const existingProxy = proxyMap.get(target)\n  if (existingProxy) {\n    return existingProxy\n  }\n  // 只有符合类型的target才能被创建响应式\n  const targetType = getTargetType(target)\n  if (targetType === TargetType.INVALID) {\n    return target\n  }\n  // 调用Proxy API创建响应式\n  const proxy = new Proxy(\n    target,\n    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers\n  )\n  // 标记该对象已经创建过响应式\n  proxyMap.set(target, proxy)\n  return proxy\n}\n```\n\n可以看到在`createReactiveObject()`方法中，主要做了以下事情：\n\n-   防止只读和重复创建响应式。\n-   根据不同的target类型选择不同的handler。\n-   创建Proxy对象。\n\n最终会调用new Proxy来创建响应式对象，我们以baseHandlers为例，看看这个handler是怎么实现的，在reactivity/src/baseHandlers.ts可以看到这部分代码，主要实现了这几个handler，如下代码所示：\n\n```\nconst get = /*#__PURE__*/ createGetter()\n...\nexport const mutableHandlers: ProxyHandler<object> = {\n  get,\n  set,\n  deleteProperty,\n  has,\n  ownKeys\n}\n```\n\n以handler.get为例看看在其内部做了什么操作，当我们尝试读取对象的属性时，便会进入get方法，其核心代码如下所示：\n\n```\nfunction createGetter(isReadonly = false, shallow = false) {\n  return function get(target: Target, key: string | symbol, receiver: object) {\n    if (key === ReactiveFlags.IS_REACTIVE) { // 如果访问对象的key是__v_isReactive，则直接返回常量\n      return !isReadonly\n    } else if (key === ReactiveFlags.IS_READONLY) {// 如果访问对象的key是__v_isReadonly，则直接返回常量\n      return isReadonly\n    } else if (// 如果访问对象的key是__v_raw，或者原始对象只读对象等等直接返回target\n      key === ReactiveFlags.RAW &&\n      receiver ===\n        (isReadonly\n          ? shallow\n            ? shallowReadonlyMap\n            : readonlyMap\n          : shallow\n          ? shallowReactiveMap\n          : reactiveMap\n        ).get(target)\n    ) {\n      return target\n    }\n    // 如果target是数组类型\n    const targetIsArray = isArray(target)\n    // 并且访问的key值是数组的原生方法，那么直接返回调用结果\n    if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\n      return Reflect.get(arrayInstrumentations, key, receiver)\n    }\n    // 求值\n    const res = Reflect.get(target, key, receiver)\n    // 判断访问的key是否是Symbol或者不需要响应式的key例如__proto__,__v_isRef,__isVue\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res\n    }\n    // 收集响应式，为了后面的effect方法可以检测到\n    if (!isReadonly) {\n      track(target, TrackOpTypes.GET, key)\n    }\n    // 如果是非递归绑定，直接返回结果\n    if (shallow) {\n      return res\n    }\n\n    // 如果结果已经是响应式的，先判断类型，再返回\n    if (isRef(res)) {\n      const shouldUnwrap = !targetIsArray || !isIntegerKey(key)\n      return shouldUnwrap ? res.value : res\n    }\n\n    // 如果当前key的结果也是一个对象，那么就要递归调用reactive方法对改对象再次执行响应式绑定逻辑\n    if (isObject(res)) {\n      return isReadonly ? readonly(res) : reactive(res)\n    }\n    // 返回结果\n    return res\n  }\n}\n```\n\n上面这段代码是Vue 3响应式的核心代码之一，其逻辑相对比较复杂，读者可以根据注释来理解，总结下来，这段代码主要做了以下事情：\n\n-   对于`handler.get`方法来说，最终都会返回当前对象对应key的结果即`obj[key]`，所以该段代码最终会return结果。\n-   对非响应式key，只读key等直接返回对应的结果。\n-   对于数组类型的target，key值如果是原型上的方法，例如includes，push，pop等，采用Reflect.get直接返回。\n-   在effect添加收集监听track，为响应式监听服务。\n-   当当前key对应的结果是一个对象时，为了保证set方法能够触发，需要循环递归的对这个对象进行响应式绑定即递归调用reactive()方法。\n\nhandler.get方法主要功能是对结果value的返回，那么我们看看handler.set主要做了什么，其代码如下所示：\n\n```\nfunction createSetter(shallow = false) {\n  return function set(\n    target: object,\n    key: string | symbol,\n    value: unknown,// 即将被设置的新值\n    receiver: object\n  ): boolean {\n    // 缓存旧值\n    let oldValue = (target as any)[key]\n    if (!shallow) {\n      // 新旧值转换原始对象\n      value = toRaw(value)\n      oldValue = toRaw(oldValue)\n      // 如果旧值已经是一个RefImpl对象且新值不是RefImpl对象\n      // 例如var v = Vue.reactive({a:1,b:Vue.ref({c:3})})场景的set\nif (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value // 直接将新值赋给旧址的响应式对象里\n        return true\n      }\n    }\n    // 用来判断是否是新增key还是更新key的值\n    const hadKey =\n      isArray(target) && isIntegerKey(key)\n        ? Number(key) < target.length\n        : hasOwn(target, key)\n    // 设置set结果，并添加监听effect逻辑\n    const result = Reflect.set(target, key, value, receiver)\n    // 判断target没有动过，包括在原型上添加或者删除某些项\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, TriggerOpTypes.ADD, key, value)// 新增key的触发监听\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, TriggerOpTypes.SET, key, value, oldValue)// 更新key的触发监听\n      }\n    }\n    // 返回set结果 true/false\n    return result\n  }\n}\n```\n\n`handler.set`方法核心功能是设置key对应的值即`obj[key] = value`，同时对新旧值进行逻辑判断和处理，最后添加上trigger触发监听track逻辑，便于触发effect。 如果读者感觉上述源码理解比较困难，笔者剔除一些边界和兼容判断，将整个流程进行梳理和简化，可以参考下面这段便于理解的代码：\n\n```\nlet foo = {a:{c:3,d:{e:4}},b:2}\nconst isObject = (val)=>{\n    return val !== null && typeof val === 'object'\n}\nconst createProxy = (target)=>{\n    let p = new Proxy(target,{\n        get:(obj,key)=>{\n            let res = obj[key] ? obj[key] : undefined\n\n            // 添加监听\n            track(target)\n            // 判断类型，避免死循环\n            if (isObject(res)) {\n                return createProxy(res)// 循环递归调用\n            } else {\n                return res\n            }\n        },\n        set: (obj, key, value)=> {\n          console.log('set')\n          \n          obj[key] = value;\n          // 触发监听\n          trigger(target)\n          return true\n        }\n    })\n\n    return p\n}\n\nlet result = createProxy(foo)\n\nresult.a.d.e = 6 // 打印出set\n```\n\n当尝试去修改一个多层嵌套的对象的属性时，会触发该属性的上一级对象的get方法，利用这个就可以对每个层级的对象添加Proxy代理，这样就实现了多层嵌套对象的属性修改问题，在此基础上同时添加track和trigger逻辑，就完成了基本的响应式流程。我们将在后面章节结合双向绑定来具体讲解track和trigger流程。\n\n\n","source":"_posts/Vue3源码解析--响应式原理.md","raw":"---\ntitle: Vue3源码解析--响应式原理\ndate: 2021-11-06 17:26:17\ntags:\n- Vue3\n- 源码解析\ncategories:\n- 914\n\n---\n\n\n响应式reactivity是Vue 3相对于Vue 2改动比较大的一个模块，也是性能提升最多的一个模块。其核心改变是采用了ES 6的Proxy API来代替Vue2中Object.defineProperty方法来实现响应式，那么什么是Proxy API呢，Vue 3的响应式又是如何实现的，下面将会进行揭晓。\n<!--more-->\n## Proxy API\n\nProxy API对应的Proxy对象是ES6就已引入的一个原生对象，用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。 从字面意思来理解，Proxy对象是目标对象的一个代理器，任何对目标对象的操作（实例化，添加/删除/修改属性等等），都必须通过该代理器。因此我们可以把来自外界的所有操作进行拦截和过滤或者修改等操作。 基于Proxy的这些特性，常用于：\n\n-   创建一个可“响应式”的对象，例如Vue3.0中的reactive方法。\n-   创建可隔离的JavaScript“沙箱”。\n\nProxy的基本语法如下代码所示：\n\n```\nconst p = new Proxy(target, handler)\n```\n\n其中，target参数表示要使用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理），handler参数表示以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理p的行为。常见使用方法如下代码所示：\n\n```\nlet foo = {\n a: 1,\n b: 2\n}\nlet handler = {\n    get:(obj,key)=>{\n        console.log('get')\n        return key in obj ? obj[key] : undefined\n    }\n}\nlet p = new Proxy(foo,handler)\nconsole.log(p.a) // 打印1\n```\n\n上面代码中p就是foo的代理对象，对p对象的相关操作都会同步到foo对象上，同时Proxy也提供了另一种生成代理对象的方法Proxy.revocable()，如下代码所示：\n\n```\nconst { proxy,revoke } = Proxy.revocable(target, handler)\n```\n\n该方法的返回值是一个对象，其结构为： `{\"proxy\": proxy, \"revoke\": revoke}`，其中：proxy表示新生成的代理对象本身，和用一般方式`new Proxy(target, handler)`创建的代理对象没什么不同，只是它可以被撤销掉，revoke表示撤销方法，调用的时候不需要加任何参数，就可以撤销掉和它一起生成的那个代理对象，如下代码所示：\n\n```\nlet foo = {\n a: 1,\n b: 2\n}\nlet handler = {\n    get:(obj,key)=>{\n        console.log('get')\n        return key in obj ? obj[key] : undefined\n    }\n}\nlet { proxy,revoke } = Proxy.revocable(foo,handler)\nconsole.log(proxy.a) // 打印1\nrevoke()\nconsole.log(proxy.a) // 报错信息：Uncaught TypeError: Cannot perform 'get' on a proxy that has been revoked\n```\n\n需要注意的是，一旦某个代理对象被撤销，它将变得几乎完全不可调用，在它身上执行任何的可代理操作都会抛出TypeError异常。 在上面代码中，我们只使用了get操作的handler，即当尝试获取对象的某个属性时会进入这个方法，除此之外Proxy共有接近14个handler也可以称作为钩子，它们分别是：\n\n```\nhandler.getPrototypeOf()：\n在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy) 时。\n\nhandler.setPrototypeOf()：\n在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。\n\nhandler.isExtensible()：\n在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时。\n\nhandler.preventExtensions()：\n在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时。\n\nhandler.getOwnPropertyDescriptor()：\n在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, \"foo\") 时。\n\nhandler.defineProperty()：\n在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, \"foo\", {}) 时。\n\nhandler.has()：\n在判断代理对象是否拥有某个属性时触发该操作，比如在执行 \"foo\" in proxy 时。\n\nhandler.get()：\n在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。\n\nhandler.set()：\n在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。\n\nhandler.deleteProperty()：\n在删除代理对象的某个属性时触发该操作，即使用 delete 运算符，比如在执行 delete proxy.foo 时。\n\nhandler.ownKeys()：\n当执行Object.getOwnPropertyNames(proxy) 和Object.getOwnPropertySymbols(proxy)时触发。\n\nhandler.apply()：\n当代理对象是一个function函数时，调用apply()方法时触发，比如proxy.apply()。\n\nhandler.construct()：\n当代理对象是一个function函数时，通过new关键字实例化时触发，比如new proxy()。\n```\n\n结合这些handler，我们可以实现一些针对对象的限制操作，例如： 禁止删除和修改对象的某个属性，如下代码所示：\n\n```\nlet foo = {\n    a:1,\n    b:2\n}\nlet handler = {\n    set:(obj,key,value,receiver)=>{\n        console.log('set')\n        if (key == 'a') throw new Error('can not change property:'+key)\n        obj[key] = value\n        return true\n    },\n    deleteProperty:(obj,key)=>{\n        console.log('delete')\n        if (key == 'a') throw new Error('can not delete property:'+key)\n        delete obj[key]\n        return true\n    }\n}\n\nlet p = new Proxy(foo,handler)\n// 尝试修改属性a\np.a = 3 // 报错信息：Uncaught Error\n// 尝试删除属性a\ndelete p.a  // 报错信息：Uncaught Error\n```\n\n上面代码中，set方法多了一个receiver参数，这个参数通常是Proxy本身即p，场景是当有一段代码执行`obj.name=\"jen\"`，obj不是一个proxy，且自身不含name属性，但是它的原型链上有一个proxy，那么，那个proxy的handler里的set方法会被调用，而此时obj会作为receiver这个参数传进来。 对属性的修改进行校验，如下代码所示：\n\n```\nlet foo = {\n    a:1,\n    b:2\n}\nlet handler = {\n    set:(obj,key,value)=>{\n        console.log('set')\n        if (typeof(value) !== 'number') throw new Error('can not change property:'+key)\n        obj[key] = value\n        return true\n    }\n}\nlet p = new Proxy(foo,handler)\np.a = 'hello' // 报错信息：Uncaught Error\n```\n\nProxy也能监听到数组变化，如下代码所示：\n\n```\nlet arr = [1]\nlet handler = {\n    set:(obj,key,value)=>{\n        console.log('set') // 打印set\n        return Reflect.set(obj, key, value);\n    }\n}\n\nlet p = new Proxy(arr,handler)\np.push(2) // 改变数组\n```\n\n`Reflect.set()`用于修改数组的值，返回布尔类型，这也可以兼容修改数组原型上的方法对应场景，相当于`obj[key] = value`。\n\n## Proxy和响应式对象reactive\n\n在Vue 3中，使用响应式对象方法如下代码所示：\n\n```\nimport {ref,reactive} from 'vue'\n...\nsetup(){\n  const name = ref('test')\n  const state = reactive({\n    list: []\n  })\n  return {name,state}\n}\n...\n```\n\n在Vue 3中，Composition API中会经常使用创建响应式对象的方法ref/reactive，其内部就是利用了Proxy API来实现的，特别是借助handler的set方法，可以实现双向数据绑定相关的逻辑，这对于Vue 2中的Object.defineProperty()是很大的改变，主要提升如下：\n\n-   `Object.defineProperty()`只能单一的监听已有属性的修改或者变化，无法检测到对象属性的新增或删除（Vue 2中是采用$set()方法来解决），而Proxy则可以轻松实现。\n-   `Object.defineProperty()`无法监听响应式数据类型是数组的变化（主要是数组长度变化，Vue 2中采用重写数组相关方法并添加钩子来解决），而Proxy则可以轻松实现。\n\n正是由于Proxy的特性，在原本使用Object.defineProperty()需要很复杂的方式才能实现的上面两种能力，在Proxy无需任何配置，利用其原生的特性就可以轻松实现。\n\n## ref()方法运行原理\n\n在Vue 3的源码中，所有关于响应式的代码都在vue-next/package/reactivity下面，其中reactivity/src/index.ts里暴露了所有可以使用的方法。我们以常用的ref()方法举例，来看看Vue 3是如何利用Proxy的。 ref()方法的主要逻辑在reactivity/src/ref.ts中，其代码如下：\n\n```\n...\n// 入口方法\nexport function ref(value?: unknown) {\n  return createRef(value, false)\n}\nfunction createRef(rawValue: unknown, shallow: boolean) {\n  // rawValue表示原始对象，shallow表示是否递归\n  // 如果本身已经是ref对象，则直接返回\n  if (isRef(rawValue)) {\n    return rawValue\n  }\n  // 创建一个新的RefImpl对象\n  return new RefImpl(rawValue, shallow)\n}\n...\n```\n\ncreateRef这个方法接收的第二个参数是shallow，表示是否是递归监听响应式，这个和另外一个响应式方法shallowRef()是对应的。在RefImpl构造函数中，有一个value属性，这个属性是由toReactive()方法所返回，toReactive()方法则在reactivity/src/reactive.ts文件中，如下代码所示：\n\n```\nclass RefImpl<T> {\n  ...\n  constructor(value: T, public readonly _shallow: boolean) {\n    this._rawValue = _shallow ? value : toRaw(value)\n    // 如果是非递归，调用toReactive\n    this._value = _shallow ? value : toReactive(value)\n  }\n  ...\n}\n```\n\n在reactive.ts中，则开始真正创建一个响应式对象，如下代码所示：\n\n```\nexport function reactive(target: object) {\n  // 如果是readonly，则直接返回，就不添加响应式了\n  if (target && (target as Target)[ReactiveFlags.IS_READONLY]) {\n    return target\n  }\n  return createReactiveObject(\n    target,// 原始对象\n    false,// 是否readonly\n    mutableHandlers,// proxy的handler对象baseHandlers\n    mutableCollectionHandlers,// proxy的handler对象collectionHandlers\n    reactiveMap// proxy对象映射\n  )\n}\n```\n\n其中，`createReactiveObject()`方法传递了两种handler，分别是baseHandlers和collectionHandlers，如果target的类型是Map，Set，WeakMap，WeakSet则会使用collectionHandlers，类型是Object，Array则会是baseHandlers，如果是一个基础对象，也不会创建Proxy对象，reactiveMap则存储所有响应式对象的映射关系，用来避免同一个对象的重复创建响应式。我们在来看看createReactiveObject()方法的实现，如下代码所示：\n\n```\nfunction createReactiveObject(...) {\n  // 如果target不满足typeof val === 'object'，则直接返回target\n  if (!isObject(target)) {\n    if (__DEV__) {\n      console.warn(`value cannot be made reactive: ${String(target)}`)\n    }\n    return target\n  }\n  // 如果target已经是proxy对象或者只读,则直接返回\n  // exception: calling readonly() on a reactive object\n  if (\n    target[ReactiveFlags.RAW] &&\n    !(isReadonly && target[ReactiveFlags.IS_REACTIVE])\n  ) {\n    return target\n  }\n  // 如果target已经被创建过Proxy对象，则直接返回这个对象\n  const existingProxy = proxyMap.get(target)\n  if (existingProxy) {\n    return existingProxy\n  }\n  // 只有符合类型的target才能被创建响应式\n  const targetType = getTargetType(target)\n  if (targetType === TargetType.INVALID) {\n    return target\n  }\n  // 调用Proxy API创建响应式\n  const proxy = new Proxy(\n    target,\n    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers\n  )\n  // 标记该对象已经创建过响应式\n  proxyMap.set(target, proxy)\n  return proxy\n}\n```\n\n可以看到在`createReactiveObject()`方法中，主要做了以下事情：\n\n-   防止只读和重复创建响应式。\n-   根据不同的target类型选择不同的handler。\n-   创建Proxy对象。\n\n最终会调用new Proxy来创建响应式对象，我们以baseHandlers为例，看看这个handler是怎么实现的，在reactivity/src/baseHandlers.ts可以看到这部分代码，主要实现了这几个handler，如下代码所示：\n\n```\nconst get = /*#__PURE__*/ createGetter()\n...\nexport const mutableHandlers: ProxyHandler<object> = {\n  get,\n  set,\n  deleteProperty,\n  has,\n  ownKeys\n}\n```\n\n以handler.get为例看看在其内部做了什么操作，当我们尝试读取对象的属性时，便会进入get方法，其核心代码如下所示：\n\n```\nfunction createGetter(isReadonly = false, shallow = false) {\n  return function get(target: Target, key: string | symbol, receiver: object) {\n    if (key === ReactiveFlags.IS_REACTIVE) { // 如果访问对象的key是__v_isReactive，则直接返回常量\n      return !isReadonly\n    } else if (key === ReactiveFlags.IS_READONLY) {// 如果访问对象的key是__v_isReadonly，则直接返回常量\n      return isReadonly\n    } else if (// 如果访问对象的key是__v_raw，或者原始对象只读对象等等直接返回target\n      key === ReactiveFlags.RAW &&\n      receiver ===\n        (isReadonly\n          ? shallow\n            ? shallowReadonlyMap\n            : readonlyMap\n          : shallow\n          ? shallowReactiveMap\n          : reactiveMap\n        ).get(target)\n    ) {\n      return target\n    }\n    // 如果target是数组类型\n    const targetIsArray = isArray(target)\n    // 并且访问的key值是数组的原生方法，那么直接返回调用结果\n    if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\n      return Reflect.get(arrayInstrumentations, key, receiver)\n    }\n    // 求值\n    const res = Reflect.get(target, key, receiver)\n    // 判断访问的key是否是Symbol或者不需要响应式的key例如__proto__,__v_isRef,__isVue\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res\n    }\n    // 收集响应式，为了后面的effect方法可以检测到\n    if (!isReadonly) {\n      track(target, TrackOpTypes.GET, key)\n    }\n    // 如果是非递归绑定，直接返回结果\n    if (shallow) {\n      return res\n    }\n\n    // 如果结果已经是响应式的，先判断类型，再返回\n    if (isRef(res)) {\n      const shouldUnwrap = !targetIsArray || !isIntegerKey(key)\n      return shouldUnwrap ? res.value : res\n    }\n\n    // 如果当前key的结果也是一个对象，那么就要递归调用reactive方法对改对象再次执行响应式绑定逻辑\n    if (isObject(res)) {\n      return isReadonly ? readonly(res) : reactive(res)\n    }\n    // 返回结果\n    return res\n  }\n}\n```\n\n上面这段代码是Vue 3响应式的核心代码之一，其逻辑相对比较复杂，读者可以根据注释来理解，总结下来，这段代码主要做了以下事情：\n\n-   对于`handler.get`方法来说，最终都会返回当前对象对应key的结果即`obj[key]`，所以该段代码最终会return结果。\n-   对非响应式key，只读key等直接返回对应的结果。\n-   对于数组类型的target，key值如果是原型上的方法，例如includes，push，pop等，采用Reflect.get直接返回。\n-   在effect添加收集监听track，为响应式监听服务。\n-   当当前key对应的结果是一个对象时，为了保证set方法能够触发，需要循环递归的对这个对象进行响应式绑定即递归调用reactive()方法。\n\nhandler.get方法主要功能是对结果value的返回，那么我们看看handler.set主要做了什么，其代码如下所示：\n\n```\nfunction createSetter(shallow = false) {\n  return function set(\n    target: object,\n    key: string | symbol,\n    value: unknown,// 即将被设置的新值\n    receiver: object\n  ): boolean {\n    // 缓存旧值\n    let oldValue = (target as any)[key]\n    if (!shallow) {\n      // 新旧值转换原始对象\n      value = toRaw(value)\n      oldValue = toRaw(oldValue)\n      // 如果旧值已经是一个RefImpl对象且新值不是RefImpl对象\n      // 例如var v = Vue.reactive({a:1,b:Vue.ref({c:3})})场景的set\nif (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value // 直接将新值赋给旧址的响应式对象里\n        return true\n      }\n    }\n    // 用来判断是否是新增key还是更新key的值\n    const hadKey =\n      isArray(target) && isIntegerKey(key)\n        ? Number(key) < target.length\n        : hasOwn(target, key)\n    // 设置set结果，并添加监听effect逻辑\n    const result = Reflect.set(target, key, value, receiver)\n    // 判断target没有动过，包括在原型上添加或者删除某些项\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, TriggerOpTypes.ADD, key, value)// 新增key的触发监听\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, TriggerOpTypes.SET, key, value, oldValue)// 更新key的触发监听\n      }\n    }\n    // 返回set结果 true/false\n    return result\n  }\n}\n```\n\n`handler.set`方法核心功能是设置key对应的值即`obj[key] = value`，同时对新旧值进行逻辑判断和处理，最后添加上trigger触发监听track逻辑，便于触发effect。 如果读者感觉上述源码理解比较困难，笔者剔除一些边界和兼容判断，将整个流程进行梳理和简化，可以参考下面这段便于理解的代码：\n\n```\nlet foo = {a:{c:3,d:{e:4}},b:2}\nconst isObject = (val)=>{\n    return val !== null && typeof val === 'object'\n}\nconst createProxy = (target)=>{\n    let p = new Proxy(target,{\n        get:(obj,key)=>{\n            let res = obj[key] ? obj[key] : undefined\n\n            // 添加监听\n            track(target)\n            // 判断类型，避免死循环\n            if (isObject(res)) {\n                return createProxy(res)// 循环递归调用\n            } else {\n                return res\n            }\n        },\n        set: (obj, key, value)=> {\n          console.log('set')\n          \n          obj[key] = value;\n          // 触发监听\n          trigger(target)\n          return true\n        }\n    })\n\n    return p\n}\n\nlet result = createProxy(foo)\n\nresult.a.d.e = 6 // 打印出set\n```\n\n当尝试去修改一个多层嵌套的对象的属性时，会触发该属性的上一级对象的get方法，利用这个就可以对每个层级的对象添加Proxy代理，这样就实现了多层嵌套对象的属性修改问题，在此基础上同时添加track和trigger逻辑，就完成了基本的响应式流程。我们将在后面章节结合双向绑定来具体讲解track和trigger流程。\n\n\n","slug":"Vue3源码解析--响应式原理","published":1,"updated":"2021-12-13T01:32:03.778Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434q0f001m2wvjlbolvkng","content":"<p>响应式reactivity是Vue 3相对于Vue 2改动比较大的一个模块，也是性能提升最多的一个模块。其核心改变是采用了ES 6的Proxy API来代替Vue2中Object.defineProperty方法来实现响应式，那么什么是Proxy API呢，Vue 3的响应式又是如何实现的，下面将会进行揭晓。<br><a id=\"more\"></a></p>\n<h2><span id=\"proxy-api\">Proxy API</span></h2><p>Proxy API对应的Proxy对象是ES6就已引入的一个原生对象，用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。 从字面意思来理解，Proxy对象是目标对象的一个代理器，任何对目标对象的操作（实例化，添加/删除/修改属性等等），都必须通过该代理器。因此我们可以把来自外界的所有操作进行拦截和过滤或者修改等操作。 基于Proxy的这些特性，常用于：</p>\n<ul>\n<li>创建一个可“响应式”的对象，例如Vue3.0中的reactive方法。</li>\n<li>创建可隔离的JavaScript“沙箱”。</li>\n</ul>\n<p>Proxy的基本语法如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const p = new Proxy(target, handler)</span><br></pre></td></tr></table></figure>\n<p>其中，target参数表示要使用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理），handler参数表示以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理p的行为。常见使用方法如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let foo = &#123;</span><br><span class=\"line\"> a: 1,</span><br><span class=\"line\"> b: 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let handler = &#123;</span><br><span class=\"line\">    get:(obj,key)=&gt;&#123;</span><br><span class=\"line\">        console.log(&apos;get&apos;)</span><br><span class=\"line\">        return key in obj ? obj[key] : undefined</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let p = new Proxy(foo,handler)</span><br><span class=\"line\">console.log(p.a) // 打印1</span><br></pre></td></tr></table></figure>\n<p>上面代码中p就是foo的代理对象，对p对象的相关操作都会同步到foo对象上，同时Proxy也提供了另一种生成代理对象的方法Proxy.revocable()，如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123; proxy,revoke &#125; = Proxy.revocable(target, handler)</span><br></pre></td></tr></table></figure>\n<p>该方法的返回值是一个对象，其结构为： <code>{&quot;proxy&quot;: proxy, &quot;revoke&quot;: revoke}</code>，其中：proxy表示新生成的代理对象本身，和用一般方式<code>new Proxy(target, handler)</code>创建的代理对象没什么不同，只是它可以被撤销掉，revoke表示撤销方法，调用的时候不需要加任何参数，就可以撤销掉和它一起生成的那个代理对象，如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let foo = &#123;</span><br><span class=\"line\"> a: 1,</span><br><span class=\"line\"> b: 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let handler = &#123;</span><br><span class=\"line\">    get:(obj,key)=&gt;&#123;</span><br><span class=\"line\">        console.log(&apos;get&apos;)</span><br><span class=\"line\">        return key in obj ? obj[key] : undefined</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let &#123; proxy,revoke &#125; = Proxy.revocable(foo,handler)</span><br><span class=\"line\">console.log(proxy.a) // 打印1</span><br><span class=\"line\">revoke()</span><br><span class=\"line\">console.log(proxy.a) // 报错信息：Uncaught TypeError: Cannot perform &apos;get&apos; on a proxy that has been revoked</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，一旦某个代理对象被撤销，它将变得几乎完全不可调用，在它身上执行任何的可代理操作都会抛出TypeError异常。 在上面代码中，我们只使用了get操作的handler，即当尝试获取对象的某个属性时会进入这个方法，除此之外Proxy共有接近14个handler也可以称作为钩子，它们分别是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handler.getPrototypeOf()：</span><br><span class=\"line\">在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy) 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.setPrototypeOf()：</span><br><span class=\"line\">在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.isExtensible()：</span><br><span class=\"line\">在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.preventExtensions()：</span><br><span class=\"line\">在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.getOwnPropertyDescriptor()：</span><br><span class=\"line\">在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, &quot;foo&quot;) 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.defineProperty()：</span><br><span class=\"line\">在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, &quot;foo&quot;, &#123;&#125;) 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.has()：</span><br><span class=\"line\">在判断代理对象是否拥有某个属性时触发该操作，比如在执行 &quot;foo&quot; in proxy 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.get()：</span><br><span class=\"line\">在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.set()：</span><br><span class=\"line\">在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.deleteProperty()：</span><br><span class=\"line\">在删除代理对象的某个属性时触发该操作，即使用 delete 运算符，比如在执行 delete proxy.foo 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.ownKeys()：</span><br><span class=\"line\">当执行Object.getOwnPropertyNames(proxy) 和Object.getOwnPropertySymbols(proxy)时触发。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.apply()：</span><br><span class=\"line\">当代理对象是一个function函数时，调用apply()方法时触发，比如proxy.apply()。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.construct()：</span><br><span class=\"line\">当代理对象是一个function函数时，通过new关键字实例化时触发，比如new proxy()。</span><br></pre></td></tr></table></figure>\n<p>结合这些handler，我们可以实现一些针对对象的限制操作，例如： 禁止删除和修改对象的某个属性，如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let foo = &#123;</span><br><span class=\"line\">    a:1,</span><br><span class=\"line\">    b:2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let handler = &#123;</span><br><span class=\"line\">    set:(obj,key,value,receiver)=&gt;&#123;</span><br><span class=\"line\">        console.log(&apos;set&apos;)</span><br><span class=\"line\">        if (key == &apos;a&apos;) throw new Error(&apos;can not change property:&apos;+key)</span><br><span class=\"line\">        obj[key] = value</span><br><span class=\"line\">        return true</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    deleteProperty:(obj,key)=&gt;&#123;</span><br><span class=\"line\">        console.log(&apos;delete&apos;)</span><br><span class=\"line\">        if (key == &apos;a&apos;) throw new Error(&apos;can not delete property:&apos;+key)</span><br><span class=\"line\">        delete obj[key]</span><br><span class=\"line\">        return true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let p = new Proxy(foo,handler)</span><br><span class=\"line\">// 尝试修改属性a</span><br><span class=\"line\">p.a = 3 // 报错信息：Uncaught Error</span><br><span class=\"line\">// 尝试删除属性a</span><br><span class=\"line\">delete p.a  // 报错信息：Uncaught Error</span><br></pre></td></tr></table></figure>\n<p>上面代码中，set方法多了一个receiver参数，这个参数通常是Proxy本身即p，场景是当有一段代码执行<code>obj.name=&quot;jen&quot;</code>，obj不是一个proxy，且自身不含name属性，但是它的原型链上有一个proxy，那么，那个proxy的handler里的set方法会被调用，而此时obj会作为receiver这个参数传进来。 对属性的修改进行校验，如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let foo = &#123;</span><br><span class=\"line\">    a:1,</span><br><span class=\"line\">    b:2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let handler = &#123;</span><br><span class=\"line\">    set:(obj,key,value)=&gt;&#123;</span><br><span class=\"line\">        console.log(&apos;set&apos;)</span><br><span class=\"line\">        if (typeof(value) !== &apos;number&apos;) throw new Error(&apos;can not change property:&apos;+key)</span><br><span class=\"line\">        obj[key] = value</span><br><span class=\"line\">        return true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let p = new Proxy(foo,handler)</span><br><span class=\"line\">p.a = &apos;hello&apos; // 报错信息：Uncaught Error</span><br></pre></td></tr></table></figure>\n<p>Proxy也能监听到数组变化，如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = [1]</span><br><span class=\"line\">let handler = &#123;</span><br><span class=\"line\">    set:(obj,key,value)=&gt;&#123;</span><br><span class=\"line\">        console.log(&apos;set&apos;) // 打印set</span><br><span class=\"line\">        return Reflect.set(obj, key, value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let p = new Proxy(arr,handler)</span><br><span class=\"line\">p.push(2) // 改变数组</span><br></pre></td></tr></table></figure>\n<p><code>Reflect.set()</code>用于修改数组的值，返回布尔类型，这也可以兼容修改数组原型上的方法对应场景，相当于<code>obj[key] = value</code>。</p>\n<h2><span id=\"proxy和响应式对象reactive\">Proxy和响应式对象reactive</span></h2><p>在Vue 3中，使用响应式对象方法如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;ref,reactive&#125; from &apos;vue&apos;</span><br><span class=\"line\">...</span><br><span class=\"line\">setup()&#123;</span><br><span class=\"line\">  const name = ref(&apos;test&apos;)</span><br><span class=\"line\">  const state = reactive(&#123;</span><br><span class=\"line\">    list: []</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  return &#123;name,state&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>在Vue 3中，Composition API中会经常使用创建响应式对象的方法ref/reactive，其内部就是利用了Proxy API来实现的，特别是借助handler的set方法，可以实现双向数据绑定相关的逻辑，这对于Vue 2中的Object.defineProperty()是很大的改变，主要提升如下：</p>\n<ul>\n<li><code>Object.defineProperty()</code>只能单一的监听已有属性的修改或者变化，无法检测到对象属性的新增或删除（Vue 2中是采用$set()方法来解决），而Proxy则可以轻松实现。</li>\n<li><code>Object.defineProperty()</code>无法监听响应式数据类型是数组的变化（主要是数组长度变化，Vue 2中采用重写数组相关方法并添加钩子来解决），而Proxy则可以轻松实现。</li>\n</ul>\n<p>正是由于Proxy的特性，在原本使用Object.defineProperty()需要很复杂的方式才能实现的上面两种能力，在Proxy无需任何配置，利用其原生的特性就可以轻松实现。</p>\n<h2><span id=\"ref方法运行原理\">ref()方法运行原理</span></h2><p>在Vue 3的源码中，所有关于响应式的代码都在vue-next/package/reactivity下面，其中reactivity/src/index.ts里暴露了所有可以使用的方法。我们以常用的ref()方法举例，来看看Vue 3是如何利用Proxy的。 ref()方法的主要逻辑在reactivity/src/ref.ts中，其代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">// 入口方法</span><br><span class=\"line\">export function ref(value?: unknown) &#123;</span><br><span class=\"line\">  return createRef(value, false)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function createRef(rawValue: unknown, shallow: boolean) &#123;</span><br><span class=\"line\">  // rawValue表示原始对象，shallow表示是否递归</span><br><span class=\"line\">  // 如果本身已经是ref对象，则直接返回</span><br><span class=\"line\">  if (isRef(rawValue)) &#123;</span><br><span class=\"line\">    return rawValue</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 创建一个新的RefImpl对象</span><br><span class=\"line\">  return new RefImpl(rawValue, shallow)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>createRef这个方法接收的第二个参数是shallow，表示是否是递归监听响应式，这个和另外一个响应式方法shallowRef()是对应的。在RefImpl构造函数中，有一个value属性，这个属性是由toReactive()方法所返回，toReactive()方法则在reactivity/src/reactive.ts文件中，如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class RefImpl&lt;T&gt; &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  constructor(value: T, public readonly _shallow: boolean) &#123;</span><br><span class=\"line\">    this._rawValue = _shallow ? value : toRaw(value)</span><br><span class=\"line\">    // 如果是非递归，调用toReactive</span><br><span class=\"line\">    this._value = _shallow ? value : toReactive(value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在reactive.ts中，则开始真正创建一个响应式对象，如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export function reactive(target: object) &#123;</span><br><span class=\"line\">  // 如果是readonly，则直接返回，就不添加响应式了</span><br><span class=\"line\">  if (target &amp;&amp; (target as Target)[ReactiveFlags.IS_READONLY]) &#123;</span><br><span class=\"line\">    return target</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return createReactiveObject(</span><br><span class=\"line\">    target,// 原始对象</span><br><span class=\"line\">    false,// 是否readonly</span><br><span class=\"line\">    mutableHandlers,// proxy的handler对象baseHandlers</span><br><span class=\"line\">    mutableCollectionHandlers,// proxy的handler对象collectionHandlers</span><br><span class=\"line\">    reactiveMap// proxy对象映射</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，<code>createReactiveObject()</code>方法传递了两种handler，分别是baseHandlers和collectionHandlers，如果target的类型是Map，Set，WeakMap，WeakSet则会使用collectionHandlers，类型是Object，Array则会是baseHandlers，如果是一个基础对象，也不会创建Proxy对象，reactiveMap则存储所有响应式对象的映射关系，用来避免同一个对象的重复创建响应式。我们在来看看createReactiveObject()方法的实现，如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createReactiveObject(...) &#123;</span><br><span class=\"line\">  // 如果target不满足typeof val === &apos;object&apos;，则直接返回target</span><br><span class=\"line\">  if (!isObject(target)) &#123;</span><br><span class=\"line\">    if (__DEV__) &#123;</span><br><span class=\"line\">      console.warn(`value cannot be made reactive: $&#123;String(target)&#125;`)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return target</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 如果target已经是proxy对象或者只读,则直接返回</span><br><span class=\"line\">  // exception: calling readonly() on a reactive object</span><br><span class=\"line\">  if (</span><br><span class=\"line\">    target[ReactiveFlags.RAW] &amp;&amp;</span><br><span class=\"line\">    !(isReadonly &amp;&amp; target[ReactiveFlags.IS_REACTIVE])</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    return target</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 如果target已经被创建过Proxy对象，则直接返回这个对象</span><br><span class=\"line\">  const existingProxy = proxyMap.get(target)</span><br><span class=\"line\">  if (existingProxy) &#123;</span><br><span class=\"line\">    return existingProxy</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 只有符合类型的target才能被创建响应式</span><br><span class=\"line\">  const targetType = getTargetType(target)</span><br><span class=\"line\">  if (targetType === TargetType.INVALID) &#123;</span><br><span class=\"line\">    return target</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 调用Proxy API创建响应式</span><br><span class=\"line\">  const proxy = new Proxy(</span><br><span class=\"line\">    target,</span><br><span class=\"line\">    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers</span><br><span class=\"line\">  )</span><br><span class=\"line\">  // 标记该对象已经创建过响应式</span><br><span class=\"line\">  proxyMap.set(target, proxy)</span><br><span class=\"line\">  return proxy</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到在<code>createReactiveObject()</code>方法中，主要做了以下事情：</p>\n<ul>\n<li>防止只读和重复创建响应式。</li>\n<li>根据不同的target类型选择不同的handler。</li>\n<li>创建Proxy对象。</li>\n</ul>\n<p>最终会调用new Proxy来创建响应式对象，我们以baseHandlers为例，看看这个handler是怎么实现的，在reactivity/src/baseHandlers.ts可以看到这部分代码，主要实现了这几个handler，如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const get = /*#__PURE__*/ createGetter()</span><br><span class=\"line\">...</span><br><span class=\"line\">export const mutableHandlers: ProxyHandler&lt;object&gt; = &#123;</span><br><span class=\"line\">  get,</span><br><span class=\"line\">  set,</span><br><span class=\"line\">  deleteProperty,</span><br><span class=\"line\">  has,</span><br><span class=\"line\">  ownKeys</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以handler.get为例看看在其内部做了什么操作，当我们尝试读取对象的属性时，便会进入get方法，其核心代码如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createGetter(isReadonly = false, shallow = false) &#123;</span><br><span class=\"line\">  return function get(target: Target, key: string | symbol, receiver: object) &#123;</span><br><span class=\"line\">    if (key === ReactiveFlags.IS_REACTIVE) &#123; // 如果访问对象的key是__v_isReactive，则直接返回常量</span><br><span class=\"line\">      return !isReadonly</span><br><span class=\"line\">    &#125; else if (key === ReactiveFlags.IS_READONLY) &#123;// 如果访问对象的key是__v_isReadonly，则直接返回常量</span><br><span class=\"line\">      return isReadonly</span><br><span class=\"line\">    &#125; else if (// 如果访问对象的key是__v_raw，或者原始对象只读对象等等直接返回target</span><br><span class=\"line\">      key === ReactiveFlags.RAW &amp;&amp;</span><br><span class=\"line\">      receiver ===</span><br><span class=\"line\">        (isReadonly</span><br><span class=\"line\">          ? shallow</span><br><span class=\"line\">            ? shallowReadonlyMap</span><br><span class=\"line\">            : readonlyMap</span><br><span class=\"line\">          : shallow</span><br><span class=\"line\">          ? shallowReactiveMap</span><br><span class=\"line\">          : reactiveMap</span><br><span class=\"line\">        ).get(target)</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      return target</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 如果target是数组类型</span><br><span class=\"line\">    const targetIsArray = isArray(target)</span><br><span class=\"line\">    // 并且访问的key值是数组的原生方法，那么直接返回调用结果</span><br><span class=\"line\">    if (!isReadonly &amp;&amp; targetIsArray &amp;&amp; hasOwn(arrayInstrumentations, key)) &#123;</span><br><span class=\"line\">      return Reflect.get(arrayInstrumentations, key, receiver)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 求值</span><br><span class=\"line\">    const res = Reflect.get(target, key, receiver)</span><br><span class=\"line\">    // 判断访问的key是否是Symbol或者不需要响应式的key例如__proto__,__v_isRef,__isVue</span><br><span class=\"line\">    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) &#123;</span><br><span class=\"line\">      return res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 收集响应式，为了后面的effect方法可以检测到</span><br><span class=\"line\">    if (!isReadonly) &#123;</span><br><span class=\"line\">      track(target, TrackOpTypes.GET, key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 如果是非递归绑定，直接返回结果</span><br><span class=\"line\">    if (shallow) &#123;</span><br><span class=\"line\">      return res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果结果已经是响应式的，先判断类型，再返回</span><br><span class=\"line\">    if (isRef(res)) &#123;</span><br><span class=\"line\">      const shouldUnwrap = !targetIsArray || !isIntegerKey(key)</span><br><span class=\"line\">      return shouldUnwrap ? res.value : res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果当前key的结果也是一个对象，那么就要递归调用reactive方法对改对象再次执行响应式绑定逻辑</span><br><span class=\"line\">    if (isObject(res)) &#123;</span><br><span class=\"line\">      return isReadonly ? readonly(res) : reactive(res)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 返回结果</span><br><span class=\"line\">    return res</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面这段代码是Vue 3响应式的核心代码之一，其逻辑相对比较复杂，读者可以根据注释来理解，总结下来，这段代码主要做了以下事情：</p>\n<ul>\n<li>对于<code>handler.get</code>方法来说，最终都会返回当前对象对应key的结果即<code>obj[key]</code>，所以该段代码最终会return结果。</li>\n<li>对非响应式key，只读key等直接返回对应的结果。</li>\n<li>对于数组类型的target，key值如果是原型上的方法，例如includes，push，pop等，采用Reflect.get直接返回。</li>\n<li>在effect添加收集监听track，为响应式监听服务。</li>\n<li>当当前key对应的结果是一个对象时，为了保证set方法能够触发，需要循环递归的对这个对象进行响应式绑定即递归调用reactive()方法。</li>\n</ul>\n<p>handler.get方法主要功能是对结果value的返回，那么我们看看handler.set主要做了什么，其代码如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createSetter(shallow = false) &#123;</span><br><span class=\"line\">  return function set(</span><br><span class=\"line\">    target: object,</span><br><span class=\"line\">    key: string | symbol,</span><br><span class=\"line\">    value: unknown,// 即将被设置的新值</span><br><span class=\"line\">    receiver: object</span><br><span class=\"line\">  ): boolean &#123;</span><br><span class=\"line\">    // 缓存旧值</span><br><span class=\"line\">    let oldValue = (target as any)[key]</span><br><span class=\"line\">    if (!shallow) &#123;</span><br><span class=\"line\">      // 新旧值转换原始对象</span><br><span class=\"line\">      value = toRaw(value)</span><br><span class=\"line\">      oldValue = toRaw(oldValue)</span><br><span class=\"line\">      // 如果旧值已经是一个RefImpl对象且新值不是RefImpl对象</span><br><span class=\"line\">      // 例如var v = Vue.reactive(&#123;a:1,b:Vue.ref(&#123;c:3&#125;)&#125;)场景的set</span><br><span class=\"line\">if (!isArray(target) &amp;&amp; isRef(oldValue) &amp;&amp; !isRef(value)) &#123;</span><br><span class=\"line\">        oldValue.value = value // 直接将新值赋给旧址的响应式对象里</span><br><span class=\"line\">        return true</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 用来判断是否是新增key还是更新key的值</span><br><span class=\"line\">    const hadKey =</span><br><span class=\"line\">      isArray(target) &amp;&amp; isIntegerKey(key)</span><br><span class=\"line\">        ? Number(key) &lt; target.length</span><br><span class=\"line\">        : hasOwn(target, key)</span><br><span class=\"line\">    // 设置set结果，并添加监听effect逻辑</span><br><span class=\"line\">    const result = Reflect.set(target, key, value, receiver)</span><br><span class=\"line\">    // 判断target没有动过，包括在原型上添加或者删除某些项</span><br><span class=\"line\">    if (target === toRaw(receiver)) &#123;</span><br><span class=\"line\">      if (!hadKey) &#123;</span><br><span class=\"line\">        trigger(target, TriggerOpTypes.ADD, key, value)// 新增key的触发监听</span><br><span class=\"line\">      &#125; else if (hasChanged(value, oldValue)) &#123;</span><br><span class=\"line\">        trigger(target, TriggerOpTypes.SET, key, value, oldValue)// 更新key的触发监听</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 返回set结果 true/false</span><br><span class=\"line\">    return result</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>handler.set</code>方法核心功能是设置key对应的值即<code>obj[key] = value</code>，同时对新旧值进行逻辑判断和处理，最后添加上trigger触发监听track逻辑，便于触发effect。 如果读者感觉上述源码理解比较困难，笔者剔除一些边界和兼容判断，将整个流程进行梳理和简化，可以参考下面这段便于理解的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let foo = &#123;a:&#123;c:3,d:&#123;e:4&#125;&#125;,b:2&#125;</span><br><span class=\"line\">const isObject = (val)=&gt;&#123;</span><br><span class=\"line\">    return val !== null &amp;&amp; typeof val === &apos;object&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const createProxy = (target)=&gt;&#123;</span><br><span class=\"line\">    let p = new Proxy(target,&#123;</span><br><span class=\"line\">        get:(obj,key)=&gt;&#123;</span><br><span class=\"line\">            let res = obj[key] ? obj[key] : undefined</span><br><span class=\"line\"></span><br><span class=\"line\">            // 添加监听</span><br><span class=\"line\">            track(target)</span><br><span class=\"line\">            // 判断类型，避免死循环</span><br><span class=\"line\">            if (isObject(res)) &#123;</span><br><span class=\"line\">                return createProxy(res)// 循环递归调用</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                return res</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        set: (obj, key, value)=&gt; &#123;</span><br><span class=\"line\">          console.log(&apos;set&apos;)</span><br><span class=\"line\">          </span><br><span class=\"line\">          obj[key] = value;</span><br><span class=\"line\">          // 触发监听</span><br><span class=\"line\">          trigger(target)</span><br><span class=\"line\">          return true</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    return p</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let result = createProxy(foo)</span><br><span class=\"line\"></span><br><span class=\"line\">result.a.d.e = 6 // 打印出set</span><br></pre></td></tr></table></figure>\n<p>当尝试去修改一个多层嵌套的对象的属性时，会触发该属性的上一级对象的get方法，利用这个就可以对每个层级的对象添加Proxy代理，这样就实现了多层嵌套对象的属性修改问题，在此基础上同时添加track和trigger逻辑，就完成了基本的响应式流程。我们将在后面章节结合双向绑定来具体讲解track和trigger流程。</p>\n","site":{"data":{}},"excerpt":"<p>响应式reactivity是Vue 3相对于Vue 2改动比较大的一个模块，也是性能提升最多的一个模块。其核心改变是采用了ES 6的Proxy API来代替Vue2中Object.defineProperty方法来实现响应式，那么什么是Proxy API呢，Vue 3的响应式又是如何实现的，下面将会进行揭晓。<br>","more":"</p>\n<h2 id=\"Proxy-API\"><a href=\"#Proxy-API\" class=\"headerlink\" title=\"Proxy API\"></a>Proxy API</h2><p>Proxy API对应的Proxy对象是ES6就已引入的一个原生对象，用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。 从字面意思来理解，Proxy对象是目标对象的一个代理器，任何对目标对象的操作（实例化，添加/删除/修改属性等等），都必须通过该代理器。因此我们可以把来自外界的所有操作进行拦截和过滤或者修改等操作。 基于Proxy的这些特性，常用于：</p>\n<ul>\n<li>创建一个可“响应式”的对象，例如Vue3.0中的reactive方法。</li>\n<li>创建可隔离的JavaScript“沙箱”。</li>\n</ul>\n<p>Proxy的基本语法如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const p = new Proxy(target, handler)</span><br></pre></td></tr></table></figure>\n<p>其中，target参数表示要使用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理），handler参数表示以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理p的行为。常见使用方法如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let foo = &#123;</span><br><span class=\"line\"> a: 1,</span><br><span class=\"line\"> b: 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let handler = &#123;</span><br><span class=\"line\">    get:(obj,key)=&gt;&#123;</span><br><span class=\"line\">        console.log(&apos;get&apos;)</span><br><span class=\"line\">        return key in obj ? obj[key] : undefined</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let p = new Proxy(foo,handler)</span><br><span class=\"line\">console.log(p.a) // 打印1</span><br></pre></td></tr></table></figure>\n<p>上面代码中p就是foo的代理对象，对p对象的相关操作都会同步到foo对象上，同时Proxy也提供了另一种生成代理对象的方法Proxy.revocable()，如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123; proxy,revoke &#125; = Proxy.revocable(target, handler)</span><br></pre></td></tr></table></figure>\n<p>该方法的返回值是一个对象，其结构为： <code>{&quot;proxy&quot;: proxy, &quot;revoke&quot;: revoke}</code>，其中：proxy表示新生成的代理对象本身，和用一般方式<code>new Proxy(target, handler)</code>创建的代理对象没什么不同，只是它可以被撤销掉，revoke表示撤销方法，调用的时候不需要加任何参数，就可以撤销掉和它一起生成的那个代理对象，如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let foo = &#123;</span><br><span class=\"line\"> a: 1,</span><br><span class=\"line\"> b: 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let handler = &#123;</span><br><span class=\"line\">    get:(obj,key)=&gt;&#123;</span><br><span class=\"line\">        console.log(&apos;get&apos;)</span><br><span class=\"line\">        return key in obj ? obj[key] : undefined</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let &#123; proxy,revoke &#125; = Proxy.revocable(foo,handler)</span><br><span class=\"line\">console.log(proxy.a) // 打印1</span><br><span class=\"line\">revoke()</span><br><span class=\"line\">console.log(proxy.a) // 报错信息：Uncaught TypeError: Cannot perform &apos;get&apos; on a proxy that has been revoked</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，一旦某个代理对象被撤销，它将变得几乎完全不可调用，在它身上执行任何的可代理操作都会抛出TypeError异常。 在上面代码中，我们只使用了get操作的handler，即当尝试获取对象的某个属性时会进入这个方法，除此之外Proxy共有接近14个handler也可以称作为钩子，它们分别是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handler.getPrototypeOf()：</span><br><span class=\"line\">在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy) 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.setPrototypeOf()：</span><br><span class=\"line\">在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.isExtensible()：</span><br><span class=\"line\">在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.preventExtensions()：</span><br><span class=\"line\">在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.getOwnPropertyDescriptor()：</span><br><span class=\"line\">在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, &quot;foo&quot;) 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.defineProperty()：</span><br><span class=\"line\">在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, &quot;foo&quot;, &#123;&#125;) 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.has()：</span><br><span class=\"line\">在判断代理对象是否拥有某个属性时触发该操作，比如在执行 &quot;foo&quot; in proxy 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.get()：</span><br><span class=\"line\">在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.set()：</span><br><span class=\"line\">在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.deleteProperty()：</span><br><span class=\"line\">在删除代理对象的某个属性时触发该操作，即使用 delete 运算符，比如在执行 delete proxy.foo 时。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.ownKeys()：</span><br><span class=\"line\">当执行Object.getOwnPropertyNames(proxy) 和Object.getOwnPropertySymbols(proxy)时触发。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.apply()：</span><br><span class=\"line\">当代理对象是一个function函数时，调用apply()方法时触发，比如proxy.apply()。</span><br><span class=\"line\"></span><br><span class=\"line\">handler.construct()：</span><br><span class=\"line\">当代理对象是一个function函数时，通过new关键字实例化时触发，比如new proxy()。</span><br></pre></td></tr></table></figure>\n<p>结合这些handler，我们可以实现一些针对对象的限制操作，例如： 禁止删除和修改对象的某个属性，如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let foo = &#123;</span><br><span class=\"line\">    a:1,</span><br><span class=\"line\">    b:2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let handler = &#123;</span><br><span class=\"line\">    set:(obj,key,value,receiver)=&gt;&#123;</span><br><span class=\"line\">        console.log(&apos;set&apos;)</span><br><span class=\"line\">        if (key == &apos;a&apos;) throw new Error(&apos;can not change property:&apos;+key)</span><br><span class=\"line\">        obj[key] = value</span><br><span class=\"line\">        return true</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    deleteProperty:(obj,key)=&gt;&#123;</span><br><span class=\"line\">        console.log(&apos;delete&apos;)</span><br><span class=\"line\">        if (key == &apos;a&apos;) throw new Error(&apos;can not delete property:&apos;+key)</span><br><span class=\"line\">        delete obj[key]</span><br><span class=\"line\">        return true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let p = new Proxy(foo,handler)</span><br><span class=\"line\">// 尝试修改属性a</span><br><span class=\"line\">p.a = 3 // 报错信息：Uncaught Error</span><br><span class=\"line\">// 尝试删除属性a</span><br><span class=\"line\">delete p.a  // 报错信息：Uncaught Error</span><br></pre></td></tr></table></figure>\n<p>上面代码中，set方法多了一个receiver参数，这个参数通常是Proxy本身即p，场景是当有一段代码执行<code>obj.name=&quot;jen&quot;</code>，obj不是一个proxy，且自身不含name属性，但是它的原型链上有一个proxy，那么，那个proxy的handler里的set方法会被调用，而此时obj会作为receiver这个参数传进来。 对属性的修改进行校验，如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let foo = &#123;</span><br><span class=\"line\">    a:1,</span><br><span class=\"line\">    b:2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let handler = &#123;</span><br><span class=\"line\">    set:(obj,key,value)=&gt;&#123;</span><br><span class=\"line\">        console.log(&apos;set&apos;)</span><br><span class=\"line\">        if (typeof(value) !== &apos;number&apos;) throw new Error(&apos;can not change property:&apos;+key)</span><br><span class=\"line\">        obj[key] = value</span><br><span class=\"line\">        return true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let p = new Proxy(foo,handler)</span><br><span class=\"line\">p.a = &apos;hello&apos; // 报错信息：Uncaught Error</span><br></pre></td></tr></table></figure>\n<p>Proxy也能监听到数组变化，如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = [1]</span><br><span class=\"line\">let handler = &#123;</span><br><span class=\"line\">    set:(obj,key,value)=&gt;&#123;</span><br><span class=\"line\">        console.log(&apos;set&apos;) // 打印set</span><br><span class=\"line\">        return Reflect.set(obj, key, value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let p = new Proxy(arr,handler)</span><br><span class=\"line\">p.push(2) // 改变数组</span><br></pre></td></tr></table></figure>\n<p><code>Reflect.set()</code>用于修改数组的值，返回布尔类型，这也可以兼容修改数组原型上的方法对应场景，相当于<code>obj[key] = value</code>。</p>\n<h2 id=\"Proxy和响应式对象reactive\"><a href=\"#Proxy和响应式对象reactive\" class=\"headerlink\" title=\"Proxy和响应式对象reactive\"></a>Proxy和响应式对象reactive</h2><p>在Vue 3中，使用响应式对象方法如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;ref,reactive&#125; from &apos;vue&apos;</span><br><span class=\"line\">...</span><br><span class=\"line\">setup()&#123;</span><br><span class=\"line\">  const name = ref(&apos;test&apos;)</span><br><span class=\"line\">  const state = reactive(&#123;</span><br><span class=\"line\">    list: []</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  return &#123;name,state&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>在Vue 3中，Composition API中会经常使用创建响应式对象的方法ref/reactive，其内部就是利用了Proxy API来实现的，特别是借助handler的set方法，可以实现双向数据绑定相关的逻辑，这对于Vue 2中的Object.defineProperty()是很大的改变，主要提升如下：</p>\n<ul>\n<li><code>Object.defineProperty()</code>只能单一的监听已有属性的修改或者变化，无法检测到对象属性的新增或删除（Vue 2中是采用$set()方法来解决），而Proxy则可以轻松实现。</li>\n<li><code>Object.defineProperty()</code>无法监听响应式数据类型是数组的变化（主要是数组长度变化，Vue 2中采用重写数组相关方法并添加钩子来解决），而Proxy则可以轻松实现。</li>\n</ul>\n<p>正是由于Proxy的特性，在原本使用Object.defineProperty()需要很复杂的方式才能实现的上面两种能力，在Proxy无需任何配置，利用其原生的特性就可以轻松实现。</p>\n<h2 id=\"ref-方法运行原理\"><a href=\"#ref-方法运行原理\" class=\"headerlink\" title=\"ref()方法运行原理\"></a>ref()方法运行原理</h2><p>在Vue 3的源码中，所有关于响应式的代码都在vue-next/package/reactivity下面，其中reactivity/src/index.ts里暴露了所有可以使用的方法。我们以常用的ref()方法举例，来看看Vue 3是如何利用Proxy的。 ref()方法的主要逻辑在reactivity/src/ref.ts中，其代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">// 入口方法</span><br><span class=\"line\">export function ref(value?: unknown) &#123;</span><br><span class=\"line\">  return createRef(value, false)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function createRef(rawValue: unknown, shallow: boolean) &#123;</span><br><span class=\"line\">  // rawValue表示原始对象，shallow表示是否递归</span><br><span class=\"line\">  // 如果本身已经是ref对象，则直接返回</span><br><span class=\"line\">  if (isRef(rawValue)) &#123;</span><br><span class=\"line\">    return rawValue</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 创建一个新的RefImpl对象</span><br><span class=\"line\">  return new RefImpl(rawValue, shallow)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>createRef这个方法接收的第二个参数是shallow，表示是否是递归监听响应式，这个和另外一个响应式方法shallowRef()是对应的。在RefImpl构造函数中，有一个value属性，这个属性是由toReactive()方法所返回，toReactive()方法则在reactivity/src/reactive.ts文件中，如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class RefImpl&lt;T&gt; &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  constructor(value: T, public readonly _shallow: boolean) &#123;</span><br><span class=\"line\">    this._rawValue = _shallow ? value : toRaw(value)</span><br><span class=\"line\">    // 如果是非递归，调用toReactive</span><br><span class=\"line\">    this._value = _shallow ? value : toReactive(value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在reactive.ts中，则开始真正创建一个响应式对象，如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export function reactive(target: object) &#123;</span><br><span class=\"line\">  // 如果是readonly，则直接返回，就不添加响应式了</span><br><span class=\"line\">  if (target &amp;&amp; (target as Target)[ReactiveFlags.IS_READONLY]) &#123;</span><br><span class=\"line\">    return target</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return createReactiveObject(</span><br><span class=\"line\">    target,// 原始对象</span><br><span class=\"line\">    false,// 是否readonly</span><br><span class=\"line\">    mutableHandlers,// proxy的handler对象baseHandlers</span><br><span class=\"line\">    mutableCollectionHandlers,// proxy的handler对象collectionHandlers</span><br><span class=\"line\">    reactiveMap// proxy对象映射</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，<code>createReactiveObject()</code>方法传递了两种handler，分别是baseHandlers和collectionHandlers，如果target的类型是Map，Set，WeakMap，WeakSet则会使用collectionHandlers，类型是Object，Array则会是baseHandlers，如果是一个基础对象，也不会创建Proxy对象，reactiveMap则存储所有响应式对象的映射关系，用来避免同一个对象的重复创建响应式。我们在来看看createReactiveObject()方法的实现，如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createReactiveObject(...) &#123;</span><br><span class=\"line\">  // 如果target不满足typeof val === &apos;object&apos;，则直接返回target</span><br><span class=\"line\">  if (!isObject(target)) &#123;</span><br><span class=\"line\">    if (__DEV__) &#123;</span><br><span class=\"line\">      console.warn(`value cannot be made reactive: $&#123;String(target)&#125;`)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return target</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 如果target已经是proxy对象或者只读,则直接返回</span><br><span class=\"line\">  // exception: calling readonly() on a reactive object</span><br><span class=\"line\">  if (</span><br><span class=\"line\">    target[ReactiveFlags.RAW] &amp;&amp;</span><br><span class=\"line\">    !(isReadonly &amp;&amp; target[ReactiveFlags.IS_REACTIVE])</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    return target</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 如果target已经被创建过Proxy对象，则直接返回这个对象</span><br><span class=\"line\">  const existingProxy = proxyMap.get(target)</span><br><span class=\"line\">  if (existingProxy) &#123;</span><br><span class=\"line\">    return existingProxy</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 只有符合类型的target才能被创建响应式</span><br><span class=\"line\">  const targetType = getTargetType(target)</span><br><span class=\"line\">  if (targetType === TargetType.INVALID) &#123;</span><br><span class=\"line\">    return target</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 调用Proxy API创建响应式</span><br><span class=\"line\">  const proxy = new Proxy(</span><br><span class=\"line\">    target,</span><br><span class=\"line\">    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers</span><br><span class=\"line\">  )</span><br><span class=\"line\">  // 标记该对象已经创建过响应式</span><br><span class=\"line\">  proxyMap.set(target, proxy)</span><br><span class=\"line\">  return proxy</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到在<code>createReactiveObject()</code>方法中，主要做了以下事情：</p>\n<ul>\n<li>防止只读和重复创建响应式。</li>\n<li>根据不同的target类型选择不同的handler。</li>\n<li>创建Proxy对象。</li>\n</ul>\n<p>最终会调用new Proxy来创建响应式对象，我们以baseHandlers为例，看看这个handler是怎么实现的，在reactivity/src/baseHandlers.ts可以看到这部分代码，主要实现了这几个handler，如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const get = /*#__PURE__*/ createGetter()</span><br><span class=\"line\">...</span><br><span class=\"line\">export const mutableHandlers: ProxyHandler&lt;object&gt; = &#123;</span><br><span class=\"line\">  get,</span><br><span class=\"line\">  set,</span><br><span class=\"line\">  deleteProperty,</span><br><span class=\"line\">  has,</span><br><span class=\"line\">  ownKeys</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以handler.get为例看看在其内部做了什么操作，当我们尝试读取对象的属性时，便会进入get方法，其核心代码如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createGetter(isReadonly = false, shallow = false) &#123;</span><br><span class=\"line\">  return function get(target: Target, key: string | symbol, receiver: object) &#123;</span><br><span class=\"line\">    if (key === ReactiveFlags.IS_REACTIVE) &#123; // 如果访问对象的key是__v_isReactive，则直接返回常量</span><br><span class=\"line\">      return !isReadonly</span><br><span class=\"line\">    &#125; else if (key === ReactiveFlags.IS_READONLY) &#123;// 如果访问对象的key是__v_isReadonly，则直接返回常量</span><br><span class=\"line\">      return isReadonly</span><br><span class=\"line\">    &#125; else if (// 如果访问对象的key是__v_raw，或者原始对象只读对象等等直接返回target</span><br><span class=\"line\">      key === ReactiveFlags.RAW &amp;&amp;</span><br><span class=\"line\">      receiver ===</span><br><span class=\"line\">        (isReadonly</span><br><span class=\"line\">          ? shallow</span><br><span class=\"line\">            ? shallowReadonlyMap</span><br><span class=\"line\">            : readonlyMap</span><br><span class=\"line\">          : shallow</span><br><span class=\"line\">          ? shallowReactiveMap</span><br><span class=\"line\">          : reactiveMap</span><br><span class=\"line\">        ).get(target)</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      return target</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 如果target是数组类型</span><br><span class=\"line\">    const targetIsArray = isArray(target)</span><br><span class=\"line\">    // 并且访问的key值是数组的原生方法，那么直接返回调用结果</span><br><span class=\"line\">    if (!isReadonly &amp;&amp; targetIsArray &amp;&amp; hasOwn(arrayInstrumentations, key)) &#123;</span><br><span class=\"line\">      return Reflect.get(arrayInstrumentations, key, receiver)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 求值</span><br><span class=\"line\">    const res = Reflect.get(target, key, receiver)</span><br><span class=\"line\">    // 判断访问的key是否是Symbol或者不需要响应式的key例如__proto__,__v_isRef,__isVue</span><br><span class=\"line\">    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) &#123;</span><br><span class=\"line\">      return res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 收集响应式，为了后面的effect方法可以检测到</span><br><span class=\"line\">    if (!isReadonly) &#123;</span><br><span class=\"line\">      track(target, TrackOpTypes.GET, key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 如果是非递归绑定，直接返回结果</span><br><span class=\"line\">    if (shallow) &#123;</span><br><span class=\"line\">      return res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果结果已经是响应式的，先判断类型，再返回</span><br><span class=\"line\">    if (isRef(res)) &#123;</span><br><span class=\"line\">      const shouldUnwrap = !targetIsArray || !isIntegerKey(key)</span><br><span class=\"line\">      return shouldUnwrap ? res.value : res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果当前key的结果也是一个对象，那么就要递归调用reactive方法对改对象再次执行响应式绑定逻辑</span><br><span class=\"line\">    if (isObject(res)) &#123;</span><br><span class=\"line\">      return isReadonly ? readonly(res) : reactive(res)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 返回结果</span><br><span class=\"line\">    return res</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面这段代码是Vue 3响应式的核心代码之一，其逻辑相对比较复杂，读者可以根据注释来理解，总结下来，这段代码主要做了以下事情：</p>\n<ul>\n<li>对于<code>handler.get</code>方法来说，最终都会返回当前对象对应key的结果即<code>obj[key]</code>，所以该段代码最终会return结果。</li>\n<li>对非响应式key，只读key等直接返回对应的结果。</li>\n<li>对于数组类型的target，key值如果是原型上的方法，例如includes，push，pop等，采用Reflect.get直接返回。</li>\n<li>在effect添加收集监听track，为响应式监听服务。</li>\n<li>当当前key对应的结果是一个对象时，为了保证set方法能够触发，需要循环递归的对这个对象进行响应式绑定即递归调用reactive()方法。</li>\n</ul>\n<p>handler.get方法主要功能是对结果value的返回，那么我们看看handler.set主要做了什么，其代码如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createSetter(shallow = false) &#123;</span><br><span class=\"line\">  return function set(</span><br><span class=\"line\">    target: object,</span><br><span class=\"line\">    key: string | symbol,</span><br><span class=\"line\">    value: unknown,// 即将被设置的新值</span><br><span class=\"line\">    receiver: object</span><br><span class=\"line\">  ): boolean &#123;</span><br><span class=\"line\">    // 缓存旧值</span><br><span class=\"line\">    let oldValue = (target as any)[key]</span><br><span class=\"line\">    if (!shallow) &#123;</span><br><span class=\"line\">      // 新旧值转换原始对象</span><br><span class=\"line\">      value = toRaw(value)</span><br><span class=\"line\">      oldValue = toRaw(oldValue)</span><br><span class=\"line\">      // 如果旧值已经是一个RefImpl对象且新值不是RefImpl对象</span><br><span class=\"line\">      // 例如var v = Vue.reactive(&#123;a:1,b:Vue.ref(&#123;c:3&#125;)&#125;)场景的set</span><br><span class=\"line\">if (!isArray(target) &amp;&amp; isRef(oldValue) &amp;&amp; !isRef(value)) &#123;</span><br><span class=\"line\">        oldValue.value = value // 直接将新值赋给旧址的响应式对象里</span><br><span class=\"line\">        return true</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 用来判断是否是新增key还是更新key的值</span><br><span class=\"line\">    const hadKey =</span><br><span class=\"line\">      isArray(target) &amp;&amp; isIntegerKey(key)</span><br><span class=\"line\">        ? Number(key) &lt; target.length</span><br><span class=\"line\">        : hasOwn(target, key)</span><br><span class=\"line\">    // 设置set结果，并添加监听effect逻辑</span><br><span class=\"line\">    const result = Reflect.set(target, key, value, receiver)</span><br><span class=\"line\">    // 判断target没有动过，包括在原型上添加或者删除某些项</span><br><span class=\"line\">    if (target === toRaw(receiver)) &#123;</span><br><span class=\"line\">      if (!hadKey) &#123;</span><br><span class=\"line\">        trigger(target, TriggerOpTypes.ADD, key, value)// 新增key的触发监听</span><br><span class=\"line\">      &#125; else if (hasChanged(value, oldValue)) &#123;</span><br><span class=\"line\">        trigger(target, TriggerOpTypes.SET, key, value, oldValue)// 更新key的触发监听</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 返回set结果 true/false</span><br><span class=\"line\">    return result</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>handler.set</code>方法核心功能是设置key对应的值即<code>obj[key] = value</code>，同时对新旧值进行逻辑判断和处理，最后添加上trigger触发监听track逻辑，便于触发effect。 如果读者感觉上述源码理解比较困难，笔者剔除一些边界和兼容判断，将整个流程进行梳理和简化，可以参考下面这段便于理解的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let foo = &#123;a:&#123;c:3,d:&#123;e:4&#125;&#125;,b:2&#125;</span><br><span class=\"line\">const isObject = (val)=&gt;&#123;</span><br><span class=\"line\">    return val !== null &amp;&amp; typeof val === &apos;object&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const createProxy = (target)=&gt;&#123;</span><br><span class=\"line\">    let p = new Proxy(target,&#123;</span><br><span class=\"line\">        get:(obj,key)=&gt;&#123;</span><br><span class=\"line\">            let res = obj[key] ? obj[key] : undefined</span><br><span class=\"line\"></span><br><span class=\"line\">            // 添加监听</span><br><span class=\"line\">            track(target)</span><br><span class=\"line\">            // 判断类型，避免死循环</span><br><span class=\"line\">            if (isObject(res)) &#123;</span><br><span class=\"line\">                return createProxy(res)// 循环递归调用</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                return res</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        set: (obj, key, value)=&gt; &#123;</span><br><span class=\"line\">          console.log(&apos;set&apos;)</span><br><span class=\"line\">          </span><br><span class=\"line\">          obj[key] = value;</span><br><span class=\"line\">          // 触发监听</span><br><span class=\"line\">          trigger(target)</span><br><span class=\"line\">          return true</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    return p</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let result = createProxy(foo)</span><br><span class=\"line\"></span><br><span class=\"line\">result.a.d.e = 6 // 打印出set</span><br></pre></td></tr></table></figure>\n<p>当尝试去修改一个多层嵌套的对象的属性时，会触发该属性的上一级对象的get方法，利用这个就可以对每个层级的对象添加Proxy代理，这样就实现了多层嵌套对象的属性修改问题，在此基础上同时添加track和trigger逻辑，就完成了基本的响应式流程。我们将在后面章节结合双向绑定来具体讲解track和trigger流程。</p>"},{"title":"Vue3源码解析--目录结构","date":"2021-12-26T09:26:17.000Z","_content":"\n## 下载并启动Vue 3源码\nVue 3的源码地址可以在Github上下载，首先安装Git，然后使用如下命令：\n```\ngit clone https://github.com/vuejs/vue-next.git\n```\n<!--more-->\n完成后，Vue 3的源码被下载到vue-next文件夹下，打开CMD命令行工具，由于Vue 3源码采用Yarn进行构建，所以需要提前安装Yarn，如下命令安装：\n```\nnpm i yarn -g\n```\n然后进入vue-next目录，执行如下命令：\n```\nyarn --ignore-scripts\n```\n执行完该命令后，相关依赖就已经安装，执行npm run dev命令，即可开启Vue 3的源码调试模式，查看vue-next\\packages\\vue\\dist目录下的vue.global.js文件，即是开发模式下构建出的Vue 3源码文件，源码完整目录结构，如图所示。\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e59a1281bfa547c1824c35080867915c~tplv-k3u1fbpfcp-watermark.image?)\n\n其中，Vue 3和核心源码都在packages里面，并且是基于RollUp构建，其中每个目录代表的含义，如下所示：\n```\n├── packages              \n│   ├── compiler-core    // 核心编译器（平台无关）\n│   ├── compiler-dom     // dom编译器\n│   ├── compiler-sfc     // vue单文件编译器\n│   ├── compiler-ssr     // 服务端渲染编译\n│   ├── global.d.ts      // typescript声明文件\n│   ├── reactivity       // 响应式模块，可以与任何框架配合使用\n│   ├── runtime-core     // 运行时核心实例相关代码（平台无关）\n│   ├── runtime-dom      // 运行时dom 关api，属性，事件处理\n│   ├── runtime-test     // 运行时测试相关代码\n│   ├── server-renderer   // 服务端渲染\n│   ├── sfc-playground    // 单文件组件在线调试器\n│   ├── shared             // 内部工具库,不对外暴露API\n│   ├── size-check          // 简单应用，用来测试代码体积\n│   ├── template-explorer  // 用于调试编译器输出的开发工具\n│   └── vue                 // 面向公众的完整版本, 包含运行时和编译器\n```\n## 目录模块\n\n通过上面源码结构，可以看到有下面几个模块比较特别：\n* compiler-core\n* compiler-dom\n* runtime-core\n* runtime-dom\n\n可以看到core, dom 分别出现了两次，那么compiler和runtime它们之间又有什么区别呢？\n\n* compile：我们可以理解为程序编绎时，是指我们写好的源代码在被编译成为目标文件这段时间，可以通俗的看成是我们写好的源代码在被构建工具转换成为最终可执行的文件这段时间，在这里可以理解为我们将.vue文件编绎成浏览器能识别的.js文件的一些工作。\n* runtime：可以理解为程序运行时，即是程序被编译了之后，在浏览器打开程序并运行它直到程序关闭的这段时间的系列处理。\n\n\n在package目录下，除了上面列举的4个目录外，还有reactivity目录比较重要，他是响应式模块的源码，由于Vue 3整体源码采用的Monorepo规范，所以其下面每个子模块都可以独立编译和打包，从而独立对外提供服务，在使用时采用require('@vue/reactivity')引入，进入reactivity目录下可以看到有对应的package.json文件。\n\n其他目录：compiler-sfc是一个单文件组件编译工具，server-renderer目录是服务端渲染模块的源码，sfc-playground是一个在线Vue单文件组件调试工具，shared目录则包括了常用的工具库方法的源码，size-check是一个工具，可以用来测试代码体积，template-explorer用于调试编译器输出的开发工具，最后的vue目录则是Vue.js的完整源码产生目录。\n## 构建版本\n比较常见的是构建出来的Vue会有vue.global.js或者vue.runtime.global.js两种版本，他们分别表示：\n\n* vue.global.js：是包含编译器和运行时的“完整”构建版本，因此它支持动态编译模板。\n* vue.runtime.global.js：只包含运行时，并且需要在构建步骤期间预编译模板。\n\n其中，如果需要在客户端上编译模板 (即：将字符串传递给template 选项，或者使用元素的DOM内HTML 作为模板挂载到元素)，将需要编译器，因此需要完整的构建版本，如下代码所示：\n```\n// 需要编译器\nVue.createApp({\n  template: '<div>{{ hi }}</div>'\n})\n\n// 不需要\nVue.createApp({\n  render() {\n    return Vue.h('div', {}, this.hi)\n  }\n})\n```\n当使用Webpack的vue-loader时，*.vue 文件中的模板会在构建时预编译为JavaScript，在最终的捆绑包中并不需要编译器，因此可以只使用运行时构建版本。所以，如果直接在浏览器打开Vue的页面，可以直接采用`<script>`引入完整版本（正如之前章节中的示例代码一样），如果采用构建工具例如Webpack进行构建，则可以使用import引入运行时版本，和构建相关的脚本源码都在vue-next/scripts下面。例如，当我们需要构建出完整版时，可以在vue-next根目录执行，或者修改package.json的dev命令：\n```\nnode scripts/dev.js -f global-runtime\n```\n当需要构建运行时版本，执行：\n```\nnode scripts/dev.js -f global\n```\n具体的-f参数以及其他参数配置含义可以在vue-next/rollup.config.js里面找到。\n执行完成后在vue-next\\packages\\vue\\dist目录下可以得到对应的文件。所有Vue 3可构建出来的版本如下所示：\n```\n// cjs（用于服务端渲染）\nvue.cjs.js\nvue.cjs.prod.js（生产版，代码进行了压缩）\n\n// global（用于浏览器<script src=\"\" />标签导入，导入之后会增加一个全局的Vue对象）\nvue.global.js\nvue.global.prod.js（生产版，代码进行了压缩）\nvue.runtime.global.js\nvue.runtime.global.prod.js（生产版，代码进行了压缩）\n\n// browser（用于支持ES6 Modules浏览器<script type=\"module\" src=\"\"/>标签导入）\nvue.esm-browser.js\nvue.esm-browser.prod.js（生产版，代码进行了压缩）\nvue.runtime.esm-browser.js\nvue.runtime.esm-browser.prod.js（生产版，代码进行了压缩）\n\n// bundler（这两个版本没有打包所有的代码，只会打包使用的代码，需要配合打包工具来使用，会让Vue体积更小）\nvue.esm-bundler.js\nbue.runtime.esm-bundler.js\n```\n不同构建版本的Vue源文件需要在不同的平台和环境中使用，便于开发者可以选择合适的场景来使用。\n\n\n\n\n","source":"_posts/Vue3源码解析--目录结构.md","raw":"---\ntitle: Vue3源码解析--目录结构\ndate: 2021-12-26 17:26:17\ntags:\n- Vue3\n- 源码解析\ncategories:\n- 913\n\n---\n\n## 下载并启动Vue 3源码\nVue 3的源码地址可以在Github上下载，首先安装Git，然后使用如下命令：\n```\ngit clone https://github.com/vuejs/vue-next.git\n```\n<!--more-->\n完成后，Vue 3的源码被下载到vue-next文件夹下，打开CMD命令行工具，由于Vue 3源码采用Yarn进行构建，所以需要提前安装Yarn，如下命令安装：\n```\nnpm i yarn -g\n```\n然后进入vue-next目录，执行如下命令：\n```\nyarn --ignore-scripts\n```\n执行完该命令后，相关依赖就已经安装，执行npm run dev命令，即可开启Vue 3的源码调试模式，查看vue-next\\packages\\vue\\dist目录下的vue.global.js文件，即是开发模式下构建出的Vue 3源码文件，源码完整目录结构，如图所示。\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e59a1281bfa547c1824c35080867915c~tplv-k3u1fbpfcp-watermark.image?)\n\n其中，Vue 3和核心源码都在packages里面，并且是基于RollUp构建，其中每个目录代表的含义，如下所示：\n```\n├── packages              \n│   ├── compiler-core    // 核心编译器（平台无关）\n│   ├── compiler-dom     // dom编译器\n│   ├── compiler-sfc     // vue单文件编译器\n│   ├── compiler-ssr     // 服务端渲染编译\n│   ├── global.d.ts      // typescript声明文件\n│   ├── reactivity       // 响应式模块，可以与任何框架配合使用\n│   ├── runtime-core     // 运行时核心实例相关代码（平台无关）\n│   ├── runtime-dom      // 运行时dom 关api，属性，事件处理\n│   ├── runtime-test     // 运行时测试相关代码\n│   ├── server-renderer   // 服务端渲染\n│   ├── sfc-playground    // 单文件组件在线调试器\n│   ├── shared             // 内部工具库,不对外暴露API\n│   ├── size-check          // 简单应用，用来测试代码体积\n│   ├── template-explorer  // 用于调试编译器输出的开发工具\n│   └── vue                 // 面向公众的完整版本, 包含运行时和编译器\n```\n## 目录模块\n\n通过上面源码结构，可以看到有下面几个模块比较特别：\n* compiler-core\n* compiler-dom\n* runtime-core\n* runtime-dom\n\n可以看到core, dom 分别出现了两次，那么compiler和runtime它们之间又有什么区别呢？\n\n* compile：我们可以理解为程序编绎时，是指我们写好的源代码在被编译成为目标文件这段时间，可以通俗的看成是我们写好的源代码在被构建工具转换成为最终可执行的文件这段时间，在这里可以理解为我们将.vue文件编绎成浏览器能识别的.js文件的一些工作。\n* runtime：可以理解为程序运行时，即是程序被编译了之后，在浏览器打开程序并运行它直到程序关闭的这段时间的系列处理。\n\n\n在package目录下，除了上面列举的4个目录外，还有reactivity目录比较重要，他是响应式模块的源码，由于Vue 3整体源码采用的Monorepo规范，所以其下面每个子模块都可以独立编译和打包，从而独立对外提供服务，在使用时采用require('@vue/reactivity')引入，进入reactivity目录下可以看到有对应的package.json文件。\n\n其他目录：compiler-sfc是一个单文件组件编译工具，server-renderer目录是服务端渲染模块的源码，sfc-playground是一个在线Vue单文件组件调试工具，shared目录则包括了常用的工具库方法的源码，size-check是一个工具，可以用来测试代码体积，template-explorer用于调试编译器输出的开发工具，最后的vue目录则是Vue.js的完整源码产生目录。\n## 构建版本\n比较常见的是构建出来的Vue会有vue.global.js或者vue.runtime.global.js两种版本，他们分别表示：\n\n* vue.global.js：是包含编译器和运行时的“完整”构建版本，因此它支持动态编译模板。\n* vue.runtime.global.js：只包含运行时，并且需要在构建步骤期间预编译模板。\n\n其中，如果需要在客户端上编译模板 (即：将字符串传递给template 选项，或者使用元素的DOM内HTML 作为模板挂载到元素)，将需要编译器，因此需要完整的构建版本，如下代码所示：\n```\n// 需要编译器\nVue.createApp({\n  template: '<div>{{ hi }}</div>'\n})\n\n// 不需要\nVue.createApp({\n  render() {\n    return Vue.h('div', {}, this.hi)\n  }\n})\n```\n当使用Webpack的vue-loader时，*.vue 文件中的模板会在构建时预编译为JavaScript，在最终的捆绑包中并不需要编译器，因此可以只使用运行时构建版本。所以，如果直接在浏览器打开Vue的页面，可以直接采用`<script>`引入完整版本（正如之前章节中的示例代码一样），如果采用构建工具例如Webpack进行构建，则可以使用import引入运行时版本，和构建相关的脚本源码都在vue-next/scripts下面。例如，当我们需要构建出完整版时，可以在vue-next根目录执行，或者修改package.json的dev命令：\n```\nnode scripts/dev.js -f global-runtime\n```\n当需要构建运行时版本，执行：\n```\nnode scripts/dev.js -f global\n```\n具体的-f参数以及其他参数配置含义可以在vue-next/rollup.config.js里面找到。\n执行完成后在vue-next\\packages\\vue\\dist目录下可以得到对应的文件。所有Vue 3可构建出来的版本如下所示：\n```\n// cjs（用于服务端渲染）\nvue.cjs.js\nvue.cjs.prod.js（生产版，代码进行了压缩）\n\n// global（用于浏览器<script src=\"\" />标签导入，导入之后会增加一个全局的Vue对象）\nvue.global.js\nvue.global.prod.js（生产版，代码进行了压缩）\nvue.runtime.global.js\nvue.runtime.global.prod.js（生产版，代码进行了压缩）\n\n// browser（用于支持ES6 Modules浏览器<script type=\"module\" src=\"\"/>标签导入）\nvue.esm-browser.js\nvue.esm-browser.prod.js（生产版，代码进行了压缩）\nvue.runtime.esm-browser.js\nvue.runtime.esm-browser.prod.js（生产版，代码进行了压缩）\n\n// bundler（这两个版本没有打包所有的代码，只会打包使用的代码，需要配合打包工具来使用，会让Vue体积更小）\nvue.esm-bundler.js\nbue.runtime.esm-bundler.js\n```\n不同构建版本的Vue源文件需要在不同的平台和环境中使用，便于开发者可以选择合适的场景来使用。\n\n\n\n\n","slug":"Vue3源码解析--目录结构","published":1,"updated":"2021-12-13T01:32:07.398Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434q0g001p2wvjiojle814","content":"<h2><span id=\"下载并启动vue-3源码\">下载并启动Vue 3源码</span></h2><p>Vue 3的源码地址可以在Github上下载，首先安装Git，然后使用如下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/vuejs/vue-next.git</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>完成后，Vue 3的源码被下载到vue-next文件夹下，打开CMD命令行工具，由于Vue 3源码采用Yarn进行构建，所以需要提前安装Yarn，如下命令安装：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i yarn -g</span><br></pre></td></tr></table></figure></p>\n<p>然后进入vue-next目录，执行如下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn --ignore-scripts</span><br></pre></td></tr></table></figure></p>\n<p>执行完该命令后，相关依赖就已经安装，执行npm run dev命令，即可开启Vue 3的源码调试模式，查看vue-next\\packages\\vue\\dist目录下的vue.global.js文件，即是开发模式下构建出的Vue 3源码文件，源码完整目录结构，如图所示。<br><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e59a1281bfa547c1824c35080867915c~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>其中，Vue 3和核心源码都在packages里面，并且是基于RollUp构建，其中每个目录代表的含义，如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── packages              </span><br><span class=\"line\">│   ├── compiler-core    // 核心编译器（平台无关）</span><br><span class=\"line\">│   ├── compiler-dom     // dom编译器</span><br><span class=\"line\">│   ├── compiler-sfc     // vue单文件编译器</span><br><span class=\"line\">│   ├── compiler-ssr     // 服务端渲染编译</span><br><span class=\"line\">│   ├── global.d.ts      // typescript声明文件</span><br><span class=\"line\">│   ├── reactivity       // 响应式模块，可以与任何框架配合使用</span><br><span class=\"line\">│   ├── runtime-core     // 运行时核心实例相关代码（平台无关）</span><br><span class=\"line\">│   ├── runtime-dom      // 运行时dom 关api，属性，事件处理</span><br><span class=\"line\">│   ├── runtime-test     // 运行时测试相关代码</span><br><span class=\"line\">│   ├── server-renderer   // 服务端渲染</span><br><span class=\"line\">│   ├── sfc-playground    // 单文件组件在线调试器</span><br><span class=\"line\">│   ├── shared             // 内部工具库,不对外暴露API</span><br><span class=\"line\">│   ├── size-check          // 简单应用，用来测试代码体积</span><br><span class=\"line\">│   ├── template-explorer  // 用于调试编译器输出的开发工具</span><br><span class=\"line\">│   └── vue                 // 面向公众的完整版本, 包含运行时和编译器</span><br></pre></td></tr></table></figure></p>\n<h2><span id=\"目录模块\">目录模块</span></h2><p>通过上面源码结构，可以看到有下面几个模块比较特别：</p>\n<ul>\n<li>compiler-core</li>\n<li>compiler-dom</li>\n<li>runtime-core</li>\n<li>runtime-dom</li>\n</ul>\n<p>可以看到core, dom 分别出现了两次，那么compiler和runtime它们之间又有什么区别呢？</p>\n<ul>\n<li>compile：我们可以理解为程序编绎时，是指我们写好的源代码在被编译成为目标文件这段时间，可以通俗的看成是我们写好的源代码在被构建工具转换成为最终可执行的文件这段时间，在这里可以理解为我们将.vue文件编绎成浏览器能识别的.js文件的一些工作。</li>\n<li>runtime：可以理解为程序运行时，即是程序被编译了之后，在浏览器打开程序并运行它直到程序关闭的这段时间的系列处理。</li>\n</ul>\n<p>在package目录下，除了上面列举的4个目录外，还有reactivity目录比较重要，他是响应式模块的源码，由于Vue 3整体源码采用的Monorepo规范，所以其下面每个子模块都可以独立编译和打包，从而独立对外提供服务，在使用时采用require(‘@vue/reactivity’)引入，进入reactivity目录下可以看到有对应的package.json文件。</p>\n<p>其他目录：compiler-sfc是一个单文件组件编译工具，server-renderer目录是服务端渲染模块的源码，sfc-playground是一个在线Vue单文件组件调试工具，shared目录则包括了常用的工具库方法的源码，size-check是一个工具，可以用来测试代码体积，template-explorer用于调试编译器输出的开发工具，最后的vue目录则是Vue.js的完整源码产生目录。</p>\n<h2><span id=\"构建版本\">构建版本</span></h2><p>比较常见的是构建出来的Vue会有vue.global.js或者vue.runtime.global.js两种版本，他们分别表示：</p>\n<ul>\n<li>vue.global.js：是包含编译器和运行时的“完整”构建版本，因此它支持动态编译模板。</li>\n<li>vue.runtime.global.js：只包含运行时，并且需要在构建步骤期间预编译模板。</li>\n</ul>\n<p>其中，如果需要在客户端上编译模板 (即：将字符串传递给template 选项，或者使用元素的DOM内HTML 作为模板挂载到元素)，将需要编译器，因此需要完整的构建版本，如下代码所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 需要编译器</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  template: &apos;&lt;div&gt;&#123;&#123; hi &#125;&#125;&lt;/div&gt;&apos;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 不需要</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return Vue.h(&apos;div&apos;, &#123;&#125;, this.hi)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>当使用Webpack的vue-loader时，*.vue 文件中的模板会在构建时预编译为JavaScript，在最终的捆绑包中并不需要编译器，因此可以只使用运行时构建版本。所以，如果直接在浏览器打开Vue的页面，可以直接采用<code>&lt;script&gt;</code>引入完整版本（正如之前章节中的示例代码一样），如果采用构建工具例如Webpack进行构建，则可以使用import引入运行时版本，和构建相关的脚本源码都在vue-next/scripts下面。例如，当我们需要构建出完整版时，可以在vue-next根目录执行，或者修改package.json的dev命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node scripts/dev.js -f global-runtime</span><br></pre></td></tr></table></figure></p>\n<p>当需要构建运行时版本，执行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node scripts/dev.js -f global</span><br></pre></td></tr></table></figure></p>\n<p>具体的-f参数以及其他参数配置含义可以在vue-next/rollup.config.js里面找到。<br>执行完成后在vue-next\\packages\\vue\\dist目录下可以得到对应的文件。所有Vue 3可构建出来的版本如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// cjs（用于服务端渲染）</span><br><span class=\"line\">vue.cjs.js</span><br><span class=\"line\">vue.cjs.prod.js（生产版，代码进行了压缩）</span><br><span class=\"line\"></span><br><span class=\"line\">// global（用于浏览器&lt;script src=&quot;&quot; /&gt;标签导入，导入之后会增加一个全局的Vue对象）</span><br><span class=\"line\">vue.global.js</span><br><span class=\"line\">vue.global.prod.js（生产版，代码进行了压缩）</span><br><span class=\"line\">vue.runtime.global.js</span><br><span class=\"line\">vue.runtime.global.prod.js（生产版，代码进行了压缩）</span><br><span class=\"line\"></span><br><span class=\"line\">// browser（用于支持ES6 Modules浏览器&lt;script type=&quot;module&quot; src=&quot;&quot;/&gt;标签导入）</span><br><span class=\"line\">vue.esm-browser.js</span><br><span class=\"line\">vue.esm-browser.prod.js（生产版，代码进行了压缩）</span><br><span class=\"line\">vue.runtime.esm-browser.js</span><br><span class=\"line\">vue.runtime.esm-browser.prod.js（生产版，代码进行了压缩）</span><br><span class=\"line\"></span><br><span class=\"line\">// bundler（这两个版本没有打包所有的代码，只会打包使用的代码，需要配合打包工具来使用，会让Vue体积更小）</span><br><span class=\"line\">vue.esm-bundler.js</span><br><span class=\"line\">bue.runtime.esm-bundler.js</span><br></pre></td></tr></table></figure></p>\n<p>不同构建版本的Vue源文件需要在不同的平台和环境中使用，便于开发者可以选择合适的场景来使用。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"下载并启动Vue-3源码\"><a href=\"#下载并启动Vue-3源码\" class=\"headerlink\" title=\"下载并启动Vue 3源码\"></a>下载并启动Vue 3源码</h2><p>Vue 3的源码地址可以在Github上下载，首先安装Git，然后使用如下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/vuejs/vue-next.git</span><br></pre></td></tr></table></figure></p>","more":"<p>完成后，Vue 3的源码被下载到vue-next文件夹下，打开CMD命令行工具，由于Vue 3源码采用Yarn进行构建，所以需要提前安装Yarn，如下命令安装：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i yarn -g</span><br></pre></td></tr></table></figure></p>\n<p>然后进入vue-next目录，执行如下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn --ignore-scripts</span><br></pre></td></tr></table></figure></p>\n<p>执行完该命令后，相关依赖就已经安装，执行npm run dev命令，即可开启Vue 3的源码调试模式，查看vue-next\\packages\\vue\\dist目录下的vue.global.js文件，即是开发模式下构建出的Vue 3源码文件，源码完整目录结构，如图所示。<br><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e59a1281bfa547c1824c35080867915c~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>其中，Vue 3和核心源码都在packages里面，并且是基于RollUp构建，其中每个目录代表的含义，如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── packages              </span><br><span class=\"line\">│   ├── compiler-core    // 核心编译器（平台无关）</span><br><span class=\"line\">│   ├── compiler-dom     // dom编译器</span><br><span class=\"line\">│   ├── compiler-sfc     // vue单文件编译器</span><br><span class=\"line\">│   ├── compiler-ssr     // 服务端渲染编译</span><br><span class=\"line\">│   ├── global.d.ts      // typescript声明文件</span><br><span class=\"line\">│   ├── reactivity       // 响应式模块，可以与任何框架配合使用</span><br><span class=\"line\">│   ├── runtime-core     // 运行时核心实例相关代码（平台无关）</span><br><span class=\"line\">│   ├── runtime-dom      // 运行时dom 关api，属性，事件处理</span><br><span class=\"line\">│   ├── runtime-test     // 运行时测试相关代码</span><br><span class=\"line\">│   ├── server-renderer   // 服务端渲染</span><br><span class=\"line\">│   ├── sfc-playground    // 单文件组件在线调试器</span><br><span class=\"line\">│   ├── shared             // 内部工具库,不对外暴露API</span><br><span class=\"line\">│   ├── size-check          // 简单应用，用来测试代码体积</span><br><span class=\"line\">│   ├── template-explorer  // 用于调试编译器输出的开发工具</span><br><span class=\"line\">│   └── vue                 // 面向公众的完整版本, 包含运行时和编译器</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"目录模块\"><a href=\"#目录模块\" class=\"headerlink\" title=\"目录模块\"></a>目录模块</h2><p>通过上面源码结构，可以看到有下面几个模块比较特别：</p>\n<ul>\n<li>compiler-core</li>\n<li>compiler-dom</li>\n<li>runtime-core</li>\n<li>runtime-dom</li>\n</ul>\n<p>可以看到core, dom 分别出现了两次，那么compiler和runtime它们之间又有什么区别呢？</p>\n<ul>\n<li>compile：我们可以理解为程序编绎时，是指我们写好的源代码在被编译成为目标文件这段时间，可以通俗的看成是我们写好的源代码在被构建工具转换成为最终可执行的文件这段时间，在这里可以理解为我们将.vue文件编绎成浏览器能识别的.js文件的一些工作。</li>\n<li>runtime：可以理解为程序运行时，即是程序被编译了之后，在浏览器打开程序并运行它直到程序关闭的这段时间的系列处理。</li>\n</ul>\n<p>在package目录下，除了上面列举的4个目录外，还有reactivity目录比较重要，他是响应式模块的源码，由于Vue 3整体源码采用的Monorepo规范，所以其下面每个子模块都可以独立编译和打包，从而独立对外提供服务，在使用时采用require(‘@vue/reactivity’)引入，进入reactivity目录下可以看到有对应的package.json文件。</p>\n<p>其他目录：compiler-sfc是一个单文件组件编译工具，server-renderer目录是服务端渲染模块的源码，sfc-playground是一个在线Vue单文件组件调试工具，shared目录则包括了常用的工具库方法的源码，size-check是一个工具，可以用来测试代码体积，template-explorer用于调试编译器输出的开发工具，最后的vue目录则是Vue.js的完整源码产生目录。</p>\n<h2 id=\"构建版本\"><a href=\"#构建版本\" class=\"headerlink\" title=\"构建版本\"></a>构建版本</h2><p>比较常见的是构建出来的Vue会有vue.global.js或者vue.runtime.global.js两种版本，他们分别表示：</p>\n<ul>\n<li>vue.global.js：是包含编译器和运行时的“完整”构建版本，因此它支持动态编译模板。</li>\n<li>vue.runtime.global.js：只包含运行时，并且需要在构建步骤期间预编译模板。</li>\n</ul>\n<p>其中，如果需要在客户端上编译模板 (即：将字符串传递给template 选项，或者使用元素的DOM内HTML 作为模板挂载到元素)，将需要编译器，因此需要完整的构建版本，如下代码所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 需要编译器</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  template: &apos;&lt;div&gt;&#123;&#123; hi &#125;&#125;&lt;/div&gt;&apos;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 不需要</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return Vue.h(&apos;div&apos;, &#123;&#125;, this.hi)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>当使用Webpack的vue-loader时，*.vue 文件中的模板会在构建时预编译为JavaScript，在最终的捆绑包中并不需要编译器，因此可以只使用运行时构建版本。所以，如果直接在浏览器打开Vue的页面，可以直接采用<code>&lt;script&gt;</code>引入完整版本（正如之前章节中的示例代码一样），如果采用构建工具例如Webpack进行构建，则可以使用import引入运行时版本，和构建相关的脚本源码都在vue-next/scripts下面。例如，当我们需要构建出完整版时，可以在vue-next根目录执行，或者修改package.json的dev命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node scripts/dev.js -f global-runtime</span><br></pre></td></tr></table></figure></p>\n<p>当需要构建运行时版本，执行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node scripts/dev.js -f global</span><br></pre></td></tr></table></figure></p>\n<p>具体的-f参数以及其他参数配置含义可以在vue-next/rollup.config.js里面找到。<br>执行完成后在vue-next\\packages\\vue\\dist目录下可以得到对应的文件。所有Vue 3可构建出来的版本如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// cjs（用于服务端渲染）</span><br><span class=\"line\">vue.cjs.js</span><br><span class=\"line\">vue.cjs.prod.js（生产版，代码进行了压缩）</span><br><span class=\"line\"></span><br><span class=\"line\">// global（用于浏览器&lt;script src=&quot;&quot; /&gt;标签导入，导入之后会增加一个全局的Vue对象）</span><br><span class=\"line\">vue.global.js</span><br><span class=\"line\">vue.global.prod.js（生产版，代码进行了压缩）</span><br><span class=\"line\">vue.runtime.global.js</span><br><span class=\"line\">vue.runtime.global.prod.js（生产版，代码进行了压缩）</span><br><span class=\"line\"></span><br><span class=\"line\">// browser（用于支持ES6 Modules浏览器&lt;script type=&quot;module&quot; src=&quot;&quot;/&gt;标签导入）</span><br><span class=\"line\">vue.esm-browser.js</span><br><span class=\"line\">vue.esm-browser.prod.js（生产版，代码进行了压缩）</span><br><span class=\"line\">vue.runtime.esm-browser.js</span><br><span class=\"line\">vue.runtime.esm-browser.prod.js（生产版，代码进行了压缩）</span><br><span class=\"line\"></span><br><span class=\"line\">// bundler（这两个版本没有打包所有的代码，只会打包使用的代码，需要配合打包工具来使用，会让Vue体积更小）</span><br><span class=\"line\">vue.esm-bundler.js</span><br><span class=\"line\">bue.runtime.esm-bundler.js</span><br></pre></td></tr></table></figure></p>\n<p>不同构建版本的Vue源文件需要在不同的平台和环境中使用，便于开发者可以选择合适的场景来使用。</p>"},{"title":"Vue3源码解析--虚拟DOM","date":"2021-11-11T09:26:17.000Z","_content":"\n\n\n## 什么是虚拟DOM\n在浏览器中，HTML页面由基本的DOM树来组成的，当其中一部分发生变化时，其实就是对应某个DOM节点发生了变化，当DOM节点发生变化时就会触发对应的重绘或者重排，当过多的重绘和重排在短时间内发生时，就会可能引起页面的卡顿，所以改变DOM是有一些代价的，那么如何优化DOM变化的次数以及在合适的时机改变DOM就是开发者需要注意的事情。\n<!--more-->\n虚拟DOM就是为了解决上述浏览器性能问题而被设计出来的。当一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是和原本的DOM进行对比，将这10次更新的变化部分内容保存到内存中，最终一次性的应用在到DOM树上，再进行后续操作，避免大量无谓的计算量。\n\n虚拟DOM实际上就是采用JavaScript对象来存储DOM节点的信息，将DOM的更新变成对象的修改，并且这些修改计算在内存中发生，当修改完成后，再将JavaScript转换成真实的DOM节点，交给浏览器，从而达到性能的提升。\n例如下面一段DOM节点，如下代码所示：\n```\n<div id=\"app\">\n  <p class=\"text\">Hello</p>\n</div>\n```\n转换成一般的虚拟DOM对象结构，如下代码所示：\n```javascript\n{\n  tag: 'div',\n  props: {\n    id: 'app'\n  },\n  chidren: [\n    {\n      tag: 'p',\n      props: {\n        className: 'text'\n      },\n      chidren: [\n        'Hello'\n      ]\n    }\n  ]\n}\n```\n上面这段代码就是一个基本的虚拟DOM，但是他并非是Vue中使用的虚拟DOM结构，因为Vue要复杂的多。\n\n## Vue 3虚拟DOM\n\n在Vue中，我们写在`<template>`标签内的内容都属于DOM节点，这部分内容会被最终转换成Vue中的虚拟DOM对象VNode，其中的步骤比较复杂，主要有以下几个过程：\n\n* 抽取`<template>`内容进行compile编译。\n* 得到AST语法树，并生成render方法。\n* 执行render方法得到VNode对象。\n* VNode转换真实DOM并渲染到页面。\n\n完整流程如下图：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/447220e690a64adfb3a008573746d95c~tplv-k3u1fbpfcp-watermark.image?)\n\n我们以一个简单的demo为例子，在Vue 3的源码里去寻找，到底是如何一步一步进行了，demo如下代码所示：\n```\n<div id=\"app\">\n  <div>\n    {{name}}\n  </div>\n  <p>123</p>\n</div>\nVue.createApp({\n  data(){\n    return {\n      name : 'abc'\n    }\n  }\n}).mount(\"#app\")\n```\n上面代码中，data中定义了一个响应式数据name，并在`<template>`中使用插值表达式`{{name}}`进行使用，还有一个静态节点`<p>123</p>`。\n\n## 获取`<template>`内容\n\n调用`createApp()`方法，会进入到源码`packages/runtime-dom/src/index.ts`里面的createApp()方法，如下代码所示：\n\n```javascript\nexport const createApp = ((...args) => {\n  const app = ensureRenderer().createApp(...args)\n  ...\n  app.mount = (containerOrSelector: Element | ShadowRoot | string): any => {\n    if (!isFunction(component) && !component.render && !component.template) {\n      // 将#app绑定的HTML内容赋值给template项上\n      component.template = container.innerHTML\n\n      // 调用mount方法渲染\n    const proxy = mount(container, false, container instanceof SVGElement)\n    return proxy\n  }\n  ...\n  return app\n}) as CreateAppFunction<Element>\n```\n\n对于根组件来说，`<template>`的内容由挂载的`#app`元素里面的内容组成，如果项目是采用npm和Vue Cli+Webpack这种前端工程化的方式，那么对于`<template>`的内容则主要由对应的loader在构建时对文件进行处理来获取，这和在浏览器运行时的处理方式是不一样的。\n\n## 生成AST语法树\n\n在得到`<template>`后，就依据内容生成AST语法树。抽象语法树（Abstract Syntax Tree，AST），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。比如，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现；而类似于if-condition-then这样的条件跳转语句，可以使用带有三个分支的节点来表示。如下代码所示：\n```javascript\nwhile b ≠ 0\n  if a > b\na := a − b\n  else\nb := b − a\nreturn a\n```\n如果将上述代码转换成广泛意义上的语法树，如图所示。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/159a46e93d5f4c87980cfb549c8ab024~tplv-k3u1fbpfcp-watermark.image?)\n\n\n对于`<template>`的内容，其大部分是由DOM组成，但是也会有`if-condition-then`这样的条件语句，例如`v-if`，`v-for`指令等等，在Vue 3中，这部分逻辑在源码`packages\\compiler-core\\src\\compile.ts中baseCompile`方法，核心代码如下所示：\n\n```javascript\nexport function baseCompile(\n  template: string | RootNode,\n  options: CompilerOptions = {}\n): CodegenResult {\n  ...\n  // 通过template生成ast树结构\n  const ast = isString(template) ? baseParse(template, options) : template\n  ...\n  // 转换\n  transform(\n    ast,\n    ...\n  )\n  return generate(\n    ast,\n    extend({}, options, {\n      prefixIdentifiers\n    })\n  )\n}\n```\n\nbaseCompile方法主要做了以下事情：\n\n* 生成Vue中的AST对象。\n* 将AST对象作为参数传入transform函数，进行转换。\n* 将转换后的AST对象作为参数传入generate函数，生成render函数。\n\n其中，baseParse方法用来创建AST对象，在Vue 3中，AST对象是一个`RootNode`类型的树状结构，在源码`packages\\compiler-core\\src\\ast.ts`中，其结构如下代码所示：\n\n```javascript\nexport function createRoot(\n  children: TemplateChildNode[],\n  loc = locStub\n): RootNode {\n  return {\n    type: NodeTypes.ROOT, // 元素类型\n    children, // 子元素\n    helpers: [],// 帮助函数\n    components: [],// 子组件\n    directives: [], // 指令\n    hoists: [],// 标识静态节点\n    imports: [],\n    cached: 0, // 缓存标志位\n    temps: 0,\n    codegenNode: undefined,// 存储生成render函数字符串\n    loc // 描述元素在AST树的位置信息\n  }\n}\n```\n其中，children存储的时后代元素节点的数据，这就构成一个AST树结构，type表示元素的类型NodeType，主要分为HTML普通类型和Vue指令类型等，常见的有以下几种：\n```\nROOT,  // 根元素 0\nELEMENT, // 普通元素 1\nTEXT, // 文本元素 2\nCOMMENT, // 注释元素 3\nSIMPLE_EXPRESSION, // 表达式 4\nINTERPOLATION, // 插值表达式 {{ }} 5\nATTRIBUTE, // 属性 6\nDIRECTIVE, // 指令 7\nIF, // if节点 9\nJS_CALL_EXPRESSION, // 方法调用 14\n...\n```\n`hoists`是一个数组，用来存储一些可以静态提升的元素，在后面的`transform`会将静态元素和响应式元素分开创建，这也是Vue 3中优化的体现，codegenNode则用来存储最终生成的render方法的字符串，loc表示元素在AST树的位置信息。\n\n在生成AST树时，Vue 3在解析`<template>`内容时，会用一个栈`stack`来保存解析到的元素标签。当它遇到开始标签时，会将这个标签推入栈，遇到结束标签时，将刚才的标签弹出栈。它的作用是保存当前已经解析了，但还没解析完的元素标签。这个栈还有另一个作用，在解析到某个字节点时，通过`stack[stack.length - 1]`可以获取它的父元素。\n\ndemo代码中生成的AST语法树如下图所示。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/479408c50a0d40a586b31f70d9c3a16d~tplv-k3u1fbpfcp-watermark.image?)\n\n\n## 生成render方法字符串\n\n在得到`AST`对象后，会进入`transform`方法，在源码`packages\\compiler-core\\src\\transform.ts`中，其核心代码如下所示：\n\n```javascript\nexport function transform(root: RootNode, options: TransformOptions) {\n// 数据组装  \nconst context = createTransformContext(root, options)\n  // 转换代码\n  traverseNode(root, context)\n  // 静态提升\n  if (options.hoistStatic) {\n    hoistStatic(root, context)\n  }// 服务端渲染\n  if (!options.ssr) {\n    createRootCodegen(root, context)\n  }\n  // 透传元信息\n  root.helpers = [...context.helpers.keys()]\n  root.components = [...context.components]\n  root.directives = [...context.directives]\n  root.imports = context.imports\n  root.hoists = context.hoists\n  root.temps = context.temps\n  root.cached = context.cached\n  if (__COMPAT__) {\n    root.filters = [...context.filters!]\n  }\n}\n```\n\n`transform`方法主要是对AST进行进一步转化，为`generate`函数生成`render`方法做准备，主要做了以下事情：\n\n* traverseNode方法将会递归的检查和解析AST元素节点的属性，例如结合helpers方法对@click等事件添加对应的方法和事件回调，对插值表达式、指令、props添加动态绑定等。\n* 处理类型逻辑包括静态提升逻辑，将静态节点赋值给hoists，以及根据不同类型的节点打上不同的patchFlag，便于后续diff使用。\n* 在AST上绑定并透传一些元数据。\n\n`generate`方法主要是生成`render`方法的字符串code，在源码`packages\\compiler-core\\src\\codegen.ts`中，其核心代码如下所示：\n```javascript\nexport function generate(\n  ast: RootNode,\n  options: CodegenOptions & {\n    onContextCreated?: (context: CodegenContext) => void\n  } = {}\n): CodegenResult {\n  const context = createCodegenContext(ast, options)\n  if (options.onContextCreated) options.onContextCreated(context)\n  const {\n    mode,\n    push,\n    prefixIdentifiers,\n    indent,\n    deindent,\n    newline,\n    scopeId,\n    ssr\n  } = context\n  ...\n  // 缩进处理\n  indent()\n  deindent()\n  // 单独处理component、directive、filters\n  genAssets()\n  // 处理NodeTypes里的所有类型\n  genNode(ast.codegenNode, context)\n  ...\n  // 返回code字符串\n  return {\n    ast,\n    code: context.code,\n    preamble: isSetupInlined ? preambleContext.code : ``,\n    // SourceMapGenerator does have toJSON() method but it's not in the types\n    map: context.map ? (context.map as any).toJSON() : undefined\n  }\n}\n```\n`generate`方法的核心逻辑在`genNode`方法中，其逻辑是根据不同的NodeTypes类型构造出不同的`render`方法字符串，部分类型如下代码所示：\n```javascript\nswitch (node.type) {\ncase NodeTypes.ELEMENT:\ncase NodeTypes.IF:\ncase NodeTypes.FOR:// for关键字元素节点\n  genNode(node.codegenNode!, context)\n  break\ncase NodeTypes.TEXT:// 文本元素节点\n  genText(node, context)\n  break\ncase NodeTypes.VNODE_CALL:// 核心：VNode混合类型节点（AST语法树节点）\n  genVNodeCall(node, context)\n  break\ncase NodeTypes.COMMENT: // 注释元素节点\n  genComment(node, context)\n  break\ncase NodeTypes.JS_FUNCTION_EXPRESSION:// 方法调用节点\n  genFunctionExpression(node, context)\n  break\n...\n```\n其中：\n\n* 节点类型NodeTypes.VNODE_CALL对应genVNodeCall方法和ast.ts文件里面的createVNodeCall方法对应，后者用来返回VNodeCall，前者生成对应的VNodeCall这部分render方法字符串，是整个render方法字符串的核心。\n* 节点类型NodeTypes.FOR对应for关键字元素节点，其内部是递归调用了genNode方法。\n* 节点类型NodeTypes.TEXT对应文本元素节点负责静态文本的生成。\n* 节点类型NodeTypes.JS_FUNCTION_EXPRESSION对应方法调用节点，负责方法表达式的生成。\n\n终于，经过一系列的加工，最终生成的render方法字符串结果如下所示：\n```javascript\n(function anonymous(\n) {\nconst _Vue = Vue\nconst { createElementVNode: _createElementVNode } = _Vue\n\nconst _hoisted_1 = [\"data-a\"] // 静态节点\nconst _hoisted_2 = /*#__PURE__*/_createElementVNode(\"p\", null, \"123\", -1 /* HOISTED */)// 静态节点\n\nreturn function render(_ctx, _cache) {// render方法\n  with (_ctx) {\n    const { toDisplayString: _toDisplayString, createElementVNode: _createElementVNode, Fragment: _Fragment, openBlock: _openBlock, createElementBlock: _createElementBlock } = _Vue // helper方法\n\n    return (_openBlock(), _createElementBlock(_Fragment, null, [\n      _createElementVNode(\"div\", { \"data-a\": attr }, _toDisplayString(name), 9 /* TEXT, PROPS */, _hoisted_1),\n      _hoisted_2\n    ], 64 /* STABLE_FRAGMENT */))\n  }\n}\n})\n```\n\n`_createElementVNode`，`_openBlock`等等上一步传进来的`helper`方法。其中`<p>123</p>`这种属于没有响应式绑定的静态节点，会被单独区分，而对于动态节点会使用`createElementVNode`方法来创建，最终这两种节点会进入`createElementBlock`方法进行VNode的创建。\n\nrender方法中使用了with关键字，with的作用如下代码所示：\n```javascript\nconst obj = {\n  a:1\n}\nwith(obj){\n  console.log(a) // 打印1\n}\n```\n在`with(_ctx)`包裹下，我们在data中定义的响应式变量才能正常使用，例如调用`_toDisplayString(name)`，其中name就是响应式变量。\n\n## 得到最终VNode对象\n\n最终，这是一段可执行代码，会赋值给组件`Component.render`方法上，其源码在`packages\\runtime-core\\src\\component.ts`中，如下所示：\n```javascript\n...\nComponent.render = compile(template, finalCompilerOptions)\n...\nif (installWithProxy) { // 绑定代理\n   installWithProxy(instance)\n}\n...\n```\n`compile`方法是最初`baseCompile`方法的入口，在完成赋值后，还需要绑定代理，执行`installWithProxy`方法，其源码在`runtime-core/src/component.ts`中，如下所示：\n```javascript\nexport function registerRuntimeCompiler(_compile: any) {\n  compile = _compile\n  installWithProxy = i => {\n    if (i.render!._rc) {\n      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers)\n    }\n  }\n}\n```\n这主要是给`render`里`_ctx`的响应式变量添加绑定，当上面`render`方法里的`name`被使用时，可以通过代理监听到调用，这样就会进入响应式的监听收集`track`，当触发`trigger`监听时，进行`diff`。\n\n在`runtime-core/src/componentRenderUtils.ts`源码里的`renderComponentRoot`方法里会执行`render`方法得到`VNode`对象，其核心代码如下所示：\n```javascript\nexport function renderComponentRoot(){\n  // 执行render\n  let result = normalizeVNode(render!.call(\n        proxyToUse,\n        proxyToUse!,\n        renderCache,\n        props,\n        setupState,\n        data,\n        ctx\n      ))\n  ...\n\n  return result\n}\n```\ndemo代码中最终得到的VNode对象如下图所示。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f3fe695743a49ee99fd69c98ccc2331~tplv-k3u1fbpfcp-watermark.image?)\n\n上图就是通过`render`方法运行后得到的`VNode`对象，可以看到`children`和`dynamicChildren`区分，前者包括了两个子节点分别是`<div>`和`<p>`这个和在`<template>`里面定义的内容是对应的，而后者只存储了动态节点，包括动态`props`即`data-a`属性。同时`VNode`也是树状结构，通过`children`和`dynamicChildren`一层一层递进下去。\n\n在通过`render`方法得到`VNode`的过程也是对指令，插值表达式，响应式数据，插槽等一系列Vue语法的解析和构造过程，最终生成结构化的`VNode`对象，可以将整个过程总结成流程图，便于读者理解，如下图所示。\n\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/447220e690a64adfb3a008573746d95c~tplv-k3u1fbpfcp-watermark.image?)\n\n另外一个需要关注的属性是patchFlag这个是后面进行VNode的diff时所用到的标志位，数字64表示稳定不需要改变。最后得到VNode对象后需要转换成真实的DOM节点，这部分逻辑是在虚拟DOM的diff中完成的，在后面的双向绑定原理解析中进行讲解。\n\n\n","source":"_posts/Vue3源码解析--虚拟DOM.md","raw":"---\ntitle: Vue3源码解析--虚拟DOM\ndate: 2021-11-11 17:26:17\ntags:\n- Vue3\n- 源码解析\ncategories:\n- 916\n\n---\n\n\n\n## 什么是虚拟DOM\n在浏览器中，HTML页面由基本的DOM树来组成的，当其中一部分发生变化时，其实就是对应某个DOM节点发生了变化，当DOM节点发生变化时就会触发对应的重绘或者重排，当过多的重绘和重排在短时间内发生时，就会可能引起页面的卡顿，所以改变DOM是有一些代价的，那么如何优化DOM变化的次数以及在合适的时机改变DOM就是开发者需要注意的事情。\n<!--more-->\n虚拟DOM就是为了解决上述浏览器性能问题而被设计出来的。当一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是和原本的DOM进行对比，将这10次更新的变化部分内容保存到内存中，最终一次性的应用在到DOM树上，再进行后续操作，避免大量无谓的计算量。\n\n虚拟DOM实际上就是采用JavaScript对象来存储DOM节点的信息，将DOM的更新变成对象的修改，并且这些修改计算在内存中发生，当修改完成后，再将JavaScript转换成真实的DOM节点，交给浏览器，从而达到性能的提升。\n例如下面一段DOM节点，如下代码所示：\n```\n<div id=\"app\">\n  <p class=\"text\">Hello</p>\n</div>\n```\n转换成一般的虚拟DOM对象结构，如下代码所示：\n```javascript\n{\n  tag: 'div',\n  props: {\n    id: 'app'\n  },\n  chidren: [\n    {\n      tag: 'p',\n      props: {\n        className: 'text'\n      },\n      chidren: [\n        'Hello'\n      ]\n    }\n  ]\n}\n```\n上面这段代码就是一个基本的虚拟DOM，但是他并非是Vue中使用的虚拟DOM结构，因为Vue要复杂的多。\n\n## Vue 3虚拟DOM\n\n在Vue中，我们写在`<template>`标签内的内容都属于DOM节点，这部分内容会被最终转换成Vue中的虚拟DOM对象VNode，其中的步骤比较复杂，主要有以下几个过程：\n\n* 抽取`<template>`内容进行compile编译。\n* 得到AST语法树，并生成render方法。\n* 执行render方法得到VNode对象。\n* VNode转换真实DOM并渲染到页面。\n\n完整流程如下图：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/447220e690a64adfb3a008573746d95c~tplv-k3u1fbpfcp-watermark.image?)\n\n我们以一个简单的demo为例子，在Vue 3的源码里去寻找，到底是如何一步一步进行了，demo如下代码所示：\n```\n<div id=\"app\">\n  <div>\n    {{name}}\n  </div>\n  <p>123</p>\n</div>\nVue.createApp({\n  data(){\n    return {\n      name : 'abc'\n    }\n  }\n}).mount(\"#app\")\n```\n上面代码中，data中定义了一个响应式数据name，并在`<template>`中使用插值表达式`{{name}}`进行使用，还有一个静态节点`<p>123</p>`。\n\n## 获取`<template>`内容\n\n调用`createApp()`方法，会进入到源码`packages/runtime-dom/src/index.ts`里面的createApp()方法，如下代码所示：\n\n```javascript\nexport const createApp = ((...args) => {\n  const app = ensureRenderer().createApp(...args)\n  ...\n  app.mount = (containerOrSelector: Element | ShadowRoot | string): any => {\n    if (!isFunction(component) && !component.render && !component.template) {\n      // 将#app绑定的HTML内容赋值给template项上\n      component.template = container.innerHTML\n\n      // 调用mount方法渲染\n    const proxy = mount(container, false, container instanceof SVGElement)\n    return proxy\n  }\n  ...\n  return app\n}) as CreateAppFunction<Element>\n```\n\n对于根组件来说，`<template>`的内容由挂载的`#app`元素里面的内容组成，如果项目是采用npm和Vue Cli+Webpack这种前端工程化的方式，那么对于`<template>`的内容则主要由对应的loader在构建时对文件进行处理来获取，这和在浏览器运行时的处理方式是不一样的。\n\n## 生成AST语法树\n\n在得到`<template>`后，就依据内容生成AST语法树。抽象语法树（Abstract Syntax Tree，AST），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。比如，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现；而类似于if-condition-then这样的条件跳转语句，可以使用带有三个分支的节点来表示。如下代码所示：\n```javascript\nwhile b ≠ 0\n  if a > b\na := a − b\n  else\nb := b − a\nreturn a\n```\n如果将上述代码转换成广泛意义上的语法树，如图所示。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/159a46e93d5f4c87980cfb549c8ab024~tplv-k3u1fbpfcp-watermark.image?)\n\n\n对于`<template>`的内容，其大部分是由DOM组成，但是也会有`if-condition-then`这样的条件语句，例如`v-if`，`v-for`指令等等，在Vue 3中，这部分逻辑在源码`packages\\compiler-core\\src\\compile.ts中baseCompile`方法，核心代码如下所示：\n\n```javascript\nexport function baseCompile(\n  template: string | RootNode,\n  options: CompilerOptions = {}\n): CodegenResult {\n  ...\n  // 通过template生成ast树结构\n  const ast = isString(template) ? baseParse(template, options) : template\n  ...\n  // 转换\n  transform(\n    ast,\n    ...\n  )\n  return generate(\n    ast,\n    extend({}, options, {\n      prefixIdentifiers\n    })\n  )\n}\n```\n\nbaseCompile方法主要做了以下事情：\n\n* 生成Vue中的AST对象。\n* 将AST对象作为参数传入transform函数，进行转换。\n* 将转换后的AST对象作为参数传入generate函数，生成render函数。\n\n其中，baseParse方法用来创建AST对象，在Vue 3中，AST对象是一个`RootNode`类型的树状结构，在源码`packages\\compiler-core\\src\\ast.ts`中，其结构如下代码所示：\n\n```javascript\nexport function createRoot(\n  children: TemplateChildNode[],\n  loc = locStub\n): RootNode {\n  return {\n    type: NodeTypes.ROOT, // 元素类型\n    children, // 子元素\n    helpers: [],// 帮助函数\n    components: [],// 子组件\n    directives: [], // 指令\n    hoists: [],// 标识静态节点\n    imports: [],\n    cached: 0, // 缓存标志位\n    temps: 0,\n    codegenNode: undefined,// 存储生成render函数字符串\n    loc // 描述元素在AST树的位置信息\n  }\n}\n```\n其中，children存储的时后代元素节点的数据，这就构成一个AST树结构，type表示元素的类型NodeType，主要分为HTML普通类型和Vue指令类型等，常见的有以下几种：\n```\nROOT,  // 根元素 0\nELEMENT, // 普通元素 1\nTEXT, // 文本元素 2\nCOMMENT, // 注释元素 3\nSIMPLE_EXPRESSION, // 表达式 4\nINTERPOLATION, // 插值表达式 {{ }} 5\nATTRIBUTE, // 属性 6\nDIRECTIVE, // 指令 7\nIF, // if节点 9\nJS_CALL_EXPRESSION, // 方法调用 14\n...\n```\n`hoists`是一个数组，用来存储一些可以静态提升的元素，在后面的`transform`会将静态元素和响应式元素分开创建，这也是Vue 3中优化的体现，codegenNode则用来存储最终生成的render方法的字符串，loc表示元素在AST树的位置信息。\n\n在生成AST树时，Vue 3在解析`<template>`内容时，会用一个栈`stack`来保存解析到的元素标签。当它遇到开始标签时，会将这个标签推入栈，遇到结束标签时，将刚才的标签弹出栈。它的作用是保存当前已经解析了，但还没解析完的元素标签。这个栈还有另一个作用，在解析到某个字节点时，通过`stack[stack.length - 1]`可以获取它的父元素。\n\ndemo代码中生成的AST语法树如下图所示。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/479408c50a0d40a586b31f70d9c3a16d~tplv-k3u1fbpfcp-watermark.image?)\n\n\n## 生成render方法字符串\n\n在得到`AST`对象后，会进入`transform`方法，在源码`packages\\compiler-core\\src\\transform.ts`中，其核心代码如下所示：\n\n```javascript\nexport function transform(root: RootNode, options: TransformOptions) {\n// 数据组装  \nconst context = createTransformContext(root, options)\n  // 转换代码\n  traverseNode(root, context)\n  // 静态提升\n  if (options.hoistStatic) {\n    hoistStatic(root, context)\n  }// 服务端渲染\n  if (!options.ssr) {\n    createRootCodegen(root, context)\n  }\n  // 透传元信息\n  root.helpers = [...context.helpers.keys()]\n  root.components = [...context.components]\n  root.directives = [...context.directives]\n  root.imports = context.imports\n  root.hoists = context.hoists\n  root.temps = context.temps\n  root.cached = context.cached\n  if (__COMPAT__) {\n    root.filters = [...context.filters!]\n  }\n}\n```\n\n`transform`方法主要是对AST进行进一步转化，为`generate`函数生成`render`方法做准备，主要做了以下事情：\n\n* traverseNode方法将会递归的检查和解析AST元素节点的属性，例如结合helpers方法对@click等事件添加对应的方法和事件回调，对插值表达式、指令、props添加动态绑定等。\n* 处理类型逻辑包括静态提升逻辑，将静态节点赋值给hoists，以及根据不同类型的节点打上不同的patchFlag，便于后续diff使用。\n* 在AST上绑定并透传一些元数据。\n\n`generate`方法主要是生成`render`方法的字符串code，在源码`packages\\compiler-core\\src\\codegen.ts`中，其核心代码如下所示：\n```javascript\nexport function generate(\n  ast: RootNode,\n  options: CodegenOptions & {\n    onContextCreated?: (context: CodegenContext) => void\n  } = {}\n): CodegenResult {\n  const context = createCodegenContext(ast, options)\n  if (options.onContextCreated) options.onContextCreated(context)\n  const {\n    mode,\n    push,\n    prefixIdentifiers,\n    indent,\n    deindent,\n    newline,\n    scopeId,\n    ssr\n  } = context\n  ...\n  // 缩进处理\n  indent()\n  deindent()\n  // 单独处理component、directive、filters\n  genAssets()\n  // 处理NodeTypes里的所有类型\n  genNode(ast.codegenNode, context)\n  ...\n  // 返回code字符串\n  return {\n    ast,\n    code: context.code,\n    preamble: isSetupInlined ? preambleContext.code : ``,\n    // SourceMapGenerator does have toJSON() method but it's not in the types\n    map: context.map ? (context.map as any).toJSON() : undefined\n  }\n}\n```\n`generate`方法的核心逻辑在`genNode`方法中，其逻辑是根据不同的NodeTypes类型构造出不同的`render`方法字符串，部分类型如下代码所示：\n```javascript\nswitch (node.type) {\ncase NodeTypes.ELEMENT:\ncase NodeTypes.IF:\ncase NodeTypes.FOR:// for关键字元素节点\n  genNode(node.codegenNode!, context)\n  break\ncase NodeTypes.TEXT:// 文本元素节点\n  genText(node, context)\n  break\ncase NodeTypes.VNODE_CALL:// 核心：VNode混合类型节点（AST语法树节点）\n  genVNodeCall(node, context)\n  break\ncase NodeTypes.COMMENT: // 注释元素节点\n  genComment(node, context)\n  break\ncase NodeTypes.JS_FUNCTION_EXPRESSION:// 方法调用节点\n  genFunctionExpression(node, context)\n  break\n...\n```\n其中：\n\n* 节点类型NodeTypes.VNODE_CALL对应genVNodeCall方法和ast.ts文件里面的createVNodeCall方法对应，后者用来返回VNodeCall，前者生成对应的VNodeCall这部分render方法字符串，是整个render方法字符串的核心。\n* 节点类型NodeTypes.FOR对应for关键字元素节点，其内部是递归调用了genNode方法。\n* 节点类型NodeTypes.TEXT对应文本元素节点负责静态文本的生成。\n* 节点类型NodeTypes.JS_FUNCTION_EXPRESSION对应方法调用节点，负责方法表达式的生成。\n\n终于，经过一系列的加工，最终生成的render方法字符串结果如下所示：\n```javascript\n(function anonymous(\n) {\nconst _Vue = Vue\nconst { createElementVNode: _createElementVNode } = _Vue\n\nconst _hoisted_1 = [\"data-a\"] // 静态节点\nconst _hoisted_2 = /*#__PURE__*/_createElementVNode(\"p\", null, \"123\", -1 /* HOISTED */)// 静态节点\n\nreturn function render(_ctx, _cache) {// render方法\n  with (_ctx) {\n    const { toDisplayString: _toDisplayString, createElementVNode: _createElementVNode, Fragment: _Fragment, openBlock: _openBlock, createElementBlock: _createElementBlock } = _Vue // helper方法\n\n    return (_openBlock(), _createElementBlock(_Fragment, null, [\n      _createElementVNode(\"div\", { \"data-a\": attr }, _toDisplayString(name), 9 /* TEXT, PROPS */, _hoisted_1),\n      _hoisted_2\n    ], 64 /* STABLE_FRAGMENT */))\n  }\n}\n})\n```\n\n`_createElementVNode`，`_openBlock`等等上一步传进来的`helper`方法。其中`<p>123</p>`这种属于没有响应式绑定的静态节点，会被单独区分，而对于动态节点会使用`createElementVNode`方法来创建，最终这两种节点会进入`createElementBlock`方法进行VNode的创建。\n\nrender方法中使用了with关键字，with的作用如下代码所示：\n```javascript\nconst obj = {\n  a:1\n}\nwith(obj){\n  console.log(a) // 打印1\n}\n```\n在`with(_ctx)`包裹下，我们在data中定义的响应式变量才能正常使用，例如调用`_toDisplayString(name)`，其中name就是响应式变量。\n\n## 得到最终VNode对象\n\n最终，这是一段可执行代码，会赋值给组件`Component.render`方法上，其源码在`packages\\runtime-core\\src\\component.ts`中，如下所示：\n```javascript\n...\nComponent.render = compile(template, finalCompilerOptions)\n...\nif (installWithProxy) { // 绑定代理\n   installWithProxy(instance)\n}\n...\n```\n`compile`方法是最初`baseCompile`方法的入口，在完成赋值后，还需要绑定代理，执行`installWithProxy`方法，其源码在`runtime-core/src/component.ts`中，如下所示：\n```javascript\nexport function registerRuntimeCompiler(_compile: any) {\n  compile = _compile\n  installWithProxy = i => {\n    if (i.render!._rc) {\n      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers)\n    }\n  }\n}\n```\n这主要是给`render`里`_ctx`的响应式变量添加绑定，当上面`render`方法里的`name`被使用时，可以通过代理监听到调用，这样就会进入响应式的监听收集`track`，当触发`trigger`监听时，进行`diff`。\n\n在`runtime-core/src/componentRenderUtils.ts`源码里的`renderComponentRoot`方法里会执行`render`方法得到`VNode`对象，其核心代码如下所示：\n```javascript\nexport function renderComponentRoot(){\n  // 执行render\n  let result = normalizeVNode(render!.call(\n        proxyToUse,\n        proxyToUse!,\n        renderCache,\n        props,\n        setupState,\n        data,\n        ctx\n      ))\n  ...\n\n  return result\n}\n```\ndemo代码中最终得到的VNode对象如下图所示。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f3fe695743a49ee99fd69c98ccc2331~tplv-k3u1fbpfcp-watermark.image?)\n\n上图就是通过`render`方法运行后得到的`VNode`对象，可以看到`children`和`dynamicChildren`区分，前者包括了两个子节点分别是`<div>`和`<p>`这个和在`<template>`里面定义的内容是对应的，而后者只存储了动态节点，包括动态`props`即`data-a`属性。同时`VNode`也是树状结构，通过`children`和`dynamicChildren`一层一层递进下去。\n\n在通过`render`方法得到`VNode`的过程也是对指令，插值表达式，响应式数据，插槽等一系列Vue语法的解析和构造过程，最终生成结构化的`VNode`对象，可以将整个过程总结成流程图，便于读者理解，如下图所示。\n\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/447220e690a64adfb3a008573746d95c~tplv-k3u1fbpfcp-watermark.image?)\n\n另外一个需要关注的属性是patchFlag这个是后面进行VNode的diff时所用到的标志位，数字64表示稳定不需要改变。最后得到VNode对象后需要转换成真实的DOM节点，这部分逻辑是在虚拟DOM的diff中完成的，在后面的双向绑定原理解析中进行讲解。\n\n\n","slug":"Vue3源码解析--虚拟DOM","published":1,"updated":"2021-12-13T01:32:10.692Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434q0i001s2wvj3l2k6acm","content":"<h2><span id=\"什么是虚拟dom\">什么是虚拟DOM</span></h2><p>在浏览器中，HTML页面由基本的DOM树来组成的，当其中一部分发生变化时，其实就是对应某个DOM节点发生了变化，当DOM节点发生变化时就会触发对应的重绘或者重排，当过多的重绘和重排在短时间内发生时，就会可能引起页面的卡顿，所以改变DOM是有一些代价的，那么如何优化DOM变化的次数以及在合适的时机改变DOM就是开发者需要注意的事情。<br><a id=\"more\"></a><br>虚拟DOM就是为了解决上述浏览器性能问题而被设计出来的。当一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是和原本的DOM进行对比，将这10次更新的变化部分内容保存到内存中，最终一次性的应用在到DOM树上，再进行后续操作，避免大量无谓的计算量。</p>\n<p>虚拟DOM实际上就是采用JavaScript对象来存储DOM节点的信息，将DOM的更新变成对象的修改，并且这些修改计算在内存中发生，当修改完成后，再将JavaScript转换成真实的DOM节点，交给浏览器，从而达到性能的提升。<br>例如下面一段DOM节点，如下代码所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;p class=&quot;text&quot;&gt;Hello&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>转换成一般的虚拟DOM对象结构，如下代码所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  tag: <span class=\"string\">'div'</span>,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    id: <span class=\"string\">'app'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  chidren: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      tag: <span class=\"string\">'p'</span>,</span><br><span class=\"line\">      props: &#123;</span><br><span class=\"line\">        className: <span class=\"string\">'text'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      chidren: [</span><br><span class=\"line\">        <span class=\"string\">'Hello'</span></span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面这段代码就是一个基本的虚拟DOM，但是他并非是Vue中使用的虚拟DOM结构，因为Vue要复杂的多。</p>\n<h2><span id=\"vue-3虚拟dom\">Vue 3虚拟DOM</span></h2><p>在Vue中，我们写在<code>&lt;template&gt;</code>标签内的内容都属于DOM节点，这部分内容会被最终转换成Vue中的虚拟DOM对象VNode，其中的步骤比较复杂，主要有以下几个过程：</p>\n<ul>\n<li>抽取<code>&lt;template&gt;</code>内容进行compile编译。</li>\n<li>得到AST语法树，并生成render方法。</li>\n<li>执行render方法得到VNode对象。</li>\n<li>VNode转换真实DOM并渲染到页面。</li>\n</ul>\n<p>完整流程如下图：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/447220e690a64adfb3a008573746d95c~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>我们以一个简单的demo为例子，在Vue 3的源码里去寻找，到底是如何一步一步进行了，demo如下代码所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &#123;&#123;name&#125;&#125;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">  &lt;p&gt;123&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  data()&#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      name : &apos;abc&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，data中定义了一个响应式数据name，并在<code>&lt;template&gt;</code>中使用插值表达式<code></code>进行使用，还有一个静态节点<code>&lt;p&gt;123&lt;/p&gt;</code>。</p>\n<h2><span id=\"获取lttemplategt内容\">获取<code>&lt;template&gt;</code>内容</span></h2><p>调用<code>createApp()</code>方法，会进入到源码<code>packages/runtime-dom/src/index.ts</code>里面的createApp()方法，如下代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> createApp = <span class=\"function\">(<span class=\"params\">(...args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> app = ensureRenderer().createApp(...args)</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  app.mount = (containerOrSelector: Element | ShadowRoot | string): <span class=\"function\"><span class=\"params\">any</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isFunction(component) &amp;&amp; !component.render &amp;&amp; !component.template) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 将#app绑定的HTML内容赋值给template项上</span></span><br><span class=\"line\">      component.template = container.innerHTML</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 调用mount方法渲染</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> proxy = mount(container, <span class=\"literal\">false</span>, container <span class=\"keyword\">instanceof</span> SVGElement)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> proxy</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">return</span> app</span><br><span class=\"line\">&#125;) <span class=\"keyword\">as</span> CreateAppFunction&lt;Element&gt;</span><br></pre></td></tr></table></figure>\n<p>对于根组件来说，<code>&lt;template&gt;</code>的内容由挂载的<code>#app</code>元素里面的内容组成，如果项目是采用npm和Vue Cli+Webpack这种前端工程化的方式，那么对于<code>&lt;template&gt;</code>的内容则主要由对应的loader在构建时对文件进行处理来获取，这和在浏览器运行时的处理方式是不一样的。</p>\n<h2><span id=\"生成ast语法树\">生成AST语法树</span></h2><p>在得到<code>&lt;template&gt;</code>后，就依据内容生成AST语法树。抽象语法树（Abstract Syntax Tree，AST），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。比如，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现；而类似于if-condition-then这样的条件跳转语句，可以使用带有三个分支的节点来表示。如下代码所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> b ≠ <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> a &gt; b</span><br><span class=\"line\">a := a − b</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">b := b − a</span><br><span class=\"line\"><span class=\"keyword\">return</span> a</span><br></pre></td></tr></table></figure></p>\n<p>如果将上述代码转换成广泛意义上的语法树，如图所示。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/159a46e93d5f4c87980cfb549c8ab024~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>对于<code>&lt;template&gt;</code>的内容，其大部分是由DOM组成，但是也会有<code>if-condition-then</code>这样的条件语句，例如<code>v-if</code>，<code>v-for</code>指令等等，在Vue 3中，这部分逻辑在源码<code>packages\\compiler-core\\src\\compile.ts中baseCompile</code>方法，核心代码如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseCompile</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  template: string | RootNode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  options: CompilerOptions = &#123;&#125;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">CodegenResult</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// 通过template生成ast树结构</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> ast = isString(template) ? baseParse(template, options) : template</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// 转换</span></span><br><span class=\"line\">  transform(</span><br><span class=\"line\">    ast,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  )</span><br><span class=\"line\">  <span class=\"keyword\">return</span> generate(</span><br><span class=\"line\">    ast,</span><br><span class=\"line\">    extend(&#123;&#125;, options, &#123;</span><br><span class=\"line\">      prefixIdentifiers</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>baseCompile方法主要做了以下事情：</p>\n<ul>\n<li>生成Vue中的AST对象。</li>\n<li>将AST对象作为参数传入transform函数，进行转换。</li>\n<li>将转换后的AST对象作为参数传入generate函数，生成render函数。</li>\n</ul>\n<p>其中，baseParse方法用来创建AST对象，在Vue 3中，AST对象是一个<code>RootNode</code>类型的树状结构，在源码<code>packages\\compiler-core\\src\\ast.ts</code>中，其结构如下代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createRoot</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  children: TemplateChildNode[],</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  loc = locStub</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">RootNode</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: NodeTypes.ROOT, <span class=\"comment\">// 元素类型</span></span><br><span class=\"line\">    children, <span class=\"comment\">// 子元素</span></span><br><span class=\"line\">    helpers: [],<span class=\"comment\">// 帮助函数</span></span><br><span class=\"line\">    components: [],<span class=\"comment\">// 子组件</span></span><br><span class=\"line\">    directives: [], <span class=\"comment\">// 指令</span></span><br><span class=\"line\">    hoists: [],<span class=\"comment\">// 标识静态节点</span></span><br><span class=\"line\">    imports: [],</span><br><span class=\"line\">    cached: <span class=\"number\">0</span>, <span class=\"comment\">// 缓存标志位</span></span><br><span class=\"line\">    temps: <span class=\"number\">0</span>,</span><br><span class=\"line\">    codegenNode: <span class=\"literal\">undefined</span>,<span class=\"comment\">// 存储生成render函数字符串</span></span><br><span class=\"line\">    loc <span class=\"comment\">// 描述元素在AST树的位置信息</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，children存储的时后代元素节点的数据，这就构成一个AST树结构，type表示元素的类型NodeType，主要分为HTML普通类型和Vue指令类型等，常见的有以下几种：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROOT,  // 根元素 0</span><br><span class=\"line\">ELEMENT, // 普通元素 1</span><br><span class=\"line\">TEXT, // 文本元素 2</span><br><span class=\"line\">COMMENT, // 注释元素 3</span><br><span class=\"line\">SIMPLE_EXPRESSION, // 表达式 4</span><br><span class=\"line\">INTERPOLATION, // 插值表达式 &#123;&#123; &#125;&#125; 5</span><br><span class=\"line\">ATTRIBUTE, // 属性 6</span><br><span class=\"line\">DIRECTIVE, // 指令 7</span><br><span class=\"line\">IF, // if节点 9</span><br><span class=\"line\">JS_CALL_EXPRESSION, // 方法调用 14</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p><code>hoists</code>是一个数组，用来存储一些可以静态提升的元素，在后面的<code>transform</code>会将静态元素和响应式元素分开创建，这也是Vue 3中优化的体现，codegenNode则用来存储最终生成的render方法的字符串，loc表示元素在AST树的位置信息。</p>\n<p>在生成AST树时，Vue 3在解析<code>&lt;template&gt;</code>内容时，会用一个栈<code>stack</code>来保存解析到的元素标签。当它遇到开始标签时，会将这个标签推入栈，遇到结束标签时，将刚才的标签弹出栈。它的作用是保存当前已经解析了，但还没解析完的元素标签。这个栈还有另一个作用，在解析到某个字节点时，通过<code>stack[stack.length - 1]</code>可以获取它的父元素。</p>\n<p>demo代码中生成的AST语法树如下图所示。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/479408c50a0d40a586b31f70d9c3a16d~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<h2><span id=\"生成render方法字符串\">生成render方法字符串</span></h2><p>在得到<code>AST</code>对象后，会进入<code>transform</code>方法，在源码<code>packages\\compiler-core\\src\\transform.ts</code>中，其核心代码如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">transform</span>(<span class=\"params\">root: RootNode, options: TransformOptions</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// 数据组装  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> context = createTransformContext(root, options)</span><br><span class=\"line\">  <span class=\"comment\">// 转换代码</span></span><br><span class=\"line\">  traverseNode(root, context)</span><br><span class=\"line\">  <span class=\"comment\">// 静态提升</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (options.hoistStatic) &#123;</span><br><span class=\"line\">    hoistStatic(root, context)</span><br><span class=\"line\">  &#125;<span class=\"comment\">// 服务端渲染</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!options.ssr) &#123;</span><br><span class=\"line\">    createRootCodegen(root, context)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 透传元信息</span></span><br><span class=\"line\">  root.helpers = [...context.helpers.keys()]</span><br><span class=\"line\">  root.components = [...context.components]</span><br><span class=\"line\">  root.directives = [...context.directives]</span><br><span class=\"line\">  root.imports = context.imports</span><br><span class=\"line\">  root.hoists = context.hoists</span><br><span class=\"line\">  root.temps = context.temps</span><br><span class=\"line\">  root.cached = context.cached</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (__COMPAT__) &#123;</span><br><span class=\"line\">    root.filters = [...context.filters!]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>transform</code>方法主要是对AST进行进一步转化，为<code>generate</code>函数生成<code>render</code>方法做准备，主要做了以下事情：</p>\n<ul>\n<li>traverseNode方法将会递归的检查和解析AST元素节点的属性，例如结合helpers方法对@click等事件添加对应的方法和事件回调，对插值表达式、指令、props添加动态绑定等。</li>\n<li>处理类型逻辑包括静态提升逻辑，将静态节点赋值给hoists，以及根据不同类型的节点打上不同的patchFlag，便于后续diff使用。</li>\n<li>在AST上绑定并透传一些元数据。</li>\n</ul>\n<p><code>generate</code>方法主要是生成<code>render</code>方法的字符串code，在源码<code>packages\\compiler-core\\src\\codegen.ts</code>中，其核心代码如下所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">generate</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  ast: RootNode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  options: CodegenOptions &amp; &#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    onContextCreated?: (context: CodegenContext</span>) =&gt; <span class=\"title\">void</span></span></span><br><span class=\"line\"><span class=\"function\">  &#125; = </span>&#123;&#125;</span><br><span class=\"line\">): CodegenResult &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> context = createCodegenContext(ast, options)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (options.onContextCreated) options.onContextCreated(context)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">    mode,</span><br><span class=\"line\">    push,</span><br><span class=\"line\">    prefixIdentifiers,</span><br><span class=\"line\">    indent,</span><br><span class=\"line\">    deindent,</span><br><span class=\"line\">    newline,</span><br><span class=\"line\">    scopeId,</span><br><span class=\"line\">    ssr</span><br><span class=\"line\">  &#125; = context</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// 缩进处理</span></span><br><span class=\"line\">  indent()</span><br><span class=\"line\">  deindent()</span><br><span class=\"line\">  <span class=\"comment\">// 单独处理component、directive、filters</span></span><br><span class=\"line\">  genAssets()</span><br><span class=\"line\">  <span class=\"comment\">// 处理NodeTypes里的所有类型</span></span><br><span class=\"line\">  genNode(ast.codegenNode, context)</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// 返回code字符串</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    ast,</span><br><span class=\"line\">    code: context.code,</span><br><span class=\"line\">    preamble: isSetupInlined ? preambleContext.code : <span class=\"string\">``</span>,</span><br><span class=\"line\">    <span class=\"comment\">// SourceMapGenerator does have toJSON() method but it's not in the types</span></span><br><span class=\"line\">    map: context.map ? (context.map <span class=\"keyword\">as</span> any).toJSON() : <span class=\"literal\">undefined</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>generate</code>方法的核心逻辑在<code>genNode</code>方法中，其逻辑是根据不同的NodeTypes类型构造出不同的<code>render</code>方法字符串，部分类型如下代码所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> (node.type) &#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> NodeTypes.ELEMENT:</span><br><span class=\"line\"><span class=\"keyword\">case</span> NodeTypes.IF:</span><br><span class=\"line\"><span class=\"keyword\">case</span> NodeTypes.FOR:<span class=\"comment\">// for关键字元素节点</span></span><br><span class=\"line\">  genNode(node.codegenNode!, context)</span><br><span class=\"line\">  <span class=\"keyword\">break</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> NodeTypes.TEXT:<span class=\"comment\">// 文本元素节点</span></span><br><span class=\"line\">  genText(node, context)</span><br><span class=\"line\">  <span class=\"keyword\">break</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> NodeTypes.VNODE_CALL:<span class=\"comment\">// 核心：VNode混合类型节点（AST语法树节点）</span></span><br><span class=\"line\">  genVNodeCall(node, context)</span><br><span class=\"line\">  <span class=\"keyword\">break</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> NodeTypes.COMMENT: <span class=\"comment\">// 注释元素节点</span></span><br><span class=\"line\">  genComment(node, context)</span><br><span class=\"line\">  <span class=\"keyword\">break</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> NodeTypes.JS_FUNCTION_EXPRESSION:<span class=\"comment\">// 方法调用节点</span></span><br><span class=\"line\">  genFunctionExpression(node, context)</span><br><span class=\"line\">  <span class=\"keyword\">break</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>其中：</p>\n<ul>\n<li>节点类型NodeTypes.VNODE_CALL对应genVNodeCall方法和ast.ts文件里面的createVNodeCall方法对应，后者用来返回VNodeCall，前者生成对应的VNodeCall这部分render方法字符串，是整个render方法字符串的核心。</li>\n<li>节点类型NodeTypes.FOR对应for关键字元素节点，其内部是递归调用了genNode方法。</li>\n<li>节点类型NodeTypes.TEXT对应文本元素节点负责静态文本的生成。</li>\n<li>节点类型NodeTypes.JS_FUNCTION_EXPRESSION对应方法调用节点，负责方法表达式的生成。</li>\n</ul>\n<p>终于，经过一系列的加工，最终生成的render方法字符串结果如下所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">anonymous</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">const</span> _Vue = Vue</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; <span class=\"attr\">createElementVNode</span>: _createElementVNode &#125; = _Vue</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> _hoisted_1 = [<span class=\"string\">\"data-a\"</span>] <span class=\"comment\">// 静态节点</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> _hoisted_2 = <span class=\"comment\">/*#__PURE__*/</span>_createElementVNode(<span class=\"string\">\"p\"</span>, <span class=\"literal\">null</span>, <span class=\"string\">\"123\"</span>, <span class=\"number\">-1</span> <span class=\"comment\">/* HOISTED */</span>)<span class=\"comment\">// 静态节点</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">_ctx, _cache</span>) </span>&#123;<span class=\"comment\">// render方法</span></span><br><span class=\"line\">  <span class=\"keyword\">with</span> (_ctx) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; <span class=\"attr\">toDisplayString</span>: _toDisplayString, <span class=\"attr\">createElementVNode</span>: _createElementVNode, <span class=\"attr\">Fragment</span>: _Fragment, <span class=\"attr\">openBlock</span>: _openBlock, <span class=\"attr\">createElementBlock</span>: _createElementBlock &#125; = _Vue <span class=\"comment\">// helper方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (_openBlock(), _createElementBlock(_Fragment, <span class=\"literal\">null</span>, [</span><br><span class=\"line\">      _createElementVNode(<span class=\"string\">\"div\"</span>, &#123; <span class=\"string\">\"data-a\"</span>: attr &#125;, _toDisplayString(name), <span class=\"number\">9</span> <span class=\"comment\">/* TEXT, PROPS */</span>, _hoisted_1),</span><br><span class=\"line\">      _hoisted_2</span><br><span class=\"line\">    ], <span class=\"number\">64</span> <span class=\"comment\">/* STABLE_FRAGMENT */</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><code>_createElementVNode</code>，<code>_openBlock</code>等等上一步传进来的<code>helper</code>方法。其中<code>&lt;p&gt;123&lt;/p&gt;</code>这种属于没有响应式绑定的静态节点，会被单独区分，而对于动态节点会使用<code>createElementVNode</code>方法来创建，最终这两种节点会进入<code>createElementBlock</code>方法进行VNode的创建。</p>\n<p>render方法中使用了with关键字，with的作用如下代码所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  a:<span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">with</span>(obj)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// 打印1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在<code>with(_ctx)</code>包裹下，我们在data中定义的响应式变量才能正常使用，例如调用<code>_toDisplayString(name)</code>，其中name就是响应式变量。</p>\n<h2><span id=\"得到最终vnode对象\">得到最终VNode对象</span></h2><p>最终，这是一段可执行代码，会赋值给组件<code>Component.render</code>方法上，其源码在<code>packages\\runtime-core\\src\\component.ts</code>中，如下所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">Component.render = compile(template, finalCompilerOptions)</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">if</span> (installWithProxy) &#123; <span class=\"comment\">// 绑定代理</span></span><br><span class=\"line\">   installWithProxy(instance)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p><code>compile</code>方法是最初<code>baseCompile</code>方法的入口，在完成赋值后，还需要绑定代理，执行<code>installWithProxy</code>方法，其源码在<code>runtime-core/src/component.ts</code>中，如下所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">registerRuntimeCompiler</span>(<span class=\"params\">_compile: any</span>) </span>&#123;</span><br><span class=\"line\">  compile = _compile</span><br><span class=\"line\">  installWithProxy = <span class=\"function\"><span class=\"params\">i</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i.render!._rc) &#123;</span><br><span class=\"line\">      i.withProxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这主要是给<code>render</code>里<code>_ctx</code>的响应式变量添加绑定，当上面<code>render</code>方法里的<code>name</code>被使用时，可以通过代理监听到调用，这样就会进入响应式的监听收集<code>track</code>，当触发<code>trigger</code>监听时，进行<code>diff</code>。</p>\n<p>在<code>runtime-core/src/componentRenderUtils.ts</code>源码里的<code>renderComponentRoot</code>方法里会执行<code>render</code>方法得到<code>VNode</code>对象，其核心代码如下所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">renderComponentRoot</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 执行render</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = normalizeVNode(render!.call(</span><br><span class=\"line\">        proxyToUse,</span><br><span class=\"line\">        proxyToUse!,</span><br><span class=\"line\">        renderCache,</span><br><span class=\"line\">        props,</span><br><span class=\"line\">        setupState,</span><br><span class=\"line\">        data,</span><br><span class=\"line\">        ctx</span><br><span class=\"line\">      ))</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>demo代码中最终得到的VNode对象如下图所示。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f3fe695743a49ee99fd69c98ccc2331~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>上图就是通过<code>render</code>方法运行后得到的<code>VNode</code>对象，可以看到<code>children</code>和<code>dynamicChildren</code>区分，前者包括了两个子节点分别是<code>&lt;div&gt;</code>和<code>&lt;p&gt;</code>这个和在<code>&lt;template&gt;</code>里面定义的内容是对应的，而后者只存储了动态节点，包括动态<code>props</code>即<code>data-a</code>属性。同时<code>VNode</code>也是树状结构，通过<code>children</code>和<code>dynamicChildren</code>一层一层递进下去。</p>\n<p>在通过<code>render</code>方法得到<code>VNode</code>的过程也是对指令，插值表达式，响应式数据，插槽等一系列Vue语法的解析和构造过程，最终生成结构化的<code>VNode</code>对象，可以将整个过程总结成流程图，便于读者理解，如下图所示。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/447220e690a64adfb3a008573746d95c~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>另外一个需要关注的属性是patchFlag这个是后面进行VNode的diff时所用到的标志位，数字64表示稳定不需要改变。最后得到VNode对象后需要转换成真实的DOM节点，这部分逻辑是在虚拟DOM的diff中完成的，在后面的双向绑定原理解析中进行讲解。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"什么是虚拟DOM\"><a href=\"#什么是虚拟DOM\" class=\"headerlink\" title=\"什么是虚拟DOM\"></a>什么是虚拟DOM</h2><p>在浏览器中，HTML页面由基本的DOM树来组成的，当其中一部分发生变化时，其实就是对应某个DOM节点发生了变化，当DOM节点发生变化时就会触发对应的重绘或者重排，当过多的重绘和重排在短时间内发生时，就会可能引起页面的卡顿，所以改变DOM是有一些代价的，那么如何优化DOM变化的次数以及在合适的时机改变DOM就是开发者需要注意的事情。<br>","more":"<br>虚拟DOM就是为了解决上述浏览器性能问题而被设计出来的。当一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是和原本的DOM进行对比，将这10次更新的变化部分内容保存到内存中，最终一次性的应用在到DOM树上，再进行后续操作，避免大量无谓的计算量。</p>\n<p>虚拟DOM实际上就是采用JavaScript对象来存储DOM节点的信息，将DOM的更新变成对象的修改，并且这些修改计算在内存中发生，当修改完成后，再将JavaScript转换成真实的DOM节点，交给浏览器，从而达到性能的提升。<br>例如下面一段DOM节点，如下代码所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;p class=&quot;text&quot;&gt;Hello&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>转换成一般的虚拟DOM对象结构，如下代码所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  tag: <span class=\"string\">'div'</span>,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    id: <span class=\"string\">'app'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  chidren: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      tag: <span class=\"string\">'p'</span>,</span><br><span class=\"line\">      props: &#123;</span><br><span class=\"line\">        className: <span class=\"string\">'text'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      chidren: [</span><br><span class=\"line\">        <span class=\"string\">'Hello'</span></span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面这段代码就是一个基本的虚拟DOM，但是他并非是Vue中使用的虚拟DOM结构，因为Vue要复杂的多。</p>\n<h2 id=\"Vue-3虚拟DOM\"><a href=\"#Vue-3虚拟DOM\" class=\"headerlink\" title=\"Vue 3虚拟DOM\"></a>Vue 3虚拟DOM</h2><p>在Vue中，我们写在<code>&lt;template&gt;</code>标签内的内容都属于DOM节点，这部分内容会被最终转换成Vue中的虚拟DOM对象VNode，其中的步骤比较复杂，主要有以下几个过程：</p>\n<ul>\n<li>抽取<code>&lt;template&gt;</code>内容进行compile编译。</li>\n<li>得到AST语法树，并生成render方法。</li>\n<li>执行render方法得到VNode对象。</li>\n<li>VNode转换真实DOM并渲染到页面。</li>\n</ul>\n<p>完整流程如下图：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/447220e690a64adfb3a008573746d95c~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>我们以一个简单的demo为例子，在Vue 3的源码里去寻找，到底是如何一步一步进行了，demo如下代码所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &#123;&#123;name&#125;&#125;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">  &lt;p&gt;123&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">Vue.createApp(&#123;</span><br><span class=\"line\">  data()&#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      name : &apos;abc&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).mount(&quot;#app&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，data中定义了一个响应式数据name，并在<code>&lt;template&gt;</code>中使用插值表达式<code></code>进行使用，还有一个静态节点<code>&lt;p&gt;123&lt;/p&gt;</code>。</p>\n<h2 id=\"获取-lt-template-gt-内容\"><a href=\"#获取-lt-template-gt-内容\" class=\"headerlink\" title=\"获取&lt;template&gt;内容\"></a>获取<code>&lt;template&gt;</code>内容</h2><p>调用<code>createApp()</code>方法，会进入到源码<code>packages/runtime-dom/src/index.ts</code>里面的createApp()方法，如下代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> createApp = <span class=\"function\">(<span class=\"params\">(...args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> app = ensureRenderer().createApp(...args)</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  app.mount = (containerOrSelector: Element | ShadowRoot | string): <span class=\"function\"><span class=\"params\">any</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isFunction(component) &amp;&amp; !component.render &amp;&amp; !component.template) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 将#app绑定的HTML内容赋值给template项上</span></span><br><span class=\"line\">      component.template = container.innerHTML</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 调用mount方法渲染</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> proxy = mount(container, <span class=\"literal\">false</span>, container <span class=\"keyword\">instanceof</span> SVGElement)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> proxy</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">return</span> app</span><br><span class=\"line\">&#125;) <span class=\"keyword\">as</span> CreateAppFunction&lt;Element&gt;</span><br></pre></td></tr></table></figure>\n<p>对于根组件来说，<code>&lt;template&gt;</code>的内容由挂载的<code>#app</code>元素里面的内容组成，如果项目是采用npm和Vue Cli+Webpack这种前端工程化的方式，那么对于<code>&lt;template&gt;</code>的内容则主要由对应的loader在构建时对文件进行处理来获取，这和在浏览器运行时的处理方式是不一样的。</p>\n<h2 id=\"生成AST语法树\"><a href=\"#生成AST语法树\" class=\"headerlink\" title=\"生成AST语法树\"></a>生成AST语法树</h2><p>在得到<code>&lt;template&gt;</code>后，就依据内容生成AST语法树。抽象语法树（Abstract Syntax Tree，AST），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。比如，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现；而类似于if-condition-then这样的条件跳转语句，可以使用带有三个分支的节点来表示。如下代码所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> b ≠ <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> a &gt; b</span><br><span class=\"line\">a := a − b</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">b := b − a</span><br><span class=\"line\"><span class=\"keyword\">return</span> a</span><br></pre></td></tr></table></figure></p>\n<p>如果将上述代码转换成广泛意义上的语法树，如图所示。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/159a46e93d5f4c87980cfb549c8ab024~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>对于<code>&lt;template&gt;</code>的内容，其大部分是由DOM组成，但是也会有<code>if-condition-then</code>这样的条件语句，例如<code>v-if</code>，<code>v-for</code>指令等等，在Vue 3中，这部分逻辑在源码<code>packages\\compiler-core\\src\\compile.ts中baseCompile</code>方法，核心代码如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseCompile</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  template: string | RootNode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  options: CompilerOptions = &#123;&#125;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">CodegenResult</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// 通过template生成ast树结构</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> ast = isString(template) ? baseParse(template, options) : template</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// 转换</span></span><br><span class=\"line\">  transform(</span><br><span class=\"line\">    ast,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  )</span><br><span class=\"line\">  <span class=\"keyword\">return</span> generate(</span><br><span class=\"line\">    ast,</span><br><span class=\"line\">    extend(&#123;&#125;, options, &#123;</span><br><span class=\"line\">      prefixIdentifiers</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>baseCompile方法主要做了以下事情：</p>\n<ul>\n<li>生成Vue中的AST对象。</li>\n<li>将AST对象作为参数传入transform函数，进行转换。</li>\n<li>将转换后的AST对象作为参数传入generate函数，生成render函数。</li>\n</ul>\n<p>其中，baseParse方法用来创建AST对象，在Vue 3中，AST对象是一个<code>RootNode</code>类型的树状结构，在源码<code>packages\\compiler-core\\src\\ast.ts</code>中，其结构如下代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createRoot</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  children: TemplateChildNode[],</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  loc = locStub</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">RootNode</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: NodeTypes.ROOT, <span class=\"comment\">// 元素类型</span></span><br><span class=\"line\">    children, <span class=\"comment\">// 子元素</span></span><br><span class=\"line\">    helpers: [],<span class=\"comment\">// 帮助函数</span></span><br><span class=\"line\">    components: [],<span class=\"comment\">// 子组件</span></span><br><span class=\"line\">    directives: [], <span class=\"comment\">// 指令</span></span><br><span class=\"line\">    hoists: [],<span class=\"comment\">// 标识静态节点</span></span><br><span class=\"line\">    imports: [],</span><br><span class=\"line\">    cached: <span class=\"number\">0</span>, <span class=\"comment\">// 缓存标志位</span></span><br><span class=\"line\">    temps: <span class=\"number\">0</span>,</span><br><span class=\"line\">    codegenNode: <span class=\"literal\">undefined</span>,<span class=\"comment\">// 存储生成render函数字符串</span></span><br><span class=\"line\">    loc <span class=\"comment\">// 描述元素在AST树的位置信息</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，children存储的时后代元素节点的数据，这就构成一个AST树结构，type表示元素的类型NodeType，主要分为HTML普通类型和Vue指令类型等，常见的有以下几种：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROOT,  // 根元素 0</span><br><span class=\"line\">ELEMENT, // 普通元素 1</span><br><span class=\"line\">TEXT, // 文本元素 2</span><br><span class=\"line\">COMMENT, // 注释元素 3</span><br><span class=\"line\">SIMPLE_EXPRESSION, // 表达式 4</span><br><span class=\"line\">INTERPOLATION, // 插值表达式 &#123;&#123; &#125;&#125; 5</span><br><span class=\"line\">ATTRIBUTE, // 属性 6</span><br><span class=\"line\">DIRECTIVE, // 指令 7</span><br><span class=\"line\">IF, // if节点 9</span><br><span class=\"line\">JS_CALL_EXPRESSION, // 方法调用 14</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p><code>hoists</code>是一个数组，用来存储一些可以静态提升的元素，在后面的<code>transform</code>会将静态元素和响应式元素分开创建，这也是Vue 3中优化的体现，codegenNode则用来存储最终生成的render方法的字符串，loc表示元素在AST树的位置信息。</p>\n<p>在生成AST树时，Vue 3在解析<code>&lt;template&gt;</code>内容时，会用一个栈<code>stack</code>来保存解析到的元素标签。当它遇到开始标签时，会将这个标签推入栈，遇到结束标签时，将刚才的标签弹出栈。它的作用是保存当前已经解析了，但还没解析完的元素标签。这个栈还有另一个作用，在解析到某个字节点时，通过<code>stack[stack.length - 1]</code>可以获取它的父元素。</p>\n<p>demo代码中生成的AST语法树如下图所示。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/479408c50a0d40a586b31f70d9c3a16d~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<h2 id=\"生成render方法字符串\"><a href=\"#生成render方法字符串\" class=\"headerlink\" title=\"生成render方法字符串\"></a>生成render方法字符串</h2><p>在得到<code>AST</code>对象后，会进入<code>transform</code>方法，在源码<code>packages\\compiler-core\\src\\transform.ts</code>中，其核心代码如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">transform</span>(<span class=\"params\">root: RootNode, options: TransformOptions</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// 数据组装  </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> context = createTransformContext(root, options)</span><br><span class=\"line\">  <span class=\"comment\">// 转换代码</span></span><br><span class=\"line\">  traverseNode(root, context)</span><br><span class=\"line\">  <span class=\"comment\">// 静态提升</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (options.hoistStatic) &#123;</span><br><span class=\"line\">    hoistStatic(root, context)</span><br><span class=\"line\">  &#125;<span class=\"comment\">// 服务端渲染</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!options.ssr) &#123;</span><br><span class=\"line\">    createRootCodegen(root, context)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 透传元信息</span></span><br><span class=\"line\">  root.helpers = [...context.helpers.keys()]</span><br><span class=\"line\">  root.components = [...context.components]</span><br><span class=\"line\">  root.directives = [...context.directives]</span><br><span class=\"line\">  root.imports = context.imports</span><br><span class=\"line\">  root.hoists = context.hoists</span><br><span class=\"line\">  root.temps = context.temps</span><br><span class=\"line\">  root.cached = context.cached</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (__COMPAT__) &#123;</span><br><span class=\"line\">    root.filters = [...context.filters!]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>transform</code>方法主要是对AST进行进一步转化，为<code>generate</code>函数生成<code>render</code>方法做准备，主要做了以下事情：</p>\n<ul>\n<li>traverseNode方法将会递归的检查和解析AST元素节点的属性，例如结合helpers方法对@click等事件添加对应的方法和事件回调，对插值表达式、指令、props添加动态绑定等。</li>\n<li>处理类型逻辑包括静态提升逻辑，将静态节点赋值给hoists，以及根据不同类型的节点打上不同的patchFlag，便于后续diff使用。</li>\n<li>在AST上绑定并透传一些元数据。</li>\n</ul>\n<p><code>generate</code>方法主要是生成<code>render</code>方法的字符串code，在源码<code>packages\\compiler-core\\src\\codegen.ts</code>中，其核心代码如下所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">generate</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  ast: RootNode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  options: CodegenOptions &amp; &#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    onContextCreated?: (context: CodegenContext</span>) =&gt; <span class=\"title\">void</span></span></span><br><span class=\"line\"><span class=\"function\">  &#125; = </span>&#123;&#125;</span><br><span class=\"line\">): CodegenResult &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> context = createCodegenContext(ast, options)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (options.onContextCreated) options.onContextCreated(context)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">    mode,</span><br><span class=\"line\">    push,</span><br><span class=\"line\">    prefixIdentifiers,</span><br><span class=\"line\">    indent,</span><br><span class=\"line\">    deindent,</span><br><span class=\"line\">    newline,</span><br><span class=\"line\">    scopeId,</span><br><span class=\"line\">    ssr</span><br><span class=\"line\">  &#125; = context</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// 缩进处理</span></span><br><span class=\"line\">  indent()</span><br><span class=\"line\">  deindent()</span><br><span class=\"line\">  <span class=\"comment\">// 单独处理component、directive、filters</span></span><br><span class=\"line\">  genAssets()</span><br><span class=\"line\">  <span class=\"comment\">// 处理NodeTypes里的所有类型</span></span><br><span class=\"line\">  genNode(ast.codegenNode, context)</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// 返回code字符串</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    ast,</span><br><span class=\"line\">    code: context.code,</span><br><span class=\"line\">    preamble: isSetupInlined ? preambleContext.code : <span class=\"string\">``</span>,</span><br><span class=\"line\">    <span class=\"comment\">// SourceMapGenerator does have toJSON() method but it's not in the types</span></span><br><span class=\"line\">    map: context.map ? (context.map <span class=\"keyword\">as</span> any).toJSON() : <span class=\"literal\">undefined</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>generate</code>方法的核心逻辑在<code>genNode</code>方法中，其逻辑是根据不同的NodeTypes类型构造出不同的<code>render</code>方法字符串，部分类型如下代码所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> (node.type) &#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> NodeTypes.ELEMENT:</span><br><span class=\"line\"><span class=\"keyword\">case</span> NodeTypes.IF:</span><br><span class=\"line\"><span class=\"keyword\">case</span> NodeTypes.FOR:<span class=\"comment\">// for关键字元素节点</span></span><br><span class=\"line\">  genNode(node.codegenNode!, context)</span><br><span class=\"line\">  <span class=\"keyword\">break</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> NodeTypes.TEXT:<span class=\"comment\">// 文本元素节点</span></span><br><span class=\"line\">  genText(node, context)</span><br><span class=\"line\">  <span class=\"keyword\">break</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> NodeTypes.VNODE_CALL:<span class=\"comment\">// 核心：VNode混合类型节点（AST语法树节点）</span></span><br><span class=\"line\">  genVNodeCall(node, context)</span><br><span class=\"line\">  <span class=\"keyword\">break</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> NodeTypes.COMMENT: <span class=\"comment\">// 注释元素节点</span></span><br><span class=\"line\">  genComment(node, context)</span><br><span class=\"line\">  <span class=\"keyword\">break</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> NodeTypes.JS_FUNCTION_EXPRESSION:<span class=\"comment\">// 方法调用节点</span></span><br><span class=\"line\">  genFunctionExpression(node, context)</span><br><span class=\"line\">  <span class=\"keyword\">break</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>其中：</p>\n<ul>\n<li>节点类型NodeTypes.VNODE_CALL对应genVNodeCall方法和ast.ts文件里面的createVNodeCall方法对应，后者用来返回VNodeCall，前者生成对应的VNodeCall这部分render方法字符串，是整个render方法字符串的核心。</li>\n<li>节点类型NodeTypes.FOR对应for关键字元素节点，其内部是递归调用了genNode方法。</li>\n<li>节点类型NodeTypes.TEXT对应文本元素节点负责静态文本的生成。</li>\n<li>节点类型NodeTypes.JS_FUNCTION_EXPRESSION对应方法调用节点，负责方法表达式的生成。</li>\n</ul>\n<p>终于，经过一系列的加工，最终生成的render方法字符串结果如下所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">anonymous</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">const</span> _Vue = Vue</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; <span class=\"attr\">createElementVNode</span>: _createElementVNode &#125; = _Vue</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> _hoisted_1 = [<span class=\"string\">\"data-a\"</span>] <span class=\"comment\">// 静态节点</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> _hoisted_2 = <span class=\"comment\">/*#__PURE__*/</span>_createElementVNode(<span class=\"string\">\"p\"</span>, <span class=\"literal\">null</span>, <span class=\"string\">\"123\"</span>, <span class=\"number\">-1</span> <span class=\"comment\">/* HOISTED */</span>)<span class=\"comment\">// 静态节点</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">_ctx, _cache</span>) </span>&#123;<span class=\"comment\">// render方法</span></span><br><span class=\"line\">  <span class=\"keyword\">with</span> (_ctx) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; <span class=\"attr\">toDisplayString</span>: _toDisplayString, <span class=\"attr\">createElementVNode</span>: _createElementVNode, <span class=\"attr\">Fragment</span>: _Fragment, <span class=\"attr\">openBlock</span>: _openBlock, <span class=\"attr\">createElementBlock</span>: _createElementBlock &#125; = _Vue <span class=\"comment\">// helper方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (_openBlock(), _createElementBlock(_Fragment, <span class=\"literal\">null</span>, [</span><br><span class=\"line\">      _createElementVNode(<span class=\"string\">\"div\"</span>, &#123; <span class=\"string\">\"data-a\"</span>: attr &#125;, _toDisplayString(name), <span class=\"number\">9</span> <span class=\"comment\">/* TEXT, PROPS */</span>, _hoisted_1),</span><br><span class=\"line\">      _hoisted_2</span><br><span class=\"line\">    ], <span class=\"number\">64</span> <span class=\"comment\">/* STABLE_FRAGMENT */</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><code>_createElementVNode</code>，<code>_openBlock</code>等等上一步传进来的<code>helper</code>方法。其中<code>&lt;p&gt;123&lt;/p&gt;</code>这种属于没有响应式绑定的静态节点，会被单独区分，而对于动态节点会使用<code>createElementVNode</code>方法来创建，最终这两种节点会进入<code>createElementBlock</code>方法进行VNode的创建。</p>\n<p>render方法中使用了with关键字，with的作用如下代码所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  a:<span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">with</span>(obj)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// 打印1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在<code>with(_ctx)</code>包裹下，我们在data中定义的响应式变量才能正常使用，例如调用<code>_toDisplayString(name)</code>，其中name就是响应式变量。</p>\n<h2 id=\"得到最终VNode对象\"><a href=\"#得到最终VNode对象\" class=\"headerlink\" title=\"得到最终VNode对象\"></a>得到最终VNode对象</h2><p>最终，这是一段可执行代码，会赋值给组件<code>Component.render</code>方法上，其源码在<code>packages\\runtime-core\\src\\component.ts</code>中，如下所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">Component.render = compile(template, finalCompilerOptions)</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">if</span> (installWithProxy) &#123; <span class=\"comment\">// 绑定代理</span></span><br><span class=\"line\">   installWithProxy(instance)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p><code>compile</code>方法是最初<code>baseCompile</code>方法的入口，在完成赋值后，还需要绑定代理，执行<code>installWithProxy</code>方法，其源码在<code>runtime-core/src/component.ts</code>中，如下所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">registerRuntimeCompiler</span>(<span class=\"params\">_compile: any</span>) </span>&#123;</span><br><span class=\"line\">  compile = _compile</span><br><span class=\"line\">  installWithProxy = <span class=\"function\"><span class=\"params\">i</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i.render!._rc) &#123;</span><br><span class=\"line\">      i.withProxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这主要是给<code>render</code>里<code>_ctx</code>的响应式变量添加绑定，当上面<code>render</code>方法里的<code>name</code>被使用时，可以通过代理监听到调用，这样就会进入响应式的监听收集<code>track</code>，当触发<code>trigger</code>监听时，进行<code>diff</code>。</p>\n<p>在<code>runtime-core/src/componentRenderUtils.ts</code>源码里的<code>renderComponentRoot</code>方法里会执行<code>render</code>方法得到<code>VNode</code>对象，其核心代码如下所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">renderComponentRoot</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 执行render</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = normalizeVNode(render!.call(</span><br><span class=\"line\">        proxyToUse,</span><br><span class=\"line\">        proxyToUse!,</span><br><span class=\"line\">        renderCache,</span><br><span class=\"line\">        props,</span><br><span class=\"line\">        setupState,</span><br><span class=\"line\">        data,</span><br><span class=\"line\">        ctx</span><br><span class=\"line\">      ))</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>demo代码中最终得到的VNode对象如下图所示。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f3fe695743a49ee99fd69c98ccc2331~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>上图就是通过<code>render</code>方法运行后得到的<code>VNode</code>对象，可以看到<code>children</code>和<code>dynamicChildren</code>区分，前者包括了两个子节点分别是<code>&lt;div&gt;</code>和<code>&lt;p&gt;</code>这个和在<code>&lt;template&gt;</code>里面定义的内容是对应的，而后者只存储了动态节点，包括动态<code>props</code>即<code>data-a</code>属性。同时<code>VNode</code>也是树状结构，通过<code>children</code>和<code>dynamicChildren</code>一层一层递进下去。</p>\n<p>在通过<code>render</code>方法得到<code>VNode</code>的过程也是对指令，插值表达式，响应式数据，插槽等一系列Vue语法的解析和构造过程，最终生成结构化的<code>VNode</code>对象，可以将整个过程总结成流程图，便于读者理解，如下图所示。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/447220e690a64adfb3a008573746d95c~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>另外一个需要关注的属性是patchFlag这个是后面进行VNode的diff时所用到的标志位，数字64表示稳定不需要改变。最后得到VNode对象后需要转换成真实的DOM节点，这部分逻辑是在虚拟DOM的diff中完成的，在后面的双向绑定原理解析中进行讲解。</p>"},{"title":"Vue开发B端系统常见性能优化技巧","date":"2021-04-26T09:26:17.000Z","_content":"\n\n\n最近工作上一直接触的时B端的管理系统，基本上都是采用Vue Cli生成脚手架后就直接开始写业务逻辑，所以一般都会忽略一些性能优化相关的想法和工作。虽说这种系统对前端要求一般来说比较简单，大多数是一些数据校验和可视化展示，可能重点的工作量在于业务逻辑，但是作为一个前端项目来说，基本的优化还是需要做的，可以参考这篇[文章](https://juejin.cn/post/6844903801296519181)。\n\n而本文将会介绍一些基于Vue Cli项目会被我们忽略的一些性能优化，尤其是首屏优化的技巧，如果对你有帮助，可以点赞支持一下。\n<!--more-->\n## UI库按需加载\n\n对于大多是B端系统而言，都会使用一些一些UI组件库，例如Ant Design或者是Element UI，这些组件都是支持按需引入，我们在使用这些组件时，如果只用到了其中一部分组件，可以配置按需加载，在`main.js`中修改代码：\n```javascript\nimport {\n    Pagination,\n    Icon,\n    Tabs,\n} from 'ant-design-vue'\n// import 'ant-design-vue/dist/antd.css'  已经通过babel引入 这里就不全局引入了\n\nVue.use(Pagination)\n    .use(Icon)\n    .use(Tabs)\n```\n\n然后修改`babel.config.js`，如下：\n```javascript\n  \"plugins\": [\n    [\"import\", { \"libraryName\": \"ant-design-vue\", \"libraryDirectory\": \"es\", \"style\": \"css\" }], // `style: true` 会加载 less 文件\n\n  ]\n```\n\n这样，组件对应的js和css文件就可以实现按需加载，关于`babel.config.js`的配置，可以参考之前的一篇[文章](https://juejin.cn/post/6906362999703863304)。\n\n## 使用webpack-bundle-analyzer分析打包后的资源包\n`webpack-bundle-analyzer`是一个webpack插件，它可以直观分析打包出的文件包含哪些，大小占比如何，模块包含关系，依赖项，文件是否重复，压缩后大小如何，针对这些，我们可以进行文件分割等操作，是我们后面分析资源包大小的基础。\n```javascript\n// 分析包内容 \nnpm install webpack-bundle-analyzer --save-dev\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin; \nmodule.exports = { \nplugins: [ \n// 开启 BundleAnalyzerPlugin \n      new BundleAnalyzerPlugin(), \n    ], \n};   \n\n```\n配置完成之后，只需要`npm run build`即可，会自动打开http://127.0.0.1:8888/\n\n![686316-20180808143606193-2047520260.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/446d403e2acb4c4c867230399e7c0a84~tplv-k3u1fbpfcp-watermark.image)\n## 路由懒加载\n对于一般比较大型的B端管理系统项目，基本上都会使用Vue Router来管理路由，这些项目涉及的页面都比较多，所以为了防止首屏资源过大，需要采用路由懒加载资源即Code Splitting，将每个页面的资源进行分离，这个只需在`router.js`里配置即可：\n```javascript\n// 采用箭头函数和import进行懒加载处理\ncomponent: () => import('./index.vue')\n```\n\n## 有选择的使用prefetch和preload\n\n### prefetch\n\n```\n<link rel=\"prefetch\" ></link>\n```\n这段代码告诉浏览器，这段资源将会在未来某个导航或者功能要用到，但是本资源的下载顺序权重比较低。也就是说prefetch通常用于加速下一次导航，而不是本次的。\n\n### preload\n\n```\n<link rel=\"preload\" ></link>\n```\npreload通常用于本页面要用到的关键资源，包括关键js、字体、css文件。preload将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度。\n\n在使用Vue Cli生成的项目里，当我们配置了路由懒加载后，默认情况下webpack在构建时会对所有的懒加载资源进行`prefetch`和`preload`，所以当你打开首页时，会看到大量的`prefetch`和`preload`请求，如下图：\n![0563B5CD-D598-40d1-A6D6-CE194BD3E8F5.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e74b65731ff94c3ca31fb4481f3cdc9c~tplv-k3u1fbpfcp-watermark.image)\n虽说prefetch会在浏览器空闲时，下载相应文件，但这是一个很笼统的定义，这些大量的预加载资源会占用浏览器的资源，可能会导致一些关键的api请求或者图片请求受影响，所以对于这种情况，可以选择指定一些资源进行预加载或者禁止掉这些预加载，代码如下：\n```javascript\n// 禁止prefetch和preload\nchainWebpack: (config) => {\n  config.plugins.delete('prefetch')\n  config.plugins.delete('preload')\n}\n// 有选择的prefetch和preload\nconfig.plugin('prefetch').tap(options => {\n    options[0].fileBlacklist = options[0].fileBlacklist || []\n    options[0].fileBlacklist.push(/myasyncRoute(.)+?\\.js$/)\n    return options\n})\n```\n上面代码修改`vue.config.js`的`chainWebpack`来添加配置。\n\n## 拆分node_modules\n\n对于一般比较大型的B端管理系统项目，一般都会使用一些UI组件库，图表库等第三方库，这些第三方库一般都是通过`npm install`到`node_modules`下面，并且每个页面大多都会使用这些库，所以会在`main.js`中引入：\n\n```javascript\nVue.use(Antd)\nVue.use(Echarts)\n\n```\n在打包时，webpack会将这些公用的模块，抽离出来，放到一个公共模块中。这样不管这个模块被多少个入口引用，都只会在最终打包结果中出现一次，以此解决代码冗余。\n\n这些在使用Vue Cli的项目中已经自动帮我们做好了，主要利用了`optimization.splitChunks`配置，但是当我们把这些公用的模块都堆在一个模块中，这个文件可能异常巨大（一般是app.js，首屏就会加载这个文件，引用的公共第三方库越多，这个文件越大），也是不利于网络请求和页面加载的。所以我们需要把这个公共模块再按照一定规则进一步拆分成几个模块文件，减小文件体积，同时也可以利用HTTP2多路复用特性，这些则需要我们自己配置，代码如下：\n```javascript\n  config.optimization.splitChunks.cacheGroups.antdv = {\n      name:'chunk-antdv',// 抽离的模块名\n      priority: 20,// 优先级\n      test: /ant-design-vue/,\n      chunks: 'initial',\n      reuseExistingChunk: true,\n      enforce: true // 强制抽离此模块\n  }\n  config.optimization.splitChunks.cacheGroups.antdv = {\n    name:'chunk-echarts',// 抽离的模块名\n    priority: 20,// 优先级\n    test: /echarts/,\n    chunks: 'initial',\n    reuseExistingChunk: true,\n    enforce: true // 强制抽离此模块\n}\n```\n上面代码在`vue.config.js`里，修改`configureWebpack`项来添加配置，关于`optimization.splitChunks`的配置，可以参考这个[文档](https://www.webpackjs.com/plugins/split-chunks-plugin/)，这里可以简单的解释一下上面配置的含义：\n\n1. 每个`cacheGroups`代表需要抽离的第三方库，这里有两个分别是ant-design-vue和echarts。\n2. `test`项表示要扫描的`node_modules`文件路径，这里简单采用了正则来匹配。\n3. `chunks`项有三个选项：`all`, `async`, `initial`。`initial` 代表负责异步模块和非异步模块加载的公共抽离，`async`代表只负责异步模块加载的公共抽离, `all`结合前面两者特点。\n\n## 定制资源文件加载位置\n\n对于使用Vue Cli创建的项目，一般来说都不会刻意的修改css，JavaScript文件加载的顺序，例如默认情况下webpack会把css放在<head>标签里，JavaScript文件放在<body>标签底部，所以，有时我们会在<body>标签底部引入一些第三方的JavaScript文件，例如jquery或者高德地图的api文件等等，如下所示：\n```html\n  <body>\n    <div id=\"app\"></div>\n    <script type=\"text/javascript\" src=\"https://webapi.amap.com/maps?v=1.4.15&key=c65f481aebaed72935e11654238ab5a6\"></script>\n    <script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js\"></script>\n    <!-- built files will be auto injected -->\n  </body>\n```\n我们知道，浏览器在解析HTML时，遇到非异步的资源，尤其是JavaScript文件资源时，会下载并解析，那么越先加载就越先解析，\n而默认情况下，项目构建之后，业务的核心JavaScript文件会被放在这些第三方的JavaScript文件后面加载，会对首屏的展示有一定的影响。\n\n解决这个问题，需要修改`html-webpack-plugin`配置，然后手动在index.html里，自定义文件的加载位置，代码如下：\n\n```javascript\n  config.plugin('html')\n  .tap(args => {\n    args[0].inject = false\n    return args\n  })\n```\n```html\n<% for (var css in htmlWebpackPlugin.files.css) { %>\n  <link href=\"<%=htmlWebpackPlugin.files.css[css] %>\" rel=\"stylesheet\">\n<% } %>\n...\n<% for (var chunk in htmlWebpackPlugin.files.chunks) { %>\n<script type=\"text/javascript\" src=\"<%=htmlWebpackPlugin.files.chunks[chunk].entry %>\"></script>\n<% } %>\n```\n\n这样，就可以将一些重要的首屏资源加载优先级提升，在一定情况下，优化首屏的加载速度。\n\n## PrerenderSpaPlugin首屏预渲染\n\n对于大多数的B端系统而言，大部分都是一个已Vue开发的单页应用SPA，所以首屏的内容基本上都是依赖JavaScript来进行渲染的，这样不仅依赖于JavaScript文件资源的加载，而且不利于SEO（可能大部分B端系统无需SEO，但不排除一些欢迎页或者品牌首页类似的页面有SEO的需求）。\n\nPrerenderSpaPlugin是一个可以将一些页面预先打包成静态资源页面的webpack插件，并且可以结合`vue-router`，来根据路由，配置指定的页面，它的工作流程如下图：\n\n![20181128215005309.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99f9e23383d54287958c36c9e5b1e949~tplv-k3u1fbpfcp-watermark.image)\n\n基于此，我们可以修改`vue.config.js`，添加PrerenderSpaPlugin支持，代码如下：\n\n```javascript\nnpm install prerender-spa-plugin --save-dev\nconst PrerenderSpaPlugin = require('prerender-spa-plugin')\n...\nnew PrerenderSpaPlugin({\n\n  staticDir: resolve('dist'),\n  // 对应自己的路由文件，比如a有参数，就需要写成 /a/param1。\n  routes: ['/login', '/about'],\n}),\n```\n上面代码中，给`/login`和`/about`两个路由配置了预加载，在项目dist之后，就可以看到两个独立的html文件，在通过一些nginx配置，将对应的路径直接转发到对应的静态页面即可。更多关于PrerenderSpaPlugin可以参考[配置](https://github.com/chrisvfritz/prerender-spa-plugin)。\n\n## 图片压缩\n\n默认情况下，Vue Cli创建的项目不会对项目中引入的一些图片资源进行二次压缩，这时如果引入一些较大的图片，并且比较多的情况下，会导致dist之后的包变得很大，这时可以采用`image-webpack-loader`来开启配置图片压缩，添加`image-webpack-loader`，代码如下：\n```javascript\nnpm install image-webpack-loader --save-dev\n...\nconfig.module\n    .rule('images')\n    .use('image-webpack-loader')\n    .loader('image-webpack-loader')\n    .options({ bypassOnDebug: true })\n    .end()\n```\n\n上面代码修改`vue.config.js`的`chainWebpack`来添加配置，`image-webpack-loader`始于[imagemin](https://github.com/imagemin/imagemin)开发的webpack的loader，可以支持无损和有损压缩。\n\n## 结语\n\n对于大多数的B端系统而言，可能更注重复杂的业务逻辑实现，但可能也会忽略一些基本的性能优化，对于整个系统而言，给到良好的用户体验才能让系统变得更加健壮，同时也是一名前端工程师的成就所在。\n\n\n","source":"_posts/Vue开发B端系统常见性能优化技巧.md","raw":"---\ntitle: Vue开发B端系统常见性能优化技巧\ndate: 2021-04-26 17:26:17\ntags:\n- Vue\n- B端系统\ncategories:\n- 919\n\n---\n\n\n\n最近工作上一直接触的时B端的管理系统，基本上都是采用Vue Cli生成脚手架后就直接开始写业务逻辑，所以一般都会忽略一些性能优化相关的想法和工作。虽说这种系统对前端要求一般来说比较简单，大多数是一些数据校验和可视化展示，可能重点的工作量在于业务逻辑，但是作为一个前端项目来说，基本的优化还是需要做的，可以参考这篇[文章](https://juejin.cn/post/6844903801296519181)。\n\n而本文将会介绍一些基于Vue Cli项目会被我们忽略的一些性能优化，尤其是首屏优化的技巧，如果对你有帮助，可以点赞支持一下。\n<!--more-->\n## UI库按需加载\n\n对于大多是B端系统而言，都会使用一些一些UI组件库，例如Ant Design或者是Element UI，这些组件都是支持按需引入，我们在使用这些组件时，如果只用到了其中一部分组件，可以配置按需加载，在`main.js`中修改代码：\n```javascript\nimport {\n    Pagination,\n    Icon,\n    Tabs,\n} from 'ant-design-vue'\n// import 'ant-design-vue/dist/antd.css'  已经通过babel引入 这里就不全局引入了\n\nVue.use(Pagination)\n    .use(Icon)\n    .use(Tabs)\n```\n\n然后修改`babel.config.js`，如下：\n```javascript\n  \"plugins\": [\n    [\"import\", { \"libraryName\": \"ant-design-vue\", \"libraryDirectory\": \"es\", \"style\": \"css\" }], // `style: true` 会加载 less 文件\n\n  ]\n```\n\n这样，组件对应的js和css文件就可以实现按需加载，关于`babel.config.js`的配置，可以参考之前的一篇[文章](https://juejin.cn/post/6906362999703863304)。\n\n## 使用webpack-bundle-analyzer分析打包后的资源包\n`webpack-bundle-analyzer`是一个webpack插件，它可以直观分析打包出的文件包含哪些，大小占比如何，模块包含关系，依赖项，文件是否重复，压缩后大小如何，针对这些，我们可以进行文件分割等操作，是我们后面分析资源包大小的基础。\n```javascript\n// 分析包内容 \nnpm install webpack-bundle-analyzer --save-dev\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin; \nmodule.exports = { \nplugins: [ \n// 开启 BundleAnalyzerPlugin \n      new BundleAnalyzerPlugin(), \n    ], \n};   \n\n```\n配置完成之后，只需要`npm run build`即可，会自动打开http://127.0.0.1:8888/\n\n![686316-20180808143606193-2047520260.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/446d403e2acb4c4c867230399e7c0a84~tplv-k3u1fbpfcp-watermark.image)\n## 路由懒加载\n对于一般比较大型的B端管理系统项目，基本上都会使用Vue Router来管理路由，这些项目涉及的页面都比较多，所以为了防止首屏资源过大，需要采用路由懒加载资源即Code Splitting，将每个页面的资源进行分离，这个只需在`router.js`里配置即可：\n```javascript\n// 采用箭头函数和import进行懒加载处理\ncomponent: () => import('./index.vue')\n```\n\n## 有选择的使用prefetch和preload\n\n### prefetch\n\n```\n<link rel=\"prefetch\" ></link>\n```\n这段代码告诉浏览器，这段资源将会在未来某个导航或者功能要用到，但是本资源的下载顺序权重比较低。也就是说prefetch通常用于加速下一次导航，而不是本次的。\n\n### preload\n\n```\n<link rel=\"preload\" ></link>\n```\npreload通常用于本页面要用到的关键资源，包括关键js、字体、css文件。preload将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度。\n\n在使用Vue Cli生成的项目里，当我们配置了路由懒加载后，默认情况下webpack在构建时会对所有的懒加载资源进行`prefetch`和`preload`，所以当你打开首页时，会看到大量的`prefetch`和`preload`请求，如下图：\n![0563B5CD-D598-40d1-A6D6-CE194BD3E8F5.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e74b65731ff94c3ca31fb4481f3cdc9c~tplv-k3u1fbpfcp-watermark.image)\n虽说prefetch会在浏览器空闲时，下载相应文件，但这是一个很笼统的定义，这些大量的预加载资源会占用浏览器的资源，可能会导致一些关键的api请求或者图片请求受影响，所以对于这种情况，可以选择指定一些资源进行预加载或者禁止掉这些预加载，代码如下：\n```javascript\n// 禁止prefetch和preload\nchainWebpack: (config) => {\n  config.plugins.delete('prefetch')\n  config.plugins.delete('preload')\n}\n// 有选择的prefetch和preload\nconfig.plugin('prefetch').tap(options => {\n    options[0].fileBlacklist = options[0].fileBlacklist || []\n    options[0].fileBlacklist.push(/myasyncRoute(.)+?\\.js$/)\n    return options\n})\n```\n上面代码修改`vue.config.js`的`chainWebpack`来添加配置。\n\n## 拆分node_modules\n\n对于一般比较大型的B端管理系统项目，一般都会使用一些UI组件库，图表库等第三方库，这些第三方库一般都是通过`npm install`到`node_modules`下面，并且每个页面大多都会使用这些库，所以会在`main.js`中引入：\n\n```javascript\nVue.use(Antd)\nVue.use(Echarts)\n\n```\n在打包时，webpack会将这些公用的模块，抽离出来，放到一个公共模块中。这样不管这个模块被多少个入口引用，都只会在最终打包结果中出现一次，以此解决代码冗余。\n\n这些在使用Vue Cli的项目中已经自动帮我们做好了，主要利用了`optimization.splitChunks`配置，但是当我们把这些公用的模块都堆在一个模块中，这个文件可能异常巨大（一般是app.js，首屏就会加载这个文件，引用的公共第三方库越多，这个文件越大），也是不利于网络请求和页面加载的。所以我们需要把这个公共模块再按照一定规则进一步拆分成几个模块文件，减小文件体积，同时也可以利用HTTP2多路复用特性，这些则需要我们自己配置，代码如下：\n```javascript\n  config.optimization.splitChunks.cacheGroups.antdv = {\n      name:'chunk-antdv',// 抽离的模块名\n      priority: 20,// 优先级\n      test: /ant-design-vue/,\n      chunks: 'initial',\n      reuseExistingChunk: true,\n      enforce: true // 强制抽离此模块\n  }\n  config.optimization.splitChunks.cacheGroups.antdv = {\n    name:'chunk-echarts',// 抽离的模块名\n    priority: 20,// 优先级\n    test: /echarts/,\n    chunks: 'initial',\n    reuseExistingChunk: true,\n    enforce: true // 强制抽离此模块\n}\n```\n上面代码在`vue.config.js`里，修改`configureWebpack`项来添加配置，关于`optimization.splitChunks`的配置，可以参考这个[文档](https://www.webpackjs.com/plugins/split-chunks-plugin/)，这里可以简单的解释一下上面配置的含义：\n\n1. 每个`cacheGroups`代表需要抽离的第三方库，这里有两个分别是ant-design-vue和echarts。\n2. `test`项表示要扫描的`node_modules`文件路径，这里简单采用了正则来匹配。\n3. `chunks`项有三个选项：`all`, `async`, `initial`。`initial` 代表负责异步模块和非异步模块加载的公共抽离，`async`代表只负责异步模块加载的公共抽离, `all`结合前面两者特点。\n\n## 定制资源文件加载位置\n\n对于使用Vue Cli创建的项目，一般来说都不会刻意的修改css，JavaScript文件加载的顺序，例如默认情况下webpack会把css放在<head>标签里，JavaScript文件放在<body>标签底部，所以，有时我们会在<body>标签底部引入一些第三方的JavaScript文件，例如jquery或者高德地图的api文件等等，如下所示：\n```html\n  <body>\n    <div id=\"app\"></div>\n    <script type=\"text/javascript\" src=\"https://webapi.amap.com/maps?v=1.4.15&key=c65f481aebaed72935e11654238ab5a6\"></script>\n    <script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js\"></script>\n    <!-- built files will be auto injected -->\n  </body>\n```\n我们知道，浏览器在解析HTML时，遇到非异步的资源，尤其是JavaScript文件资源时，会下载并解析，那么越先加载就越先解析，\n而默认情况下，项目构建之后，业务的核心JavaScript文件会被放在这些第三方的JavaScript文件后面加载，会对首屏的展示有一定的影响。\n\n解决这个问题，需要修改`html-webpack-plugin`配置，然后手动在index.html里，自定义文件的加载位置，代码如下：\n\n```javascript\n  config.plugin('html')\n  .tap(args => {\n    args[0].inject = false\n    return args\n  })\n```\n```html\n<% for (var css in htmlWebpackPlugin.files.css) { %>\n  <link href=\"<%=htmlWebpackPlugin.files.css[css] %>\" rel=\"stylesheet\">\n<% } %>\n...\n<% for (var chunk in htmlWebpackPlugin.files.chunks) { %>\n<script type=\"text/javascript\" src=\"<%=htmlWebpackPlugin.files.chunks[chunk].entry %>\"></script>\n<% } %>\n```\n\n这样，就可以将一些重要的首屏资源加载优先级提升，在一定情况下，优化首屏的加载速度。\n\n## PrerenderSpaPlugin首屏预渲染\n\n对于大多数的B端系统而言，大部分都是一个已Vue开发的单页应用SPA，所以首屏的内容基本上都是依赖JavaScript来进行渲染的，这样不仅依赖于JavaScript文件资源的加载，而且不利于SEO（可能大部分B端系统无需SEO，但不排除一些欢迎页或者品牌首页类似的页面有SEO的需求）。\n\nPrerenderSpaPlugin是一个可以将一些页面预先打包成静态资源页面的webpack插件，并且可以结合`vue-router`，来根据路由，配置指定的页面，它的工作流程如下图：\n\n![20181128215005309.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99f9e23383d54287958c36c9e5b1e949~tplv-k3u1fbpfcp-watermark.image)\n\n基于此，我们可以修改`vue.config.js`，添加PrerenderSpaPlugin支持，代码如下：\n\n```javascript\nnpm install prerender-spa-plugin --save-dev\nconst PrerenderSpaPlugin = require('prerender-spa-plugin')\n...\nnew PrerenderSpaPlugin({\n\n  staticDir: resolve('dist'),\n  // 对应自己的路由文件，比如a有参数，就需要写成 /a/param1。\n  routes: ['/login', '/about'],\n}),\n```\n上面代码中，给`/login`和`/about`两个路由配置了预加载，在项目dist之后，就可以看到两个独立的html文件，在通过一些nginx配置，将对应的路径直接转发到对应的静态页面即可。更多关于PrerenderSpaPlugin可以参考[配置](https://github.com/chrisvfritz/prerender-spa-plugin)。\n\n## 图片压缩\n\n默认情况下，Vue Cli创建的项目不会对项目中引入的一些图片资源进行二次压缩，这时如果引入一些较大的图片，并且比较多的情况下，会导致dist之后的包变得很大，这时可以采用`image-webpack-loader`来开启配置图片压缩，添加`image-webpack-loader`，代码如下：\n```javascript\nnpm install image-webpack-loader --save-dev\n...\nconfig.module\n    .rule('images')\n    .use('image-webpack-loader')\n    .loader('image-webpack-loader')\n    .options({ bypassOnDebug: true })\n    .end()\n```\n\n上面代码修改`vue.config.js`的`chainWebpack`来添加配置，`image-webpack-loader`始于[imagemin](https://github.com/imagemin/imagemin)开发的webpack的loader，可以支持无损和有损压缩。\n\n## 结语\n\n对于大多数的B端系统而言，可能更注重复杂的业务逻辑实现，但可能也会忽略一些基本的性能优化，对于整个系统而言，给到良好的用户体验才能让系统变得更加健壮，同时也是一名前端工程师的成就所在。\n\n\n","slug":"Vue开发B端系统常见性能优化技巧","published":1,"updated":"2021-12-10T16:13:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434q0j001u2wvjkdpq9dcc","content":"<p>最近工作上一直接触的时B端的管理系统，基本上都是采用Vue Cli生成脚手架后就直接开始写业务逻辑，所以一般都会忽略一些性能优化相关的想法和工作。虽说这种系统对前端要求一般来说比较简单，大多数是一些数据校验和可视化展示，可能重点的工作量在于业务逻辑，但是作为一个前端项目来说，基本的优化还是需要做的，可以参考这篇<a href=\"https://juejin.cn/post/6844903801296519181\" target=\"_blank\" rel=\"noopener\">文章</a>。</p>\n<p>而本文将会介绍一些基于Vue Cli项目会被我们忽略的一些性能优化，尤其是首屏优化的技巧，如果对你有帮助，可以点赞支持一下。<br><a id=\"more\"></a></p>\n<h2><span id=\"ui库按需加载\">UI库按需加载</span></h2><p>对于大多是B端系统而言，都会使用一些一些UI组件库，例如Ant Design或者是Element UI，这些组件都是支持按需引入，我们在使用这些组件时，如果只用到了其中一部分组件，可以配置按需加载，在<code>main.js</code>中修改代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;</span><br><span class=\"line\">    Pagination,</span><br><span class=\"line\">    Icon,</span><br><span class=\"line\">    Tabs,</span><br><span class=\"line\">&#125; <span class=\"keyword\">from</span> <span class=\"string\">'ant-design-vue'</span></span><br><span class=\"line\"><span class=\"comment\">// import 'ant-design-vue/dist/antd.css'  已经通过babel引入 这里就不全局引入了</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Pagination)</span><br><span class=\"line\">    .use(Icon)</span><br><span class=\"line\">    .use(Tabs)</span><br></pre></td></tr></table></figure></p>\n<p>然后修改<code>babel.config.js</code>，如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"plugins\"</span>: [</span><br><span class=\"line\">  [<span class=\"string\">\"import\"</span>, &#123; <span class=\"string\">\"libraryName\"</span>: <span class=\"string\">\"ant-design-vue\"</span>, <span class=\"string\">\"libraryDirectory\"</span>: <span class=\"string\">\"es\"</span>, <span class=\"string\">\"style\"</span>: <span class=\"string\">\"css\"</span> &#125;], <span class=\"comment\">// `style: true` 会加载 less 文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<p>这样，组件对应的js和css文件就可以实现按需加载，关于<code>babel.config.js</code>的配置，可以参考之前的一篇<a href=\"https://juejin.cn/post/6906362999703863304\" target=\"_blank\" rel=\"noopener\">文章</a>。</p>\n<h2><span id=\"使用webpack-bundle-analyzer分析打包后的资源包\">使用webpack-bundle-analyzer分析打包后的资源包</span></h2><p><code>webpack-bundle-analyzer</code>是一个webpack插件，它可以直观分析打包出的文件包含哪些，大小占比如何，模块包含关系，依赖项，文件是否重复，压缩后大小如何，针对这些，我们可以进行文件分割等操作，是我们后面分析资源包大小的基础。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 分析包内容 </span></span><br><span class=\"line\">npm install webpack-bundle-analyzer --save-dev</span><br><span class=\"line\"><span class=\"keyword\">const</span> BundleAnalyzerPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin; </span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123; </span><br><span class=\"line\">plugins: [ </span><br><span class=\"line\"><span class=\"comment\">// 开启 BundleAnalyzerPlugin </span></span><br><span class=\"line\">      <span class=\"keyword\">new</span> BundleAnalyzerPlugin(), </span><br><span class=\"line\">    ], </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>配置完成之后，只需要<code>npm run build</code>即可，会自动打开<a href=\"http://127.0.0.1:8888/\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8888/</a></p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/446d403e2acb4c4c867230399e7c0a84~tplv-k3u1fbpfcp-watermark.image\" alt=\"686316-20180808143606193-2047520260.png\"></p>\n<h2><span id=\"路由懒加载\">路由懒加载</span></h2><p>对于一般比较大型的B端管理系统项目，基本上都会使用Vue Router来管理路由，这些项目涉及的页面都比较多，所以为了防止首屏资源过大，需要采用路由懒加载资源即Code Splitting，将每个页面的资源进行分离，这个只需在<code>router.js</code>里配置即可：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 采用箭头函数和import进行懒加载处理</span></span><br><span class=\"line\">component: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"string\">'./index.vue'</span>)</span><br></pre></td></tr></table></figure></p>\n<h2><span id=\"有选择的使用prefetch和preload\">有选择的使用prefetch和preload</span></h2><h3><span id=\"prefetch\">prefetch</span></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link rel=&quot;prefetch&quot; &gt;&lt;/link&gt;</span><br></pre></td></tr></table></figure>\n<p>这段代码告诉浏览器，这段资源将会在未来某个导航或者功能要用到，但是本资源的下载顺序权重比较低。也就是说prefetch通常用于加速下一次导航，而不是本次的。</p>\n<h3><span id=\"preload\">preload</span></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link rel=&quot;preload&quot; &gt;&lt;/link&gt;</span><br></pre></td></tr></table></figure>\n<p>preload通常用于本页面要用到的关键资源，包括关键js、字体、css文件。preload将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度。</p>\n<p>在使用Vue Cli生成的项目里，当我们配置了路由懒加载后，默认情况下webpack在构建时会对所有的懒加载资源进行<code>prefetch</code>和<code>preload</code>，所以当你打开首页时，会看到大量的<code>prefetch</code>和<code>preload</code>请求，如下图：<br><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e74b65731ff94c3ca31fb4481f3cdc9c~tplv-k3u1fbpfcp-watermark.image\" alt=\"0563B5CD-D598-40d1-A6D6-CE194BD3E8F5.png\"><br>虽说prefetch会在浏览器空闲时，下载相应文件，但这是一个很笼统的定义，这些大量的预加载资源会占用浏览器的资源，可能会导致一些关键的api请求或者图片请求受影响，所以对于这种情况，可以选择指定一些资源进行预加载或者禁止掉这些预加载，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 禁止prefetch和preload</span></span><br><span class=\"line\">chainWebpack: <span class=\"function\">(<span class=\"params\">config</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  config.plugins.delete(<span class=\"string\">'prefetch'</span>)</span><br><span class=\"line\">  config.plugins.delete(<span class=\"string\">'preload'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 有选择的prefetch和preload</span></span><br><span class=\"line\">config.plugin(<span class=\"string\">'prefetch'</span>).tap(<span class=\"function\"><span class=\"params\">options</span> =&gt;</span> &#123;</span><br><span class=\"line\">    options[<span class=\"number\">0</span>].fileBlacklist = options[<span class=\"number\">0</span>].fileBlacklist || []</span><br><span class=\"line\">    options[<span class=\"number\">0</span>].fileBlacklist.push(<span class=\"regexp\">/myasyncRoute(.)+?\\.js$/</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> options</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>上面代码修改<code>vue.config.js</code>的<code>chainWebpack</code>来添加配置。</p>\n<h2><span id=\"拆分node_modules\">拆分node_modules</span></h2><p>对于一般比较大型的B端管理系统项目，一般都会使用一些UI组件库，图表库等第三方库，这些第三方库一般都是通过<code>npm install</code>到<code>node_modules</code>下面，并且每个页面大多都会使用这些库，所以会在<code>main.js</code>中引入：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.use(Antd)</span><br><span class=\"line\">Vue.use(Echarts)</span><br></pre></td></tr></table></figure>\n<p>在打包时，webpack会将这些公用的模块，抽离出来，放到一个公共模块中。这样不管这个模块被多少个入口引用，都只会在最终打包结果中出现一次，以此解决代码冗余。</p>\n<p>这些在使用Vue Cli的项目中已经自动帮我们做好了，主要利用了<code>optimization.splitChunks</code>配置，但是当我们把这些公用的模块都堆在一个模块中，这个文件可能异常巨大（一般是app.js，首屏就会加载这个文件，引用的公共第三方库越多，这个文件越大），也是不利于网络请求和页面加载的。所以我们需要把这个公共模块再按照一定规则进一步拆分成几个模块文件，减小文件体积，同时也可以利用HTTP2多路复用特性，这些则需要我们自己配置，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  config.optimization.splitChunks.cacheGroups.antdv = &#123;</span><br><span class=\"line\">      name:<span class=\"string\">'chunk-antdv'</span>,<span class=\"comment\">// 抽离的模块名</span></span><br><span class=\"line\">      priority: <span class=\"number\">20</span>,<span class=\"comment\">// 优先级</span></span><br><span class=\"line\">      test: <span class=\"regexp\">/ant-design-vue/</span>,</span><br><span class=\"line\">      chunks: <span class=\"string\">'initial'</span>,</span><br><span class=\"line\">      reuseExistingChunk: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      enforce: <span class=\"literal\">true</span> <span class=\"comment\">// 强制抽离此模块</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  config.optimization.splitChunks.cacheGroups.antdv = &#123;</span><br><span class=\"line\">    name:<span class=\"string\">'chunk-echarts'</span>,<span class=\"comment\">// 抽离的模块名</span></span><br><span class=\"line\">    priority: <span class=\"number\">20</span>,<span class=\"comment\">// 优先级</span></span><br><span class=\"line\">    test: <span class=\"regexp\">/echarts/</span>,</span><br><span class=\"line\">    chunks: <span class=\"string\">'initial'</span>,</span><br><span class=\"line\">    reuseExistingChunk: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    enforce: <span class=\"literal\">true</span> <span class=\"comment\">// 强制抽离此模块</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码在<code>vue.config.js</code>里，修改<code>configureWebpack</code>项来添加配置，关于<code>optimization.splitChunks</code>的配置，可以参考这个<a href=\"https://www.webpackjs.com/plugins/split-chunks-plugin/\" target=\"_blank\" rel=\"noopener\">文档</a>，这里可以简单的解释一下上面配置的含义：</p>\n<ol>\n<li>每个<code>cacheGroups</code>代表需要抽离的第三方库，这里有两个分别是ant-design-vue和echarts。</li>\n<li><code>test</code>项表示要扫描的<code>node_modules</code>文件路径，这里简单采用了正则来匹配。</li>\n<li><code>chunks</code>项有三个选项：<code>all</code>, <code>async</code>, <code>initial</code>。<code>initial</code> 代表负责异步模块和非异步模块加载的公共抽离，<code>async</code>代表只负责异步模块加载的公共抽离, <code>all</code>结合前面两者特点。</li>\n</ol>\n<h2><span id=\"定制资源文件加载位置\">定制资源文件加载位置</span></h2><p>对于使用Vue Cli创建的项目，一般来说都不会刻意的修改css，JavaScript文件加载的顺序，例如默认情况下webpack会把css放在<head>标签里，JavaScript文件放在</head><body>标签底部，所以，有时我们会在<body>标签底部引入一些第三方的JavaScript文件，例如jquery或者高德地图的api文件等等，如下所示：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://webapi.amap.com/maps?v=1.4.15&amp;key=c65f481aebaed72935e11654238ab5a6\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- built files will be auto injected --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure></body></body></p>\n<p>我们知道，浏览器在解析HTML时，遇到非异步的资源，尤其是JavaScript文件资源时，会下载并解析，那么越先加载就越先解析，<br>而默认情况下，项目构建之后，业务的核心JavaScript文件会被放在这些第三方的JavaScript文件后面加载，会对首屏的展示有一定的影响。</p>\n<p>解决这个问题，需要修改<code>html-webpack-plugin</code>配置，然后手动在index.html里，自定义文件的加载位置，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config.plugin(<span class=\"string\">'html'</span>)</span><br><span class=\"line\">.tap(<span class=\"function\"><span class=\"params\">args</span> =&gt;</span> &#123;</span><br><span class=\"line\">  args[<span class=\"number\">0</span>].inject = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> args</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%</span> <span class=\"attr\">for</span> (<span class=\"attr\">var</span> <span class=\"attr\">css</span> <span class=\"attr\">in</span> <span class=\"attr\">htmlWebpackPlugin.files.css</span>) &#123; %&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">href</span>=<span class=\"string\">\"&lt;%=htmlWebpackPlugin.files.css[css] %&gt;\"</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%</span> &#125; %&gt;</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%</span> <span class=\"attr\">for</span> (<span class=\"attr\">var</span> <span class=\"attr\">chunk</span> <span class=\"attr\">in</span> <span class=\"attr\">htmlWebpackPlugin.files.chunks</span>) &#123; %&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"&lt;%=htmlWebpackPlugin.files.chunks[chunk].entry %&gt;\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这样，就可以将一些重要的首屏资源加载优先级提升，在一定情况下，优化首屏的加载速度。</p>\n<h2><span id=\"prerenderspaplugin首屏预渲染\">PrerenderSpaPlugin首屏预渲染</span></h2><p>对于大多数的B端系统而言，大部分都是一个已Vue开发的单页应用SPA，所以首屏的内容基本上都是依赖JavaScript来进行渲染的，这样不仅依赖于JavaScript文件资源的加载，而且不利于SEO（可能大部分B端系统无需SEO，但不排除一些欢迎页或者品牌首页类似的页面有SEO的需求）。</p>\n<p>PrerenderSpaPlugin是一个可以将一些页面预先打包成静态资源页面的webpack插件，并且可以结合<code>vue-router</code>，来根据路由，配置指定的页面，它的工作流程如下图：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99f9e23383d54287958c36c9e5b1e949~tplv-k3u1fbpfcp-watermark.image\" alt=\"20181128215005309.png\"></p>\n<p>基于此，我们可以修改<code>vue.config.js</code>，添加PrerenderSpaPlugin支持，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install prerender-spa-plugin --save-dev</span><br><span class=\"line\"><span class=\"keyword\">const</span> PrerenderSpaPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'prerender-spa-plugin'</span>)</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">new</span> PrerenderSpaPlugin(&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  staticDir: resolve(<span class=\"string\">'dist'</span>),</span><br><span class=\"line\">  <span class=\"comment\">// 对应自己的路由文件，比如a有参数，就需要写成 /a/param1。</span></span><br><span class=\"line\">  routes: [<span class=\"string\">'/login'</span>, <span class=\"string\">'/about'</span>],</span><br><span class=\"line\">&#125;),</span><br></pre></td></tr></table></figure>\n<p>上面代码中，给<code>/login</code>和<code>/about</code>两个路由配置了预加载，在项目dist之后，就可以看到两个独立的html文件，在通过一些nginx配置，将对应的路径直接转发到对应的静态页面即可。更多关于PrerenderSpaPlugin可以参考<a href=\"https://github.com/chrisvfritz/prerender-spa-plugin\" target=\"_blank\" rel=\"noopener\">配置</a>。</p>\n<h2><span id=\"图片压缩\">图片压缩</span></h2><p>默认情况下，Vue Cli创建的项目不会对项目中引入的一些图片资源进行二次压缩，这时如果引入一些较大的图片，并且比较多的情况下，会导致dist之后的包变得很大，这时可以采用<code>image-webpack-loader</code>来开启配置图片压缩，添加<code>image-webpack-loader</code>，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install image-webpack-loader --save-dev</span><br><span class=\"line\">...</span><br><span class=\"line\">config.module</span><br><span class=\"line\">    .rule(<span class=\"string\">'images'</span>)</span><br><span class=\"line\">    .use(<span class=\"string\">'image-webpack-loader'</span>)</span><br><span class=\"line\">    .loader(<span class=\"string\">'image-webpack-loader'</span>)</span><br><span class=\"line\">    .options(&#123; <span class=\"attr\">bypassOnDebug</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">    .end()</span><br></pre></td></tr></table></figure></p>\n<p>上面代码修改<code>vue.config.js</code>的<code>chainWebpack</code>来添加配置，<code>image-webpack-loader</code>始于<a href=\"https://github.com/imagemin/imagemin\" target=\"_blank\" rel=\"noopener\">imagemin</a>开发的webpack的loader，可以支持无损和有损压缩。</p>\n<h2><span id=\"结语\">结语</span></h2><p>对于大多数的B端系统而言，可能更注重复杂的业务逻辑实现，但可能也会忽略一些基本的性能优化，对于整个系统而言，给到良好的用户体验才能让系统变得更加健壮，同时也是一名前端工程师的成就所在。</p>\n","site":{"data":{}},"excerpt":"<p>最近工作上一直接触的时B端的管理系统，基本上都是采用Vue Cli生成脚手架后就直接开始写业务逻辑，所以一般都会忽略一些性能优化相关的想法和工作。虽说这种系统对前端要求一般来说比较简单，大多数是一些数据校验和可视化展示，可能重点的工作量在于业务逻辑，但是作为一个前端项目来说，基本的优化还是需要做的，可以参考这篇<a href=\"https://juejin.cn/post/6844903801296519181\" target=\"_blank\" rel=\"noopener\">文章</a>。</p>\n<p>而本文将会介绍一些基于Vue Cli项目会被我们忽略的一些性能优化，尤其是首屏优化的技巧，如果对你有帮助，可以点赞支持一下。<br>","more":"</p>\n<h2 id=\"UI库按需加载\"><a href=\"#UI库按需加载\" class=\"headerlink\" title=\"UI库按需加载\"></a>UI库按需加载</h2><p>对于大多是B端系统而言，都会使用一些一些UI组件库，例如Ant Design或者是Element UI，这些组件都是支持按需引入，我们在使用这些组件时，如果只用到了其中一部分组件，可以配置按需加载，在<code>main.js</code>中修改代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;</span><br><span class=\"line\">    Pagination,</span><br><span class=\"line\">    Icon,</span><br><span class=\"line\">    Tabs,</span><br><span class=\"line\">&#125; <span class=\"keyword\">from</span> <span class=\"string\">'ant-design-vue'</span></span><br><span class=\"line\"><span class=\"comment\">// import 'ant-design-vue/dist/antd.css'  已经通过babel引入 这里就不全局引入了</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Pagination)</span><br><span class=\"line\">    .use(Icon)</span><br><span class=\"line\">    .use(Tabs)</span><br></pre></td></tr></table></figure></p>\n<p>然后修改<code>babel.config.js</code>，如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"plugins\"</span>: [</span><br><span class=\"line\">  [<span class=\"string\">\"import\"</span>, &#123; <span class=\"string\">\"libraryName\"</span>: <span class=\"string\">\"ant-design-vue\"</span>, <span class=\"string\">\"libraryDirectory\"</span>: <span class=\"string\">\"es\"</span>, <span class=\"string\">\"style\"</span>: <span class=\"string\">\"css\"</span> &#125;], <span class=\"comment\">// `style: true` 会加载 less 文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<p>这样，组件对应的js和css文件就可以实现按需加载，关于<code>babel.config.js</code>的配置，可以参考之前的一篇<a href=\"https://juejin.cn/post/6906362999703863304\" target=\"_blank\" rel=\"noopener\">文章</a>。</p>\n<h2 id=\"使用webpack-bundle-analyzer分析打包后的资源包\"><a href=\"#使用webpack-bundle-analyzer分析打包后的资源包\" class=\"headerlink\" title=\"使用webpack-bundle-analyzer分析打包后的资源包\"></a>使用webpack-bundle-analyzer分析打包后的资源包</h2><p><code>webpack-bundle-analyzer</code>是一个webpack插件，它可以直观分析打包出的文件包含哪些，大小占比如何，模块包含关系，依赖项，文件是否重复，压缩后大小如何，针对这些，我们可以进行文件分割等操作，是我们后面分析资源包大小的基础。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 分析包内容 </span></span><br><span class=\"line\">npm install webpack-bundle-analyzer --save-dev</span><br><span class=\"line\"><span class=\"keyword\">const</span> BundleAnalyzerPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin; </span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123; </span><br><span class=\"line\">plugins: [ </span><br><span class=\"line\"><span class=\"comment\">// 开启 BundleAnalyzerPlugin </span></span><br><span class=\"line\">      <span class=\"keyword\">new</span> BundleAnalyzerPlugin(), </span><br><span class=\"line\">    ], </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>配置完成之后，只需要<code>npm run build</code>即可，会自动打开<a href=\"http://127.0.0.1:8888/\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8888/</a></p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/446d403e2acb4c4c867230399e7c0a84~tplv-k3u1fbpfcp-watermark.image\" alt=\"686316-20180808143606193-2047520260.png\"></p>\n<h2 id=\"路由懒加载\"><a href=\"#路由懒加载\" class=\"headerlink\" title=\"路由懒加载\"></a>路由懒加载</h2><p>对于一般比较大型的B端管理系统项目，基本上都会使用Vue Router来管理路由，这些项目涉及的页面都比较多，所以为了防止首屏资源过大，需要采用路由懒加载资源即Code Splitting，将每个页面的资源进行分离，这个只需在<code>router.js</code>里配置即可：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 采用箭头函数和import进行懒加载处理</span></span><br><span class=\"line\">component: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"string\">'./index.vue'</span>)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"有选择的使用prefetch和preload\"><a href=\"#有选择的使用prefetch和preload\" class=\"headerlink\" title=\"有选择的使用prefetch和preload\"></a>有选择的使用prefetch和preload</h2><h3 id=\"prefetch\"><a href=\"#prefetch\" class=\"headerlink\" title=\"prefetch\"></a>prefetch</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link rel=&quot;prefetch&quot; &gt;&lt;/link&gt;</span><br></pre></td></tr></table></figure>\n<p>这段代码告诉浏览器，这段资源将会在未来某个导航或者功能要用到，但是本资源的下载顺序权重比较低。也就是说prefetch通常用于加速下一次导航，而不是本次的。</p>\n<h3 id=\"preload\"><a href=\"#preload\" class=\"headerlink\" title=\"preload\"></a>preload</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link rel=&quot;preload&quot; &gt;&lt;/link&gt;</span><br></pre></td></tr></table></figure>\n<p>preload通常用于本页面要用到的关键资源，包括关键js、字体、css文件。preload将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度。</p>\n<p>在使用Vue Cli生成的项目里，当我们配置了路由懒加载后，默认情况下webpack在构建时会对所有的懒加载资源进行<code>prefetch</code>和<code>preload</code>，所以当你打开首页时，会看到大量的<code>prefetch</code>和<code>preload</code>请求，如下图：<br><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e74b65731ff94c3ca31fb4481f3cdc9c~tplv-k3u1fbpfcp-watermark.image\" alt=\"0563B5CD-D598-40d1-A6D6-CE194BD3E8F5.png\"><br>虽说prefetch会在浏览器空闲时，下载相应文件，但这是一个很笼统的定义，这些大量的预加载资源会占用浏览器的资源，可能会导致一些关键的api请求或者图片请求受影响，所以对于这种情况，可以选择指定一些资源进行预加载或者禁止掉这些预加载，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 禁止prefetch和preload</span></span><br><span class=\"line\">chainWebpack: <span class=\"function\">(<span class=\"params\">config</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  config.plugins.delete(<span class=\"string\">'prefetch'</span>)</span><br><span class=\"line\">  config.plugins.delete(<span class=\"string\">'preload'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 有选择的prefetch和preload</span></span><br><span class=\"line\">config.plugin(<span class=\"string\">'prefetch'</span>).tap(<span class=\"function\"><span class=\"params\">options</span> =&gt;</span> &#123;</span><br><span class=\"line\">    options[<span class=\"number\">0</span>].fileBlacklist = options[<span class=\"number\">0</span>].fileBlacklist || []</span><br><span class=\"line\">    options[<span class=\"number\">0</span>].fileBlacklist.push(<span class=\"regexp\">/myasyncRoute(.)+?\\.js$/</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> options</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>上面代码修改<code>vue.config.js</code>的<code>chainWebpack</code>来添加配置。</p>\n<h2 id=\"拆分node-modules\"><a href=\"#拆分node-modules\" class=\"headerlink\" title=\"拆分node_modules\"></a>拆分node_modules</h2><p>对于一般比较大型的B端管理系统项目，一般都会使用一些UI组件库，图表库等第三方库，这些第三方库一般都是通过<code>npm install</code>到<code>node_modules</code>下面，并且每个页面大多都会使用这些库，所以会在<code>main.js</code>中引入：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.use(Antd)</span><br><span class=\"line\">Vue.use(Echarts)</span><br></pre></td></tr></table></figure>\n<p>在打包时，webpack会将这些公用的模块，抽离出来，放到一个公共模块中。这样不管这个模块被多少个入口引用，都只会在最终打包结果中出现一次，以此解决代码冗余。</p>\n<p>这些在使用Vue Cli的项目中已经自动帮我们做好了，主要利用了<code>optimization.splitChunks</code>配置，但是当我们把这些公用的模块都堆在一个模块中，这个文件可能异常巨大（一般是app.js，首屏就会加载这个文件，引用的公共第三方库越多，这个文件越大），也是不利于网络请求和页面加载的。所以我们需要把这个公共模块再按照一定规则进一步拆分成几个模块文件，减小文件体积，同时也可以利用HTTP2多路复用特性，这些则需要我们自己配置，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  config.optimization.splitChunks.cacheGroups.antdv = &#123;</span><br><span class=\"line\">      name:<span class=\"string\">'chunk-antdv'</span>,<span class=\"comment\">// 抽离的模块名</span></span><br><span class=\"line\">      priority: <span class=\"number\">20</span>,<span class=\"comment\">// 优先级</span></span><br><span class=\"line\">      test: <span class=\"regexp\">/ant-design-vue/</span>,</span><br><span class=\"line\">      chunks: <span class=\"string\">'initial'</span>,</span><br><span class=\"line\">      reuseExistingChunk: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      enforce: <span class=\"literal\">true</span> <span class=\"comment\">// 强制抽离此模块</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  config.optimization.splitChunks.cacheGroups.antdv = &#123;</span><br><span class=\"line\">    name:<span class=\"string\">'chunk-echarts'</span>,<span class=\"comment\">// 抽离的模块名</span></span><br><span class=\"line\">    priority: <span class=\"number\">20</span>,<span class=\"comment\">// 优先级</span></span><br><span class=\"line\">    test: <span class=\"regexp\">/echarts/</span>,</span><br><span class=\"line\">    chunks: <span class=\"string\">'initial'</span>,</span><br><span class=\"line\">    reuseExistingChunk: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    enforce: <span class=\"literal\">true</span> <span class=\"comment\">// 强制抽离此模块</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码在<code>vue.config.js</code>里，修改<code>configureWebpack</code>项来添加配置，关于<code>optimization.splitChunks</code>的配置，可以参考这个<a href=\"https://www.webpackjs.com/plugins/split-chunks-plugin/\" target=\"_blank\" rel=\"noopener\">文档</a>，这里可以简单的解释一下上面配置的含义：</p>\n<ol>\n<li>每个<code>cacheGroups</code>代表需要抽离的第三方库，这里有两个分别是ant-design-vue和echarts。</li>\n<li><code>test</code>项表示要扫描的<code>node_modules</code>文件路径，这里简单采用了正则来匹配。</li>\n<li><code>chunks</code>项有三个选项：<code>all</code>, <code>async</code>, <code>initial</code>。<code>initial</code> 代表负责异步模块和非异步模块加载的公共抽离，<code>async</code>代表只负责异步模块加载的公共抽离, <code>all</code>结合前面两者特点。</li>\n</ol>\n<h2 id=\"定制资源文件加载位置\"><a href=\"#定制资源文件加载位置\" class=\"headerlink\" title=\"定制资源文件加载位置\"></a>定制资源文件加载位置</h2><p>对于使用Vue Cli创建的项目，一般来说都不会刻意的修改css，JavaScript文件加载的顺序，例如默认情况下webpack会把css放在<head>标签里，JavaScript文件放在</head><body>标签底部，所以，有时我们会在<body>标签底部引入一些第三方的JavaScript文件，例如jquery或者高德地图的api文件等等，如下所示：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://webapi.amap.com/maps?v=1.4.15&amp;key=c65f481aebaed72935e11654238ab5a6\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- built files will be auto injected --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure></body></body></p>\n<p>我们知道，浏览器在解析HTML时，遇到非异步的资源，尤其是JavaScript文件资源时，会下载并解析，那么越先加载就越先解析，<br>而默认情况下，项目构建之后，业务的核心JavaScript文件会被放在这些第三方的JavaScript文件后面加载，会对首屏的展示有一定的影响。</p>\n<p>解决这个问题，需要修改<code>html-webpack-plugin</code>配置，然后手动在index.html里，自定义文件的加载位置，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config.plugin(<span class=\"string\">'html'</span>)</span><br><span class=\"line\">.tap(<span class=\"function\"><span class=\"params\">args</span> =&gt;</span> &#123;</span><br><span class=\"line\">  args[<span class=\"number\">0</span>].inject = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> args</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%</span> <span class=\"attr\">for</span> (<span class=\"attr\">var</span> <span class=\"attr\">css</span> <span class=\"attr\">in</span> <span class=\"attr\">htmlWebpackPlugin.files.css</span>) &#123; %&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">href</span>=<span class=\"string\">\"&lt;%=htmlWebpackPlugin.files.css[css] %&gt;\"</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%</span> &#125; %&gt;</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%</span> <span class=\"attr\">for</span> (<span class=\"attr\">var</span> <span class=\"attr\">chunk</span> <span class=\"attr\">in</span> <span class=\"attr\">htmlWebpackPlugin.files.chunks</span>) &#123; %&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"&lt;%=htmlWebpackPlugin.files.chunks[chunk].entry %&gt;\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这样，就可以将一些重要的首屏资源加载优先级提升，在一定情况下，优化首屏的加载速度。</p>\n<h2 id=\"PrerenderSpaPlugin首屏预渲染\"><a href=\"#PrerenderSpaPlugin首屏预渲染\" class=\"headerlink\" title=\"PrerenderSpaPlugin首屏预渲染\"></a>PrerenderSpaPlugin首屏预渲染</h2><p>对于大多数的B端系统而言，大部分都是一个已Vue开发的单页应用SPA，所以首屏的内容基本上都是依赖JavaScript来进行渲染的，这样不仅依赖于JavaScript文件资源的加载，而且不利于SEO（可能大部分B端系统无需SEO，但不排除一些欢迎页或者品牌首页类似的页面有SEO的需求）。</p>\n<p>PrerenderSpaPlugin是一个可以将一些页面预先打包成静态资源页面的webpack插件，并且可以结合<code>vue-router</code>，来根据路由，配置指定的页面，它的工作流程如下图：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99f9e23383d54287958c36c9e5b1e949~tplv-k3u1fbpfcp-watermark.image\" alt=\"20181128215005309.png\"></p>\n<p>基于此，我们可以修改<code>vue.config.js</code>，添加PrerenderSpaPlugin支持，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install prerender-spa-plugin --save-dev</span><br><span class=\"line\"><span class=\"keyword\">const</span> PrerenderSpaPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'prerender-spa-plugin'</span>)</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">new</span> PrerenderSpaPlugin(&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  staticDir: resolve(<span class=\"string\">'dist'</span>),</span><br><span class=\"line\">  <span class=\"comment\">// 对应自己的路由文件，比如a有参数，就需要写成 /a/param1。</span></span><br><span class=\"line\">  routes: [<span class=\"string\">'/login'</span>, <span class=\"string\">'/about'</span>],</span><br><span class=\"line\">&#125;),</span><br></pre></td></tr></table></figure>\n<p>上面代码中，给<code>/login</code>和<code>/about</code>两个路由配置了预加载，在项目dist之后，就可以看到两个独立的html文件，在通过一些nginx配置，将对应的路径直接转发到对应的静态页面即可。更多关于PrerenderSpaPlugin可以参考<a href=\"https://github.com/chrisvfritz/prerender-spa-plugin\" target=\"_blank\" rel=\"noopener\">配置</a>。</p>\n<h2 id=\"图片压缩\"><a href=\"#图片压缩\" class=\"headerlink\" title=\"图片压缩\"></a>图片压缩</h2><p>默认情况下，Vue Cli创建的项目不会对项目中引入的一些图片资源进行二次压缩，这时如果引入一些较大的图片，并且比较多的情况下，会导致dist之后的包变得很大，这时可以采用<code>image-webpack-loader</code>来开启配置图片压缩，添加<code>image-webpack-loader</code>，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install image-webpack-loader --save-dev</span><br><span class=\"line\">...</span><br><span class=\"line\">config.module</span><br><span class=\"line\">    .rule(<span class=\"string\">'images'</span>)</span><br><span class=\"line\">    .use(<span class=\"string\">'image-webpack-loader'</span>)</span><br><span class=\"line\">    .loader(<span class=\"string\">'image-webpack-loader'</span>)</span><br><span class=\"line\">    .options(&#123; <span class=\"attr\">bypassOnDebug</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">    .end()</span><br></pre></td></tr></table></figure></p>\n<p>上面代码修改<code>vue.config.js</code>的<code>chainWebpack</code>来添加配置，<code>image-webpack-loader</code>始于<a href=\"https://github.com/imagemin/imagemin\" target=\"_blank\" rel=\"noopener\">imagemin</a>开发的webpack的loader，可以支持无损和有损压缩。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>对于大多数的B端系统而言，可能更注重复杂的业务逻辑实现，但可能也会忽略一些基本的性能优化，对于整个系统而言，给到良好的用户体验才能让系统变得更加健壮，同时也是一名前端工程师的成就所在。</p>"},{"title":"Webpack1升级Webpack2整理总结","date":"2017-07-09T15:00:13.000Z","photos":["https://qiniu.nihaoshijie.com.cn/u%3D3396435274%2C4251997814%26fm%3D26%26gp%3D0.jpg"],"_content":"\nWebpack2已经发布半年之多了，就连webpack3都已经发布了，但是项目目前还是使用的webpack1，有点跟不上节奏，webpack2的诸多特性类似tree-shaking等等新特性还是比较令人激动的，现在整理一下从webpack1升级到webpack2的过程。\n### 1.package.json的整体变化\n<!--more-->\n如下图：分别对相关的组件进行升级，图上所示的需要升级的组件只是针对自己项目的，如果需要升级其他组件可以根据自己的需求升级。\n![](https://qiniu.nihaoshijie.com.cn/blogcaikeng1.png)\n\n### 2.安装升级组件\n每种组件的升级有两种办法：\n1. 将组件从node_modules里面删掉，同时删掉package.json里的配置，然后在`npm install XXX`可以直接从官网下载最新的包。\n2. 采用`npm install --save-dev xxx@版本号`的方式安装指定版本的包，同时package.json会自动更新。\n个人推荐使用第二种方式，比较灵活。\n\n### 3.修改webpack配置文件webpack.config.js\n\n#### 1). resolve.extensions的修改：\n将`extensions: ['', '.js', '.jsx']`改为`extensions: ['.js', '.jsx']`webpack2修复了webpack1必须要求第一个数组元素填空的要求。\n#### 2). resolve.mudule的修改：\n主要是将原本的loaders和loader的搭配写法改为rules加上use的写法:\n```javascript\nloaders: [{\n    test: /\\.jsx?$/,\n    loader: 'happypack/loader?id=jsx',\n    include: path.resolve(config.srcPath)\n}, {\n    test: /\\.css$/,\n    loader: ExtractTextPlugin.extract(\"style-loader\",'happypack/loader?id=css'),\n    include: path.resolve(config.srcPath)\n}, {\n    test: /\\.less$/,\n    loader: ExtractTextPlugin.extract(\"style-loader\", 'happypack/loader?id=less'),\n    include: path.resolve(config.srcPath)\n}, {\n    test: /\\.(jpe?g|png|gif|svg)$/i,\n    loader: 'url-loader?limit=1500&name=images/[name].[hash].[ext]',\n    include: path.resolve(config.srcPath)\n}]\n```\n改为：\n```javascript\nrules: [{\n    test: /\\.jsx?$/,\n    use: 'happypack/loader?id=jsx',\n    include: path.resolve(config.srcPath)\n}, {\n    test: /\\.less$/,\n    use: ExtractTextPlugin.extract({fallback:\"style-loader\", use:'happypack/loader?id=less'}),\n    include: path.resolve(config.srcPath)\n}, {\n    test: /\\.css$/,\n    use: ExtractTextPlugin.extract({fallback:\"style-loader\", use:'happypack/loader?id=css'}),\n    include: path.resolve(config.srcPath)\n}, {\n    test: /\\.(jpe?g|png|gif|svg)$/i,\n    loader: 'url-loader?limit=1500&name=images/[name].[hash].[ext]',\n    include: path.resolve(config.srcPath)\n}]\n```\n这个修改并不是必须的，webpack2同时支持原有的写法，但是为了规范起见还是采用webpack2新写法为好。\n\n#### 3). ExtractTextPlugin写法的修改：\n\n```javascript\nExtractTextPlugin.extract(\"style-loader\", 'happypack/loader?id=less')\n```\n修改为\n```\nExtractTextPlugin.extract({fallback:\"style-loader\", use:'happypack/loader?id=less'})\n```\n坑：在网上查资料时有些是将`fallback`写成`fallbackCallback`不要相信，还是安装`fallback`来。\n\n#### 3). ExtractTextPlugin的plugins写法的修改：\n\n```\nnew ExtractTextPlugin(\"../css/[name].min.css\", {\n    allChunks: true\n}),\n```\n修改为：\n```\nnew ExtractTextPlugin({\n    filename: \"../css/[name].min.css\",\n    allChunks: true\n}),\n```\n没啥说的，就是将原本的string加obj的形式修改为obj形式的参数。\n\n#### 4). CommonsChunkPlugin的plugins写法的修改：\n\n```\nnew CommonsChunkPlugin(\"common\", \"common.min.js\", ['index', 'barindex', 'detail']),\n```\n修改为：\n```\nnew webpack.optimize.CommonsChunkPlugin({\n    name: 'common', \n    filename: 'common.min.js',\n    chunks: ['index', 'barindex', 'detail'] \n}),\n```\n坑：注意如果采用了CommonsChunkPlugin将公共模块提取出来，同时采用了require.ensure的方式来异步拉取js，则上一步的ExtractTextPlugin的allChunks必须设置成为true。\n坑：路径问题：webpack2采用绝对路径，所以直接填写的相对路径都需要__dirname来转换成绝对路径。\n\n#### 5). happypack写法的修改：\n1. happypack：采用多进程来加快webpack的构建速度的组件。目前最新版本是4.0.0但是笔着并没有升级到最新版本，而是采用了更稳定的3.1.0版本，如果升级到最新版本原有的相关配置项都需要修改，例如`cache`属性将不再被支持，可以参照官方的[文档](https://www.npmjs.com/package/happypack)。\n2. happypack自带有.happypack目录的缓存，记得升级完成之后需要删除这个目录下的文件，重新生成。\n\n### 4.关于require.ensure\n1）升级webpack2的另外一个重要因素就是：原本采用`require.ensure`来异步加载代码时无法捕获到组件拉取失败的回调，需要单独引入一个插件`require('require-error-handler-webpack-plugin')`来解决,但是升级了webpack2之后，原生就已经支持了，所以不需要引入这个插件了。\n![](https://qiniu.nihaoshijie.com.cn/blog/caikeng2.png)\n2) 在webpack2环境下使用`require.ensure`还需要注意一点就是必须引入`babel-polyfill`来支持Promise写法，因为webpack2的`require.ensure`采用的Promise来实现回调，所以必须引入这个。\n3）引入babel-polyfill之后可能会使js文件增加许多，这里同样推荐使用es6-promis来只针对promise来进行polyfil，减少文件增加的大小。\n\n### 5.关于tree-shaking\n在升级完成webpack2之后，webpack构建会自动支持[tree-shaking](https://webpack.js.org/guides/tree-shaking/)特性来进行代码层级的压缩优化，但是也有一些需要了解的：\n1）先要理解关于CommonJS和ES6 modules的区别。\n2）虽然采用了babel之后，代码还是最终会转为浏览器兼容性较好的es5，但是我们在写代码的时候还是推荐采用ES6 modules的写法。\n3）基于ES6来写，tree-shaking才能职别，才能根据import和export来查找引入的多余的代码。\n4）同时需要修改babel的配置文件`[\"es2015\",{\"modules\":false}]` 这样才能让webpack2先于babel来进行代码级别的tree-shaking优化。\n\n### 参考资料：\n[webpack2升级官方指南](https://webpack.js.org/guides/migrating/)","source":"_posts/Webpack1升级Webpack2整理总结.md","raw":"---\ntitle: Webpack1升级Webpack2整理总结\ndate: 2017-07-09 23:00:13\ntags:\n- webpack2\n- 升级\ncategories:\n- 702\nphotos: https://qiniu.nihaoshijie.com.cn/u%3D3396435274%2C4251997814%26fm%3D26%26gp%3D0.jpg\n---\n\nWebpack2已经发布半年之多了，就连webpack3都已经发布了，但是项目目前还是使用的webpack1，有点跟不上节奏，webpack2的诸多特性类似tree-shaking等等新特性还是比较令人激动的，现在整理一下从webpack1升级到webpack2的过程。\n### 1.package.json的整体变化\n<!--more-->\n如下图：分别对相关的组件进行升级，图上所示的需要升级的组件只是针对自己项目的，如果需要升级其他组件可以根据自己的需求升级。\n![](https://qiniu.nihaoshijie.com.cn/blogcaikeng1.png)\n\n### 2.安装升级组件\n每种组件的升级有两种办法：\n1. 将组件从node_modules里面删掉，同时删掉package.json里的配置，然后在`npm install XXX`可以直接从官网下载最新的包。\n2. 采用`npm install --save-dev xxx@版本号`的方式安装指定版本的包，同时package.json会自动更新。\n个人推荐使用第二种方式，比较灵活。\n\n### 3.修改webpack配置文件webpack.config.js\n\n#### 1). resolve.extensions的修改：\n将`extensions: ['', '.js', '.jsx']`改为`extensions: ['.js', '.jsx']`webpack2修复了webpack1必须要求第一个数组元素填空的要求。\n#### 2). resolve.mudule的修改：\n主要是将原本的loaders和loader的搭配写法改为rules加上use的写法:\n```javascript\nloaders: [{\n    test: /\\.jsx?$/,\n    loader: 'happypack/loader?id=jsx',\n    include: path.resolve(config.srcPath)\n}, {\n    test: /\\.css$/,\n    loader: ExtractTextPlugin.extract(\"style-loader\",'happypack/loader?id=css'),\n    include: path.resolve(config.srcPath)\n}, {\n    test: /\\.less$/,\n    loader: ExtractTextPlugin.extract(\"style-loader\", 'happypack/loader?id=less'),\n    include: path.resolve(config.srcPath)\n}, {\n    test: /\\.(jpe?g|png|gif|svg)$/i,\n    loader: 'url-loader?limit=1500&name=images/[name].[hash].[ext]',\n    include: path.resolve(config.srcPath)\n}]\n```\n改为：\n```javascript\nrules: [{\n    test: /\\.jsx?$/,\n    use: 'happypack/loader?id=jsx',\n    include: path.resolve(config.srcPath)\n}, {\n    test: /\\.less$/,\n    use: ExtractTextPlugin.extract({fallback:\"style-loader\", use:'happypack/loader?id=less'}),\n    include: path.resolve(config.srcPath)\n}, {\n    test: /\\.css$/,\n    use: ExtractTextPlugin.extract({fallback:\"style-loader\", use:'happypack/loader?id=css'}),\n    include: path.resolve(config.srcPath)\n}, {\n    test: /\\.(jpe?g|png|gif|svg)$/i,\n    loader: 'url-loader?limit=1500&name=images/[name].[hash].[ext]',\n    include: path.resolve(config.srcPath)\n}]\n```\n这个修改并不是必须的，webpack2同时支持原有的写法，但是为了规范起见还是采用webpack2新写法为好。\n\n#### 3). ExtractTextPlugin写法的修改：\n\n```javascript\nExtractTextPlugin.extract(\"style-loader\", 'happypack/loader?id=less')\n```\n修改为\n```\nExtractTextPlugin.extract({fallback:\"style-loader\", use:'happypack/loader?id=less'})\n```\n坑：在网上查资料时有些是将`fallback`写成`fallbackCallback`不要相信，还是安装`fallback`来。\n\n#### 3). ExtractTextPlugin的plugins写法的修改：\n\n```\nnew ExtractTextPlugin(\"../css/[name].min.css\", {\n    allChunks: true\n}),\n```\n修改为：\n```\nnew ExtractTextPlugin({\n    filename: \"../css/[name].min.css\",\n    allChunks: true\n}),\n```\n没啥说的，就是将原本的string加obj的形式修改为obj形式的参数。\n\n#### 4). CommonsChunkPlugin的plugins写法的修改：\n\n```\nnew CommonsChunkPlugin(\"common\", \"common.min.js\", ['index', 'barindex', 'detail']),\n```\n修改为：\n```\nnew webpack.optimize.CommonsChunkPlugin({\n    name: 'common', \n    filename: 'common.min.js',\n    chunks: ['index', 'barindex', 'detail'] \n}),\n```\n坑：注意如果采用了CommonsChunkPlugin将公共模块提取出来，同时采用了require.ensure的方式来异步拉取js，则上一步的ExtractTextPlugin的allChunks必须设置成为true。\n坑：路径问题：webpack2采用绝对路径，所以直接填写的相对路径都需要__dirname来转换成绝对路径。\n\n#### 5). happypack写法的修改：\n1. happypack：采用多进程来加快webpack的构建速度的组件。目前最新版本是4.0.0但是笔着并没有升级到最新版本，而是采用了更稳定的3.1.0版本，如果升级到最新版本原有的相关配置项都需要修改，例如`cache`属性将不再被支持，可以参照官方的[文档](https://www.npmjs.com/package/happypack)。\n2. happypack自带有.happypack目录的缓存，记得升级完成之后需要删除这个目录下的文件，重新生成。\n\n### 4.关于require.ensure\n1）升级webpack2的另外一个重要因素就是：原本采用`require.ensure`来异步加载代码时无法捕获到组件拉取失败的回调，需要单独引入一个插件`require('require-error-handler-webpack-plugin')`来解决,但是升级了webpack2之后，原生就已经支持了，所以不需要引入这个插件了。\n![](https://qiniu.nihaoshijie.com.cn/blog/caikeng2.png)\n2) 在webpack2环境下使用`require.ensure`还需要注意一点就是必须引入`babel-polyfill`来支持Promise写法，因为webpack2的`require.ensure`采用的Promise来实现回调，所以必须引入这个。\n3）引入babel-polyfill之后可能会使js文件增加许多，这里同样推荐使用es6-promis来只针对promise来进行polyfil，减少文件增加的大小。\n\n### 5.关于tree-shaking\n在升级完成webpack2之后，webpack构建会自动支持[tree-shaking](https://webpack.js.org/guides/tree-shaking/)特性来进行代码层级的压缩优化，但是也有一些需要了解的：\n1）先要理解关于CommonJS和ES6 modules的区别。\n2）虽然采用了babel之后，代码还是最终会转为浏览器兼容性较好的es5，但是我们在写代码的时候还是推荐采用ES6 modules的写法。\n3）基于ES6来写，tree-shaking才能职别，才能根据import和export来查找引入的多余的代码。\n4）同时需要修改babel的配置文件`[\"es2015\",{\"modules\":false}]` 这样才能让webpack2先于babel来进行代码级别的tree-shaking优化。\n\n### 参考资料：\n[webpack2升级官方指南](https://webpack.js.org/guides/migrating/)","slug":"Webpack1升级Webpack2整理总结","published":1,"updated":"2020-04-30T16:10:24.000Z","comments":1,"layout":"post","link":"","_id":"ckx434q0l001y2wvjng4ofx4a","content":"<p>Webpack2已经发布半年之多了，就连webpack3都已经发布了，但是项目目前还是使用的webpack1，有点跟不上节奏，webpack2的诸多特性类似tree-shaking等等新特性还是比较令人激动的，现在整理一下从webpack1升级到webpack2的过程。</p>\n<h3><span id=\"1packagejson的整体变化\">1.package.json的整体变化</span></h3><a id=\"more\"></a>\n<p>如下图：分别对相关的组件进行升级，图上所示的需要升级的组件只是针对自己项目的，如果需要升级其他组件可以根据自己的需求升级。<br><img src=\"https://qiniu.nihaoshijie.com.cn/blogcaikeng1.png\" alt></p>\n<h3><span id=\"2安装升级组件\">2.安装升级组件</span></h3><p>每种组件的升级有两种办法：</p>\n<ol>\n<li>将组件从node_modules里面删掉，同时删掉package.json里的配置，然后在<code>npm install XXX</code>可以直接从官网下载最新的包。</li>\n<li>采用<code>npm install --save-dev xxx@版本号</code>的方式安装指定版本的包，同时package.json会自动更新。<br>个人推荐使用第二种方式，比较灵活。</li>\n</ol>\n<h3><span id=\"3修改webpack配置文件webpackconfigjs\">3.修改webpack配置文件webpack.config.js</span></h3><h4><span id=\"1-resolveextensions的修改\">1). resolve.extensions的修改：</span></h4><p>将<code>extensions: [&#39;&#39;, &#39;.js&#39;, &#39;.jsx&#39;]</code>改为<code>extensions: [&#39;.js&#39;, &#39;.jsx&#39;]</code>webpack2修复了webpack1必须要求第一个数组元素填空的要求。</p>\n<h4><span id=\"2-resolvemudule的修改\">2). resolve.mudule的修改：</span></h4><p>主要是将原本的loaders和loader的搭配写法改为rules加上use的写法:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loaders: [&#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.jsx?$/</span>,</span><br><span class=\"line\">    loader: <span class=\"string\">'happypack/loader?id=jsx'</span>,</span><br><span class=\"line\">    include: path.resolve(config.srcPath)</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">    loader: ExtractTextPlugin.extract(<span class=\"string\">\"style-loader\"</span>,<span class=\"string\">'happypack/loader?id=css'</span>),</span><br><span class=\"line\">    include: path.resolve(config.srcPath)</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.less$/</span>,</span><br><span class=\"line\">    loader: ExtractTextPlugin.extract(<span class=\"string\">\"style-loader\"</span>, <span class=\"string\">'happypack/loader?id=less'</span>),</span><br><span class=\"line\">    include: path.resolve(config.srcPath)</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.(jpe?g|png|gif|svg)$/i</span>,</span><br><span class=\"line\">    loader: <span class=\"string\">'url-loader?limit=1500&amp;name=images/[name].[hash].[ext]'</span>,</span><br><span class=\"line\">    include: path.resolve(config.srcPath)</span><br><span class=\"line\">&#125;]</span><br></pre></td></tr></table></figure></p>\n<p>改为：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rules: [&#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.jsx?$/</span>,</span><br><span class=\"line\">    use: <span class=\"string\">'happypack/loader?id=jsx'</span>,</span><br><span class=\"line\">    include: path.resolve(config.srcPath)</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.less$/</span>,</span><br><span class=\"line\">    use: ExtractTextPlugin.extract(&#123;<span class=\"attr\">fallback</span>:<span class=\"string\">\"style-loader\"</span>, <span class=\"attr\">use</span>:<span class=\"string\">'happypack/loader?id=less'</span>&#125;),</span><br><span class=\"line\">    include: path.resolve(config.srcPath)</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">    use: ExtractTextPlugin.extract(&#123;<span class=\"attr\">fallback</span>:<span class=\"string\">\"style-loader\"</span>, <span class=\"attr\">use</span>:<span class=\"string\">'happypack/loader?id=css'</span>&#125;),</span><br><span class=\"line\">    include: path.resolve(config.srcPath)</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.(jpe?g|png|gif|svg)$/i</span>,</span><br><span class=\"line\">    loader: <span class=\"string\">'url-loader?limit=1500&amp;name=images/[name].[hash].[ext]'</span>,</span><br><span class=\"line\">    include: path.resolve(config.srcPath)</span><br><span class=\"line\">&#125;]</span><br></pre></td></tr></table></figure></p>\n<p>这个修改并不是必须的，webpack2同时支持原有的写法，但是为了规范起见还是采用webpack2新写法为好。</p>\n<h4><span id=\"3-extracttextplugin写法的修改\">3). ExtractTextPlugin写法的修改：</span></h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExtractTextPlugin.extract(<span class=\"string\">\"style-loader\"</span>, <span class=\"string\">'happypack/loader?id=less'</span>)</span><br></pre></td></tr></table></figure>\n<p>修改为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExtractTextPlugin.extract(&#123;fallback:&quot;style-loader&quot;, use:&apos;happypack/loader?id=less&apos;&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>坑：在网上查资料时有些是将<code>fallback</code>写成<code>fallbackCallback</code>不要相信，还是安装<code>fallback</code>来。</p>\n<h4><span id=\"3-extracttextplugin的plugins写法的修改\">3). ExtractTextPlugin的plugins写法的修改：</span></h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new ExtractTextPlugin(&quot;../css/[name].min.css&quot;, &#123;</span><br><span class=\"line\">    allChunks: true</span><br><span class=\"line\">&#125;),</span><br></pre></td></tr></table></figure>\n<p>修改为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new ExtractTextPlugin(&#123;</span><br><span class=\"line\">    filename: &quot;../css/[name].min.css&quot;,</span><br><span class=\"line\">    allChunks: true</span><br><span class=\"line\">&#125;),</span><br></pre></td></tr></table></figure></p>\n<p>没啥说的，就是将原本的string加obj的形式修改为obj形式的参数。</p>\n<h4><span id=\"4-commonschunkplugin的plugins写法的修改\">4). CommonsChunkPlugin的plugins写法的修改：</span></h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new CommonsChunkPlugin(&quot;common&quot;, &quot;common.min.js&quot;, [&apos;index&apos;, &apos;barindex&apos;, &apos;detail&apos;]),</span><br></pre></td></tr></table></figure>\n<p>修改为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">    name: &apos;common&apos;, </span><br><span class=\"line\">    filename: &apos;common.min.js&apos;,</span><br><span class=\"line\">    chunks: [&apos;index&apos;, &apos;barindex&apos;, &apos;detail&apos;] </span><br><span class=\"line\">&#125;),</span><br></pre></td></tr></table></figure></p>\n<p>坑：注意如果采用了CommonsChunkPlugin将公共模块提取出来，同时采用了require.ensure的方式来异步拉取js，则上一步的ExtractTextPlugin的allChunks必须设置成为true。<br>坑：路径问题：webpack2采用绝对路径，所以直接填写的相对路径都需要__dirname来转换成绝对路径。</p>\n<h4><span id=\"5-happypack写法的修改\">5). happypack写法的修改：</span></h4><ol>\n<li>happypack：采用多进程来加快webpack的构建速度的组件。目前最新版本是4.0.0但是笔着并没有升级到最新版本，而是采用了更稳定的3.1.0版本，如果升级到最新版本原有的相关配置项都需要修改，例如<code>cache</code>属性将不再被支持，可以参照官方的<a href=\"https://www.npmjs.com/package/happypack\" target=\"_blank\" rel=\"noopener\">文档</a>。</li>\n<li>happypack自带有.happypack目录的缓存，记得升级完成之后需要删除这个目录下的文件，重新生成。</li>\n</ol>\n<h3><span id=\"4关于requireensure\">4.关于require.ensure</span></h3><p>1）升级webpack2的另外一个重要因素就是：原本采用<code>require.ensure</code>来异步加载代码时无法捕获到组件拉取失败的回调，需要单独引入一个插件<code>require(&#39;require-error-handler-webpack-plugin&#39;)</code>来解决,但是升级了webpack2之后，原生就已经支持了，所以不需要引入这个插件了。<br><img src=\"https://qiniu.nihaoshijie.com.cn/blog/caikeng2.png\" alt><br>2) 在webpack2环境下使用<code>require.ensure</code>还需要注意一点就是必须引入<code>babel-polyfill</code>来支持Promise写法，因为webpack2的<code>require.ensure</code>采用的Promise来实现回调，所以必须引入这个。<br>3）引入babel-polyfill之后可能会使js文件增加许多，这里同样推荐使用es6-promis来只针对promise来进行polyfil，减少文件增加的大小。</p>\n<h3><span id=\"5关于tree-shaking\">5.关于tree-shaking</span></h3><p>在升级完成webpack2之后，webpack构建会自动支持<a href=\"https://webpack.js.org/guides/tree-shaking/\" target=\"_blank\" rel=\"noopener\">tree-shaking</a>特性来进行代码层级的压缩优化，但是也有一些需要了解的：<br>1）先要理解关于CommonJS和ES6 modules的区别。<br>2）虽然采用了babel之后，代码还是最终会转为浏览器兼容性较好的es5，但是我们在写代码的时候还是推荐采用ES6 modules的写法。<br>3）基于ES6来写，tree-shaking才能职别，才能根据import和export来查找引入的多余的代码。<br>4）同时需要修改babel的配置文件<code>[&quot;es2015&quot;,{&quot;modules&quot;:false}]</code> 这样才能让webpack2先于babel来进行代码级别的tree-shaking优化。</p>\n<h3><span id=\"参考资料\">参考资料：</span></h3><p><a href=\"https://webpack.js.org/guides/migrating/\" target=\"_blank\" rel=\"noopener\">webpack2升级官方指南</a></p>\n","site":{"data":{}},"excerpt":"<p>Webpack2已经发布半年之多了，就连webpack3都已经发布了，但是项目目前还是使用的webpack1，有点跟不上节奏，webpack2的诸多特性类似tree-shaking等等新特性还是比较令人激动的，现在整理一下从webpack1升级到webpack2的过程。</p>\n<h3 id=\"1-package-json的整体变化\"><a href=\"#1-package-json的整体变化\" class=\"headerlink\" title=\"1.package.json的整体变化\"></a>1.package.json的整体变化</h3>","more":"<p>如下图：分别对相关的组件进行升级，图上所示的需要升级的组件只是针对自己项目的，如果需要升级其他组件可以根据自己的需求升级。<br><img src=\"https://qiniu.nihaoshijie.com.cn/blogcaikeng1.png\" alt=\"\"></p>\n<h3 id=\"2-安装升级组件\"><a href=\"#2-安装升级组件\" class=\"headerlink\" title=\"2.安装升级组件\"></a>2.安装升级组件</h3><p>每种组件的升级有两种办法：</p>\n<ol>\n<li>将组件从node_modules里面删掉，同时删掉package.json里的配置，然后在<code>npm install XXX</code>可以直接从官网下载最新的包。</li>\n<li>采用<code>npm install --save-dev xxx@版本号</code>的方式安装指定版本的包，同时package.json会自动更新。<br>个人推荐使用第二种方式，比较灵活。</li>\n</ol>\n<h3 id=\"3-修改webpack配置文件webpack-config-js\"><a href=\"#3-修改webpack配置文件webpack-config-js\" class=\"headerlink\" title=\"3.修改webpack配置文件webpack.config.js\"></a>3.修改webpack配置文件webpack.config.js</h3><h4 id=\"1-resolve-extensions的修改：\"><a href=\"#1-resolve-extensions的修改：\" class=\"headerlink\" title=\"1). resolve.extensions的修改：\"></a>1). resolve.extensions的修改：</h4><p>将<code>extensions: [&#39;&#39;, &#39;.js&#39;, &#39;.jsx&#39;]</code>改为<code>extensions: [&#39;.js&#39;, &#39;.jsx&#39;]</code>webpack2修复了webpack1必须要求第一个数组元素填空的要求。</p>\n<h4 id=\"2-resolve-mudule的修改：\"><a href=\"#2-resolve-mudule的修改：\" class=\"headerlink\" title=\"2). resolve.mudule的修改：\"></a>2). resolve.mudule的修改：</h4><p>主要是将原本的loaders和loader的搭配写法改为rules加上use的写法:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loaders: [&#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.jsx?$/</span>,</span><br><span class=\"line\">    loader: <span class=\"string\">'happypack/loader?id=jsx'</span>,</span><br><span class=\"line\">    include: path.resolve(config.srcPath)</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">    loader: ExtractTextPlugin.extract(<span class=\"string\">\"style-loader\"</span>,<span class=\"string\">'happypack/loader?id=css'</span>),</span><br><span class=\"line\">    include: path.resolve(config.srcPath)</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.less$/</span>,</span><br><span class=\"line\">    loader: ExtractTextPlugin.extract(<span class=\"string\">\"style-loader\"</span>, <span class=\"string\">'happypack/loader?id=less'</span>),</span><br><span class=\"line\">    include: path.resolve(config.srcPath)</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.(jpe?g|png|gif|svg)$/i</span>,</span><br><span class=\"line\">    loader: <span class=\"string\">'url-loader?limit=1500&amp;name=images/[name].[hash].[ext]'</span>,</span><br><span class=\"line\">    include: path.resolve(config.srcPath)</span><br><span class=\"line\">&#125;]</span><br></pre></td></tr></table></figure></p>\n<p>改为：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rules: [&#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.jsx?$/</span>,</span><br><span class=\"line\">    use: <span class=\"string\">'happypack/loader?id=jsx'</span>,</span><br><span class=\"line\">    include: path.resolve(config.srcPath)</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.less$/</span>,</span><br><span class=\"line\">    use: ExtractTextPlugin.extract(&#123;<span class=\"attr\">fallback</span>:<span class=\"string\">\"style-loader\"</span>, <span class=\"attr\">use</span>:<span class=\"string\">'happypack/loader?id=less'</span>&#125;),</span><br><span class=\"line\">    include: path.resolve(config.srcPath)</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">    use: ExtractTextPlugin.extract(&#123;<span class=\"attr\">fallback</span>:<span class=\"string\">\"style-loader\"</span>, <span class=\"attr\">use</span>:<span class=\"string\">'happypack/loader?id=css'</span>&#125;),</span><br><span class=\"line\">    include: path.resolve(config.srcPath)</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.(jpe?g|png|gif|svg)$/i</span>,</span><br><span class=\"line\">    loader: <span class=\"string\">'url-loader?limit=1500&amp;name=images/[name].[hash].[ext]'</span>,</span><br><span class=\"line\">    include: path.resolve(config.srcPath)</span><br><span class=\"line\">&#125;]</span><br></pre></td></tr></table></figure></p>\n<p>这个修改并不是必须的，webpack2同时支持原有的写法，但是为了规范起见还是采用webpack2新写法为好。</p>\n<h4 id=\"3-ExtractTextPlugin写法的修改：\"><a href=\"#3-ExtractTextPlugin写法的修改：\" class=\"headerlink\" title=\"3). ExtractTextPlugin写法的修改：\"></a>3). ExtractTextPlugin写法的修改：</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExtractTextPlugin.extract(<span class=\"string\">\"style-loader\"</span>, <span class=\"string\">'happypack/loader?id=less'</span>)</span><br></pre></td></tr></table></figure>\n<p>修改为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExtractTextPlugin.extract(&#123;fallback:&quot;style-loader&quot;, use:&apos;happypack/loader?id=less&apos;&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>坑：在网上查资料时有些是将<code>fallback</code>写成<code>fallbackCallback</code>不要相信，还是安装<code>fallback</code>来。</p>\n<h4 id=\"3-ExtractTextPlugin的plugins写法的修改：\"><a href=\"#3-ExtractTextPlugin的plugins写法的修改：\" class=\"headerlink\" title=\"3). ExtractTextPlugin的plugins写法的修改：\"></a>3). ExtractTextPlugin的plugins写法的修改：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new ExtractTextPlugin(&quot;../css/[name].min.css&quot;, &#123;</span><br><span class=\"line\">    allChunks: true</span><br><span class=\"line\">&#125;),</span><br></pre></td></tr></table></figure>\n<p>修改为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new ExtractTextPlugin(&#123;</span><br><span class=\"line\">    filename: &quot;../css/[name].min.css&quot;,</span><br><span class=\"line\">    allChunks: true</span><br><span class=\"line\">&#125;),</span><br></pre></td></tr></table></figure></p>\n<p>没啥说的，就是将原本的string加obj的形式修改为obj形式的参数。</p>\n<h4 id=\"4-CommonsChunkPlugin的plugins写法的修改：\"><a href=\"#4-CommonsChunkPlugin的plugins写法的修改：\" class=\"headerlink\" title=\"4). CommonsChunkPlugin的plugins写法的修改：\"></a>4). CommonsChunkPlugin的plugins写法的修改：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new CommonsChunkPlugin(&quot;common&quot;, &quot;common.min.js&quot;, [&apos;index&apos;, &apos;barindex&apos;, &apos;detail&apos;]),</span><br></pre></td></tr></table></figure>\n<p>修改为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">    name: &apos;common&apos;, </span><br><span class=\"line\">    filename: &apos;common.min.js&apos;,</span><br><span class=\"line\">    chunks: [&apos;index&apos;, &apos;barindex&apos;, &apos;detail&apos;] </span><br><span class=\"line\">&#125;),</span><br></pre></td></tr></table></figure></p>\n<p>坑：注意如果采用了CommonsChunkPlugin将公共模块提取出来，同时采用了require.ensure的方式来异步拉取js，则上一步的ExtractTextPlugin的allChunks必须设置成为true。<br>坑：路径问题：webpack2采用绝对路径，所以直接填写的相对路径都需要__dirname来转换成绝对路径。</p>\n<h4 id=\"5-happypack写法的修改：\"><a href=\"#5-happypack写法的修改：\" class=\"headerlink\" title=\"5). happypack写法的修改：\"></a>5). happypack写法的修改：</h4><ol>\n<li>happypack：采用多进程来加快webpack的构建速度的组件。目前最新版本是4.0.0但是笔着并没有升级到最新版本，而是采用了更稳定的3.1.0版本，如果升级到最新版本原有的相关配置项都需要修改，例如<code>cache</code>属性将不再被支持，可以参照官方的<a href=\"https://www.npmjs.com/package/happypack\" target=\"_blank\" rel=\"noopener\">文档</a>。</li>\n<li>happypack自带有.happypack目录的缓存，记得升级完成之后需要删除这个目录下的文件，重新生成。</li>\n</ol>\n<h3 id=\"4-关于require-ensure\"><a href=\"#4-关于require-ensure\" class=\"headerlink\" title=\"4.关于require.ensure\"></a>4.关于require.ensure</h3><p>1）升级webpack2的另外一个重要因素就是：原本采用<code>require.ensure</code>来异步加载代码时无法捕获到组件拉取失败的回调，需要单独引入一个插件<code>require(&#39;require-error-handler-webpack-plugin&#39;)</code>来解决,但是升级了webpack2之后，原生就已经支持了，所以不需要引入这个插件了。<br><img src=\"https://qiniu.nihaoshijie.com.cn/blog/caikeng2.png\" alt=\"\"><br>2) 在webpack2环境下使用<code>require.ensure</code>还需要注意一点就是必须引入<code>babel-polyfill</code>来支持Promise写法，因为webpack2的<code>require.ensure</code>采用的Promise来实现回调，所以必须引入这个。<br>3）引入babel-polyfill之后可能会使js文件增加许多，这里同样推荐使用es6-promis来只针对promise来进行polyfil，减少文件增加的大小。</p>\n<h3 id=\"5-关于tree-shaking\"><a href=\"#5-关于tree-shaking\" class=\"headerlink\" title=\"5.关于tree-shaking\"></a>5.关于tree-shaking</h3><p>在升级完成webpack2之后，webpack构建会自动支持<a href=\"https://webpack.js.org/guides/tree-shaking/\" target=\"_blank\" rel=\"noopener\">tree-shaking</a>特性来进行代码层级的压缩优化，但是也有一些需要了解的：<br>1）先要理解关于CommonJS和ES6 modules的区别。<br>2）虽然采用了babel之后，代码还是最终会转为浏览器兼容性较好的es5，但是我们在写代码的时候还是推荐采用ES6 modules的写法。<br>3）基于ES6来写，tree-shaking才能职别，才能根据import和export来查找引入的多余的代码。<br>4）同时需要修改babel的配置文件<code>[&quot;es2015&quot;,{&quot;modules&quot;:false}]</code> 这样才能让webpack2先于babel来进行代码级别的tree-shaking优化。</p>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p><a href=\"https://webpack.js.org/guides/migrating/\" target=\"_blank\" rel=\"noopener\">webpack2升级官方指南</a></p>"},{"title":"Web程序员学习iOS开发知识记录","date":"2016-03-01T11:25:22.000Z","_content":"<h2><span style=\"color: #008000;\"><strong>前言</strong></span></h2>\n本文将已一个web开发者的角度来记录一些日常学习ios开发中踩过的坑和web前端与ios开发的知识对比，如果有ios大神看出什么不对的地方，还请指出哈。\n\n<h2><span style=\"color: #008000;\">正文</span></h2>\n<strong>1</strong>. ios开发要装<span style=\"color: #3366ff;\">xcode</span>，而且没有什么其他更好的ide，这样做前端的我感觉很不习惯，每次修改完代码后都要点击运行，这比刷新浏览器慢多了。。\n<!--more-->\n&nbsp;\n\n<strong>2</strong>. ios开发中，页面顶部的导航叫做navigationBar，这是ios里面自带的一种控件，不像web需要自己写div css来实现一个header栏，navigationBar的一本和navigationController配合使用，关于navigationController其实他并不是一个真正的页面，他是一个虚拟的用来管理页面跳转的组件，并不像一般的viewcontroller有这可以看到的对应的页面，跟navigationController类似的还有tabBarController\n\n&nbsp;\n\n<strong>3</strong>. ios开发中每一个页面叫做一个viewController相当于web里面的html页面，其中<span style=\"color: #3366ff;\">viewController</span>里面有<span style=\"color: #3366ff;\">viewDidLoad</span>，<span style=\"color: #3366ff;\">viewDidAppear</span>等方法，这些方法是viewController的生命周期方法，在这些方法里面可以写页面相关的逻辑，这有点类似与web里面window的onload方法或者domcument.ready方法，viewController里有一个view属性，这是一个大的父view，可以看做html的body标签，在这个属性里面可以添加一些子自定义的view。\n\n&nbsp;\n\n<strong>4</strong>. ios开发中，最基本的ui元素是uiview，可以把它当作div，并且在ios中 布局都是绝对定位的absolute（和web里面的canvas布局类似），每一个ios的ui元素有一个属性叫做frame，这个属性包括x,y,width,heigt这四个值就可以确定一个元素在界面中的位置。\n\n&nbsp;\n\n<strong>5</strong>.ios开发中，使用oc进行变成，可以将一些需要的依赖通过import的方式引入，import \"\"双引号一般表示引入自己写的一些文件，import &lt;&gt;尖括号标识引入系统的库例如uikit啥的，这个和nodejs里的require有些类似，但是又有一些区分，nodejs中require引入的依赖文件必须已module.export结尾，oc里面的import不必需要。\n\n&nbsp;\n\n<strong>6</strong>.关于ios中的<span style=\"color: #3366ff;\">navigationbar</span>，下面这张图表示的比较清晰<img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/navigationbar.png\" alt=\"\" width=\"640\" height=\"174\" />\n\n&nbsp;\n\n<strong>7</strong>. ios开发中，可以利用oc的宏定义一些全局的变量或者全局的方法，所谓宏就是一种特殊的语法，只要引入后，在oc的代码里都可以使用，可以理解成在window下挂一些变量和方法，使用起来比较方便，另外，由于定于宏的代码都放在一个 统一的文件里面，所以oc端想使用这个宏，必须引入他例如import \"Define.h\",这个跟js相比还是比较麻烦的，不过也有解决办法，在xcode里面可以一个projectName-<span style=\"color: #222426;\">Prefix.pch以pch结尾的文件。</span>\n\n&nbsp;\n\n<span style=\"color: #222426;\"><strong>8</strong>.pch全称是“<span style=\"color: #3366ff;\">precompiled header</span>”，也就是预编译头文件，该文件里存放的工程中一些不常被修改的代码，比如常用的框架头文件，这样做的目的提高编译器编译速度。<span style=\"color: #000000;\">假如pch中某个文件修改了，那么pch整个文件里包含的的其他文件也会重新编译一次，这样就会消耗大量时间，所以它里面添加的文件最好是是很少变动或不变动的头文件或者是预编译的代码片段：</span></span>\n```c\n#ifndef __IPHONE_4_0  \n#warning \"This project uses features only available in iOS SDK 4.0 and later.\"  \n#endif  \n  \n#ifdef __OBJC__  \n    #import &lt;UIKit/UIKit.h&gt;  \n    #import &lt;Foundation/Foundation.h&gt;  \n#endif\n```\n<strong>9</strong>. ios里面如果想显示一张图片并不像web那样简单，在web里，我们只用给img标签配置一个src即可，但是在ios客户端开发中，图片其实是一个文件，包括本地和网络图片，如果要想显示，我自己写逻辑将图片下载下来，然后将结果传给UIImage，但是这只是一个图片对象，还要将UIImage配置给UIImageView才能真正看到图片，当然ios已经有许多开源的图片下载库来简化我们这些操作例如AFNetworking等。\n\n&nbsp;\n\n<strong>10</strong>. ios里关于图片有多个展示的类型，也就是说图片较大怎么居中截取，图片较小怎么拉伸都有相关的配置，这一点比web要丰富一些，web要想实现这些必须自己写逻辑代码实现，例如UIImageview的<a href=\"http://www.jianshu.com/p/338af5eb5c60\" target=\"_blank\">contentmode</a>属性\n\n其中主要分为:<span style=\"color: #3366ff;\">ScaleToFill</span>,<span style=\"color: #3366ff;\">ScaleAspectFit</span>,<span style=\"color: #3366ff;\">ScaleAspectFill</span>三种。\n\nScaleToFill为将图片按照整个区域进行拉伸(会破坏图片的比例)\nScaleAspectFit将图片等比例拉伸，可能不会填充满整个区域\nScaleAspectFill将图片等比例拉伸，会填充整个区域，但是会有一部分过大而超出整个区域。\n至于Top,Left,Right等等就是将图片在view中的位置进行调整。\n\n&nbsp;\n\n<strong>11</strong>. ios里实现页面跳转主要分为模态modal和入栈态push，具体思路就是找到将要<span style=\"color: #3366ff;\">跳转</span>的页面的viewcontroller，new出来之后，调用\n\n<strong><span class=\"s1\">- (void)pushViewController:(<a style=\"color: #000000;\" href=\"file:///Applications/Xcode.app/Contents/Developer/Documentation/DocSets/com.apple.adc.documentation.AppleiOS8.1.iOSLibrary.docset/Contents/Resources/Documents/documentation/UIKit/Reference/UIViewController_Class/index.html#//apple_ref/doc/c_ref/UIViewController\"><span class=\"s2\">UIViewController</span></a> *)viewController animated:(BOOL)animated</span></strong>\n\n<strong><span class=\"s1\">- (void)presentViewController:(UIViewController *)viewControllerToPresent animated:(BOOL)flag completion:(void (^)(void))completion</span></strong>\n\n来实现页面跳转，前者一般配合navigationController使用，后者则在一般的viewcongroller里面使用即可。\n\n&nbsp;\n\n<strong>12</strong>. ios里面可以将一个view隐藏，调用view.hidden = true即可，但是跟web不同的是，隐藏的view同样占用这位置，同时，挨着被隐藏的view的兄弟view也并不会顶上来（占用隐藏view的位置）这一点和ios的绝对定位有关，所以如果用web的思想去隐藏和显示一个view在ios上会很麻烦，这里笔着曾经一度不能接受这样的转变，不能适应过来。。\n\n&nbsp;\n\n<strong>13</strong>. ios里也有一个类似于web相对定位的东西叫做<a href=\"http://blog.csdn.net/sxfcct/article/details/8776928\" target=\"_blank\">autolayout</a>，这中开发方式完全抛弃了使用frame去定义一个view位置的方式，而且这个方式配合xib（<span style=\"color: #000000;\">Interface Builder</span>），来构建页面的布局跟web很相似，所见即所得，我们在xcode里面直接将我们需要的组件拖入进来即可，同时可以定义view直接的约束，类似与web的margin padding 之类的限制条件，就可以很方便的布局和适配，具体可以参考<a href=\"http://www.cnblogs.com/WhoJun/p/3498408.html?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\">这个链接</a>。\n\n<strong>14</strong>.<img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/NavigationViews_2x.png\" alt=\"\" width=\"977\" height=\"986\" />\n\n上面这个图完美的表现了 底部tabbar，顶部navigationbar，viewcontroller，view的层次图，所以对于ios来说，很多组件系统都是提供的，并不像web很多组件要自己用div和css来实现。\n\n&nbsp;\n\n<strong>15</strong>. 在ios中，如果使用的TabBarController（一种底部bar的viewController）这是一种特殊的controller，通过配置TabBarController的viewControllers属性就可以往这个TabBarController里面添加需要展示的页面，TabBarController会自己控制当点击哪一个tab时显示哪个页面，这点比web要智能很多，web要自己实现这种控件，而ios里面都已经实现了了。\n\n&nbsp;\n\n<strong>16</strong>. 在含有TabBarController的页面中，当从这个页面跳转出去时，<span style=\"color: #3366ff;\">必须手动把 底部tabba给隐藏掉</span>，这点一开始也是很不理解，不过理解下来，其实用了TabBarController时，整个页面都在这个页面里的那个区域内跳转，所以底部的bar是常驻的，因此要隐藏底部。\n\n&nbsp;\n\n<strong>17.</strong> 关于ios里面的<span style=\"color: #3366ff;\">重写</span>和<span style=\"color: #3366ff;\">重载</span>，重写就是子类继承父类时，子类写一个方法和父类的方法名，参数，返回一样这样就是重写，重载就是在子类写两个相同的方法叫做重载，在viewController里会经常看到，viewDidLoad，viewDidAppear这类方法中经常看到[super viewDidLoad]这样调用父类的方法，原因是调用子类的方法时候 如果子类没有这个方法就会去父类找 所以如果不重写父类方法，不会影响到父类的调用，但是如果重写了方法，就不会去父类找 这个时候如果不再子类里面调用一下[super viewDidLoad]就会调用不到父类的默认方法了。\n\n&nbsp;\n\n<strong>18.</strong>viewConfroller的<span style=\"color: #3366ff;\">生命周期</span>\n<p style=\"color: #555555;\"><strong>init</strong>－初始化程序</p>\n<p style=\"color: #555555;\"><strong>loadView- </strong>加载视图的view（通常这一步不需要去干涉）</p>\n<p style=\"color: #555555;\"><strong>viewDidLoad</strong>－加载视图（各种初始数据的载入，初始设定等很多内容，都会在这个方法中实现）</p>\n<p style=\"color: #555555;\"><strong>viewWillAppear</strong>－UIViewController对象的视图即将加入窗口时调用；（当APP有多个视图时，在视图间切换时，并不会再次载入viewDidLoad方法，所以如果在调入视图时，需要对数据做更新，就只能在这个方法内实现了）</p>\n<p style=\"color: #555555;\"><strong>viewDidApper</strong>－UIViewController对象的视图已经加入到窗口时调用；</p>\n<p style=\"color: #555555;\"><strong>viewWillDisappear</strong>－UIViewController对象的视图即将消失、被覆盖或是隐藏时调用；</p>\n<p style=\"color: #555555;\"><strong>viewDidDisappear</strong>－UIViewController对象的视图已经消失、被覆盖或是隐藏时调用；</p>\n<p style=\"color: #555555;\"><strong>viewVillUnload</strong>－当内存过低时，需要释放一些不需要使用的视图时，即将释放时调用；</p>\n<p style=\"color: #555555;\"><strong>viewDidUnload</strong>－当内存过低，释放一些不需要的视图时调用。</p>\n<p style=\"color: #555555;\"><strong>19.</strong>关于ios里的<span style=\"color: #222222;\"><span style=\"color: #3366ff;\">edgesForExtendedLayout</span>，<span style=\"color: #3366ff;\">automaticallyAdjustsScrollViewInsets</span>，<span style=\"color: #3366ff;\">translucent</span>，和navigationBar之间的关系其中：</span></p>\n<p style=\"color: #555555;\"><span style=\"color: #222222;\">1 <span style=\"color: #3366ff;\">translucent是navigationBar的属性优先级最高</span></span></p>\n<p style=\"color: #555555;\"><span style=\"color: #222222;\">当translucent=true（默认）时，即在含有navigationBar的页面中，frame的0是从页面的statusBar开始算的。</span></p>\n<p style=\"color: #555555;\">当<span style=\"color: #222222;\">translucent=false时，即在含有navigationBar的页面中，frame的0是从navigationBar下面开始算的。</span></p>\n<p style=\"color: #555555;\">2 <span style=\"color: #3366ff;\">edgesForExtendedLayout是viewController的属性优先级其次</span></p>\n<p style=\"color: #555555;\">当<span style=\"color: #222222;\">edgesForExtendedLayout=RectEdgeNone时，即在含有navigationBar的页面中，frame的0是从navigationBar下面开始算的。</span></p>\n<p style=\"color: #555555;\">当<span style=\"color: #222222;\">edgesForExtendedLayout=RectEdgeAll（默认）时，即在含有navigationBar的页面中，frame的0是从statusBar开始算的。</span></p>\n<p style=\"color: #555555;\">3 <span style=\"color: #3366ff;\">automaticallyAdjustsScrollViewInsets是viewController的属性，只对UIScrollView，UITableView有效</span></p>\n<p style=\"color: #555555;\">当automaticallyAdjustsScrollViewInsets<span style=\"color: #222222;\">=true时，即在含有navigationBar的页面中，UIScrollView是从navigationBar底部开始滚动的，frame的0根据前两个属性影响。</span></p>\n<p style=\"color: #555555;\">当automaticallyAdjustsScrollViewInsets<span style=\"color: #222222;\">=false时，即在含有navigationBar的页面中，UIScrollView是从本身的位置开始滚动的，frame的0根据前两个属性影响。</span></p>\n<p style=\"color: #555555;\">再设置<span style=\"color: #222222;\">edgesForExtendedLayout和translucent时会影响viewController的view的高度，在viewDidLoad和viewWillAppear会有所体现。</span></p>\n<p style=\"color: #555555;\"></p>\n<p style=\"color: #555555;\"><span style=\"font-weight: bolder; line-height: 28.7999992370605px;\">20.</span><span>关于<span style=\"color: #008080;\">alloc init</span> 和 <span style=\"color: #008080;\">new</span> 的区别，在oc中，创建一个对象经常是alloc init调用两个方法，其实oc也支持用new来创建对象的，这两个方法其实没什么区别，使用alloc init思路更清晰一些，先分配内存，然后返回实例对象，可以参考<a style=\"color: #336699;\" href=\"http://stackoverflow.com/questions/719877/use-of-alloc-init-instead-of-new\" target=\"_blank\">stackoverflow</a>。</span></p>\n<p style=\"color: #555555;\"></p>\n<p style=\"color: #555555;\"><span style=\"font-weight: bold;\">21.</span>appDelegate生命周期方法</p>\n\n```c\n//当应用程序将要进入非活动状态执行，在此期间，应用程序不接受消息或事件，比如来电  \n- (void)applicationWillResignActive:(UIApplication *)application  \n{  \n    NSLog(@\"应用程序将要进入非活动状态，即将进入后台\");  \n}  \n  \n//应用程序已经进入后台运行  \n- (void)applicationDidEnterBackground:(UIApplication *)application  \n{  \n    NSLog(@\"如果应用程序支持后台运行，则应用程序已经进入后台运行\");  \n}  \n  \n//应用程序将要进入活动状态执行  \n- (void)applicationWillEnterForeground:(UIApplication *)application  \n{  \n    NSLog(@\"应用程序将要进入活动状态，即将进入前台运行\");  \n}  \n  \n//应用程序已经进入活动状态  \n- (void)applicationDidBecomeActive:(UIApplication *)application  \n{  \n    NSLog(@\"应用程序已进入前台，处于活动状态\");  \n}  \n  \n//应用程序将要退出，通常用于保存书架喝一些推出前的清理工作，  \n- (void)applicationWillTerminate:(UIApplication *)application  \n{  \n    NSLog(@\"应用程序将要退出，通常用于保存书架喝一些推出前的清理工作\");  \n}  \n  \n//当设备为应用程序分配了太多的内存，操作系统会终止应用程序的运行，在终止前会执行这个方法  \n//通常可以在这里进行内存清理工作，防止程序被终止  \n-(void)applicationDidReceiveMemoryWarning:(UIApplication *)application  \n{  \n    NSLog(@\"系统内存不足，需要进行清理工作\");  \n}  \n  \n//当系统时间发生改变时执行  \n-(void)applicationSignificantTimeChange:(UIApplication *)application  \n{  \n    NSLog(@\"当系统时间发生改变时执行\");  \n}  \n  \n//当程序载入后执行  \n-(void)applicationDidFinishLaunching:(UIApplication *)application  \n{  \n    NSLog(@\"当程序载入后执行\");  \n}\n```\n&nbsp;\n<p style=\"color: #555555;\">附上最近做的一个ios的demo：<a href=\"https://github.com/lvming6816077/wodu\" target=\"_blank\">https://github.com/lvming6816077/wodu</a></p>\nhttp://www.cocoachina.com/bbs/read.php?tid=280826\n\n未完。。","source":"_posts/Web程序员学习iOS开发知识记录.md","raw":"---\ntitle: Web程序员学习iOS开发知识记录\ndate: 2016-03-01 19:25:22\ntags:\n- ios\ncategories:\n- 578\n---\n<h2><span style=\"color: #008000;\"><strong>前言</strong></span></h2>\n本文将已一个web开发者的角度来记录一些日常学习ios开发中踩过的坑和web前端与ios开发的知识对比，如果有ios大神看出什么不对的地方，还请指出哈。\n\n<h2><span style=\"color: #008000;\">正文</span></h2>\n<strong>1</strong>. ios开发要装<span style=\"color: #3366ff;\">xcode</span>，而且没有什么其他更好的ide，这样做前端的我感觉很不习惯，每次修改完代码后都要点击运行，这比刷新浏览器慢多了。。\n<!--more-->\n&nbsp;\n\n<strong>2</strong>. ios开发中，页面顶部的导航叫做navigationBar，这是ios里面自带的一种控件，不像web需要自己写div css来实现一个header栏，navigationBar的一本和navigationController配合使用，关于navigationController其实他并不是一个真正的页面，他是一个虚拟的用来管理页面跳转的组件，并不像一般的viewcontroller有这可以看到的对应的页面，跟navigationController类似的还有tabBarController\n\n&nbsp;\n\n<strong>3</strong>. ios开发中每一个页面叫做一个viewController相当于web里面的html页面，其中<span style=\"color: #3366ff;\">viewController</span>里面有<span style=\"color: #3366ff;\">viewDidLoad</span>，<span style=\"color: #3366ff;\">viewDidAppear</span>等方法，这些方法是viewController的生命周期方法，在这些方法里面可以写页面相关的逻辑，这有点类似与web里面window的onload方法或者domcument.ready方法，viewController里有一个view属性，这是一个大的父view，可以看做html的body标签，在这个属性里面可以添加一些子自定义的view。\n\n&nbsp;\n\n<strong>4</strong>. ios开发中，最基本的ui元素是uiview，可以把它当作div，并且在ios中 布局都是绝对定位的absolute（和web里面的canvas布局类似），每一个ios的ui元素有一个属性叫做frame，这个属性包括x,y,width,heigt这四个值就可以确定一个元素在界面中的位置。\n\n&nbsp;\n\n<strong>5</strong>.ios开发中，使用oc进行变成，可以将一些需要的依赖通过import的方式引入，import \"\"双引号一般表示引入自己写的一些文件，import &lt;&gt;尖括号标识引入系统的库例如uikit啥的，这个和nodejs里的require有些类似，但是又有一些区分，nodejs中require引入的依赖文件必须已module.export结尾，oc里面的import不必需要。\n\n&nbsp;\n\n<strong>6</strong>.关于ios中的<span style=\"color: #3366ff;\">navigationbar</span>，下面这张图表示的比较清晰<img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/navigationbar.png\" alt=\"\" width=\"640\" height=\"174\" />\n\n&nbsp;\n\n<strong>7</strong>. ios开发中，可以利用oc的宏定义一些全局的变量或者全局的方法，所谓宏就是一种特殊的语法，只要引入后，在oc的代码里都可以使用，可以理解成在window下挂一些变量和方法，使用起来比较方便，另外，由于定于宏的代码都放在一个 统一的文件里面，所以oc端想使用这个宏，必须引入他例如import \"Define.h\",这个跟js相比还是比较麻烦的，不过也有解决办法，在xcode里面可以一个projectName-<span style=\"color: #222426;\">Prefix.pch以pch结尾的文件。</span>\n\n&nbsp;\n\n<span style=\"color: #222426;\"><strong>8</strong>.pch全称是“<span style=\"color: #3366ff;\">precompiled header</span>”，也就是预编译头文件，该文件里存放的工程中一些不常被修改的代码，比如常用的框架头文件，这样做的目的提高编译器编译速度。<span style=\"color: #000000;\">假如pch中某个文件修改了，那么pch整个文件里包含的的其他文件也会重新编译一次，这样就会消耗大量时间，所以它里面添加的文件最好是是很少变动或不变动的头文件或者是预编译的代码片段：</span></span>\n```c\n#ifndef __IPHONE_4_0  \n#warning \"This project uses features only available in iOS SDK 4.0 and later.\"  \n#endif  \n  \n#ifdef __OBJC__  \n    #import &lt;UIKit/UIKit.h&gt;  \n    #import &lt;Foundation/Foundation.h&gt;  \n#endif\n```\n<strong>9</strong>. ios里面如果想显示一张图片并不像web那样简单，在web里，我们只用给img标签配置一个src即可，但是在ios客户端开发中，图片其实是一个文件，包括本地和网络图片，如果要想显示，我自己写逻辑将图片下载下来，然后将结果传给UIImage，但是这只是一个图片对象，还要将UIImage配置给UIImageView才能真正看到图片，当然ios已经有许多开源的图片下载库来简化我们这些操作例如AFNetworking等。\n\n&nbsp;\n\n<strong>10</strong>. ios里关于图片有多个展示的类型，也就是说图片较大怎么居中截取，图片较小怎么拉伸都有相关的配置，这一点比web要丰富一些，web要想实现这些必须自己写逻辑代码实现，例如UIImageview的<a href=\"http://www.jianshu.com/p/338af5eb5c60\" target=\"_blank\">contentmode</a>属性\n\n其中主要分为:<span style=\"color: #3366ff;\">ScaleToFill</span>,<span style=\"color: #3366ff;\">ScaleAspectFit</span>,<span style=\"color: #3366ff;\">ScaleAspectFill</span>三种。\n\nScaleToFill为将图片按照整个区域进行拉伸(会破坏图片的比例)\nScaleAspectFit将图片等比例拉伸，可能不会填充满整个区域\nScaleAspectFill将图片等比例拉伸，会填充整个区域，但是会有一部分过大而超出整个区域。\n至于Top,Left,Right等等就是将图片在view中的位置进行调整。\n\n&nbsp;\n\n<strong>11</strong>. ios里实现页面跳转主要分为模态modal和入栈态push，具体思路就是找到将要<span style=\"color: #3366ff;\">跳转</span>的页面的viewcontroller，new出来之后，调用\n\n<strong><span class=\"s1\">- (void)pushViewController:(<a style=\"color: #000000;\" href=\"file:///Applications/Xcode.app/Contents/Developer/Documentation/DocSets/com.apple.adc.documentation.AppleiOS8.1.iOSLibrary.docset/Contents/Resources/Documents/documentation/UIKit/Reference/UIViewController_Class/index.html#//apple_ref/doc/c_ref/UIViewController\"><span class=\"s2\">UIViewController</span></a> *)viewController animated:(BOOL)animated</span></strong>\n\n<strong><span class=\"s1\">- (void)presentViewController:(UIViewController *)viewControllerToPresent animated:(BOOL)flag completion:(void (^)(void))completion</span></strong>\n\n来实现页面跳转，前者一般配合navigationController使用，后者则在一般的viewcongroller里面使用即可。\n\n&nbsp;\n\n<strong>12</strong>. ios里面可以将一个view隐藏，调用view.hidden = true即可，但是跟web不同的是，隐藏的view同样占用这位置，同时，挨着被隐藏的view的兄弟view也并不会顶上来（占用隐藏view的位置）这一点和ios的绝对定位有关，所以如果用web的思想去隐藏和显示一个view在ios上会很麻烦，这里笔着曾经一度不能接受这样的转变，不能适应过来。。\n\n&nbsp;\n\n<strong>13</strong>. ios里也有一个类似于web相对定位的东西叫做<a href=\"http://blog.csdn.net/sxfcct/article/details/8776928\" target=\"_blank\">autolayout</a>，这中开发方式完全抛弃了使用frame去定义一个view位置的方式，而且这个方式配合xib（<span style=\"color: #000000;\">Interface Builder</span>），来构建页面的布局跟web很相似，所见即所得，我们在xcode里面直接将我们需要的组件拖入进来即可，同时可以定义view直接的约束，类似与web的margin padding 之类的限制条件，就可以很方便的布局和适配，具体可以参考<a href=\"http://www.cnblogs.com/WhoJun/p/3498408.html?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\">这个链接</a>。\n\n<strong>14</strong>.<img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/NavigationViews_2x.png\" alt=\"\" width=\"977\" height=\"986\" />\n\n上面这个图完美的表现了 底部tabbar，顶部navigationbar，viewcontroller，view的层次图，所以对于ios来说，很多组件系统都是提供的，并不像web很多组件要自己用div和css来实现。\n\n&nbsp;\n\n<strong>15</strong>. 在ios中，如果使用的TabBarController（一种底部bar的viewController）这是一种特殊的controller，通过配置TabBarController的viewControllers属性就可以往这个TabBarController里面添加需要展示的页面，TabBarController会自己控制当点击哪一个tab时显示哪个页面，这点比web要智能很多，web要自己实现这种控件，而ios里面都已经实现了了。\n\n&nbsp;\n\n<strong>16</strong>. 在含有TabBarController的页面中，当从这个页面跳转出去时，<span style=\"color: #3366ff;\">必须手动把 底部tabba给隐藏掉</span>，这点一开始也是很不理解，不过理解下来，其实用了TabBarController时，整个页面都在这个页面里的那个区域内跳转，所以底部的bar是常驻的，因此要隐藏底部。\n\n&nbsp;\n\n<strong>17.</strong> 关于ios里面的<span style=\"color: #3366ff;\">重写</span>和<span style=\"color: #3366ff;\">重载</span>，重写就是子类继承父类时，子类写一个方法和父类的方法名，参数，返回一样这样就是重写，重载就是在子类写两个相同的方法叫做重载，在viewController里会经常看到，viewDidLoad，viewDidAppear这类方法中经常看到[super viewDidLoad]这样调用父类的方法，原因是调用子类的方法时候 如果子类没有这个方法就会去父类找 所以如果不重写父类方法，不会影响到父类的调用，但是如果重写了方法，就不会去父类找 这个时候如果不再子类里面调用一下[super viewDidLoad]就会调用不到父类的默认方法了。\n\n&nbsp;\n\n<strong>18.</strong>viewConfroller的<span style=\"color: #3366ff;\">生命周期</span>\n<p style=\"color: #555555;\"><strong>init</strong>－初始化程序</p>\n<p style=\"color: #555555;\"><strong>loadView- </strong>加载视图的view（通常这一步不需要去干涉）</p>\n<p style=\"color: #555555;\"><strong>viewDidLoad</strong>－加载视图（各种初始数据的载入，初始设定等很多内容，都会在这个方法中实现）</p>\n<p style=\"color: #555555;\"><strong>viewWillAppear</strong>－UIViewController对象的视图即将加入窗口时调用；（当APP有多个视图时，在视图间切换时，并不会再次载入viewDidLoad方法，所以如果在调入视图时，需要对数据做更新，就只能在这个方法内实现了）</p>\n<p style=\"color: #555555;\"><strong>viewDidApper</strong>－UIViewController对象的视图已经加入到窗口时调用；</p>\n<p style=\"color: #555555;\"><strong>viewWillDisappear</strong>－UIViewController对象的视图即将消失、被覆盖或是隐藏时调用；</p>\n<p style=\"color: #555555;\"><strong>viewDidDisappear</strong>－UIViewController对象的视图已经消失、被覆盖或是隐藏时调用；</p>\n<p style=\"color: #555555;\"><strong>viewVillUnload</strong>－当内存过低时，需要释放一些不需要使用的视图时，即将释放时调用；</p>\n<p style=\"color: #555555;\"><strong>viewDidUnload</strong>－当内存过低，释放一些不需要的视图时调用。</p>\n<p style=\"color: #555555;\"><strong>19.</strong>关于ios里的<span style=\"color: #222222;\"><span style=\"color: #3366ff;\">edgesForExtendedLayout</span>，<span style=\"color: #3366ff;\">automaticallyAdjustsScrollViewInsets</span>，<span style=\"color: #3366ff;\">translucent</span>，和navigationBar之间的关系其中：</span></p>\n<p style=\"color: #555555;\"><span style=\"color: #222222;\">1 <span style=\"color: #3366ff;\">translucent是navigationBar的属性优先级最高</span></span></p>\n<p style=\"color: #555555;\"><span style=\"color: #222222;\">当translucent=true（默认）时，即在含有navigationBar的页面中，frame的0是从页面的statusBar开始算的。</span></p>\n<p style=\"color: #555555;\">当<span style=\"color: #222222;\">translucent=false时，即在含有navigationBar的页面中，frame的0是从navigationBar下面开始算的。</span></p>\n<p style=\"color: #555555;\">2 <span style=\"color: #3366ff;\">edgesForExtendedLayout是viewController的属性优先级其次</span></p>\n<p style=\"color: #555555;\">当<span style=\"color: #222222;\">edgesForExtendedLayout=RectEdgeNone时，即在含有navigationBar的页面中，frame的0是从navigationBar下面开始算的。</span></p>\n<p style=\"color: #555555;\">当<span style=\"color: #222222;\">edgesForExtendedLayout=RectEdgeAll（默认）时，即在含有navigationBar的页面中，frame的0是从statusBar开始算的。</span></p>\n<p style=\"color: #555555;\">3 <span style=\"color: #3366ff;\">automaticallyAdjustsScrollViewInsets是viewController的属性，只对UIScrollView，UITableView有效</span></p>\n<p style=\"color: #555555;\">当automaticallyAdjustsScrollViewInsets<span style=\"color: #222222;\">=true时，即在含有navigationBar的页面中，UIScrollView是从navigationBar底部开始滚动的，frame的0根据前两个属性影响。</span></p>\n<p style=\"color: #555555;\">当automaticallyAdjustsScrollViewInsets<span style=\"color: #222222;\">=false时，即在含有navigationBar的页面中，UIScrollView是从本身的位置开始滚动的，frame的0根据前两个属性影响。</span></p>\n<p style=\"color: #555555;\">再设置<span style=\"color: #222222;\">edgesForExtendedLayout和translucent时会影响viewController的view的高度，在viewDidLoad和viewWillAppear会有所体现。</span></p>\n<p style=\"color: #555555;\"></p>\n<p style=\"color: #555555;\"><span style=\"font-weight: bolder; line-height: 28.7999992370605px;\">20.</span><span>关于<span style=\"color: #008080;\">alloc init</span> 和 <span style=\"color: #008080;\">new</span> 的区别，在oc中，创建一个对象经常是alloc init调用两个方法，其实oc也支持用new来创建对象的，这两个方法其实没什么区别，使用alloc init思路更清晰一些，先分配内存，然后返回实例对象，可以参考<a style=\"color: #336699;\" href=\"http://stackoverflow.com/questions/719877/use-of-alloc-init-instead-of-new\" target=\"_blank\">stackoverflow</a>。</span></p>\n<p style=\"color: #555555;\"></p>\n<p style=\"color: #555555;\"><span style=\"font-weight: bold;\">21.</span>appDelegate生命周期方法</p>\n\n```c\n//当应用程序将要进入非活动状态执行，在此期间，应用程序不接受消息或事件，比如来电  \n- (void)applicationWillResignActive:(UIApplication *)application  \n{  \n    NSLog(@\"应用程序将要进入非活动状态，即将进入后台\");  \n}  \n  \n//应用程序已经进入后台运行  \n- (void)applicationDidEnterBackground:(UIApplication *)application  \n{  \n    NSLog(@\"如果应用程序支持后台运行，则应用程序已经进入后台运行\");  \n}  \n  \n//应用程序将要进入活动状态执行  \n- (void)applicationWillEnterForeground:(UIApplication *)application  \n{  \n    NSLog(@\"应用程序将要进入活动状态，即将进入前台运行\");  \n}  \n  \n//应用程序已经进入活动状态  \n- (void)applicationDidBecomeActive:(UIApplication *)application  \n{  \n    NSLog(@\"应用程序已进入前台，处于活动状态\");  \n}  \n  \n//应用程序将要退出，通常用于保存书架喝一些推出前的清理工作，  \n- (void)applicationWillTerminate:(UIApplication *)application  \n{  \n    NSLog(@\"应用程序将要退出，通常用于保存书架喝一些推出前的清理工作\");  \n}  \n  \n//当设备为应用程序分配了太多的内存，操作系统会终止应用程序的运行，在终止前会执行这个方法  \n//通常可以在这里进行内存清理工作，防止程序被终止  \n-(void)applicationDidReceiveMemoryWarning:(UIApplication *)application  \n{  \n    NSLog(@\"系统内存不足，需要进行清理工作\");  \n}  \n  \n//当系统时间发生改变时执行  \n-(void)applicationSignificantTimeChange:(UIApplication *)application  \n{  \n    NSLog(@\"当系统时间发生改变时执行\");  \n}  \n  \n//当程序载入后执行  \n-(void)applicationDidFinishLaunching:(UIApplication *)application  \n{  \n    NSLog(@\"当程序载入后执行\");  \n}\n```\n&nbsp;\n<p style=\"color: #555555;\">附上最近做的一个ios的demo：<a href=\"https://github.com/lvming6816077/wodu\" target=\"_blank\">https://github.com/lvming6816077/wodu</a></p>\nhttp://www.cocoachina.com/bbs/read.php?tid=280826\n\n未完。。","slug":"Web程序员学习iOS开发知识记录","published":1,"updated":"2017-04-27T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434q0m001z2wvjjh28d2fy","content":"<p></p><h2><span id=\"前言\"><span style=\"color: #008000;\"><strong>前言</strong></span></span></h2><br>本文将已一个web开发者的角度来记录一些日常学习ios开发中踩过的坑和web前端与ios开发的知识对比，如果有ios大神看出什么不对的地方，还请指出哈。<p></p>\n<p></p><h2><span id=\"正文\"><span style=\"color: #008000;\">正文</span></span></h2><br><strong>1</strong>. ios开发要装<span style=\"color: #3366ff;\">xcode</span>，而且没有什么其他更好的ide，这样做前端的我感觉很不习惯，每次修改完代码后都要点击运行，这比刷新浏览器慢多了。。<br><a id=\"more\"></a><br>&nbsp;<p></p>\n<p><strong>2</strong>. ios开发中，页面顶部的导航叫做navigationBar，这是ios里面自带的一种控件，不像web需要自己写div css来实现一个header栏，navigationBar的一本和navigationController配合使用，关于navigationController其实他并不是一个真正的页面，他是一个虚拟的用来管理页面跳转的组件，并不像一般的viewcontroller有这可以看到的对应的页面，跟navigationController类似的还有tabBarController</p>\n<p>&nbsp;</p>\n<p><strong>3</strong>. ios开发中每一个页面叫做一个viewController相当于web里面的html页面，其中<span style=\"color: #3366ff;\">viewController</span>里面有<span style=\"color: #3366ff;\">viewDidLoad</span>，<span style=\"color: #3366ff;\">viewDidAppear</span>等方法，这些方法是viewController的生命周期方法，在这些方法里面可以写页面相关的逻辑，这有点类似与web里面window的onload方法或者domcument.ready方法，viewController里有一个view属性，这是一个大的父view，可以看做html的body标签，在这个属性里面可以添加一些子自定义的view。</p>\n<p>&nbsp;</p>\n<p><strong>4</strong>. ios开发中，最基本的ui元素是uiview，可以把它当作div，并且在ios中 布局都是绝对定位的absolute（和web里面的canvas布局类似），每一个ios的ui元素有一个属性叫做frame，这个属性包括x,y,width,heigt这四个值就可以确定一个元素在界面中的位置。</p>\n<p>&nbsp;</p>\n<p><strong>5</strong>.ios开发中，使用oc进行变成，可以将一些需要的依赖通过import的方式引入，import “”双引号一般表示引入自己写的一些文件，import &lt;&gt;尖括号标识引入系统的库例如uikit啥的，这个和nodejs里的require有些类似，但是又有一些区分，nodejs中require引入的依赖文件必须已module.export结尾，oc里面的import不必需要。</p>\n<p>&nbsp;</p>\n<p><strong>6</strong>.关于ios中的<span style=\"color: #3366ff;\">navigationbar</span>，下面这张图表示的比较清晰<img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/navigationbar.png\" alt width=\"640\" height=\"174\"></p>\n<p>&nbsp;</p>\n<p><strong>7</strong>. ios开发中，可以利用oc的宏定义一些全局的变量或者全局的方法，所谓宏就是一种特殊的语法，只要引入后，在oc的代码里都可以使用，可以理解成在window下挂一些变量和方法，使用起来比较方便，另外，由于定于宏的代码都放在一个 统一的文件里面，所以oc端想使用这个宏，必须引入他例如import “Define.h”,这个跟js相比还是比较麻烦的，不过也有解决办法，在xcode里面可以一个projectName-<span style=\"color: #222426;\">Prefix.pch以pch结尾的文件。</span></p>\n<p>&nbsp;</p>\n<p><span style=\"color: #222426;\"><strong>8</strong>.pch全称是“<span style=\"color: #3366ff;\">precompiled header</span>”，也就是预编译头文件，该文件里存放的工程中一些不常被修改的代码，比如常用的框架头文件，这样做的目的提高编译器编译速度。<span style=\"color: #000000;\">假如pch中某个文件修改了，那么pch整个文件里包含的的其他文件也会重新编译一次，这样就会消耗大量时间，所以它里面添加的文件最好是是很少变动或不变动的头文件或者是预编译的代码片段：</span></span><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> __IPHONE_4_0  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">warning</span> <span class=\"meta-string\">\"This project uses features only available in iOS SDK 4.0 and later.\"</span>  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __OBJC__  </span></span><br><span class=\"line\">    <span class=\"meta\">#import &amp;lt;UIKit/UIKit.h&amp;gt;  </span></span><br><span class=\"line\">    <span class=\"meta\">#import &amp;lt;Foundation/Foundation.h&amp;gt;  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure></p>\n<p><strong>9</strong>. ios里面如果想显示一张图片并不像web那样简单，在web里，我们只用给img标签配置一个src即可，但是在ios客户端开发中，图片其实是一个文件，包括本地和网络图片，如果要想显示，我自己写逻辑将图片下载下来，然后将结果传给UIImage，但是这只是一个图片对象，还要将UIImage配置给UIImageView才能真正看到图片，当然ios已经有许多开源的图片下载库来简化我们这些操作例如AFNetworking等。</p>\n<p>&nbsp;</p>\n<p><strong>10</strong>. ios里关于图片有多个展示的类型，也就是说图片较大怎么居中截取，图片较小怎么拉伸都有相关的配置，这一点比web要丰富一些，web要想实现这些必须自己写逻辑代码实现，例如UIImageview的<a href=\"http://www.jianshu.com/p/338af5eb5c60\" target=\"_blank\">contentmode</a>属性</p>\n<p>其中主要分为:<span style=\"color: #3366ff;\">ScaleToFill</span>,<span style=\"color: #3366ff;\">ScaleAspectFit</span>,<span style=\"color: #3366ff;\">ScaleAspectFill</span>三种。</p>\n<p>ScaleToFill为将图片按照整个区域进行拉伸(会破坏图片的比例)<br>ScaleAspectFit将图片等比例拉伸，可能不会填充满整个区域<br>ScaleAspectFill将图片等比例拉伸，会填充整个区域，但是会有一部分过大而超出整个区域。<br>至于Top,Left,Right等等就是将图片在view中的位置进行调整。</p>\n<p>&nbsp;</p>\n<p><strong>11</strong>. ios里实现页面跳转主要分为模态modal和入栈态push，具体思路就是找到将要<span style=\"color: #3366ff;\">跳转</span>的页面的viewcontroller，new出来之后，调用</p>\n<p><strong><span class=\"s1\">- (void)pushViewController:(<a style=\"color: #000000;\" href=\"file:///Applications/Xcode.app/Contents/Developer/Documentation/DocSets/com.apple.adc.documentation.AppleiOS8.1.iOSLibrary.docset/Contents/Resources/Documents/documentation/UIKit/Reference/UIViewController_Class/index.html#//apple_ref/doc/c_ref/UIViewController\" target=\"_blank\" rel=\"noopener\"><span class=\"s2\">UIViewController</span></a> *)viewController animated:(BOOL)animated</span></strong></p>\n<p><strong><span class=\"s1\">- (void)presentViewController:(UIViewController *)viewControllerToPresent animated:(BOOL)flag completion:(void (^)(void))completion</span></strong></p>\n<p>来实现页面跳转，前者一般配合navigationController使用，后者则在一般的viewcongroller里面使用即可。</p>\n<p>&nbsp;</p>\n<p><strong>12</strong>. ios里面可以将一个view隐藏，调用view.hidden = true即可，但是跟web不同的是，隐藏的view同样占用这位置，同时，挨着被隐藏的view的兄弟view也并不会顶上来（占用隐藏view的位置）这一点和ios的绝对定位有关，所以如果用web的思想去隐藏和显示一个view在ios上会很麻烦，这里笔着曾经一度不能接受这样的转变，不能适应过来。。</p>\n<p>&nbsp;</p>\n<p><strong>13</strong>. ios里也有一个类似于web相对定位的东西叫做<a href=\"http://blog.csdn.net/sxfcct/article/details/8776928\" target=\"_blank\">autolayout</a>，这中开发方式完全抛弃了使用frame去定义一个view位置的方式，而且这个方式配合xib（<span style=\"color: #000000;\">Interface Builder</span>），来构建页面的布局跟web很相似，所见即所得，我们在xcode里面直接将我们需要的组件拖入进来即可，同时可以定义view直接的约束，类似与web的margin padding 之类的限制条件，就可以很方便的布局和适配，具体可以参考<a href=\"http://www.cnblogs.com/WhoJun/p/3498408.html?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\">这个链接</a>。</p>\n<p><strong>14</strong>.<img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/NavigationViews_2x.png\" alt width=\"977\" height=\"986\"></p>\n<p>上面这个图完美的表现了 底部tabbar，顶部navigationbar，viewcontroller，view的层次图，所以对于ios来说，很多组件系统都是提供的，并不像web很多组件要自己用div和css来实现。</p>\n<p>&nbsp;</p>\n<p><strong>15</strong>. 在ios中，如果使用的TabBarController（一种底部bar的viewController）这是一种特殊的controller，通过配置TabBarController的viewControllers属性就可以往这个TabBarController里面添加需要展示的页面，TabBarController会自己控制当点击哪一个tab时显示哪个页面，这点比web要智能很多，web要自己实现这种控件，而ios里面都已经实现了了。</p>\n<p>&nbsp;</p>\n<p><strong>16</strong>. 在含有TabBarController的页面中，当从这个页面跳转出去时，<span style=\"color: #3366ff;\">必须手动把 底部tabba给隐藏掉</span>，这点一开始也是很不理解，不过理解下来，其实用了TabBarController时，整个页面都在这个页面里的那个区域内跳转，所以底部的bar是常驻的，因此要隐藏底部。</p>\n<p>&nbsp;</p>\n<p><strong>17.</strong> 关于ios里面的<span style=\"color: #3366ff;\">重写</span>和<span style=\"color: #3366ff;\">重载</span>，重写就是子类继承父类时，子类写一个方法和父类的方法名，参数，返回一样这样就是重写，重载就是在子类写两个相同的方法叫做重载，在viewController里会经常看到，viewDidLoad，viewDidAppear这类方法中经常看到[super viewDidLoad]这样调用父类的方法，原因是调用子类的方法时候 如果子类没有这个方法就会去父类找 所以如果不重写父类方法，不会影响到父类的调用，但是如果重写了方法，就不会去父类找 这个时候如果不再子类里面调用一下[super viewDidLoad]就会调用不到父类的默认方法了。</p>\n<p>&nbsp;</p>\n<p><strong>18.</strong>viewConfroller的<span style=\"color: #3366ff;\">生命周期</span></p>\n<p style=\"color: #555555;\"><strong>init</strong>－初始化程序</p><br><p style=\"color: #555555;\"><strong>loadView- </strong>加载视图的view（通常这一步不需要去干涉）</p><br><p style=\"color: #555555;\"><strong>viewDidLoad</strong>－加载视图（各种初始数据的载入，初始设定等很多内容，都会在这个方法中实现）</p><br><p style=\"color: #555555;\"><strong>viewWillAppear</strong>－UIViewController对象的视图即将加入窗口时调用；（当APP有多个视图时，在视图间切换时，并不会再次载入viewDidLoad方法，所以如果在调入视图时，需要对数据做更新，就只能在这个方法内实现了）</p><br><p style=\"color: #555555;\"><strong>viewDidApper</strong>－UIViewController对象的视图已经加入到窗口时调用；</p><br><p style=\"color: #555555;\"><strong>viewWillDisappear</strong>－UIViewController对象的视图即将消失、被覆盖或是隐藏时调用；</p><br><p style=\"color: #555555;\"><strong>viewDidDisappear</strong>－UIViewController对象的视图已经消失、被覆盖或是隐藏时调用；</p><br><p style=\"color: #555555;\"><strong>viewVillUnload</strong>－当内存过低时，需要释放一些不需要使用的视图时，即将释放时调用；</p><br><p style=\"color: #555555;\"><strong>viewDidUnload</strong>－当内存过低，释放一些不需要的视图时调用。</p><br><p style=\"color: #555555;\"><strong>19.</strong>关于ios里的<span style=\"color: #222222;\"><span style=\"color: #3366ff;\">edgesForExtendedLayout</span>，<span style=\"color: #3366ff;\">automaticallyAdjustsScrollViewInsets</span>，<span style=\"color: #3366ff;\">translucent</span>，和navigationBar之间的关系其中：</span></p><br><p style=\"color: #555555;\"><span style=\"color: #222222;\">1 <span style=\"color: #3366ff;\">translucent是navigationBar的属性优先级最高</span></span></p><br><p style=\"color: #555555;\"><span style=\"color: #222222;\">当translucent=true（默认）时，即在含有navigationBar的页面中，frame的0是从页面的statusBar开始算的。</span></p><br><p style=\"color: #555555;\">当<span style=\"color: #222222;\">translucent=false时，即在含有navigationBar的页面中，frame的0是从navigationBar下面开始算的。</span></p><br><p style=\"color: #555555;\">2 <span style=\"color: #3366ff;\">edgesForExtendedLayout是viewController的属性优先级其次</span></p><br><p style=\"color: #555555;\">当<span style=\"color: #222222;\">edgesForExtendedLayout=RectEdgeNone时，即在含有navigationBar的页面中，frame的0是从navigationBar下面开始算的。</span></p><br><p style=\"color: #555555;\">当<span style=\"color: #222222;\">edgesForExtendedLayout=RectEdgeAll（默认）时，即在含有navigationBar的页面中，frame的0是从statusBar开始算的。</span></p><br><p style=\"color: #555555;\">3 <span style=\"color: #3366ff;\">automaticallyAdjustsScrollViewInsets是viewController的属性，只对UIScrollView，UITableView有效</span></p><br><p style=\"color: #555555;\">当automaticallyAdjustsScrollViewInsets<span style=\"color: #222222;\">=true时，即在含有navigationBar的页面中，UIScrollView是从navigationBar底部开始滚动的，frame的0根据前两个属性影响。</span></p><br><p style=\"color: #555555;\">当automaticallyAdjustsScrollViewInsets<span style=\"color: #222222;\">=false时，即在含有navigationBar的页面中，UIScrollView是从本身的位置开始滚动的，frame的0根据前两个属性影响。</span></p><br><p style=\"color: #555555;\">再设置<span style=\"color: #222222;\">edgesForExtendedLayout和translucent时会影响viewController的view的高度，在viewDidLoad和viewWillAppear会有所体现。</span></p><br><p style=\"color: #555555;\"></p><br><p style=\"color: #555555;\"><span style=\"font-weight: bolder; line-height: 28.7999992370605px;\">20.</span><span>关于<span style=\"color: #008080;\">alloc init</span> 和 <span style=\"color: #008080;\">new</span> 的区别，在oc中，创建一个对象经常是alloc init调用两个方法，其实oc也支持用new来创建对象的，这两个方法其实没什么区别，使用alloc init思路更清晰一些，先分配内存，然后返回实例对象，可以参考<a style=\"color: #336699;\" href=\"http://stackoverflow.com/questions/719877/use-of-alloc-init-instead-of-new\" target=\"_blank\">stackoverflow</a>。</span></p><br><p style=\"color: #555555;\"></p><br><p style=\"color: #555555;\"><span style=\"font-weight: bold;\">21.</span>appDelegate生命周期方法</p>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//当应用程序将要进入非活动状态执行，在此期间，应用程序不接受消息或事件，比如来电  </span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)applicationWillResignActive:(UIApplication *)application  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    NSLog(@<span class=\"string\">\"应用程序将要进入非活动状态，即将进入后台\"</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//应用程序已经进入后台运行  </span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)applicationDidEnterBackground:(UIApplication *)application  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    NSLog(@<span class=\"string\">\"如果应用程序支持后台运行，则应用程序已经进入后台运行\"</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//应用程序将要进入活动状态执行  </span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)applicationWillEnterForeground:(UIApplication *)application  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    NSLog(@<span class=\"string\">\"应用程序将要进入活动状态，即将进入前台运行\"</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//应用程序已经进入活动状态  </span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)applicationDidBecomeActive:(UIApplication *)application  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    NSLog(@<span class=\"string\">\"应用程序已进入前台，处于活动状态\"</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//应用程序将要退出，通常用于保存书架喝一些推出前的清理工作，  </span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)applicationWillTerminate:(UIApplication *)application  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    NSLog(@<span class=\"string\">\"应用程序将要退出，通常用于保存书架喝一些推出前的清理工作\"</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//当设备为应用程序分配了太多的内存，操作系统会终止应用程序的运行，在终止前会执行这个方法  </span></span><br><span class=\"line\"><span class=\"comment\">//通常可以在这里进行内存清理工作，防止程序被终止  </span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)applicationDidReceiveMemoryWarning:(UIApplication *)application  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    NSLog(@<span class=\"string\">\"系统内存不足，需要进行清理工作\"</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//当系统时间发生改变时执行  </span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)applicationSignificantTimeChange:(UIApplication *)application  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    NSLog(@<span class=\"string\">\"当系统时间发生改变时执行\"</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//当程序载入后执行  </span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)applicationDidFinishLaunching:(UIApplication *)application  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    NSLog(@<span class=\"string\">\"当程序载入后执行\"</span>);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&nbsp;</p>\n<p></p><p style=\"color: #555555;\">附上最近做的一个ios的demo：<a href=\"https://github.com/lvming6816077/wodu\" target=\"_blank\">https://github.com/lvming6816077/wodu</a></p><br><a href=\"http://www.cocoachina.com/bbs/read.php?tid=280826\" target=\"_blank\" rel=\"noopener\">http://www.cocoachina.com/bbs/read.php?tid=280826</a><p></p>\n<p>未完。。</p>\n","site":{"data":{}},"excerpt":"<p></p><h2><span style=\"color: #008000;\"><strong>前言</strong></span></h2><br>本文将已一个web开发者的角度来记录一些日常学习ios开发中踩过的坑和web前端与ios开发的知识对比，如果有ios大神看出什么不对的地方，还请指出哈。<p></p>\n<p></p><h2><span style=\"color: #008000;\">正文</span></h2><br><strong>1</strong>. ios开发要装<span style=\"color: #3366ff;\">xcode</span>，而且没有什么其他更好的ide，这样做前端的我感觉很不习惯，每次修改完代码后都要点击运行，这比刷新浏览器慢多了。。<br>","more":"<br>&nbsp;<p></p>\n<p><strong>2</strong>. ios开发中，页面顶部的导航叫做navigationBar，这是ios里面自带的一种控件，不像web需要自己写div css来实现一个header栏，navigationBar的一本和navigationController配合使用，关于navigationController其实他并不是一个真正的页面，他是一个虚拟的用来管理页面跳转的组件，并不像一般的viewcontroller有这可以看到的对应的页面，跟navigationController类似的还有tabBarController</p>\n<p>&nbsp;</p>\n<p><strong>3</strong>. ios开发中每一个页面叫做一个viewController相当于web里面的html页面，其中<span style=\"color: #3366ff;\">viewController</span>里面有<span style=\"color: #3366ff;\">viewDidLoad</span>，<span style=\"color: #3366ff;\">viewDidAppear</span>等方法，这些方法是viewController的生命周期方法，在这些方法里面可以写页面相关的逻辑，这有点类似与web里面window的onload方法或者domcument.ready方法，viewController里有一个view属性，这是一个大的父view，可以看做html的body标签，在这个属性里面可以添加一些子自定义的view。</p>\n<p>&nbsp;</p>\n<p><strong>4</strong>. ios开发中，最基本的ui元素是uiview，可以把它当作div，并且在ios中 布局都是绝对定位的absolute（和web里面的canvas布局类似），每一个ios的ui元素有一个属性叫做frame，这个属性包括x,y,width,heigt这四个值就可以确定一个元素在界面中的位置。</p>\n<p>&nbsp;</p>\n<p><strong>5</strong>.ios开发中，使用oc进行变成，可以将一些需要的依赖通过import的方式引入，import “”双引号一般表示引入自己写的一些文件，import &lt;&gt;尖括号标识引入系统的库例如uikit啥的，这个和nodejs里的require有些类似，但是又有一些区分，nodejs中require引入的依赖文件必须已module.export结尾，oc里面的import不必需要。</p>\n<p>&nbsp;</p>\n<p><strong>6</strong>.关于ios中的<span style=\"color: #3366ff;\">navigationbar</span>，下面这张图表示的比较清晰<img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/navigationbar.png\" alt=\"\" width=\"640\" height=\"174\"></p>\n<p>&nbsp;</p>\n<p><strong>7</strong>. ios开发中，可以利用oc的宏定义一些全局的变量或者全局的方法，所谓宏就是一种特殊的语法，只要引入后，在oc的代码里都可以使用，可以理解成在window下挂一些变量和方法，使用起来比较方便，另外，由于定于宏的代码都放在一个 统一的文件里面，所以oc端想使用这个宏，必须引入他例如import “Define.h”,这个跟js相比还是比较麻烦的，不过也有解决办法，在xcode里面可以一个projectName-<span style=\"color: #222426;\">Prefix.pch以pch结尾的文件。</span></p>\n<p>&nbsp;</p>\n<p><span style=\"color: #222426;\"><strong>8</strong>.pch全称是“<span style=\"color: #3366ff;\">precompiled header</span>”，也就是预编译头文件，该文件里存放的工程中一些不常被修改的代码，比如常用的框架头文件，这样做的目的提高编译器编译速度。<span style=\"color: #000000;\">假如pch中某个文件修改了，那么pch整个文件里包含的的其他文件也会重新编译一次，这样就会消耗大量时间，所以它里面添加的文件最好是是很少变动或不变动的头文件或者是预编译的代码片段：</span></span><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> __IPHONE_4_0  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">warning</span> <span class=\"meta-string\">\"This project uses features only available in iOS SDK 4.0 and later.\"</span>  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __OBJC__  </span></span><br><span class=\"line\">    <span class=\"meta\">#import &amp;lt;UIKit/UIKit.h&amp;gt;  </span></span><br><span class=\"line\">    <span class=\"meta\">#import &amp;lt;Foundation/Foundation.h&amp;gt;  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure></p>\n<p><strong>9</strong>. ios里面如果想显示一张图片并不像web那样简单，在web里，我们只用给img标签配置一个src即可，但是在ios客户端开发中，图片其实是一个文件，包括本地和网络图片，如果要想显示，我自己写逻辑将图片下载下来，然后将结果传给UIImage，但是这只是一个图片对象，还要将UIImage配置给UIImageView才能真正看到图片，当然ios已经有许多开源的图片下载库来简化我们这些操作例如AFNetworking等。</p>\n<p>&nbsp;</p>\n<p><strong>10</strong>. ios里关于图片有多个展示的类型，也就是说图片较大怎么居中截取，图片较小怎么拉伸都有相关的配置，这一点比web要丰富一些，web要想实现这些必须自己写逻辑代码实现，例如UIImageview的<a href=\"http://www.jianshu.com/p/338af5eb5c60\" target=\"_blank\">contentmode</a>属性</p>\n<p>其中主要分为:<span style=\"color: #3366ff;\">ScaleToFill</span>,<span style=\"color: #3366ff;\">ScaleAspectFit</span>,<span style=\"color: #3366ff;\">ScaleAspectFill</span>三种。</p>\n<p>ScaleToFill为将图片按照整个区域进行拉伸(会破坏图片的比例)<br>ScaleAspectFit将图片等比例拉伸，可能不会填充满整个区域<br>ScaleAspectFill将图片等比例拉伸，会填充整个区域，但是会有一部分过大而超出整个区域。<br>至于Top,Left,Right等等就是将图片在view中的位置进行调整。</p>\n<p>&nbsp;</p>\n<p><strong>11</strong>. ios里实现页面跳转主要分为模态modal和入栈态push，具体思路就是找到将要<span style=\"color: #3366ff;\">跳转</span>的页面的viewcontroller，new出来之后，调用</p>\n<p><strong><span class=\"s1\">- (void)pushViewController:(<a style=\"color: #000000;\" href=\"file:///Applications/Xcode.app/Contents/Developer/Documentation/DocSets/com.apple.adc.documentation.AppleiOS8.1.iOSLibrary.docset/Contents/Resources/Documents/documentation/UIKit/Reference/UIViewController_Class/index.html#//apple_ref/doc/c_ref/UIViewController\" target=\"_blank\" rel=\"noopener\"><span class=\"s2\">UIViewController</span></a> *)viewController animated:(BOOL)animated</span></strong></p>\n<p><strong><span class=\"s1\">- (void)presentViewController:(UIViewController *)viewControllerToPresent animated:(BOOL)flag completion:(void (^)(void))completion</span></strong></p>\n<p>来实现页面跳转，前者一般配合navigationController使用，后者则在一般的viewcongroller里面使用即可。</p>\n<p>&nbsp;</p>\n<p><strong>12</strong>. ios里面可以将一个view隐藏，调用view.hidden = true即可，但是跟web不同的是，隐藏的view同样占用这位置，同时，挨着被隐藏的view的兄弟view也并不会顶上来（占用隐藏view的位置）这一点和ios的绝对定位有关，所以如果用web的思想去隐藏和显示一个view在ios上会很麻烦，这里笔着曾经一度不能接受这样的转变，不能适应过来。。</p>\n<p>&nbsp;</p>\n<p><strong>13</strong>. ios里也有一个类似于web相对定位的东西叫做<a href=\"http://blog.csdn.net/sxfcct/article/details/8776928\" target=\"_blank\">autolayout</a>，这中开发方式完全抛弃了使用frame去定义一个view位置的方式，而且这个方式配合xib（<span style=\"color: #000000;\">Interface Builder</span>），来构建页面的布局跟web很相似，所见即所得，我们在xcode里面直接将我们需要的组件拖入进来即可，同时可以定义view直接的约束，类似与web的margin padding 之类的限制条件，就可以很方便的布局和适配，具体可以参考<a href=\"http://www.cnblogs.com/WhoJun/p/3498408.html?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\">这个链接</a>。</p>\n<p><strong>14</strong>.<img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/NavigationViews_2x.png\" alt=\"\" width=\"977\" height=\"986\"></p>\n<p>上面这个图完美的表现了 底部tabbar，顶部navigationbar，viewcontroller，view的层次图，所以对于ios来说，很多组件系统都是提供的，并不像web很多组件要自己用div和css来实现。</p>\n<p>&nbsp;</p>\n<p><strong>15</strong>. 在ios中，如果使用的TabBarController（一种底部bar的viewController）这是一种特殊的controller，通过配置TabBarController的viewControllers属性就可以往这个TabBarController里面添加需要展示的页面，TabBarController会自己控制当点击哪一个tab时显示哪个页面，这点比web要智能很多，web要自己实现这种控件，而ios里面都已经实现了了。</p>\n<p>&nbsp;</p>\n<p><strong>16</strong>. 在含有TabBarController的页面中，当从这个页面跳转出去时，<span style=\"color: #3366ff;\">必须手动把 底部tabba给隐藏掉</span>，这点一开始也是很不理解，不过理解下来，其实用了TabBarController时，整个页面都在这个页面里的那个区域内跳转，所以底部的bar是常驻的，因此要隐藏底部。</p>\n<p>&nbsp;</p>\n<p><strong>17.</strong> 关于ios里面的<span style=\"color: #3366ff;\">重写</span>和<span style=\"color: #3366ff;\">重载</span>，重写就是子类继承父类时，子类写一个方法和父类的方法名，参数，返回一样这样就是重写，重载就是在子类写两个相同的方法叫做重载，在viewController里会经常看到，viewDidLoad，viewDidAppear这类方法中经常看到[super viewDidLoad]这样调用父类的方法，原因是调用子类的方法时候 如果子类没有这个方法就会去父类找 所以如果不重写父类方法，不会影响到父类的调用，但是如果重写了方法，就不会去父类找 这个时候如果不再子类里面调用一下[super viewDidLoad]就会调用不到父类的默认方法了。</p>\n<p>&nbsp;</p>\n<p><strong>18.</strong>viewConfroller的<span style=\"color: #3366ff;\">生命周期</span></p>\n<p style=\"color: #555555;\"><strong>init</strong>－初始化程序</p><br><p style=\"color: #555555;\"><strong>loadView- </strong>加载视图的view（通常这一步不需要去干涉）</p><br><p style=\"color: #555555;\"><strong>viewDidLoad</strong>－加载视图（各种初始数据的载入，初始设定等很多内容，都会在这个方法中实现）</p><br><p style=\"color: #555555;\"><strong>viewWillAppear</strong>－UIViewController对象的视图即将加入窗口时调用；（当APP有多个视图时，在视图间切换时，并不会再次载入viewDidLoad方法，所以如果在调入视图时，需要对数据做更新，就只能在这个方法内实现了）</p><br><p style=\"color: #555555;\"><strong>viewDidApper</strong>－UIViewController对象的视图已经加入到窗口时调用；</p><br><p style=\"color: #555555;\"><strong>viewWillDisappear</strong>－UIViewController对象的视图即将消失、被覆盖或是隐藏时调用；</p><br><p style=\"color: #555555;\"><strong>viewDidDisappear</strong>－UIViewController对象的视图已经消失、被覆盖或是隐藏时调用；</p><br><p style=\"color: #555555;\"><strong>viewVillUnload</strong>－当内存过低时，需要释放一些不需要使用的视图时，即将释放时调用；</p><br><p style=\"color: #555555;\"><strong>viewDidUnload</strong>－当内存过低，释放一些不需要的视图时调用。</p><br><p style=\"color: #555555;\"><strong>19.</strong>关于ios里的<span style=\"color: #222222;\"><span style=\"color: #3366ff;\">edgesForExtendedLayout</span>，<span style=\"color: #3366ff;\">automaticallyAdjustsScrollViewInsets</span>，<span style=\"color: #3366ff;\">translucent</span>，和navigationBar之间的关系其中：</span></p><br><p style=\"color: #555555;\"><span style=\"color: #222222;\">1 <span style=\"color: #3366ff;\">translucent是navigationBar的属性优先级最高</span></span></p><br><p style=\"color: #555555;\"><span style=\"color: #222222;\">当translucent=true（默认）时，即在含有navigationBar的页面中，frame的0是从页面的statusBar开始算的。</span></p><br><p style=\"color: #555555;\">当<span style=\"color: #222222;\">translucent=false时，即在含有navigationBar的页面中，frame的0是从navigationBar下面开始算的。</span></p><br><p style=\"color: #555555;\">2 <span style=\"color: #3366ff;\">edgesForExtendedLayout是viewController的属性优先级其次</span></p><br><p style=\"color: #555555;\">当<span style=\"color: #222222;\">edgesForExtendedLayout=RectEdgeNone时，即在含有navigationBar的页面中，frame的0是从navigationBar下面开始算的。</span></p><br><p style=\"color: #555555;\">当<span style=\"color: #222222;\">edgesForExtendedLayout=RectEdgeAll（默认）时，即在含有navigationBar的页面中，frame的0是从statusBar开始算的。</span></p><br><p style=\"color: #555555;\">3 <span style=\"color: #3366ff;\">automaticallyAdjustsScrollViewInsets是viewController的属性，只对UIScrollView，UITableView有效</span></p><br><p style=\"color: #555555;\">当automaticallyAdjustsScrollViewInsets<span style=\"color: #222222;\">=true时，即在含有navigationBar的页面中，UIScrollView是从navigationBar底部开始滚动的，frame的0根据前两个属性影响。</span></p><br><p style=\"color: #555555;\">当automaticallyAdjustsScrollViewInsets<span style=\"color: #222222;\">=false时，即在含有navigationBar的页面中，UIScrollView是从本身的位置开始滚动的，frame的0根据前两个属性影响。</span></p><br><p style=\"color: #555555;\">再设置<span style=\"color: #222222;\">edgesForExtendedLayout和translucent时会影响viewController的view的高度，在viewDidLoad和viewWillAppear会有所体现。</span></p><br><p style=\"color: #555555;\"></p><br><p style=\"color: #555555;\"><span style=\"font-weight: bolder; line-height: 28.7999992370605px;\">20.</span><span>关于<span style=\"color: #008080;\">alloc init</span> 和 <span style=\"color: #008080;\">new</span> 的区别，在oc中，创建一个对象经常是alloc init调用两个方法，其实oc也支持用new来创建对象的，这两个方法其实没什么区别，使用alloc init思路更清晰一些，先分配内存，然后返回实例对象，可以参考<a style=\"color: #336699;\" href=\"http://stackoverflow.com/questions/719877/use-of-alloc-init-instead-of-new\" target=\"_blank\">stackoverflow</a>。</span></p><br><p style=\"color: #555555;\"></p><br><p style=\"color: #555555;\"><span style=\"font-weight: bold;\">21.</span>appDelegate生命周期方法</p>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//当应用程序将要进入非活动状态执行，在此期间，应用程序不接受消息或事件，比如来电  </span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)applicationWillResignActive:(UIApplication *)application  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    NSLog(@<span class=\"string\">\"应用程序将要进入非活动状态，即将进入后台\"</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//应用程序已经进入后台运行  </span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)applicationDidEnterBackground:(UIApplication *)application  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    NSLog(@<span class=\"string\">\"如果应用程序支持后台运行，则应用程序已经进入后台运行\"</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//应用程序将要进入活动状态执行  </span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)applicationWillEnterForeground:(UIApplication *)application  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    NSLog(@<span class=\"string\">\"应用程序将要进入活动状态，即将进入前台运行\"</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//应用程序已经进入活动状态  </span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)applicationDidBecomeActive:(UIApplication *)application  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    NSLog(@<span class=\"string\">\"应用程序已进入前台，处于活动状态\"</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//应用程序将要退出，通常用于保存书架喝一些推出前的清理工作，  </span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)applicationWillTerminate:(UIApplication *)application  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    NSLog(@<span class=\"string\">\"应用程序将要退出，通常用于保存书架喝一些推出前的清理工作\"</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//当设备为应用程序分配了太多的内存，操作系统会终止应用程序的运行，在终止前会执行这个方法  </span></span><br><span class=\"line\"><span class=\"comment\">//通常可以在这里进行内存清理工作，防止程序被终止  </span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)applicationDidReceiveMemoryWarning:(UIApplication *)application  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    NSLog(@<span class=\"string\">\"系统内存不足，需要进行清理工作\"</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//当系统时间发生改变时执行  </span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)applicationSignificantTimeChange:(UIApplication *)application  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    NSLog(@<span class=\"string\">\"当系统时间发生改变时执行\"</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//当程序载入后执行  </span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)applicationDidFinishLaunching:(UIApplication *)application  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    NSLog(@<span class=\"string\">\"当程序载入后执行\"</span>);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&nbsp;</p>\n<p></p><p style=\"color: #555555;\">附上最近做的一个ios的demo：<a href=\"https://github.com/lvming6816077/wodu\" target=\"_blank\">https://github.com/lvming6816077/wodu</a></p><br><a href=\"http://www.cocoachina.com/bbs/read.php?tid=280826\" target=\"_blank\" rel=\"noopener\">http://www.cocoachina.com/bbs/read.php?tid=280826</a><p></p>\n<p>未完。。</p>"},{"title":"requireJS实现原理研究1","date":"2014-08-12T10:31:29.000Z","_content":"众所周知，Javascript有一个很棒的模块化库requireJS，这个基于AMD规范的js库受到越来越多的程序员喜爱，那么，下面就来谈谈我对requireJS的研究和理解。\n\n<!--more-->\n\n<h3>1. 简单流程概括：</h3>\n<ol>\n\t<li>我们在使用requireJS时，都会把所有的js交给requireJS来管理，也就是我们的页面上只引入一个require.js，把data-main指向我们的main.js。</li>\n\t<li>通过我们在main.js里面定义的require方法或者define方法，requireJS会把这些依赖和回调方法都用一个数据结构保存起来。</li>\n\t<li>当页面加载时，requireJS会根据这些依赖预先把需要的js通过document.createElement的方法引入到dom中，这样，被引入dom中的script便会运行。</li>\n\t<li>由于我们依赖的js也是要按照requireJS的规范来写的，所以他们也会有define或者require方法，同样类似第二步这样循环向上查找依赖，同样会把他们村起来。</li>\n\t<li>当我们的js里需要用到依赖所返回的结果时(通常是一个key value类型的object),requireJS便会把之前那个保存回调方法的数据结构里面的方法拿出来并且运行，然后把结果给需要依赖的方法。</li>\n\t<li>以上就是一个简单的流程。</li>\n</ol>\n&nbsp;\n<h3>2. 测试代码</h3>\n下面我把一个requireJS小Demo写出来，是下面研究源码的基础：\n\nmain.js\n```javascript\nrequire.config({\n　　　　paths: {\n　　　　　　\"a\": \"a\",\n　　　　　　\"b\": \"b\"\n　　　　}\n});\nrequire(['a'], function (a){\n        console.log('main');\n        //console.log(a);\n});\n```\na.js\n```javascript\ndefine(['b'], function(b){\n    console.log('a');\n    return {\n        'text' : 1\n    }\n})\n```\nb.js\n```javascript\ndefine(function(){\n    console.log('b');\n    //return 1;\n})\n```\n这些代码都很简单，下面开始正式的研究。\n\n&nbsp;\n<h3>3. 开始研究</h3>\n<ol>\n\t<li> <em><strong>关于requireJS预加载</strong></em>。也就是说，我每个模块所依赖的其他模块都会比本模块预先加载，这点可以直接运行测试代码来证明。\n```javascript\nb b.js:2\na a.js:2\nmain main.js：8\n```\n这是控制台打印出的信息，可以看到，加载的顺序确实如上面所说。</li>\n\t<li><em><strong>requireJS的上下文对象context。</strong></em>翻开requireJS的代码，看到通篇的function定义和其他变量的声明，这些暂时都还不重要，我们只用关心两行代码。\n```javascript\n//Create default context.\n    req({});\n```\n根据注释可以知道，这段代码初始化了一个上下文对象context，调用的是req方法\n```javascript\nreq = requirejs = function (deps, callback, errback, optional) {\n\n        //Find the right context, use default\n        var context, config,\n            contextName = defContextName;\n\n        // Determine if have config object in the call.\n        if (!isArray(deps) &amp;&amp; typeof deps !== 'string') {\n            // deps is a config object\n            config = deps;\n            if (isArray(callback)) {\n                // Adjust args if there are dependencies\n                deps = callback;\n                callback = errback;\n                errback = optional;\n            } else {\n                deps = [];\n            }\n        }\n\n        if (config &amp;&amp; config.context) {\n            contextName = config.context;\n        }\n\n        context = getOwn(contexts, contextName);\n        if (!context) {\n            context = contexts[contextName] = req.s.newContext(contextName);\n        }\n\n        if (config) {\n            context.configure(config);\n        }\n        var fg = context.require(deps, callback, errback);\n        return fg;\n    };\n```\n这也方法也就是常用的require方法，可以看到这个context只会初始化一次，打印出来就是\n```javascript\nModule: function (map) {\ncompleteLoad: function (moduleName) {\nconfig: Object\nconfigure: function (cfg) {\ncontextName: \"_\"\ndefQueue: Array[0]\ndefined: Object\nenable: function (depMap) {\nexecCb: function (name, callback, args, exports) {\nload: function (id, url) {\nmakeModuleMap: function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {\nmakeRequire: function (relMap, options) {\nmakeShimExports: function (value) {\nnameToUrl: function (moduleName, ext, skipExt) {\nnextTick: function (fn) {\nonError: function onError(err, errback) {\nonScriptError: function (evt) {\nonScriptLoad: function (evt) {\nregistry: Object\nrequire: function localRequire(deps, callback, errback) {\nurlFetched: Object\n__proto__: Object\n```\n当然，这里面有很多东西，但是根据命名，不难理解，这里很多东西都是以后要用到的，例如defQueue，makeRequire等等，不用着急，这些都会在后面说道的。这个方法return了一个fg我是自己调试用的，这个fg是一个function（闭包），程序运行到这里由于我们传入的defs是空，这个function里的大多数逻辑都没有走，所以这个方法就结束了，程序会继续往下运行。</li>\n\t<li><em><strong>requireJS的引入script。</strong></em>上一步我们得到的第一次初始化的context对象，看上去里面什么还没有，我们继续debug下，程序走到了这里：\n```javascript\nif (isBrowser) {\n    head = s.head = document.getElementsByTagName('head')[0];\n    //If BASE tag is in play, using appendChild is a problem for IE6.\n    //When that browser dies, this can be removed. Details in this jQuery bug:\n    //http://dev.jquery.com/ticket/2709\n    baseElement = document.getElementsByTagName('base')[0];\n    if (baseElement) {\n        head = s.head = baseElement.parentNode;\n    }\n}\n```\n这段代码不难理解，跟我上面说道的流程一样，开始寻找html里的head标签了，当然是为了引入script了！然后程序走到了这里：\n```javascript\nif (isBrowser &amp;&amp; !cfg.skipDataMain) {\n\n\teachReverse(scripts(), function (script) {\n\n\t    if (!head) {\n\t        head = script.parentNode;\n\t    }\n\n\t    dataMain = script.getAttribute('data-main');\n\t    if (dataMain) {\n\n\t        mainScript = dataMain;\n\n\t        if (!cfg.baseUrl) {\n\n\t            src = mainScript.split('/');\n\t            mainScript = src.pop();\n\t            subPath = src.length ? src.join('/')  + '/' : './';\n\n\t            cfg.baseUrl = subPath;\n\t        }\n\n\t        mainScript = mainScript.replace(jsSuffixRegExp, '');\n\n\t        if (req.jsExtRegExp.test(mainScript)) {\n\t            mainScript = dataMain;\n\t        }\n\n\t        cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];\n\n\t        return true;\n\t    }\n\t});\n}\n```\n这段代码的主要功能就是找到我们之前绑定的data-main的，然后往全局的cfg对象里添加base路径和main，当然如果我们自己通过require的config设置打印出cfg：\n```javascript\nObject {baseUrl: \"./\", deps: Array[1]}\nbaseUrl: \"./\"\ndeps: Array[1]\n0: \"main\"\nlength: 1\n__proto__: Array[0]\n__proto__: Object\n```\n这个cfg马上就会用到了。</li>\n\t<li><em><strong>第二次执行req方法。</strong></em>这时候程序来到了整个文件的倒数第二行\n```javascript\n//Set up with config info.\n    req(cfg);\n```\n这个时候调用req方法，把刚才的cfg传了进去，然后便又回到了require方法里面，到此为止，html页面上还只有一个script标签和一个require.js，我们的main a b .js都还没有运行，里面的代码都还没有起作用。\n再次进入req方法，这时deps不再是｛｝，而是上面cfg，里面有一个main，这是在回头看看刚才return的fg，打印出来：\n```javascript\nfunction localRequire(deps, callback, errback) {\n    var id, map, requireMod;\n\n    if (options.enableBuildCallback &amp;&amp; callback &amp;&amp; isFunction(callback)) {\n        callback.__requireJsBuild = true;\n    }\n\n    if (typeof deps === 'string') {\n        if (isFunction(callback)) {\n            //Invalid call\n            return onError(makeError('requireargs', 'Invalid require call'), errback);\n        }\n\n        if (relMap &amp;&amp; hasProp(handlers, deps)) {\n            return handlers[deps](registry[relMap.id]);\n        }\n\n\n        if (req.get) {\n            return req.get(context, deps, relMap, localRequire);\n        }\n\n        //Normalize module name, if it contains . or ..\n        map = makeModuleMap(deps, relMap, false, true);\n        id = map.id;\n\n        if (!hasProp(defined, id)) {\n            return onError(makeError('notloaded', 'Module name \"' +\n                        id +\n                        '\" has not been loaded yet for context: ' +\n                        contextName +\n                        (relMap ? '' : '. Use require([])')));\n        }\n        return defined[id];\n    }\n\n    intakeDefines();\n\n    context.nextTick(function () {\n\n        intakeDefines();\n\n        requireMod = getModule(makeModuleMap(null, relMap));\n\n        requireMod.skipMap = options.skipMap;\n        requireMod.init(deps, callback, errback, {\n            enabled: true\n        });\n\n        checkLoaded();\n    });\n\n    return localRequire;\n}\n```\n原来程序走到了这里，于是我们继续debug。由于我们传入的defs不为空，所以这次和第一次执行req方法大不一样了，一路走下来，我们发现context.nextTick这个方法，很奇怪的是，找到nextTick定义的地方\n```javascript\nreq.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {\n        setTimeout(fn, 4);\n    } : function (fn) { fn(); };\n```\n没错，这里用到了setTimeout来延迟执行一个方法，这是为什么呢？还是4ms，至今没有搞明白！nextTick方法：\n```javascript\ncontext.nextTick(function () {\n        //Some defines could have been added since the\n        //require call, collect them.\n        intakeDefines();\n\n        requireMod = getModule(makeModuleMap(null, relMap));\n\n        //Store if map config should be applied to this require\n        //call for dependencies.\n        requireMod.skipMap = options.skipMap;\n        requireMod.init(deps, callback, errback, {\n             enabled: true\n        });\n\n        checkLoaded();\n});\n```\n这里说一下getModule方法，这个方法返回context里面的Module对象，这个对象是唯一标识的，也就说每个模块对应一个module，module里面存储这当前模块所依赖的模块和当前模块运行的结果。\n```javascript\nModule = function (map) {\n    this.events = getOwn(undefEvents, map.id) || {};\n    this.map = map;\n    this.shim = getOwn(config.shim, map.id);\n    this.depExports = [];\n    this.depMaps = [];\n    this.depMatched = [];\n    this.pluginMaps = {};\n    this.depCount = 0;\n\n    /* this.exports this.factory\n       this.depMaps = [],\n       this.enabled, this.fetched\n    */\n};\n```\n这个方法里的intakeDefines方法，可以理解为对上面context里面defQueue的初始化，通过getModule方法，最终会执行Module的init方法，这个defQueue数组里面存的是全局当前的依赖。由于此时defQueue还为空，所以不会初始化。\n然后程序接着往下运行，由于我们的deps里面有main，所以我们得到了一个新的Module，是关于main的requireMod，然后执行init方法。</li>\n\t<li><em><strong>开始引入main.js。</strong></em>进入init（）方法：\n```javascript\ninit: function (depMaps, factory, errback, options) {\n\t    options = options || {};\n\n\t    if (this.inited) {\n\t        return;\n\t    }\n\n\t    this.factory = factory;\n\n\t    if (errback) {\n\t this.on('error', errback);\n\t    } else if (this.events.error) {\n\n\t        errback = bind(this, function (err) {\n\t            this.emit('error', err);\n\t        });\n\t    }\n\n\t    this.depMaps = depMaps &amp;&amp; depMaps.slice(0);\n\n\t    this.errback = errback;\n\n\n\t    this.inited = true;\n\n\t    this.ignore = options.ignore;\n\n\n\t    if (options.enabled || this.enabled) {\n\t        //Enable this module and dependencies.\n\t        //Will call this.check()\n\n\t        this.enable();\n\t    } else {\n\t        this.check();\n\t    }\n\t},\n```\n这段代码这么长，一开始我也看不懂的，但是我们可以抽取要点，看最后的this.enable()由于执行了这个方法，再往下debug，中间经过了check（）方法，fetch（）方法，load（）方法，然后进入到了req.load（），在这里感叹一下requireJS确实比较复杂，中间的每个方法都对一些全局变量有修改或者设置，在这里不细致描述，继续我们主要的流程。在req.load（）\n```javascript\nreq.load = function (context, moduleName, url) {\n    var config = (context &amp;&amp; context.config) || {},\n        node;\n    if (isBrowser) {\n\n        node = req.createNode(config, moduleName, url);\n\n        node.setAttribute('data-requirecontext', context.contextName);\n        node.setAttribute('data-requiremodule', moduleName);\n\n\n        if (node.attachEvent &amp;&amp;\n\n                !(node.attachEvent.toString &amp;&amp; node.attachEvent.toString().indexOf('[native code') &lt; 0) &amp;&amp;\n                !isOpera) {\n\n            useInteractive = true;\n\n            node.attachEvent('onreadystatechange', context.onScriptLoad);\n\n        } else {\n            node.addEventListener('load', context.onScriptLoad, false);\n            node.addEventListener('error', context.onScriptError, false);\n        }\n        node.src = url;\n\n        currentlyAddingScript = node;\n        if (baseElement) {\n            head.insertBefore(node, baseElement);\n        } else {\n            head.appendChild(node);\n        }\n        currentlyAddingScript = null;\n\n        return node;\n    } else if (isWebWorker) {\n        try {\n\n            importScripts(url);\n\n            context.completeLoad(moduleName);\n        } catch (e) {\n            context.onError(makeError('importscripts',\n                            'importScripts failed for ' +\n                                moduleName + ' at ' + url,\n                            e,\n                            [moduleName]));\n        }\n    }\n};\n```\n终于，我们看到了证据，requireJS开始往dom里面插script了！打印出参数context, moduleName, url即\n```javascript\ncontext：\n\nModule: function (map) {\ncompleteLoad: function (moduleName) {\nconfig: Object\nconfigure: function (cfg) {\ncontextName: \"_\"\ndefQueue: Array[0]\ndefined: Object\nenable: function (depMap) {\nexecCb: function (name, callback, args, exports) {\nload: function (id, url) {\nmakeModuleMap: function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {\nmakeRequire: function (relMap, options) {\nmakeShimExports: function (value) {\nnameToUrl: function (moduleName, ext, skipExt) {\nnextTick: function (fn) {\nonError: function onError(err, errback) {\nonScriptError: function (evt) {\nonScriptLoad: function (evt) {\nregistry: Object\nrequire: function localRequire(deps, callback, errback) {\nstartTime: 1407753904901\nurlFetched: Object\n\n\nmoduleName：\nmain\n\nurl：\n./main.js\n```\n然后，我们的main.js就引入进来了！\n```html\n<script type=\"text/javascript\" charset=\"utf-8\" async=\"\" data-requirecontext=\"_\" data-requiremodule=\"main\" src=\"./main.js\"></script>\n```\n当然，localRequire方法最后还有一个checkLoaded();方法，顾名思义就是用来检测是否引入成功，里面还有一个exprier时间，超出则报错。</li>\n\t<li>OK，这篇文章先写到这里。</li>\n</ol>","source":"_posts/requireJS实现原理研究1.md","raw":"---\ntitle: requireJS实现原理研究1\ndate: 2014-08-12 18:31:29\ntags:\n- requirejs\ncategories:\n- 381\n---\n众所周知，Javascript有一个很棒的模块化库requireJS，这个基于AMD规范的js库受到越来越多的程序员喜爱，那么，下面就来谈谈我对requireJS的研究和理解。\n\n<!--more-->\n\n<h3>1. 简单流程概括：</h3>\n<ol>\n\t<li>我们在使用requireJS时，都会把所有的js交给requireJS来管理，也就是我们的页面上只引入一个require.js，把data-main指向我们的main.js。</li>\n\t<li>通过我们在main.js里面定义的require方法或者define方法，requireJS会把这些依赖和回调方法都用一个数据结构保存起来。</li>\n\t<li>当页面加载时，requireJS会根据这些依赖预先把需要的js通过document.createElement的方法引入到dom中，这样，被引入dom中的script便会运行。</li>\n\t<li>由于我们依赖的js也是要按照requireJS的规范来写的，所以他们也会有define或者require方法，同样类似第二步这样循环向上查找依赖，同样会把他们村起来。</li>\n\t<li>当我们的js里需要用到依赖所返回的结果时(通常是一个key value类型的object),requireJS便会把之前那个保存回调方法的数据结构里面的方法拿出来并且运行，然后把结果给需要依赖的方法。</li>\n\t<li>以上就是一个简单的流程。</li>\n</ol>\n&nbsp;\n<h3>2. 测试代码</h3>\n下面我把一个requireJS小Demo写出来，是下面研究源码的基础：\n\nmain.js\n```javascript\nrequire.config({\n　　　　paths: {\n　　　　　　\"a\": \"a\",\n　　　　　　\"b\": \"b\"\n　　　　}\n});\nrequire(['a'], function (a){\n        console.log('main');\n        //console.log(a);\n});\n```\na.js\n```javascript\ndefine(['b'], function(b){\n    console.log('a');\n    return {\n        'text' : 1\n    }\n})\n```\nb.js\n```javascript\ndefine(function(){\n    console.log('b');\n    //return 1;\n})\n```\n这些代码都很简单，下面开始正式的研究。\n\n&nbsp;\n<h3>3. 开始研究</h3>\n<ol>\n\t<li> <em><strong>关于requireJS预加载</strong></em>。也就是说，我每个模块所依赖的其他模块都会比本模块预先加载，这点可以直接运行测试代码来证明。\n```javascript\nb b.js:2\na a.js:2\nmain main.js：8\n```\n这是控制台打印出的信息，可以看到，加载的顺序确实如上面所说。</li>\n\t<li><em><strong>requireJS的上下文对象context。</strong></em>翻开requireJS的代码，看到通篇的function定义和其他变量的声明，这些暂时都还不重要，我们只用关心两行代码。\n```javascript\n//Create default context.\n    req({});\n```\n根据注释可以知道，这段代码初始化了一个上下文对象context，调用的是req方法\n```javascript\nreq = requirejs = function (deps, callback, errback, optional) {\n\n        //Find the right context, use default\n        var context, config,\n            contextName = defContextName;\n\n        // Determine if have config object in the call.\n        if (!isArray(deps) &amp;&amp; typeof deps !== 'string') {\n            // deps is a config object\n            config = deps;\n            if (isArray(callback)) {\n                // Adjust args if there are dependencies\n                deps = callback;\n                callback = errback;\n                errback = optional;\n            } else {\n                deps = [];\n            }\n        }\n\n        if (config &amp;&amp; config.context) {\n            contextName = config.context;\n        }\n\n        context = getOwn(contexts, contextName);\n        if (!context) {\n            context = contexts[contextName] = req.s.newContext(contextName);\n        }\n\n        if (config) {\n            context.configure(config);\n        }\n        var fg = context.require(deps, callback, errback);\n        return fg;\n    };\n```\n这也方法也就是常用的require方法，可以看到这个context只会初始化一次，打印出来就是\n```javascript\nModule: function (map) {\ncompleteLoad: function (moduleName) {\nconfig: Object\nconfigure: function (cfg) {\ncontextName: \"_\"\ndefQueue: Array[0]\ndefined: Object\nenable: function (depMap) {\nexecCb: function (name, callback, args, exports) {\nload: function (id, url) {\nmakeModuleMap: function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {\nmakeRequire: function (relMap, options) {\nmakeShimExports: function (value) {\nnameToUrl: function (moduleName, ext, skipExt) {\nnextTick: function (fn) {\nonError: function onError(err, errback) {\nonScriptError: function (evt) {\nonScriptLoad: function (evt) {\nregistry: Object\nrequire: function localRequire(deps, callback, errback) {\nurlFetched: Object\n__proto__: Object\n```\n当然，这里面有很多东西，但是根据命名，不难理解，这里很多东西都是以后要用到的，例如defQueue，makeRequire等等，不用着急，这些都会在后面说道的。这个方法return了一个fg我是自己调试用的，这个fg是一个function（闭包），程序运行到这里由于我们传入的defs是空，这个function里的大多数逻辑都没有走，所以这个方法就结束了，程序会继续往下运行。</li>\n\t<li><em><strong>requireJS的引入script。</strong></em>上一步我们得到的第一次初始化的context对象，看上去里面什么还没有，我们继续debug下，程序走到了这里：\n```javascript\nif (isBrowser) {\n    head = s.head = document.getElementsByTagName('head')[0];\n    //If BASE tag is in play, using appendChild is a problem for IE6.\n    //When that browser dies, this can be removed. Details in this jQuery bug:\n    //http://dev.jquery.com/ticket/2709\n    baseElement = document.getElementsByTagName('base')[0];\n    if (baseElement) {\n        head = s.head = baseElement.parentNode;\n    }\n}\n```\n这段代码不难理解，跟我上面说道的流程一样，开始寻找html里的head标签了，当然是为了引入script了！然后程序走到了这里：\n```javascript\nif (isBrowser &amp;&amp; !cfg.skipDataMain) {\n\n\teachReverse(scripts(), function (script) {\n\n\t    if (!head) {\n\t        head = script.parentNode;\n\t    }\n\n\t    dataMain = script.getAttribute('data-main');\n\t    if (dataMain) {\n\n\t        mainScript = dataMain;\n\n\t        if (!cfg.baseUrl) {\n\n\t            src = mainScript.split('/');\n\t            mainScript = src.pop();\n\t            subPath = src.length ? src.join('/')  + '/' : './';\n\n\t            cfg.baseUrl = subPath;\n\t        }\n\n\t        mainScript = mainScript.replace(jsSuffixRegExp, '');\n\n\t        if (req.jsExtRegExp.test(mainScript)) {\n\t            mainScript = dataMain;\n\t        }\n\n\t        cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];\n\n\t        return true;\n\t    }\n\t});\n}\n```\n这段代码的主要功能就是找到我们之前绑定的data-main的，然后往全局的cfg对象里添加base路径和main，当然如果我们自己通过require的config设置打印出cfg：\n```javascript\nObject {baseUrl: \"./\", deps: Array[1]}\nbaseUrl: \"./\"\ndeps: Array[1]\n0: \"main\"\nlength: 1\n__proto__: Array[0]\n__proto__: Object\n```\n这个cfg马上就会用到了。</li>\n\t<li><em><strong>第二次执行req方法。</strong></em>这时候程序来到了整个文件的倒数第二行\n```javascript\n//Set up with config info.\n    req(cfg);\n```\n这个时候调用req方法，把刚才的cfg传了进去，然后便又回到了require方法里面，到此为止，html页面上还只有一个script标签和一个require.js，我们的main a b .js都还没有运行，里面的代码都还没有起作用。\n再次进入req方法，这时deps不再是｛｝，而是上面cfg，里面有一个main，这是在回头看看刚才return的fg，打印出来：\n```javascript\nfunction localRequire(deps, callback, errback) {\n    var id, map, requireMod;\n\n    if (options.enableBuildCallback &amp;&amp; callback &amp;&amp; isFunction(callback)) {\n        callback.__requireJsBuild = true;\n    }\n\n    if (typeof deps === 'string') {\n        if (isFunction(callback)) {\n            //Invalid call\n            return onError(makeError('requireargs', 'Invalid require call'), errback);\n        }\n\n        if (relMap &amp;&amp; hasProp(handlers, deps)) {\n            return handlers[deps](registry[relMap.id]);\n        }\n\n\n        if (req.get) {\n            return req.get(context, deps, relMap, localRequire);\n        }\n\n        //Normalize module name, if it contains . or ..\n        map = makeModuleMap(deps, relMap, false, true);\n        id = map.id;\n\n        if (!hasProp(defined, id)) {\n            return onError(makeError('notloaded', 'Module name \"' +\n                        id +\n                        '\" has not been loaded yet for context: ' +\n                        contextName +\n                        (relMap ? '' : '. Use require([])')));\n        }\n        return defined[id];\n    }\n\n    intakeDefines();\n\n    context.nextTick(function () {\n\n        intakeDefines();\n\n        requireMod = getModule(makeModuleMap(null, relMap));\n\n        requireMod.skipMap = options.skipMap;\n        requireMod.init(deps, callback, errback, {\n            enabled: true\n        });\n\n        checkLoaded();\n    });\n\n    return localRequire;\n}\n```\n原来程序走到了这里，于是我们继续debug。由于我们传入的defs不为空，所以这次和第一次执行req方法大不一样了，一路走下来，我们发现context.nextTick这个方法，很奇怪的是，找到nextTick定义的地方\n```javascript\nreq.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {\n        setTimeout(fn, 4);\n    } : function (fn) { fn(); };\n```\n没错，这里用到了setTimeout来延迟执行一个方法，这是为什么呢？还是4ms，至今没有搞明白！nextTick方法：\n```javascript\ncontext.nextTick(function () {\n        //Some defines could have been added since the\n        //require call, collect them.\n        intakeDefines();\n\n        requireMod = getModule(makeModuleMap(null, relMap));\n\n        //Store if map config should be applied to this require\n        //call for dependencies.\n        requireMod.skipMap = options.skipMap;\n        requireMod.init(deps, callback, errback, {\n             enabled: true\n        });\n\n        checkLoaded();\n});\n```\n这里说一下getModule方法，这个方法返回context里面的Module对象，这个对象是唯一标识的，也就说每个模块对应一个module，module里面存储这当前模块所依赖的模块和当前模块运行的结果。\n```javascript\nModule = function (map) {\n    this.events = getOwn(undefEvents, map.id) || {};\n    this.map = map;\n    this.shim = getOwn(config.shim, map.id);\n    this.depExports = [];\n    this.depMaps = [];\n    this.depMatched = [];\n    this.pluginMaps = {};\n    this.depCount = 0;\n\n    /* this.exports this.factory\n       this.depMaps = [],\n       this.enabled, this.fetched\n    */\n};\n```\n这个方法里的intakeDefines方法，可以理解为对上面context里面defQueue的初始化，通过getModule方法，最终会执行Module的init方法，这个defQueue数组里面存的是全局当前的依赖。由于此时defQueue还为空，所以不会初始化。\n然后程序接着往下运行，由于我们的deps里面有main，所以我们得到了一个新的Module，是关于main的requireMod，然后执行init方法。</li>\n\t<li><em><strong>开始引入main.js。</strong></em>进入init（）方法：\n```javascript\ninit: function (depMaps, factory, errback, options) {\n\t    options = options || {};\n\n\t    if (this.inited) {\n\t        return;\n\t    }\n\n\t    this.factory = factory;\n\n\t    if (errback) {\n\t this.on('error', errback);\n\t    } else if (this.events.error) {\n\n\t        errback = bind(this, function (err) {\n\t            this.emit('error', err);\n\t        });\n\t    }\n\n\t    this.depMaps = depMaps &amp;&amp; depMaps.slice(0);\n\n\t    this.errback = errback;\n\n\n\t    this.inited = true;\n\n\t    this.ignore = options.ignore;\n\n\n\t    if (options.enabled || this.enabled) {\n\t        //Enable this module and dependencies.\n\t        //Will call this.check()\n\n\t        this.enable();\n\t    } else {\n\t        this.check();\n\t    }\n\t},\n```\n这段代码这么长，一开始我也看不懂的，但是我们可以抽取要点，看最后的this.enable()由于执行了这个方法，再往下debug，中间经过了check（）方法，fetch（）方法，load（）方法，然后进入到了req.load（），在这里感叹一下requireJS确实比较复杂，中间的每个方法都对一些全局变量有修改或者设置，在这里不细致描述，继续我们主要的流程。在req.load（）\n```javascript\nreq.load = function (context, moduleName, url) {\n    var config = (context &amp;&amp; context.config) || {},\n        node;\n    if (isBrowser) {\n\n        node = req.createNode(config, moduleName, url);\n\n        node.setAttribute('data-requirecontext', context.contextName);\n        node.setAttribute('data-requiremodule', moduleName);\n\n\n        if (node.attachEvent &amp;&amp;\n\n                !(node.attachEvent.toString &amp;&amp; node.attachEvent.toString().indexOf('[native code') &lt; 0) &amp;&amp;\n                !isOpera) {\n\n            useInteractive = true;\n\n            node.attachEvent('onreadystatechange', context.onScriptLoad);\n\n        } else {\n            node.addEventListener('load', context.onScriptLoad, false);\n            node.addEventListener('error', context.onScriptError, false);\n        }\n        node.src = url;\n\n        currentlyAddingScript = node;\n        if (baseElement) {\n            head.insertBefore(node, baseElement);\n        } else {\n            head.appendChild(node);\n        }\n        currentlyAddingScript = null;\n\n        return node;\n    } else if (isWebWorker) {\n        try {\n\n            importScripts(url);\n\n            context.completeLoad(moduleName);\n        } catch (e) {\n            context.onError(makeError('importscripts',\n                            'importScripts failed for ' +\n                                moduleName + ' at ' + url,\n                            e,\n                            [moduleName]));\n        }\n    }\n};\n```\n终于，我们看到了证据，requireJS开始往dom里面插script了！打印出参数context, moduleName, url即\n```javascript\ncontext：\n\nModule: function (map) {\ncompleteLoad: function (moduleName) {\nconfig: Object\nconfigure: function (cfg) {\ncontextName: \"_\"\ndefQueue: Array[0]\ndefined: Object\nenable: function (depMap) {\nexecCb: function (name, callback, args, exports) {\nload: function (id, url) {\nmakeModuleMap: function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {\nmakeRequire: function (relMap, options) {\nmakeShimExports: function (value) {\nnameToUrl: function (moduleName, ext, skipExt) {\nnextTick: function (fn) {\nonError: function onError(err, errback) {\nonScriptError: function (evt) {\nonScriptLoad: function (evt) {\nregistry: Object\nrequire: function localRequire(deps, callback, errback) {\nstartTime: 1407753904901\nurlFetched: Object\n\n\nmoduleName：\nmain\n\nurl：\n./main.js\n```\n然后，我们的main.js就引入进来了！\n```html\n<script type=\"text/javascript\" charset=\"utf-8\" async=\"\" data-requirecontext=\"_\" data-requiremodule=\"main\" src=\"./main.js\"></script>\n```\n当然，localRequire方法最后还有一个checkLoaded();方法，顾名思义就是用来检测是否引入成功，里面还有一个exprier时间，超出则报错。</li>\n\t<li>OK，这篇文章先写到这里。</li>\n</ol>","slug":"requireJS实现原理研究1","published":1,"updated":"2017-04-30T10:46:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434q0o00242wvjnexjspv9","content":"<p>众所周知，Javascript有一个很棒的模块化库requireJS，这个基于AMD规范的js库受到越来越多的程序员喜爱，那么，下面就来谈谈我对requireJS的研究和理解。</p>\n<a id=\"more\"></a>\n<p></p><h3><span id=\"1-简单流程概括\">1. 简单流程概括：</span></h3><p></p>\n<ol><br>    <li>我们在使用requireJS时，都会把所有的js交给requireJS来管理，也就是我们的页面上只引入一个require.js，把data-main指向我们的main.js。</li><br>    <li>通过我们在main.js里面定义的require方法或者define方法，requireJS会把这些依赖和回调方法都用一个数据结构保存起来。</li><br>    <li>当页面加载时，requireJS会根据这些依赖预先把需要的js通过document.createElement的方法引入到dom中，这样，被引入dom中的script便会运行。</li><br>    <li>由于我们依赖的js也是要按照requireJS的规范来写的，所以他们也会有define或者require方法，同样类似第二步这样循环向上查找依赖，同样会把他们村起来。</li><br>    <li>当我们的js里需要用到依赖所返回的结果时(通常是一个key value类型的object),requireJS便会把之前那个保存回调方法的数据结构里面的方法拿出来并且运行，然后把结果给需要依赖的方法。</li><br>    <li>以上就是一个简单的流程。</li><br></ol><br>&nbsp;<br><h3><span id=\"2-测试代码\">2. 测试代码</span></h3><br>下面我把一个requireJS小Demo写出来，是下面研究源码的基础：<br><br>main.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>.config(&#123;</span><br><span class=\"line\">　　　　paths: &#123;</span><br><span class=\"line\">　　　　　　<span class=\"string\">\"a\"</span>: <span class=\"string\">\"a\"</span>,</span><br><span class=\"line\">　　　　　　<span class=\"string\">\"b\"</span>: <span class=\"string\">\"b\"</span></span><br><span class=\"line\">　　　　&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'a'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'main'</span>);</span><br><span class=\"line\">        <span class=\"comment\">//console.log(a);</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure><br><br>a.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">'b'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'a'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"string\">'text'</span> : <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><br><br>b.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'b'</span>);</span><br><span class=\"line\">    <span class=\"comment\">//return 1;</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><br><br>这些代码都很简单，下面开始正式的研究。<br><br>&nbsp;<br><h3><span id=\"3-开始研究\">3. 开始研究</span></h3><br><ol><br>    <li> <em><strong>关于requireJS预加载</strong></em>。也就是说，我每个模块所依赖的其他模块都会比本模块预先加载，这点可以直接运行测试代码来证明。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b b.js:<span class=\"number\">2</span></span><br><span class=\"line\">a a.js:<span class=\"number\">2</span></span><br><span class=\"line\">main main.js：<span class=\"number\">8</span></span><br></pre></td></tr></table></figure><br><br>这是控制台打印出的信息，可以看到，加载的顺序确实如上面所说。</li><br>    <li><em><strong>requireJS的上下文对象context。</strong></em>翻开requireJS的代码，看到通篇的function定义和其他变量的声明，这些暂时都还不重要，我们只用关心两行代码。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Create default context.</span></span><br><span class=\"line\">    req(&#123;&#125;);</span><br></pre></td></tr></table></figure><br><br>根据注释可以知道，这段代码初始化了一个上下文对象context，调用的是req方法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">req = requirejs = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">deps, callback, errback, optional</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//Find the right context, use default</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> context, config,</span><br><span class=\"line\">            contextName = defContextName;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Determine if have config object in the call.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isArray(deps) &amp;amp;&amp;amp; <span class=\"keyword\">typeof</span> deps !== <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// deps is a config object</span></span><br><span class=\"line\">            config = deps;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isArray(callback)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Adjust args if there are dependencies</span></span><br><span class=\"line\">                deps = callback;</span><br><span class=\"line\">                callback = errback;</span><br><span class=\"line\">                errback = optional;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                deps = [];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (config &amp;amp;&amp;amp; config.context) &#123;</span><br><span class=\"line\">            contextName = config.context;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        context = getOwn(contexts, contextName);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!context) &#123;</span><br><span class=\"line\">            context = contexts[contextName] = req.s.newContext(contextName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (config) &#123;</span><br><span class=\"line\">            context.configure(config);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> fg = context.require(deps, callback, errback);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fg;</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure><br><br>这也方法也就是常用的require方法，可以看到这个context只会初始化一次，打印出来就是<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Module: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">map</span>) </span>&#123;</span><br><span class=\"line\">completeLoad: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">moduleName</span>) </span>&#123;</span><br><span class=\"line\">config: <span class=\"built_in\">Object</span></span><br><span class=\"line\">configure: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">cfg</span>) </span>&#123;</span><br><span class=\"line\">contextName: <span class=\"string\">\"_\"</span></span><br><span class=\"line\">defQueue: <span class=\"built_in\">Array</span>[<span class=\"number\">0</span>]</span><br><span class=\"line\">defined: <span class=\"built_in\">Object</span></span><br><span class=\"line\">enable: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">depMap</span>) </span>&#123;</span><br><span class=\"line\">execCb: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, callback, args, exports</span>) </span>&#123;</span><br><span class=\"line\">load: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id, url</span>) </span>&#123;</span><br><span class=\"line\">makeModuleMap: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeModuleMap</span>(<span class=\"params\">name, parentModuleMap, isNormalized, applyMap</span>) </span>&#123;</span><br><span class=\"line\">makeRequire: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">relMap, options</span>) </span>&#123;</span><br><span class=\"line\">makeShimExports: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">nameToUrl: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">moduleName, ext, skipExt</span>) </span>&#123;</span><br><span class=\"line\">nextTick: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">onError: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onError</span>(<span class=\"params\">err, errback</span>) </span>&#123;</span><br><span class=\"line\">onScriptError: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">evt</span>) </span>&#123;</span><br><span class=\"line\">onScriptLoad: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">evt</span>) </span>&#123;</span><br><span class=\"line\">registry: <span class=\"built_in\">Object</span></span><br><span class=\"line\"><span class=\"built_in\">require</span>: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">localRequire</span>(<span class=\"params\">deps, callback, errback</span>) </span>&#123;</span><br><span class=\"line\">urlFetched: <span class=\"built_in\">Object</span></span><br><span class=\"line\">__proto__: <span class=\"built_in\">Object</span></span><br></pre></td></tr></table></figure><br><br>当然，这里面有很多东西，但是根据命名，不难理解，这里很多东西都是以后要用到的，例如defQueue，makeRequire等等，不用着急，这些都会在后面说道的。这个方法return了一个fg我是自己调试用的，这个fg是一个function（闭包），程序运行到这里由于我们传入的defs是空，这个function里的大多数逻辑都没有走，所以这个方法就结束了，程序会继续往下运行。</li><br>    <li><em><strong>requireJS的引入script。</strong></em>上一步我们得到的第一次初始化的context对象，看上去里面什么还没有，我们继续debug下，程序走到了这里：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (isBrowser) &#123;</span><br><span class=\"line\">    head = s.head = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'head'</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"comment\">//If BASE tag is in play, using appendChild is a problem for IE6.</span></span><br><span class=\"line\">    <span class=\"comment\">//When that browser dies, this can be removed. Details in this jQuery bug:</span></span><br><span class=\"line\">    <span class=\"comment\">//http://dev.jquery.com/ticket/2709</span></span><br><span class=\"line\">    baseElement = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'base'</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (baseElement) &#123;</span><br><span class=\"line\">        head = s.head = baseElement.parentNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br>这段代码不难理解，跟我上面说道的流程一样，开始寻找html里的head标签了，当然是为了引入script了！然后程序走到了这里：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (isBrowser &amp;amp;&amp;amp; !cfg.skipDataMain) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\teachReverse(scripts(), <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">script</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (!head) &#123;</span><br><span class=\"line\">\t        head = script.parentNode;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t    dataMain = script.getAttribute(<span class=\"string\">'data-main'</span>);</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (dataMain) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t        mainScript = dataMain;</span><br><span class=\"line\"></span><br><span class=\"line\">\t        <span class=\"keyword\">if</span> (!cfg.baseUrl) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t            src = mainScript.split(<span class=\"string\">'/'</span>);</span><br><span class=\"line\">\t            mainScript = src.pop();</span><br><span class=\"line\">\t            subPath = src.length ? src.join(<span class=\"string\">'/'</span>)  + <span class=\"string\">'/'</span> : <span class=\"string\">'./'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t            cfg.baseUrl = subPath;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t        mainScript = mainScript.replace(jsSuffixRegExp, <span class=\"string\">''</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t        <span class=\"keyword\">if</span> (req.jsExtRegExp.test(mainScript)) &#123;</span><br><span class=\"line\">\t            mainScript = dataMain;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t        cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];</span><br><span class=\"line\"></span><br><span class=\"line\">\t        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br>这段代码的主要功能就是找到我们之前绑定的data-main的，然后往全局的cfg对象里添加base路径和main，当然如果我们自己通过require的config设置打印出cfg：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span> &#123;<span class=\"attr\">baseUrl</span>: <span class=\"string\">\"./\"</span>, <span class=\"attr\">deps</span>: <span class=\"built_in\">Array</span>[<span class=\"number\">1</span>]&#125;</span><br><span class=\"line\">baseUrl: <span class=\"string\">\"./\"</span></span><br><span class=\"line\">deps: <span class=\"built_in\">Array</span>[<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"number\">0</span>: <span class=\"string\">\"main\"</span></span><br><span class=\"line\">length: <span class=\"number\">1</span></span><br><span class=\"line\">__proto__: <span class=\"built_in\">Array</span>[<span class=\"number\">0</span>]</span><br><span class=\"line\">__proto__: <span class=\"built_in\">Object</span></span><br></pre></td></tr></table></figure><br><br>这个cfg马上就会用到了。</li><br>    <li><em><strong>第二次执行req方法。</strong></em>这时候程序来到了整个文件的倒数第二行<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Set up with config info.</span></span><br><span class=\"line\">    req(cfg);</span><br></pre></td></tr></table></figure><br><br>这个时候调用req方法，把刚才的cfg传了进去，然后便又回到了require方法里面，到此为止，html页面上还只有一个script标签和一个require.js，我们的main a b .js都还没有运行，里面的代码都还没有起作用。<br>再次进入req方法，这时deps不再是｛｝，而是上面cfg，里面有一个main，这是在回头看看刚才return的fg，打印出来：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">localRequire</span>(<span class=\"params\">deps, callback, errback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> id, map, requireMod;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options.enableBuildCallback &amp;amp;&amp;amp; callback &amp;amp;&amp;amp; isFunction(callback)) &#123;</span><br><span class=\"line\">        callback.__requireJsBuild = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> deps === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isFunction(callback)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//Invalid call</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> onError(makeError(<span class=\"string\">'requireargs'</span>, <span class=\"string\">'Invalid require call'</span>), errback);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (relMap &amp;amp;&amp;amp; hasProp(handlers, deps)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> handlers[deps](registry[relMap.id]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (req.get) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> req.get(context, deps, relMap, localRequire);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//Normalize module name, if it contains . or ..</span></span><br><span class=\"line\">        map = makeModuleMap(deps, relMap, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        id = map.id;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!hasProp(defined, id)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> onError(makeError(<span class=\"string\">'notloaded'</span>, <span class=\"string\">'Module name \"'</span> +</span><br><span class=\"line\">                        id +</span><br><span class=\"line\">                        <span class=\"string\">'\" has not been loaded yet for context: '</span> +</span><br><span class=\"line\">                        contextName +</span><br><span class=\"line\">                        (relMap ? <span class=\"string\">''</span> : <span class=\"string\">'. Use require([])'</span>)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> defined[id];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    intakeDefines();</span><br><span class=\"line\"></span><br><span class=\"line\">    context.nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        intakeDefines();</span><br><span class=\"line\"></span><br><span class=\"line\">        requireMod = getModule(makeModuleMap(<span class=\"literal\">null</span>, relMap));</span><br><span class=\"line\"></span><br><span class=\"line\">        requireMod.skipMap = options.skipMap;</span><br><span class=\"line\">        requireMod.init(deps, callback, errback, &#123;</span><br><span class=\"line\">            enabled: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        checkLoaded();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> localRequire;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br>原来程序走到了这里，于是我们继续debug。由于我们传入的defs不为空，所以这次和第一次执行req方法大不一样了，一路走下来，我们发现context.nextTick这个方法，很奇怪的是，找到nextTick定义的地方<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">req.nextTick = <span class=\"keyword\">typeof</span> setTimeout !== <span class=\"string\">'undefined'</span> ? <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(fn, <span class=\"number\">4</span>);</span><br><span class=\"line\">    &#125; : <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>&#123; fn(); &#125;;</span><br></pre></td></tr></table></figure><br><br>没错，这里用到了setTimeout来延迟执行一个方法，这是为什么呢？还是4ms，至今没有搞明白！nextTick方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">context.nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//Some defines could have been added since the</span></span><br><span class=\"line\">        <span class=\"comment\">//require call, collect them.</span></span><br><span class=\"line\">        intakeDefines();</span><br><span class=\"line\"></span><br><span class=\"line\">        requireMod = getModule(makeModuleMap(<span class=\"literal\">null</span>, relMap));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//Store if map config should be applied to this require</span></span><br><span class=\"line\">        <span class=\"comment\">//call for dependencies.</span></span><br><span class=\"line\">        requireMod.skipMap = options.skipMap;</span><br><span class=\"line\">        requireMod.init(deps, callback, errback, &#123;</span><br><span class=\"line\">             enabled: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        checkLoaded();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure><br><br>这里说一下getModule方法，这个方法返回context里面的Module对象，这个对象是唯一标识的，也就说每个模块对应一个module，module里面存储这当前模块所依赖的模块和当前模块运行的结果。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Module = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">map</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.events = getOwn(undefEvents, map.id) || &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.map = map;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.shim = getOwn(config.shim, map.id);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.depExports = [];</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.depMaps = [];</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.depMatched = [];</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.pluginMaps = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.depCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* this.exports this.factory</span></span><br><span class=\"line\"><span class=\"comment\">       this.depMaps = [],</span></span><br><span class=\"line\"><span class=\"comment\">       this.enabled, this.fetched</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br><br>这个方法里的intakeDefines方法，可以理解为对上面context里面defQueue的初始化，通过getModule方法，最终会执行Module的init方法，这个defQueue数组里面存的是全局当前的依赖。由于此时defQueue还为空，所以不会初始化。<br>然后程序接着往下运行，由于我们的deps里面有main，所以我们得到了一个新的Module，是关于main的requireMod，然后执行init方法。</li><br>    <li><em><strong>开始引入main.js。</strong></em>进入init（）方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">depMaps, factory, errback, options</span>) </span>&#123;</span><br><span class=\"line\">\t    options = options || &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.inited) &#123;</span><br><span class=\"line\">\t        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t    <span class=\"keyword\">this</span>.factory = factory;</span><br><span class=\"line\"></span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (errback) &#123;</span><br><span class=\"line\">\t <span class=\"keyword\">this</span>.on(<span class=\"string\">'error'</span>, errback);</span><br><span class=\"line\">\t    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.events.error) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t        errback = bind(<span class=\"keyword\">this</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">\t            <span class=\"keyword\">this</span>.emit(<span class=\"string\">'error'</span>, err);</span><br><span class=\"line\">\t        &#125;);</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t    <span class=\"keyword\">this</span>.depMaps = depMaps &amp;amp;&amp;amp; depMaps.slice(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t    <span class=\"keyword\">this</span>.errback = errback;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t    <span class=\"keyword\">this</span>.inited = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t    <span class=\"keyword\">this</span>.ignore = options.ignore;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (options.enabled || <span class=\"keyword\">this</span>.enabled) &#123;</span><br><span class=\"line\">\t        <span class=\"comment\">//Enable this module and dependencies.</span></span><br><span class=\"line\">\t        <span class=\"comment\">//Will call this.check()</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t        <span class=\"keyword\">this</span>.enable();</span><br><span class=\"line\">\t    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t        <span class=\"keyword\">this</span>.check();</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;,</span><br></pre></td></tr></table></figure><br><br>这段代码这么长，一开始我也看不懂的，但是我们可以抽取要点，看最后的this.enable()由于执行了这个方法，再往下debug，中间经过了check（）方法，fetch（）方法，load（）方法，然后进入到了req.load（），在这里感叹一下requireJS确实比较复杂，中间的每个方法都对一些全局变量有修改或者设置，在这里不细致描述，继续我们主要的流程。在req.load（）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">req.load = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context, moduleName, url</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> config = (context &amp;amp;&amp;amp; context.config) || &#123;&#125;,</span><br><span class=\"line\">        node;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isBrowser) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        node = req.createNode(config, moduleName, url);</span><br><span class=\"line\"></span><br><span class=\"line\">        node.setAttribute(<span class=\"string\">'data-requirecontext'</span>, context.contextName);</span><br><span class=\"line\">        node.setAttribute(<span class=\"string\">'data-requiremodule'</span>, moduleName);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.attachEvent &amp;amp;&amp;amp;</span><br><span class=\"line\"></span><br><span class=\"line\">                !(node.attachEvent.toString &amp;amp;&amp;amp; node.attachEvent.toString().indexOf(<span class=\"string\">'[native code'</span>) &amp;lt; <span class=\"number\">0</span>) &amp;amp;&amp;amp;</span><br><span class=\"line\">                !isOpera) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            useInteractive = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            node.attachEvent(<span class=\"string\">'onreadystatechange'</span>, context.onScriptLoad);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            node.addEventListener(<span class=\"string\">'load'</span>, context.onScriptLoad, <span class=\"literal\">false</span>);</span><br><span class=\"line\">            node.addEventListener(<span class=\"string\">'error'</span>, context.onScriptError, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        node.src = url;</span><br><span class=\"line\"></span><br><span class=\"line\">        currentlyAddingScript = node;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (baseElement) &#123;</span><br><span class=\"line\">            head.insertBefore(node, baseElement);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            head.appendChild(node);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        currentlyAddingScript = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isWebWorker) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            importScripts(url);</span><br><span class=\"line\"></span><br><span class=\"line\">            context.completeLoad(moduleName);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">            context.onError(makeError(<span class=\"string\">'importscripts'</span>,</span><br><span class=\"line\">                            <span class=\"string\">'importScripts failed for '</span> +</span><br><span class=\"line\">                                moduleName + <span class=\"string\">' at '</span> + url,</span><br><span class=\"line\">                            e,</span><br><span class=\"line\">                            [moduleName]));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br><br>终于，我们看到了证据，requireJS开始往dom里面插script了！打印出参数context, moduleName, url即<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">context：</span><br><span class=\"line\"></span><br><span class=\"line\">Module: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">map</span>) </span>&#123;</span><br><span class=\"line\">completeLoad: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">moduleName</span>) </span>&#123;</span><br><span class=\"line\">config: <span class=\"built_in\">Object</span></span><br><span class=\"line\">configure: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">cfg</span>) </span>&#123;</span><br><span class=\"line\">contextName: <span class=\"string\">\"_\"</span></span><br><span class=\"line\">defQueue: <span class=\"built_in\">Array</span>[<span class=\"number\">0</span>]</span><br><span class=\"line\">defined: <span class=\"built_in\">Object</span></span><br><span class=\"line\">enable: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">depMap</span>) </span>&#123;</span><br><span class=\"line\">execCb: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, callback, args, exports</span>) </span>&#123;</span><br><span class=\"line\">load: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id, url</span>) </span>&#123;</span><br><span class=\"line\">makeModuleMap: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeModuleMap</span>(<span class=\"params\">name, parentModuleMap, isNormalized, applyMap</span>) </span>&#123;</span><br><span class=\"line\">makeRequire: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">relMap, options</span>) </span>&#123;</span><br><span class=\"line\">makeShimExports: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">nameToUrl: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">moduleName, ext, skipExt</span>) </span>&#123;</span><br><span class=\"line\">nextTick: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">onError: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onError</span>(<span class=\"params\">err, errback</span>) </span>&#123;</span><br><span class=\"line\">onScriptError: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">evt</span>) </span>&#123;</span><br><span class=\"line\">onScriptLoad: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">evt</span>) </span>&#123;</span><br><span class=\"line\">registry: <span class=\"built_in\">Object</span></span><br><span class=\"line\"><span class=\"built_in\">require</span>: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">localRequire</span>(<span class=\"params\">deps, callback, errback</span>) </span>&#123;</span><br><span class=\"line\">startTime: <span class=\"number\">1407753904901</span></span><br><span class=\"line\">urlFetched: <span class=\"built_in\">Object</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">moduleName：</span><br><span class=\"line\">main</span><br><span class=\"line\"></span><br><span class=\"line\">url：</span><br><span class=\"line\">./main.js</span><br></pre></td></tr></table></figure><br><br>然后，我们的main.js就引入进来了！<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span> <span class=\"attr\">async</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">data-requirecontext</span>=<span class=\"string\">\"_\"</span> <span class=\"attr\">data-requiremodule</span>=<span class=\"string\">\"main\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./main.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure><br><br>当然，localRequire方法最后还有一个checkLoaded();方法，顾名思义就是用来检测是否引入成功，里面还有一个exprier时间，超出则报错。</li><br>    <li>OK，这篇文章先写到这里。</li><br></ol>","site":{"data":{}},"excerpt":"<p>众所周知，Javascript有一个很棒的模块化库requireJS，这个基于AMD规范的js库受到越来越多的程序员喜爱，那么，下面就来谈谈我对requireJS的研究和理解。</p>","more":"<p></p><h3>1. 简单流程概括：</h3><p></p>\n<ol><br>    <li>我们在使用requireJS时，都会把所有的js交给requireJS来管理，也就是我们的页面上只引入一个require.js，把data-main指向我们的main.js。</li><br>    <li>通过我们在main.js里面定义的require方法或者define方法，requireJS会把这些依赖和回调方法都用一个数据结构保存起来。</li><br>    <li>当页面加载时，requireJS会根据这些依赖预先把需要的js通过document.createElement的方法引入到dom中，这样，被引入dom中的script便会运行。</li><br>    <li>由于我们依赖的js也是要按照requireJS的规范来写的，所以他们也会有define或者require方法，同样类似第二步这样循环向上查找依赖，同样会把他们村起来。</li><br>    <li>当我们的js里需要用到依赖所返回的结果时(通常是一个key value类型的object),requireJS便会把之前那个保存回调方法的数据结构里面的方法拿出来并且运行，然后把结果给需要依赖的方法。</li><br>    <li>以上就是一个简单的流程。</li><br></ol><br>&nbsp;<br><h3>2. 测试代码</h3><br>下面我把一个requireJS小Demo写出来，是下面研究源码的基础：<br><br>main.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>.config(&#123;</span><br><span class=\"line\">　　　　paths: &#123;</span><br><span class=\"line\">　　　　　　<span class=\"string\">\"a\"</span>: <span class=\"string\">\"a\"</span>,</span><br><span class=\"line\">　　　　　　<span class=\"string\">\"b\"</span>: <span class=\"string\">\"b\"</span></span><br><span class=\"line\">　　　　&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'a'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'main'</span>);</span><br><span class=\"line\">        <span class=\"comment\">//console.log(a);</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure><br><br>a.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">'b'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'a'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"string\">'text'</span> : <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><br><br>b.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'b'</span>);</span><br><span class=\"line\">    <span class=\"comment\">//return 1;</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><br><br>这些代码都很简单，下面开始正式的研究。<br><br>&nbsp;<br><h3>3. 开始研究</h3><br><ol><br>    <li> <em><strong>关于requireJS预加载</strong></em>。也就是说，我每个模块所依赖的其他模块都会比本模块预先加载，这点可以直接运行测试代码来证明。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b b.js:<span class=\"number\">2</span></span><br><span class=\"line\">a a.js:<span class=\"number\">2</span></span><br><span class=\"line\">main main.js：<span class=\"number\">8</span></span><br></pre></td></tr></table></figure><br><br>这是控制台打印出的信息，可以看到，加载的顺序确实如上面所说。</li><br>    <li><em><strong>requireJS的上下文对象context。</strong></em>翻开requireJS的代码，看到通篇的function定义和其他变量的声明，这些暂时都还不重要，我们只用关心两行代码。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Create default context.</span></span><br><span class=\"line\">    req(&#123;&#125;);</span><br></pre></td></tr></table></figure><br><br>根据注释可以知道，这段代码初始化了一个上下文对象context，调用的是req方法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">req = requirejs = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">deps, callback, errback, optional</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//Find the right context, use default</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> context, config,</span><br><span class=\"line\">            contextName = defContextName;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Determine if have config object in the call.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isArray(deps) &amp;amp;&amp;amp; <span class=\"keyword\">typeof</span> deps !== <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// deps is a config object</span></span><br><span class=\"line\">            config = deps;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isArray(callback)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Adjust args if there are dependencies</span></span><br><span class=\"line\">                deps = callback;</span><br><span class=\"line\">                callback = errback;</span><br><span class=\"line\">                errback = optional;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                deps = [];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (config &amp;amp;&amp;amp; config.context) &#123;</span><br><span class=\"line\">            contextName = config.context;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        context = getOwn(contexts, contextName);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!context) &#123;</span><br><span class=\"line\">            context = contexts[contextName] = req.s.newContext(contextName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (config) &#123;</span><br><span class=\"line\">            context.configure(config);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> fg = context.require(deps, callback, errback);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fg;</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure><br><br>这也方法也就是常用的require方法，可以看到这个context只会初始化一次，打印出来就是<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Module: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">map</span>) </span>&#123;</span><br><span class=\"line\">completeLoad: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">moduleName</span>) </span>&#123;</span><br><span class=\"line\">config: <span class=\"built_in\">Object</span></span><br><span class=\"line\">configure: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">cfg</span>) </span>&#123;</span><br><span class=\"line\">contextName: <span class=\"string\">\"_\"</span></span><br><span class=\"line\">defQueue: <span class=\"built_in\">Array</span>[<span class=\"number\">0</span>]</span><br><span class=\"line\">defined: <span class=\"built_in\">Object</span></span><br><span class=\"line\">enable: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">depMap</span>) </span>&#123;</span><br><span class=\"line\">execCb: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, callback, args, exports</span>) </span>&#123;</span><br><span class=\"line\">load: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id, url</span>) </span>&#123;</span><br><span class=\"line\">makeModuleMap: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeModuleMap</span>(<span class=\"params\">name, parentModuleMap, isNormalized, applyMap</span>) </span>&#123;</span><br><span class=\"line\">makeRequire: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">relMap, options</span>) </span>&#123;</span><br><span class=\"line\">makeShimExports: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">nameToUrl: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">moduleName, ext, skipExt</span>) </span>&#123;</span><br><span class=\"line\">nextTick: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">onError: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onError</span>(<span class=\"params\">err, errback</span>) </span>&#123;</span><br><span class=\"line\">onScriptError: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">evt</span>) </span>&#123;</span><br><span class=\"line\">onScriptLoad: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">evt</span>) </span>&#123;</span><br><span class=\"line\">registry: <span class=\"built_in\">Object</span></span><br><span class=\"line\"><span class=\"built_in\">require</span>: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">localRequire</span>(<span class=\"params\">deps, callback, errback</span>) </span>&#123;</span><br><span class=\"line\">urlFetched: <span class=\"built_in\">Object</span></span><br><span class=\"line\">__proto__: <span class=\"built_in\">Object</span></span><br></pre></td></tr></table></figure><br><br>当然，这里面有很多东西，但是根据命名，不难理解，这里很多东西都是以后要用到的，例如defQueue，makeRequire等等，不用着急，这些都会在后面说道的。这个方法return了一个fg我是自己调试用的，这个fg是一个function（闭包），程序运行到这里由于我们传入的defs是空，这个function里的大多数逻辑都没有走，所以这个方法就结束了，程序会继续往下运行。</li><br>    <li><em><strong>requireJS的引入script。</strong></em>上一步我们得到的第一次初始化的context对象，看上去里面什么还没有，我们继续debug下，程序走到了这里：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (isBrowser) &#123;</span><br><span class=\"line\">    head = s.head = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'head'</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"comment\">//If BASE tag is in play, using appendChild is a problem for IE6.</span></span><br><span class=\"line\">    <span class=\"comment\">//When that browser dies, this can be removed. Details in this jQuery bug:</span></span><br><span class=\"line\">    <span class=\"comment\">//http://dev.jquery.com/ticket/2709</span></span><br><span class=\"line\">    baseElement = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'base'</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (baseElement) &#123;</span><br><span class=\"line\">        head = s.head = baseElement.parentNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br>这段代码不难理解，跟我上面说道的流程一样，开始寻找html里的head标签了，当然是为了引入script了！然后程序走到了这里：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (isBrowser &amp;amp;&amp;amp; !cfg.skipDataMain) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\teachReverse(scripts(), <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">script</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (!head) &#123;</span><br><span class=\"line\">\t        head = script.parentNode;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t    dataMain = script.getAttribute(<span class=\"string\">'data-main'</span>);</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (dataMain) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t        mainScript = dataMain;</span><br><span class=\"line\"></span><br><span class=\"line\">\t        <span class=\"keyword\">if</span> (!cfg.baseUrl) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t            src = mainScript.split(<span class=\"string\">'/'</span>);</span><br><span class=\"line\">\t            mainScript = src.pop();</span><br><span class=\"line\">\t            subPath = src.length ? src.join(<span class=\"string\">'/'</span>)  + <span class=\"string\">'/'</span> : <span class=\"string\">'./'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t            cfg.baseUrl = subPath;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t        mainScript = mainScript.replace(jsSuffixRegExp, <span class=\"string\">''</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t        <span class=\"keyword\">if</span> (req.jsExtRegExp.test(mainScript)) &#123;</span><br><span class=\"line\">\t            mainScript = dataMain;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t        cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];</span><br><span class=\"line\"></span><br><span class=\"line\">\t        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br>这段代码的主要功能就是找到我们之前绑定的data-main的，然后往全局的cfg对象里添加base路径和main，当然如果我们自己通过require的config设置打印出cfg：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span> &#123;<span class=\"attr\">baseUrl</span>: <span class=\"string\">\"./\"</span>, <span class=\"attr\">deps</span>: <span class=\"built_in\">Array</span>[<span class=\"number\">1</span>]&#125;</span><br><span class=\"line\">baseUrl: <span class=\"string\">\"./\"</span></span><br><span class=\"line\">deps: <span class=\"built_in\">Array</span>[<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"number\">0</span>: <span class=\"string\">\"main\"</span></span><br><span class=\"line\">length: <span class=\"number\">1</span></span><br><span class=\"line\">__proto__: <span class=\"built_in\">Array</span>[<span class=\"number\">0</span>]</span><br><span class=\"line\">__proto__: <span class=\"built_in\">Object</span></span><br></pre></td></tr></table></figure><br><br>这个cfg马上就会用到了。</li><br>    <li><em><strong>第二次执行req方法。</strong></em>这时候程序来到了整个文件的倒数第二行<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Set up with config info.</span></span><br><span class=\"line\">    req(cfg);</span><br></pre></td></tr></table></figure><br><br>这个时候调用req方法，把刚才的cfg传了进去，然后便又回到了require方法里面，到此为止，html页面上还只有一个script标签和一个require.js，我们的main a b .js都还没有运行，里面的代码都还没有起作用。<br>再次进入req方法，这时deps不再是｛｝，而是上面cfg，里面有一个main，这是在回头看看刚才return的fg，打印出来：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">localRequire</span>(<span class=\"params\">deps, callback, errback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> id, map, requireMod;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options.enableBuildCallback &amp;amp;&amp;amp; callback &amp;amp;&amp;amp; isFunction(callback)) &#123;</span><br><span class=\"line\">        callback.__requireJsBuild = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> deps === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isFunction(callback)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//Invalid call</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> onError(makeError(<span class=\"string\">'requireargs'</span>, <span class=\"string\">'Invalid require call'</span>), errback);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (relMap &amp;amp;&amp;amp; hasProp(handlers, deps)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> handlers[deps](registry[relMap.id]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (req.get) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> req.get(context, deps, relMap, localRequire);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//Normalize module name, if it contains . or ..</span></span><br><span class=\"line\">        map = makeModuleMap(deps, relMap, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        id = map.id;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!hasProp(defined, id)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> onError(makeError(<span class=\"string\">'notloaded'</span>, <span class=\"string\">'Module name \"'</span> +</span><br><span class=\"line\">                        id +</span><br><span class=\"line\">                        <span class=\"string\">'\" has not been loaded yet for context: '</span> +</span><br><span class=\"line\">                        contextName +</span><br><span class=\"line\">                        (relMap ? <span class=\"string\">''</span> : <span class=\"string\">'. Use require([])'</span>)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> defined[id];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    intakeDefines();</span><br><span class=\"line\"></span><br><span class=\"line\">    context.nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        intakeDefines();</span><br><span class=\"line\"></span><br><span class=\"line\">        requireMod = getModule(makeModuleMap(<span class=\"literal\">null</span>, relMap));</span><br><span class=\"line\"></span><br><span class=\"line\">        requireMod.skipMap = options.skipMap;</span><br><span class=\"line\">        requireMod.init(deps, callback, errback, &#123;</span><br><span class=\"line\">            enabled: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        checkLoaded();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> localRequire;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br>原来程序走到了这里，于是我们继续debug。由于我们传入的defs不为空，所以这次和第一次执行req方法大不一样了，一路走下来，我们发现context.nextTick这个方法，很奇怪的是，找到nextTick定义的地方<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">req.nextTick = <span class=\"keyword\">typeof</span> setTimeout !== <span class=\"string\">'undefined'</span> ? <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(fn, <span class=\"number\">4</span>);</span><br><span class=\"line\">    &#125; : <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>&#123; fn(); &#125;;</span><br></pre></td></tr></table></figure><br><br>没错，这里用到了setTimeout来延迟执行一个方法，这是为什么呢？还是4ms，至今没有搞明白！nextTick方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">context.nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//Some defines could have been added since the</span></span><br><span class=\"line\">        <span class=\"comment\">//require call, collect them.</span></span><br><span class=\"line\">        intakeDefines();</span><br><span class=\"line\"></span><br><span class=\"line\">        requireMod = getModule(makeModuleMap(<span class=\"literal\">null</span>, relMap));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//Store if map config should be applied to this require</span></span><br><span class=\"line\">        <span class=\"comment\">//call for dependencies.</span></span><br><span class=\"line\">        requireMod.skipMap = options.skipMap;</span><br><span class=\"line\">        requireMod.init(deps, callback, errback, &#123;</span><br><span class=\"line\">             enabled: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        checkLoaded();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure><br><br>这里说一下getModule方法，这个方法返回context里面的Module对象，这个对象是唯一标识的，也就说每个模块对应一个module，module里面存储这当前模块所依赖的模块和当前模块运行的结果。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Module = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">map</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.events = getOwn(undefEvents, map.id) || &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.map = map;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.shim = getOwn(config.shim, map.id);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.depExports = [];</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.depMaps = [];</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.depMatched = [];</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.pluginMaps = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.depCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* this.exports this.factory</span></span><br><span class=\"line\"><span class=\"comment\">       this.depMaps = [],</span></span><br><span class=\"line\"><span class=\"comment\">       this.enabled, this.fetched</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br><br>这个方法里的intakeDefines方法，可以理解为对上面context里面defQueue的初始化，通过getModule方法，最终会执行Module的init方法，这个defQueue数组里面存的是全局当前的依赖。由于此时defQueue还为空，所以不会初始化。<br>然后程序接着往下运行，由于我们的deps里面有main，所以我们得到了一个新的Module，是关于main的requireMod，然后执行init方法。</li><br>    <li><em><strong>开始引入main.js。</strong></em>进入init（）方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">depMaps, factory, errback, options</span>) </span>&#123;</span><br><span class=\"line\">\t    options = options || &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.inited) &#123;</span><br><span class=\"line\">\t        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t    <span class=\"keyword\">this</span>.factory = factory;</span><br><span class=\"line\"></span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (errback) &#123;</span><br><span class=\"line\">\t <span class=\"keyword\">this</span>.on(<span class=\"string\">'error'</span>, errback);</span><br><span class=\"line\">\t    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.events.error) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t        errback = bind(<span class=\"keyword\">this</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">\t            <span class=\"keyword\">this</span>.emit(<span class=\"string\">'error'</span>, err);</span><br><span class=\"line\">\t        &#125;);</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t    <span class=\"keyword\">this</span>.depMaps = depMaps &amp;amp;&amp;amp; depMaps.slice(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t    <span class=\"keyword\">this</span>.errback = errback;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t    <span class=\"keyword\">this</span>.inited = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t    <span class=\"keyword\">this</span>.ignore = options.ignore;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (options.enabled || <span class=\"keyword\">this</span>.enabled) &#123;</span><br><span class=\"line\">\t        <span class=\"comment\">//Enable this module and dependencies.</span></span><br><span class=\"line\">\t        <span class=\"comment\">//Will call this.check()</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t        <span class=\"keyword\">this</span>.enable();</span><br><span class=\"line\">\t    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t        <span class=\"keyword\">this</span>.check();</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;,</span><br></pre></td></tr></table></figure><br><br>这段代码这么长，一开始我也看不懂的，但是我们可以抽取要点，看最后的this.enable()由于执行了这个方法，再往下debug，中间经过了check（）方法，fetch（）方法，load（）方法，然后进入到了req.load（），在这里感叹一下requireJS确实比较复杂，中间的每个方法都对一些全局变量有修改或者设置，在这里不细致描述，继续我们主要的流程。在req.load（）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">req.load = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context, moduleName, url</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> config = (context &amp;amp;&amp;amp; context.config) || &#123;&#125;,</span><br><span class=\"line\">        node;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isBrowser) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        node = req.createNode(config, moduleName, url);</span><br><span class=\"line\"></span><br><span class=\"line\">        node.setAttribute(<span class=\"string\">'data-requirecontext'</span>, context.contextName);</span><br><span class=\"line\">        node.setAttribute(<span class=\"string\">'data-requiremodule'</span>, moduleName);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.attachEvent &amp;amp;&amp;amp;</span><br><span class=\"line\"></span><br><span class=\"line\">                !(node.attachEvent.toString &amp;amp;&amp;amp; node.attachEvent.toString().indexOf(<span class=\"string\">'[native code'</span>) &amp;lt; <span class=\"number\">0</span>) &amp;amp;&amp;amp;</span><br><span class=\"line\">                !isOpera) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            useInteractive = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            node.attachEvent(<span class=\"string\">'onreadystatechange'</span>, context.onScriptLoad);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            node.addEventListener(<span class=\"string\">'load'</span>, context.onScriptLoad, <span class=\"literal\">false</span>);</span><br><span class=\"line\">            node.addEventListener(<span class=\"string\">'error'</span>, context.onScriptError, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        node.src = url;</span><br><span class=\"line\"></span><br><span class=\"line\">        currentlyAddingScript = node;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (baseElement) &#123;</span><br><span class=\"line\">            head.insertBefore(node, baseElement);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            head.appendChild(node);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        currentlyAddingScript = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isWebWorker) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            importScripts(url);</span><br><span class=\"line\"></span><br><span class=\"line\">            context.completeLoad(moduleName);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">            context.onError(makeError(<span class=\"string\">'importscripts'</span>,</span><br><span class=\"line\">                            <span class=\"string\">'importScripts failed for '</span> +</span><br><span class=\"line\">                                moduleName + <span class=\"string\">' at '</span> + url,</span><br><span class=\"line\">                            e,</span><br><span class=\"line\">                            [moduleName]));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br><br>终于，我们看到了证据，requireJS开始往dom里面插script了！打印出参数context, moduleName, url即<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">context：</span><br><span class=\"line\"></span><br><span class=\"line\">Module: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">map</span>) </span>&#123;</span><br><span class=\"line\">completeLoad: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">moduleName</span>) </span>&#123;</span><br><span class=\"line\">config: <span class=\"built_in\">Object</span></span><br><span class=\"line\">configure: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">cfg</span>) </span>&#123;</span><br><span class=\"line\">contextName: <span class=\"string\">\"_\"</span></span><br><span class=\"line\">defQueue: <span class=\"built_in\">Array</span>[<span class=\"number\">0</span>]</span><br><span class=\"line\">defined: <span class=\"built_in\">Object</span></span><br><span class=\"line\">enable: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">depMap</span>) </span>&#123;</span><br><span class=\"line\">execCb: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, callback, args, exports</span>) </span>&#123;</span><br><span class=\"line\">load: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id, url</span>) </span>&#123;</span><br><span class=\"line\">makeModuleMap: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeModuleMap</span>(<span class=\"params\">name, parentModuleMap, isNormalized, applyMap</span>) </span>&#123;</span><br><span class=\"line\">makeRequire: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">relMap, options</span>) </span>&#123;</span><br><span class=\"line\">makeShimExports: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">nameToUrl: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">moduleName, ext, skipExt</span>) </span>&#123;</span><br><span class=\"line\">nextTick: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">onError: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onError</span>(<span class=\"params\">err, errback</span>) </span>&#123;</span><br><span class=\"line\">onScriptError: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">evt</span>) </span>&#123;</span><br><span class=\"line\">onScriptLoad: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">evt</span>) </span>&#123;</span><br><span class=\"line\">registry: <span class=\"built_in\">Object</span></span><br><span class=\"line\"><span class=\"built_in\">require</span>: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">localRequire</span>(<span class=\"params\">deps, callback, errback</span>) </span>&#123;</span><br><span class=\"line\">startTime: <span class=\"number\">1407753904901</span></span><br><span class=\"line\">urlFetched: <span class=\"built_in\">Object</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">moduleName：</span><br><span class=\"line\">main</span><br><span class=\"line\"></span><br><span class=\"line\">url：</span><br><span class=\"line\">./main.js</span><br></pre></td></tr></table></figure><br><br>然后，我们的main.js就引入进来了！<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span> <span class=\"attr\">async</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">data-requirecontext</span>=<span class=\"string\">\"_\"</span> <span class=\"attr\">data-requiremodule</span>=<span class=\"string\">\"main\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./main.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure><br><br>当然，localRequire方法最后还有一个checkLoaded();方法，顾名思义就是用来检测是否引入成功，里面还有一个exprier时间，超出则报错。</li><br>    <li>OK，这篇文章先写到这里。</li><br></ol>"},{"title":"requireJS实现原理研究2","date":"2014-08-12T10:31:29.000Z","_content":"<em><strong>上文说到了main.js被引入进来，然后我们接着往下看。</strong></em>\n<h3>接着写</h3>\nmain.js被引入进来后，当然需要运行了，看一下main.js\n<!--more-->\n```javascript\nrequire.config({\n　　　　paths: {\n　　　　　　\"a\": \"a\",\n　　　　　　\"b\": \"b\"\n　　　　}\n});\nrequire(['a'], function (a){\n        console.log('main');\n        //console.log(a);\n});\n```\n第一行是关于config的配置，于是去源码里寻找config方法，发现：\n```javascript\nreq.config = function (config) {\n    return req(config);\n};\n```\n原来还是调用的require方法，继续看debug的require方法，看这段代码：\n```javascript\n// Determine if have config object in the call.\nif (!isArray(deps) &amp;&amp; typeof deps !== 'string') {\n    // deps is a config object\n    config = deps;\n    if (isArray(callback)) {\n        // Adjust args if there are dependencies\n        deps = callback;\n        callback = errback;\n        errback = optional;\n    } else {\n        deps = [];\n    }\n}\n```\n由于我们传入的deps不是数组而是一个对象，所以进过这段代码后，config被全局变量config保存了起来，deps又被设置成空，这又回到了以前的那一布，由于我们传入的defs是空，这个function里的大多数逻辑都没有走，所以这个方法就结束了，程序会继续往下运行。\n\n这时程序又回到main.js里面了，执行完config方法后，又去执行require方法，这时由于传入的deps和callback都不为空，这样，真正的调用require方法了！我们接着debug。\n```javascript\n\tconsole.log(deps, callback)；\n\t[\"a\"] function (a){\n\t        console.log('main');\n\t        //console.log(a);\n\t}\n```\n经过require方法，最后就会到loadRequire方法，根据上面main.js引入的原理，由于我们的deps里面有a，所以也会依次经过nextTick方法，module的init方法，enable方法，fetch方法，最后经过load方法来吧a.js引入进来，由于我们是真正调用的require方法，callback已经被传入进去，所以，这个main.js调用的require方法就为自己生产了一个含有callback的module，这个callback被存储在factory（之前都不不含有callback的也可以说没有factory），通过代码：\n```javascript\nfunction getModule(depMap) {\n    var id = depMap.id,\n        mod = getOwn(registry, id);\n\n    if (!mod) {\n        mod = registry[id] = new context.Module(depMap);\n    }\n    return mod;\n}\n```\n打印出这么main.js的module：\n```javascript\nModule {events: Object, map: Object, shim: false, depExports: Array[0], depMaps: Array[0]…}\ndefineEmitComplete: true\ndefineEmitted: true\ndefined: true\ndefining: false\ndepCount: 0\ndepExports: Array[1]\n0: Object\ntext: 1\n__proto__: Object\nlength: 1\n__proto__: Array[0]\ndepMaps: Array[1]\ndepMatched: Array[1]\nenabled: true\nenabling: false\nerrback: undefined\nevents: Object\nexports: undefined\nfactory: function (a){\narguments: null\ncaller: null\nlength: 1\nname: \"\"\nprototype: Object\n__proto__: function Empty() {}\nfunction scope\nignore: undefined\ninited: true\nmap: Object\nid: \"_@r6\"\nisDefine: false\nname: \"_@r6\"\noriginalName: null\nparentMap: undefined\nprefix: undefined\nunnormalized: false\nurl: \"./_@r6.js\"\n__proto__: Object\npluginMaps: Object\nshim: false\nskipMap: undefined\n__proto__: Object\n```\n这个时候我们知道a,js已经被引入进来了，然后便会执行a.js里面的代码，和main.js不同的是a用的define方法来加载模块，那么这和用require方法有什么不同呢？看一下define方法：\n```javascript\ndefine = function (name, deps, callback) {\n    var node, context;\n\n    //Allow for anonymous modules\n    if (typeof name !== 'string') {\n        //Adjust args appropriately\n        callback = deps;\n        deps = name;\n        name = null;\n    }\n\n    //This module may not have dependencies\n    if (!isArray(deps)) {\n        callback = deps;\n        deps = null;\n    }\n\n    if (!deps &amp;&amp; isFunction(callback)) {\n        deps = [];\n       \n        if (callback.length) {\n            callback\n                .toString()\n                .replace(commentRegExp, '')\n                .replace(cjsRequireRegExp, function (match, dep) {\n                    deps.push(dep);\n                });\n\n            \n            deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);\n        }\n    }\n\n    \n    if (useInteractive) {\n        node = currentlyAddingScript || getInteractiveScript();\n        if (node) {\n            if (!name) {\n                name = node.getAttribute('data-requiremodule');\n            }\n            context = contexts[node.getAttribute('data-requirecontext')];\n        }\n    }\n\n   \n    (context ? context.defQueue : globalDefQueue).push([name, deps, callback]);\n};\n```\nOK，又是这么多代码，但是我看到了最后一步比较重要的(context ? context.defQueue : globalDefQueue).push([name, deps, callback]);这段代码往 context.defQueue塞了一个对象，还记得之前提到过的intakeDefines方法么，当程序运行到这之后，script的onload事件就会触发，然后就会走到intakeDefines方法里面，在intakeDefines方法里面便会执行callGetModule方法，得到a.js对应的module，然后，a对应的module也打印出来看：\n```javascript\nModule {events: Object, map: Object, shim: false, depExports: Array[0], depMaps: Array[0]…}\ndefineEmitComplete: true\ndefineEmitted: true\ndefined: true\ndefining: false\ndepCount: 0\ndepExports: Array[1]\n0: undefined\nlength: 1\n__proto__: Array[0]\ndepMaps: Array[1]\n0: Object\nid: \"b\"\nisDefine: true\nname: \"b\"\noriginalName: \"b\"\nparentMap: Object\nprefix: undefined\nunnormalized: false\nurl: \"./b.js\"\n__proto__: Object\nlength: 1\n__proto__: Array[0]\ndepMatched: Array[1]\nenabled: true\nenabling: false\nerrback: undefined\nevents: Object\nexports: Object\nfactory: function (b){\nfetched: true\nignore: undefined\ninited: true\nmap: Object\nid: \"a\"\nisDefine: true\nname: \"a\"\noriginalName: \"a\"\nparentMap: undefined\nprefix: undefined\nunnormalized: false\nurl: \"./a.js\"\n__proto__: Object\npluginMaps: Object\nshim: false\n__proto__: Object\n```\nmap的id证明了这个module是属于a的，depMaps证明这个a依赖b，这个module对像里depExports存的就是这个a依赖b的callback返回的结果，factory存的就是自己的callback，<span style=\"color: #303942;\">那么这个b的callback是在什么时候运行的，又是在什么时候塞到depExports里呢？于是在源码里找到：</span>\n```javascript\nexports = context.execCb(id, factory, depExports, exports);\n```\n执行的就是：\n```javascript\nexecCb: function (name, callback, args, exports) {\n    return callback.apply(exports, args);\n},\n```\n最后，终于找到callback被执行的地方了，随着callback被执行把得到的就过塞入到module，我们的module也基本完成了，但是这还不算完，虽然module里面的东西都有了，但是还并没有应用到我们自己写的代码里，也就是我们自身的callback还没有执行，于是发现了这段代码：\n```javascript\non: function (name, cb) {\n    var cbs = this.events[name];\n    if (!cbs) {\n        cbs = this.events[name] = [];\n    }\n\n    cbs.push(cb);\n},\n\nemit: function (name, evt) {\n    //console.log(this.events[name]);\n    \n    each(this.events[name], function (cb) {\n        console.log(cb);\n        cb(evt);\n    });\n    if (name === 'error') {\n        //Now that the error handler was triggered, remove\n        //the listeners, since this broken Module instance\n        //can stay around for a while in the registry.\n        delete this.events[name];\n    }\n}\n```\n这个on和emit一个是注册，一个是触发，我们的module在拿到export后便会传入emit方法来出发，从而达到调用我们自身回调的过程，这里的cb其实是一个bind方法，依然是一个闭包。写到这里，requireJS的基本流程差不多完了。\n<h3>结束语</h3>\n整个requireJS研究下来，发现还是有点难度的，所以本文只是讲的一个基本的流程，有什么不对的地方，还请多多指出。\n\n&nbsp;","source":"_posts/requireJS实现原理研究2.md","raw":"---\ntitle: requireJS实现原理研究2\ndate: 2014-08-12 18:31:29\ntags:\n- requirejs\ncategories:\n- 390\n---\n<em><strong>上文说到了main.js被引入进来，然后我们接着往下看。</strong></em>\n<h3>接着写</h3>\nmain.js被引入进来后，当然需要运行了，看一下main.js\n<!--more-->\n```javascript\nrequire.config({\n　　　　paths: {\n　　　　　　\"a\": \"a\",\n　　　　　　\"b\": \"b\"\n　　　　}\n});\nrequire(['a'], function (a){\n        console.log('main');\n        //console.log(a);\n});\n```\n第一行是关于config的配置，于是去源码里寻找config方法，发现：\n```javascript\nreq.config = function (config) {\n    return req(config);\n};\n```\n原来还是调用的require方法，继续看debug的require方法，看这段代码：\n```javascript\n// Determine if have config object in the call.\nif (!isArray(deps) &amp;&amp; typeof deps !== 'string') {\n    // deps is a config object\n    config = deps;\n    if (isArray(callback)) {\n        // Adjust args if there are dependencies\n        deps = callback;\n        callback = errback;\n        errback = optional;\n    } else {\n        deps = [];\n    }\n}\n```\n由于我们传入的deps不是数组而是一个对象，所以进过这段代码后，config被全局变量config保存了起来，deps又被设置成空，这又回到了以前的那一布，由于我们传入的defs是空，这个function里的大多数逻辑都没有走，所以这个方法就结束了，程序会继续往下运行。\n\n这时程序又回到main.js里面了，执行完config方法后，又去执行require方法，这时由于传入的deps和callback都不为空，这样，真正的调用require方法了！我们接着debug。\n```javascript\n\tconsole.log(deps, callback)；\n\t[\"a\"] function (a){\n\t        console.log('main');\n\t        //console.log(a);\n\t}\n```\n经过require方法，最后就会到loadRequire方法，根据上面main.js引入的原理，由于我们的deps里面有a，所以也会依次经过nextTick方法，module的init方法，enable方法，fetch方法，最后经过load方法来吧a.js引入进来，由于我们是真正调用的require方法，callback已经被传入进去，所以，这个main.js调用的require方法就为自己生产了一个含有callback的module，这个callback被存储在factory（之前都不不含有callback的也可以说没有factory），通过代码：\n```javascript\nfunction getModule(depMap) {\n    var id = depMap.id,\n        mod = getOwn(registry, id);\n\n    if (!mod) {\n        mod = registry[id] = new context.Module(depMap);\n    }\n    return mod;\n}\n```\n打印出这么main.js的module：\n```javascript\nModule {events: Object, map: Object, shim: false, depExports: Array[0], depMaps: Array[0]…}\ndefineEmitComplete: true\ndefineEmitted: true\ndefined: true\ndefining: false\ndepCount: 0\ndepExports: Array[1]\n0: Object\ntext: 1\n__proto__: Object\nlength: 1\n__proto__: Array[0]\ndepMaps: Array[1]\ndepMatched: Array[1]\nenabled: true\nenabling: false\nerrback: undefined\nevents: Object\nexports: undefined\nfactory: function (a){\narguments: null\ncaller: null\nlength: 1\nname: \"\"\nprototype: Object\n__proto__: function Empty() {}\nfunction scope\nignore: undefined\ninited: true\nmap: Object\nid: \"_@r6\"\nisDefine: false\nname: \"_@r6\"\noriginalName: null\nparentMap: undefined\nprefix: undefined\nunnormalized: false\nurl: \"./_@r6.js\"\n__proto__: Object\npluginMaps: Object\nshim: false\nskipMap: undefined\n__proto__: Object\n```\n这个时候我们知道a,js已经被引入进来了，然后便会执行a.js里面的代码，和main.js不同的是a用的define方法来加载模块，那么这和用require方法有什么不同呢？看一下define方法：\n```javascript\ndefine = function (name, deps, callback) {\n    var node, context;\n\n    //Allow for anonymous modules\n    if (typeof name !== 'string') {\n        //Adjust args appropriately\n        callback = deps;\n        deps = name;\n        name = null;\n    }\n\n    //This module may not have dependencies\n    if (!isArray(deps)) {\n        callback = deps;\n        deps = null;\n    }\n\n    if (!deps &amp;&amp; isFunction(callback)) {\n        deps = [];\n       \n        if (callback.length) {\n            callback\n                .toString()\n                .replace(commentRegExp, '')\n                .replace(cjsRequireRegExp, function (match, dep) {\n                    deps.push(dep);\n                });\n\n            \n            deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);\n        }\n    }\n\n    \n    if (useInteractive) {\n        node = currentlyAddingScript || getInteractiveScript();\n        if (node) {\n            if (!name) {\n                name = node.getAttribute('data-requiremodule');\n            }\n            context = contexts[node.getAttribute('data-requirecontext')];\n        }\n    }\n\n   \n    (context ? context.defQueue : globalDefQueue).push([name, deps, callback]);\n};\n```\nOK，又是这么多代码，但是我看到了最后一步比较重要的(context ? context.defQueue : globalDefQueue).push([name, deps, callback]);这段代码往 context.defQueue塞了一个对象，还记得之前提到过的intakeDefines方法么，当程序运行到这之后，script的onload事件就会触发，然后就会走到intakeDefines方法里面，在intakeDefines方法里面便会执行callGetModule方法，得到a.js对应的module，然后，a对应的module也打印出来看：\n```javascript\nModule {events: Object, map: Object, shim: false, depExports: Array[0], depMaps: Array[0]…}\ndefineEmitComplete: true\ndefineEmitted: true\ndefined: true\ndefining: false\ndepCount: 0\ndepExports: Array[1]\n0: undefined\nlength: 1\n__proto__: Array[0]\ndepMaps: Array[1]\n0: Object\nid: \"b\"\nisDefine: true\nname: \"b\"\noriginalName: \"b\"\nparentMap: Object\nprefix: undefined\nunnormalized: false\nurl: \"./b.js\"\n__proto__: Object\nlength: 1\n__proto__: Array[0]\ndepMatched: Array[1]\nenabled: true\nenabling: false\nerrback: undefined\nevents: Object\nexports: Object\nfactory: function (b){\nfetched: true\nignore: undefined\ninited: true\nmap: Object\nid: \"a\"\nisDefine: true\nname: \"a\"\noriginalName: \"a\"\nparentMap: undefined\nprefix: undefined\nunnormalized: false\nurl: \"./a.js\"\n__proto__: Object\npluginMaps: Object\nshim: false\n__proto__: Object\n```\nmap的id证明了这个module是属于a的，depMaps证明这个a依赖b，这个module对像里depExports存的就是这个a依赖b的callback返回的结果，factory存的就是自己的callback，<span style=\"color: #303942;\">那么这个b的callback是在什么时候运行的，又是在什么时候塞到depExports里呢？于是在源码里找到：</span>\n```javascript\nexports = context.execCb(id, factory, depExports, exports);\n```\n执行的就是：\n```javascript\nexecCb: function (name, callback, args, exports) {\n    return callback.apply(exports, args);\n},\n```\n最后，终于找到callback被执行的地方了，随着callback被执行把得到的就过塞入到module，我们的module也基本完成了，但是这还不算完，虽然module里面的东西都有了，但是还并没有应用到我们自己写的代码里，也就是我们自身的callback还没有执行，于是发现了这段代码：\n```javascript\non: function (name, cb) {\n    var cbs = this.events[name];\n    if (!cbs) {\n        cbs = this.events[name] = [];\n    }\n\n    cbs.push(cb);\n},\n\nemit: function (name, evt) {\n    //console.log(this.events[name]);\n    \n    each(this.events[name], function (cb) {\n        console.log(cb);\n        cb(evt);\n    });\n    if (name === 'error') {\n        //Now that the error handler was triggered, remove\n        //the listeners, since this broken Module instance\n        //can stay around for a while in the registry.\n        delete this.events[name];\n    }\n}\n```\n这个on和emit一个是注册，一个是触发，我们的module在拿到export后便会传入emit方法来出发，从而达到调用我们自身回调的过程，这里的cb其实是一个bind方法，依然是一个闭包。写到这里，requireJS的基本流程差不多完了。\n<h3>结束语</h3>\n整个requireJS研究下来，发现还是有点难度的，所以本文只是讲的一个基本的流程，有什么不对的地方，还请多多指出。\n\n&nbsp;","slug":"requireJS实现原理研究2","published":1,"updated":"2017-04-30T10:38:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434q0p00262wvjadzse5kt","content":"<p><em><strong>上文说到了main.js被引入进来，然后我们接着往下看。</strong></em></p>\n<p></p><h3><span id=\"接着写\">接着写</span></h3><br>main.js被引入进来后，当然需要运行了，看一下main.js<br><a id=\"more\"></a><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>.config(&#123;</span><br><span class=\"line\">　　　　paths: &#123;</span><br><span class=\"line\">　　　　　　<span class=\"string\">\"a\"</span>: <span class=\"string\">\"a\"</span>,</span><br><span class=\"line\">　　　　　　<span class=\"string\">\"b\"</span>: <span class=\"string\">\"b\"</span></span><br><span class=\"line\">　　　　&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'a'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'main'</span>);</span><br><span class=\"line\">        <span class=\"comment\">//console.log(a);</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure><p></p>\n<p>第一行是关于config的配置，于是去源码里寻找config方法，发现：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">req.config = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">config</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> req(config);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>原来还是调用的require方法，继续看debug的require方法，看这段代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Determine if have config object in the call.</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!isArray(deps) &amp;amp;&amp;amp; <span class=\"keyword\">typeof</span> deps !== <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// deps is a config object</span></span><br><span class=\"line\">    config = deps;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isArray(callback)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Adjust args if there are dependencies</span></span><br><span class=\"line\">        deps = callback;</span><br><span class=\"line\">        callback = errback;</span><br><span class=\"line\">        errback = optional;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        deps = [];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于我们传入的deps不是数组而是一个对象，所以进过这段代码后，config被全局变量config保存了起来，deps又被设置成空，这又回到了以前的那一布，由于我们传入的defs是空，这个function里的大多数逻辑都没有走，所以这个方法就结束了，程序会继续往下运行。</p>\n<p>这时程序又回到main.js里面了，执行完config方法后，又去执行require方法，这时由于传入的deps和callback都不为空，这样，真正的调用require方法了！我们接着debug。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(deps, callback)；</span><br><span class=\"line\">[<span class=\"string\">\"a\"</span>] <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'main'</span>);</span><br><span class=\"line\">        <span class=\"comment\">//console.log(a);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>经过require方法，最后就会到loadRequire方法，根据上面main.js引入的原理，由于我们的deps里面有a，所以也会依次经过nextTick方法，module的init方法，enable方法，fetch方法，最后经过load方法来吧a.js引入进来，由于我们是真正调用的require方法，callback已经被传入进去，所以，这个main.js调用的require方法就为自己生产了一个含有callback的module，这个callback被存储在factory（之前都不不含有callback的也可以说没有factory），通过代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getModule</span>(<span class=\"params\">depMap</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> id = depMap.id,</span><br><span class=\"line\">        mod = getOwn(registry, id);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mod) &#123;</span><br><span class=\"line\">        mod = registry[id] = <span class=\"keyword\">new</span> context.Module(depMap);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mod;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>打印出这么main.js的module：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Module &#123;<span class=\"attr\">events</span>: <span class=\"built_in\">Object</span>, <span class=\"attr\">map</span>: <span class=\"built_in\">Object</span>, <span class=\"attr\">shim</span>: <span class=\"literal\">false</span>, <span class=\"attr\">depExports</span>: <span class=\"built_in\">Array</span>[<span class=\"number\">0</span>], <span class=\"attr\">depMaps</span>: <span class=\"built_in\">Array</span>[<span class=\"number\">0</span>]…&#125;</span><br><span class=\"line\">defineEmitComplete: <span class=\"literal\">true</span></span><br><span class=\"line\">defineEmitted: <span class=\"literal\">true</span></span><br><span class=\"line\">defined: <span class=\"literal\">true</span></span><br><span class=\"line\">defining: <span class=\"literal\">false</span></span><br><span class=\"line\">depCount: <span class=\"number\">0</span></span><br><span class=\"line\">depExports: <span class=\"built_in\">Array</span>[<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"number\">0</span>: <span class=\"built_in\">Object</span></span><br><span class=\"line\">text: <span class=\"number\">1</span></span><br><span class=\"line\">__proto__: <span class=\"built_in\">Object</span></span><br><span class=\"line\">length: <span class=\"number\">1</span></span><br><span class=\"line\">__proto__: <span class=\"built_in\">Array</span>[<span class=\"number\">0</span>]</span><br><span class=\"line\">depMaps: <span class=\"built_in\">Array</span>[<span class=\"number\">1</span>]</span><br><span class=\"line\">depMatched: <span class=\"built_in\">Array</span>[<span class=\"number\">1</span>]</span><br><span class=\"line\">enabled: <span class=\"literal\">true</span></span><br><span class=\"line\">enabling: <span class=\"literal\">false</span></span><br><span class=\"line\">errback: <span class=\"literal\">undefined</span></span><br><span class=\"line\">events: <span class=\"built_in\">Object</span></span><br><span class=\"line\">exports: <span class=\"literal\">undefined</span></span><br><span class=\"line\">factory: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">arguments</span>: <span class=\"literal\">null</span></span><br><span class=\"line\">caller: <span class=\"literal\">null</span></span><br><span class=\"line\">length: <span class=\"number\">1</span></span><br><span class=\"line\">name: <span class=\"string\">\"\"</span></span><br><span class=\"line\">prototype: <span class=\"built_in\">Object</span></span><br><span class=\"line\">__proto__: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Empty</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">scope</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">ignore</span>: <span class=\"title\">undefined</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">inited</span>: <span class=\"title\">true</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">map</span>: <span class=\"title\">Object</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">id</span>: \"<span class=\"title\">_</span>@<span class=\"title\">r6</span>\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">isDefine</span>: <span class=\"title\">false</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">name</span>: \"<span class=\"title\">_</span>@<span class=\"title\">r6</span>\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">originalName</span>: <span class=\"title\">null</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">parentMap</span>: <span class=\"title\">undefined</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">prefix</span>: <span class=\"title\">undefined</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">unnormalized</span>: <span class=\"title\">false</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">url</span>: \"./<span class=\"title\">_</span>@<span class=\"title\">r6</span>.<span class=\"title\">js</span>\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">__proto__</span>: <span class=\"title\">Object</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">pluginMaps</span>: <span class=\"title\">Object</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">shim</span>: <span class=\"title\">false</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">skipMap</span>: <span class=\"title\">undefined</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">__proto__</span>: <span class=\"title\">Object</span></span></span><br></pre></td></tr></table></figure></p>\n<p>这个时候我们知道a,js已经被引入进来了，然后便会执行a.js里面的代码，和main.js不同的是a用的define方法来加载模块，那么这和用require方法有什么不同呢？看一下define方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, deps, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> node, context;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Allow for anonymous modules</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> name !== <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Adjust args appropriately</span></span><br><span class=\"line\">        callback = deps;</span><br><span class=\"line\">        deps = name;</span><br><span class=\"line\">        name = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//This module may not have dependencies</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isArray(deps)) &#123;</span><br><span class=\"line\">        callback = deps;</span><br><span class=\"line\">        deps = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!deps &amp;amp;&amp;amp; isFunction(callback)) &#123;</span><br><span class=\"line\">        deps = [];</span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (callback.length) &#123;</span><br><span class=\"line\">            callback</span><br><span class=\"line\">                .toString()</span><br><span class=\"line\">                .replace(commentRegExp, <span class=\"string\">''</span>)</span><br><span class=\"line\">                .replace(cjsRequireRegExp, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">match, dep</span>) </span>&#123;</span><br><span class=\"line\">                    deps.push(dep);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            </span><br><span class=\"line\">            deps = (callback.length === <span class=\"number\">1</span> ? [<span class=\"string\">'require'</span>] : [<span class=\"string\">'require'</span>, <span class=\"string\">'exports'</span>, <span class=\"string\">'module'</span>]).concat(deps);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (useInteractive) &#123;</span><br><span class=\"line\">        node = currentlyAddingScript || getInteractiveScript();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!name) &#123;</span><br><span class=\"line\">                name = node.getAttribute(<span class=\"string\">'data-requiremodule'</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            context = contexts[node.getAttribute(<span class=\"string\">'data-requirecontext'</span>)];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   </span><br><span class=\"line\">    (context ? context.defQueue : globalDefQueue).push([name, deps, callback]);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>OK，又是这么多代码，但是我看到了最后一步比较重要的(context ? context.defQueue : globalDefQueue).push([name, deps, callback]);这段代码往 context.defQueue塞了一个对象，还记得之前提到过的intakeDefines方法么，当程序运行到这之后，script的onload事件就会触发，然后就会走到intakeDefines方法里面，在intakeDefines方法里面便会执行callGetModule方法，得到a.js对应的module，然后，a对应的module也打印出来看：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Module &#123;<span class=\"attr\">events</span>: <span class=\"built_in\">Object</span>, <span class=\"attr\">map</span>: <span class=\"built_in\">Object</span>, <span class=\"attr\">shim</span>: <span class=\"literal\">false</span>, <span class=\"attr\">depExports</span>: <span class=\"built_in\">Array</span>[<span class=\"number\">0</span>], <span class=\"attr\">depMaps</span>: <span class=\"built_in\">Array</span>[<span class=\"number\">0</span>]…&#125;</span><br><span class=\"line\">defineEmitComplete: <span class=\"literal\">true</span></span><br><span class=\"line\">defineEmitted: <span class=\"literal\">true</span></span><br><span class=\"line\">defined: <span class=\"literal\">true</span></span><br><span class=\"line\">defining: <span class=\"literal\">false</span></span><br><span class=\"line\">depCount: <span class=\"number\">0</span></span><br><span class=\"line\">depExports: <span class=\"built_in\">Array</span>[<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"number\">0</span>: <span class=\"literal\">undefined</span></span><br><span class=\"line\">length: <span class=\"number\">1</span></span><br><span class=\"line\">__proto__: <span class=\"built_in\">Array</span>[<span class=\"number\">0</span>]</span><br><span class=\"line\">depMaps: <span class=\"built_in\">Array</span>[<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"number\">0</span>: <span class=\"built_in\">Object</span></span><br><span class=\"line\">id: <span class=\"string\">\"b\"</span></span><br><span class=\"line\">isDefine: <span class=\"literal\">true</span></span><br><span class=\"line\">name: <span class=\"string\">\"b\"</span></span><br><span class=\"line\">originalName: <span class=\"string\">\"b\"</span></span><br><span class=\"line\">parentMap: <span class=\"built_in\">Object</span></span><br><span class=\"line\">prefix: <span class=\"literal\">undefined</span></span><br><span class=\"line\">unnormalized: <span class=\"literal\">false</span></span><br><span class=\"line\">url: <span class=\"string\">\"./b.js\"</span></span><br><span class=\"line\">__proto__: <span class=\"built_in\">Object</span></span><br><span class=\"line\">length: <span class=\"number\">1</span></span><br><span class=\"line\">__proto__: <span class=\"built_in\">Array</span>[<span class=\"number\">0</span>]</span><br><span class=\"line\">depMatched: <span class=\"built_in\">Array</span>[<span class=\"number\">1</span>]</span><br><span class=\"line\">enabled: <span class=\"literal\">true</span></span><br><span class=\"line\">enabling: <span class=\"literal\">false</span></span><br><span class=\"line\">errback: <span class=\"literal\">undefined</span></span><br><span class=\"line\">events: <span class=\"built_in\">Object</span></span><br><span class=\"line\">exports: <span class=\"built_in\">Object</span></span><br><span class=\"line\">factory: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">b</span>)</span>&#123;</span><br><span class=\"line\">fetched: <span class=\"literal\">true</span></span><br><span class=\"line\">ignore: <span class=\"literal\">undefined</span></span><br><span class=\"line\">inited: <span class=\"literal\">true</span></span><br><span class=\"line\">map: <span class=\"built_in\">Object</span></span><br><span class=\"line\">id: <span class=\"string\">\"a\"</span></span><br><span class=\"line\">isDefine: <span class=\"literal\">true</span></span><br><span class=\"line\">name: <span class=\"string\">\"a\"</span></span><br><span class=\"line\">originalName: <span class=\"string\">\"a\"</span></span><br><span class=\"line\">parentMap: <span class=\"literal\">undefined</span></span><br><span class=\"line\">prefix: <span class=\"literal\">undefined</span></span><br><span class=\"line\">unnormalized: <span class=\"literal\">false</span></span><br><span class=\"line\">url: <span class=\"string\">\"./a.js\"</span></span><br><span class=\"line\">__proto__: <span class=\"built_in\">Object</span></span><br><span class=\"line\">pluginMaps: <span class=\"built_in\">Object</span></span><br><span class=\"line\">shim: <span class=\"literal\">false</span></span><br><span class=\"line\">__proto__: <span class=\"built_in\">Object</span></span><br></pre></td></tr></table></figure></p>\n<p>map的id证明了这个module是属于a的，depMaps证明这个a依赖b，这个module对像里depExports存的就是这个a依赖b的callback返回的结果，factory存的就是自己的callback，<span style=\"color: #303942;\">那么这个b的callback是在什么时候运行的，又是在什么时候塞到depExports里呢？于是在源码里找到：</span><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exports = context.execCb(id, factory, depExports, exports);</span><br></pre></td></tr></table></figure></p>\n<p>执行的就是：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">execCb: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, callback, args, exports</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> callback.apply(exports, args);</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>最后，终于找到callback被执行的地方了，随着callback被执行把得到的就过塞入到module，我们的module也基本完成了，但是这还不算完，虽然module里面的东西都有了，但是还并没有应用到我们自己写的代码里，也就是我们自身的callback还没有执行，于是发现了这段代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, cb</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cbs = <span class=\"keyword\">this</span>.events[name];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cbs) &#123;</span><br><span class=\"line\">        cbs = <span class=\"keyword\">this</span>.events[name] = [];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cbs.push(cb);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">emit: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, evt</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//console.log(this.events[name]);</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    each(<span class=\"keyword\">this</span>.events[name], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">cb</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(cb);</span><br><span class=\"line\">        cb(evt);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name === <span class=\"string\">'error'</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Now that the error handler was triggered, remove</span></span><br><span class=\"line\">        <span class=\"comment\">//the listeners, since this broken Module instance</span></span><br><span class=\"line\">        <span class=\"comment\">//can stay around for a while in the registry.</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>.events[name];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个on和emit一个是注册，一个是触发，我们的module在拿到export后便会传入emit方法来出发，从而达到调用我们自身回调的过程，这里的cb其实是一个bind方法，依然是一个闭包。写到这里，requireJS的基本流程差不多完了。</p>\n<p></p><h3><span id=\"结束语\">结束语</span></h3><br>整个requireJS研究下来，发现还是有点难度的，所以本文只是讲的一个基本的流程，有什么不对的地方，还请多多指出。<p></p>\n<p>&nbsp;</p>\n","site":{"data":{}},"excerpt":"<p><em><strong>上文说到了main.js被引入进来，然后我们接着往下看。</strong></em></p>\n<p></p><h3>接着写</h3><br>main.js被引入进来后，当然需要运行了，看一下main.js<br>","more":"<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>.config(&#123;</span><br><span class=\"line\">　　　　paths: &#123;</span><br><span class=\"line\">　　　　　　<span class=\"string\">\"a\"</span>: <span class=\"string\">\"a\"</span>,</span><br><span class=\"line\">　　　　　　<span class=\"string\">\"b\"</span>: <span class=\"string\">\"b\"</span></span><br><span class=\"line\">　　　　&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'a'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'main'</span>);</span><br><span class=\"line\">        <span class=\"comment\">//console.log(a);</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure><p></p>\n<p>第一行是关于config的配置，于是去源码里寻找config方法，发现：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">req.config = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">config</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> req(config);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>原来还是调用的require方法，继续看debug的require方法，看这段代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Determine if have config object in the call.</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!isArray(deps) &amp;amp;&amp;amp; <span class=\"keyword\">typeof</span> deps !== <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// deps is a config object</span></span><br><span class=\"line\">    config = deps;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isArray(callback)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Adjust args if there are dependencies</span></span><br><span class=\"line\">        deps = callback;</span><br><span class=\"line\">        callback = errback;</span><br><span class=\"line\">        errback = optional;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        deps = [];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于我们传入的deps不是数组而是一个对象，所以进过这段代码后，config被全局变量config保存了起来，deps又被设置成空，这又回到了以前的那一布，由于我们传入的defs是空，这个function里的大多数逻辑都没有走，所以这个方法就结束了，程序会继续往下运行。</p>\n<p>这时程序又回到main.js里面了，执行完config方法后，又去执行require方法，这时由于传入的deps和callback都不为空，这样，真正的调用require方法了！我们接着debug。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(deps, callback)；</span><br><span class=\"line\">[<span class=\"string\">\"a\"</span>] <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'main'</span>);</span><br><span class=\"line\">        <span class=\"comment\">//console.log(a);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>经过require方法，最后就会到loadRequire方法，根据上面main.js引入的原理，由于我们的deps里面有a，所以也会依次经过nextTick方法，module的init方法，enable方法，fetch方法，最后经过load方法来吧a.js引入进来，由于我们是真正调用的require方法，callback已经被传入进去，所以，这个main.js调用的require方法就为自己生产了一个含有callback的module，这个callback被存储在factory（之前都不不含有callback的也可以说没有factory），通过代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getModule</span>(<span class=\"params\">depMap</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> id = depMap.id,</span><br><span class=\"line\">        mod = getOwn(registry, id);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mod) &#123;</span><br><span class=\"line\">        mod = registry[id] = <span class=\"keyword\">new</span> context.Module(depMap);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mod;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>打印出这么main.js的module：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Module &#123;<span class=\"attr\">events</span>: <span class=\"built_in\">Object</span>, <span class=\"attr\">map</span>: <span class=\"built_in\">Object</span>, <span class=\"attr\">shim</span>: <span class=\"literal\">false</span>, <span class=\"attr\">depExports</span>: <span class=\"built_in\">Array</span>[<span class=\"number\">0</span>], <span class=\"attr\">depMaps</span>: <span class=\"built_in\">Array</span>[<span class=\"number\">0</span>]…&#125;</span><br><span class=\"line\">defineEmitComplete: <span class=\"literal\">true</span></span><br><span class=\"line\">defineEmitted: <span class=\"literal\">true</span></span><br><span class=\"line\">defined: <span class=\"literal\">true</span></span><br><span class=\"line\">defining: <span class=\"literal\">false</span></span><br><span class=\"line\">depCount: <span class=\"number\">0</span></span><br><span class=\"line\">depExports: <span class=\"built_in\">Array</span>[<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"number\">0</span>: <span class=\"built_in\">Object</span></span><br><span class=\"line\">text: <span class=\"number\">1</span></span><br><span class=\"line\">__proto__: <span class=\"built_in\">Object</span></span><br><span class=\"line\">length: <span class=\"number\">1</span></span><br><span class=\"line\">__proto__: <span class=\"built_in\">Array</span>[<span class=\"number\">0</span>]</span><br><span class=\"line\">depMaps: <span class=\"built_in\">Array</span>[<span class=\"number\">1</span>]</span><br><span class=\"line\">depMatched: <span class=\"built_in\">Array</span>[<span class=\"number\">1</span>]</span><br><span class=\"line\">enabled: <span class=\"literal\">true</span></span><br><span class=\"line\">enabling: <span class=\"literal\">false</span></span><br><span class=\"line\">errback: <span class=\"literal\">undefined</span></span><br><span class=\"line\">events: <span class=\"built_in\">Object</span></span><br><span class=\"line\">exports: <span class=\"literal\">undefined</span></span><br><span class=\"line\">factory: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">arguments</span>: <span class=\"literal\">null</span></span><br><span class=\"line\">caller: <span class=\"literal\">null</span></span><br><span class=\"line\">length: <span class=\"number\">1</span></span><br><span class=\"line\">name: <span class=\"string\">\"\"</span></span><br><span class=\"line\">prototype: <span class=\"built_in\">Object</span></span><br><span class=\"line\">__proto__: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Empty</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">scope</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">ignore</span>: <span class=\"title\">undefined</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">inited</span>: <span class=\"title\">true</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">map</span>: <span class=\"title\">Object</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">id</span>: \"<span class=\"title\">_</span>@<span class=\"title\">r6</span>\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">isDefine</span>: <span class=\"title\">false</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">name</span>: \"<span class=\"title\">_</span>@<span class=\"title\">r6</span>\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">originalName</span>: <span class=\"title\">null</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">parentMap</span>: <span class=\"title\">undefined</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">prefix</span>: <span class=\"title\">undefined</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">unnormalized</span>: <span class=\"title\">false</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">url</span>: \"./<span class=\"title\">_</span>@<span class=\"title\">r6</span>.<span class=\"title\">js</span>\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">__proto__</span>: <span class=\"title\">Object</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">pluginMaps</span>: <span class=\"title\">Object</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">shim</span>: <span class=\"title\">false</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">skipMap</span>: <span class=\"title\">undefined</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">__proto__</span>: <span class=\"title\">Object</span></span></span><br></pre></td></tr></table></figure></p>\n<p>这个时候我们知道a,js已经被引入进来了，然后便会执行a.js里面的代码，和main.js不同的是a用的define方法来加载模块，那么这和用require方法有什么不同呢？看一下define方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, deps, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> node, context;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Allow for anonymous modules</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> name !== <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Adjust args appropriately</span></span><br><span class=\"line\">        callback = deps;</span><br><span class=\"line\">        deps = name;</span><br><span class=\"line\">        name = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//This module may not have dependencies</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isArray(deps)) &#123;</span><br><span class=\"line\">        callback = deps;</span><br><span class=\"line\">        deps = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!deps &amp;amp;&amp;amp; isFunction(callback)) &#123;</span><br><span class=\"line\">        deps = [];</span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (callback.length) &#123;</span><br><span class=\"line\">            callback</span><br><span class=\"line\">                .toString()</span><br><span class=\"line\">                .replace(commentRegExp, <span class=\"string\">''</span>)</span><br><span class=\"line\">                .replace(cjsRequireRegExp, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">match, dep</span>) </span>&#123;</span><br><span class=\"line\">                    deps.push(dep);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            </span><br><span class=\"line\">            deps = (callback.length === <span class=\"number\">1</span> ? [<span class=\"string\">'require'</span>] : [<span class=\"string\">'require'</span>, <span class=\"string\">'exports'</span>, <span class=\"string\">'module'</span>]).concat(deps);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (useInteractive) &#123;</span><br><span class=\"line\">        node = currentlyAddingScript || getInteractiveScript();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!name) &#123;</span><br><span class=\"line\">                name = node.getAttribute(<span class=\"string\">'data-requiremodule'</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            context = contexts[node.getAttribute(<span class=\"string\">'data-requirecontext'</span>)];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   </span><br><span class=\"line\">    (context ? context.defQueue : globalDefQueue).push([name, deps, callback]);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>OK，又是这么多代码，但是我看到了最后一步比较重要的(context ? context.defQueue : globalDefQueue).push([name, deps, callback]);这段代码往 context.defQueue塞了一个对象，还记得之前提到过的intakeDefines方法么，当程序运行到这之后，script的onload事件就会触发，然后就会走到intakeDefines方法里面，在intakeDefines方法里面便会执行callGetModule方法，得到a.js对应的module，然后，a对应的module也打印出来看：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Module &#123;<span class=\"attr\">events</span>: <span class=\"built_in\">Object</span>, <span class=\"attr\">map</span>: <span class=\"built_in\">Object</span>, <span class=\"attr\">shim</span>: <span class=\"literal\">false</span>, <span class=\"attr\">depExports</span>: <span class=\"built_in\">Array</span>[<span class=\"number\">0</span>], <span class=\"attr\">depMaps</span>: <span class=\"built_in\">Array</span>[<span class=\"number\">0</span>]…&#125;</span><br><span class=\"line\">defineEmitComplete: <span class=\"literal\">true</span></span><br><span class=\"line\">defineEmitted: <span class=\"literal\">true</span></span><br><span class=\"line\">defined: <span class=\"literal\">true</span></span><br><span class=\"line\">defining: <span class=\"literal\">false</span></span><br><span class=\"line\">depCount: <span class=\"number\">0</span></span><br><span class=\"line\">depExports: <span class=\"built_in\">Array</span>[<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"number\">0</span>: <span class=\"literal\">undefined</span></span><br><span class=\"line\">length: <span class=\"number\">1</span></span><br><span class=\"line\">__proto__: <span class=\"built_in\">Array</span>[<span class=\"number\">0</span>]</span><br><span class=\"line\">depMaps: <span class=\"built_in\">Array</span>[<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"number\">0</span>: <span class=\"built_in\">Object</span></span><br><span class=\"line\">id: <span class=\"string\">\"b\"</span></span><br><span class=\"line\">isDefine: <span class=\"literal\">true</span></span><br><span class=\"line\">name: <span class=\"string\">\"b\"</span></span><br><span class=\"line\">originalName: <span class=\"string\">\"b\"</span></span><br><span class=\"line\">parentMap: <span class=\"built_in\">Object</span></span><br><span class=\"line\">prefix: <span class=\"literal\">undefined</span></span><br><span class=\"line\">unnormalized: <span class=\"literal\">false</span></span><br><span class=\"line\">url: <span class=\"string\">\"./b.js\"</span></span><br><span class=\"line\">__proto__: <span class=\"built_in\">Object</span></span><br><span class=\"line\">length: <span class=\"number\">1</span></span><br><span class=\"line\">__proto__: <span class=\"built_in\">Array</span>[<span class=\"number\">0</span>]</span><br><span class=\"line\">depMatched: <span class=\"built_in\">Array</span>[<span class=\"number\">1</span>]</span><br><span class=\"line\">enabled: <span class=\"literal\">true</span></span><br><span class=\"line\">enabling: <span class=\"literal\">false</span></span><br><span class=\"line\">errback: <span class=\"literal\">undefined</span></span><br><span class=\"line\">events: <span class=\"built_in\">Object</span></span><br><span class=\"line\">exports: <span class=\"built_in\">Object</span></span><br><span class=\"line\">factory: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">b</span>)</span>&#123;</span><br><span class=\"line\">fetched: <span class=\"literal\">true</span></span><br><span class=\"line\">ignore: <span class=\"literal\">undefined</span></span><br><span class=\"line\">inited: <span class=\"literal\">true</span></span><br><span class=\"line\">map: <span class=\"built_in\">Object</span></span><br><span class=\"line\">id: <span class=\"string\">\"a\"</span></span><br><span class=\"line\">isDefine: <span class=\"literal\">true</span></span><br><span class=\"line\">name: <span class=\"string\">\"a\"</span></span><br><span class=\"line\">originalName: <span class=\"string\">\"a\"</span></span><br><span class=\"line\">parentMap: <span class=\"literal\">undefined</span></span><br><span class=\"line\">prefix: <span class=\"literal\">undefined</span></span><br><span class=\"line\">unnormalized: <span class=\"literal\">false</span></span><br><span class=\"line\">url: <span class=\"string\">\"./a.js\"</span></span><br><span class=\"line\">__proto__: <span class=\"built_in\">Object</span></span><br><span class=\"line\">pluginMaps: <span class=\"built_in\">Object</span></span><br><span class=\"line\">shim: <span class=\"literal\">false</span></span><br><span class=\"line\">__proto__: <span class=\"built_in\">Object</span></span><br></pre></td></tr></table></figure></p>\n<p>map的id证明了这个module是属于a的，depMaps证明这个a依赖b，这个module对像里depExports存的就是这个a依赖b的callback返回的结果，factory存的就是自己的callback，<span style=\"color: #303942;\">那么这个b的callback是在什么时候运行的，又是在什么时候塞到depExports里呢？于是在源码里找到：</span><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exports = context.execCb(id, factory, depExports, exports);</span><br></pre></td></tr></table></figure></p>\n<p>执行的就是：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">execCb: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, callback, args, exports</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> callback.apply(exports, args);</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>最后，终于找到callback被执行的地方了，随着callback被执行把得到的就过塞入到module，我们的module也基本完成了，但是这还不算完，虽然module里面的东西都有了，但是还并没有应用到我们自己写的代码里，也就是我们自身的callback还没有执行，于是发现了这段代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, cb</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cbs = <span class=\"keyword\">this</span>.events[name];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cbs) &#123;</span><br><span class=\"line\">        cbs = <span class=\"keyword\">this</span>.events[name] = [];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cbs.push(cb);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">emit: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, evt</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//console.log(this.events[name]);</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    each(<span class=\"keyword\">this</span>.events[name], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">cb</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(cb);</span><br><span class=\"line\">        cb(evt);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name === <span class=\"string\">'error'</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Now that the error handler was triggered, remove</span></span><br><span class=\"line\">        <span class=\"comment\">//the listeners, since this broken Module instance</span></span><br><span class=\"line\">        <span class=\"comment\">//can stay around for a while in the registry.</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>.events[name];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个on和emit一个是注册，一个是触发，我们的module在拿到export后便会传入emit方法来出发，从而达到调用我们自身回调的过程，这里的cb其实是一个bind方法，依然是一个闭包。写到这里，requireJS的基本流程差不多完了。</p>\n<p></p><h3>结束语</h3><br>整个requireJS研究下来，发现还是有点难度的，所以本文只是讲的一个基本的流程，有什么不对的地方，还请多多指出。<p></p>\n<p>&nbsp;</p>"},{"title":"全屏滚动效果H5FullscreenPage.js测试版给力上线","date":"2014-09-24T12:15:18.000Z","photos":["https://qiniu.nihaoshijie.com.cn/H5FullscreenPage.png"],"_content":"介于现在很多活动都使用了 类似全屏滚动效果 尤其在微信里面 我自己开发了一个快速构建 此类项目的控件 基于zepto.js 后续会对此控件完善。\n\n&nbsp;\n\n项目地址：<a href=\"http://lvming6816077.github.io/H5FullscreenPage/\" target=\"_blank\">http://lvming6816077.github.io/H5FullscreenPage/</a>\n\n&nbsp;\n\n文档地址：<a href=\"https://github.com/lvming6816077/H5FullscreenPage/blob/master/README.md\" target=\"_blank\">https://github.com/lvming6816077/H5FullscreenPage/blob/master/README.md</a>","source":"_posts/全屏滚动效果H5FullscreenPage-js测试版给力上线.md","raw":"---\ntitle: 全屏滚动效果H5FullscreenPage.js测试版给力上线\ndate: 2014-09-24 20:15:18\ntags:\n- css动画\n- 全屏滚动\ncategories:\n- 447\nphotos: https://qiniu.nihaoshijie.com.cn/H5FullscreenPage.png\n\n---\n介于现在很多活动都使用了 类似全屏滚动效果 尤其在微信里面 我自己开发了一个快速构建 此类项目的控件 基于zepto.js 后续会对此控件完善。\n\n&nbsp;\n\n项目地址：<a href=\"http://lvming6816077.github.io/H5FullscreenPage/\" target=\"_blank\">http://lvming6816077.github.io/H5FullscreenPage/</a>\n\n&nbsp;\n\n文档地址：<a href=\"https://github.com/lvming6816077/H5FullscreenPage/blob/master/README.md\" target=\"_blank\">https://github.com/lvming6816077/H5FullscreenPage/blob/master/README.md</a>","slug":"全屏滚动效果H5FullscreenPage-js测试版给力上线","published":1,"updated":"2021-12-10T16:07:48.000Z","comments":1,"layout":"post","link":"","_id":"ckx434q0r002a2wvjty9c4v1e","content":"<p>介于现在很多活动都使用了 类似全屏滚动效果 尤其在微信里面 我自己开发了一个快速构建 此类项目的控件 基于zepto.js 后续会对此控件完善。</p>\n<p>&nbsp;</p>\n<p>项目地址：<a href=\"http://lvming6816077.github.io/H5FullscreenPage/\" target=\"_blank\">http://lvming6816077.github.io/H5FullscreenPage/</a></p>\n<p>&nbsp;</p>\n<p>文档地址：<a href=\"https://github.com/lvming6816077/H5FullscreenPage/blob/master/README.md\" target=\"_blank\">https://github.com/lvming6816077/H5FullscreenPage/blob/master/README.md</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>介于现在很多活动都使用了 类似全屏滚动效果 尤其在微信里面 我自己开发了一个快速构建 此类项目的控件 基于zepto.js 后续会对此控件完善。</p>\n<p>&nbsp;</p>\n<p>项目地址：<a href=\"http://lvming6816077.github.io/H5FullscreenPage/\" target=\"_blank\">http://lvming6816077.github.io/H5FullscreenPage/</a></p>\n<p>&nbsp;</p>\n<p>文档地址：<a href=\"https://github.com/lvming6816077/H5FullscreenPage/blob/master/README.md\" target=\"_blank\">https://github.com/lvming6816077/H5FullscreenPage/blob/master/README.md</a></p>\n"},{"title":"web前端性能优化之Html Css Javascript","date":"2015-05-05T08:06:08.000Z","_content":"<strong><span style=\"color: #008080;\">前言</span></strong>\n\nhtml css javascript可以算是前端必须掌握的东西了，但是我们的浏览器是怎样解析这些东西的呢 我们如何处理html css javascript这些东西来让我们的网页更加合理，在我这里做了一些实验，总结起来给大家看看。\n\n<!--more-->\n<strong><span style=\"color: #008080;\">最简单的页面</span></strong>\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>test</title>\n  </head>\n  <body>\n    <img src=\"download-button.png\">\n  </body>\n</html>\n```\n我们打开chrome的控制台查看timeline\n\n<img class=\"alignnone\" src=\"http://cdn.alloyteam.com/wp-content/uploads/2015/04/11.png\" alt=\"\" width=\"1073\" height=\"142\" />\n\n\n由上图 可得结论\n\n\n\n1 图中蓝色透明条标识浏览器从发起请求到接收到服务器返回第一个字节的时间，时间还是挺长的，而蓝色实体条则为真正的html页面下载的时间 还是很短的。\n\n\n2 图中红框内的这部分时间则表示浏览器从下载完成html之后开始构建dom，当发现一个image标签时所花费的时间，由此可见dom是顺序执行的，当发现image时便立即发起请求，而紫色透明条则是image发起请求时在网络传输时所消耗的时间。\n\n\n3 图中timeline蓝色竖线所处的时间为domComplete时间，红色竖线为dom的onload时间，由此可见两种事件的差异。而浏览器构建dom树所花费的时间可以算出即domComplete时间 减去 html下载完成后的时间大概80ms。\n\n\n<strong><span style=\"color: #008080;\">含有css的页面</span></strong>\n<pre class=\"lang:default decode:true  \">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;test&lt;/title&gt;\n    &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"stylesheet.css\" media=\"screen\"&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;img src=\"download-button.png\"&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</pre>\n我们打开chrome的控制台查看timeline\n\n<a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2015/05/2.png\"><img class=\"alignleft wp-image-623 size-full\" src=\"http://www.alloyteam.com/wp-content/uploads/2015/04/2.png\" alt=\"2\" width=\"1072\" height=\"196\" /></a>\n\n&nbsp;\n\n\n&nbsp;\n\n&nbsp;\n\n1 在添加了外部引入css之后，并没有发现什么异常，但是有一点指的注意，也就是红色竖线和蓝色竖线挨得更进了，这表明domComplete时间必须等待css解析完成，也就是构建dom树必须等待css解析完成，这也就解释了下图\n\n<a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2015/05/3.png\"><img class=\"alignnone wp-image-624 size-full\" src=\"http://www.alloyteam.com/wp-content/uploads/2015/04/3.png\" alt=\"3\" width=\"734\" height=\"348\" /></a>\n\n&nbsp;\n\n<hr />\n\n<strong><span style=\"color: #008080;\">含有javascript和css的页面</span></strong>\n<pre class=\"lang:default decode:true \">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;test&lt;/title&gt;\n      &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"stylesheet.css\" media=\"screen\"&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;img src=\"download-button.png\"&gt;\n  &lt;script type=\"text/javascript\" src=\"H5FullscreenPage.js\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</pre>\n&nbsp;\n\n我们打开chrome的控制台查看timeline\n\n<a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2015/05/4.png\"><img class=\"alignnone size-full wp-image-625\" src=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2015/05/4.png\" alt=\"4\" width=\"1221\" height=\"227\" /></a>\n\n&nbsp;\n\n1 图上显示在引入外部的js文件之后domComplete时间又被延后了，结合上面的renderTree，由于javascript代码可能会更改css属性或者是dom结构，所以在形成renderTree之前必须等待javascript解析完成才能接着构建renderTree。\n\n2 将javascript放在head内和body底部的区别也在于此，放在head里面，由于浏览器发现head里面有javascript标签就会暂时停止其他渲染行为，等待javascript下载并执行完成才能接着往下渲染，而这个时候由于在head里面这个时候页面是白的，如果将javascript放在页面底部，renderTree已经完成大部分，所以此时页面有内容呈现，即使遇到javascript阻塞渲染，也不会有白屏出现。\n\n<hr />\n\n<strong><span style=\"color: #008080;\">内嵌javascript的页面</span></strong>\n\n&nbsp;\n\n<a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2015/05/51.png\"><img class=\"alignnone size-full wp-image-626\" src=\"http://www.alloyteam.com/wp-content/uploads/2015/04/51.png\" alt=\"51\" width=\"1222\" height=\"213\" /></a>\n\n1 图上可以看到，由于内嵌了javascript，页面上减少了一个请求，导致html文档变大，消耗时间增多，但是domComplete时间提升的并不多。\n\n<hr />\n\n<span style=\"color: #008080;\"><strong>使用async的javascript</strong></span>\n<pre class=\"lang:default decode:true\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;test&lt;/title&gt;\n      &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"stylesheet.css\" media=\"screen\"&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;img src=\"download-button.png\"&gt;\n      &lt;script async src=\"H5FullscreenPage.js\" type =\"text/javascript\" &gt;&lt;/script &gt;\n  &lt;/body&gt;\n&lt;/html&gt;</pre>\n&nbsp;\n\n<a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2015/05/6.png\"><img class=\"alignnone size-full wp-image-627\" src=\"http://www.alloyteam.com/wp-content/uploads/2015/05/6.png\" alt=\"6\" width=\"1215\" height=\"348\" /></a>\n\n1 可以看到domComplete时间被大大提前 javascript也没有阻塞css和body里面img元素的并行下载。\n\n2 使用<a href=\"http://www.w3school.com.cn/tags/att_script_async.asp\">async</a>标识的script，浏览器将异步执行这中script不会阻塞正常的dom渲染，这时html5所支持的属性，另外<a href=\"http://www.w3school.com.cn/tags/att_script_defer.asp\">defer</a>也可以达到这种效果。\n\n<hr />\n\n<strong><span style=\"color: #008080;\">head里面js和css加载的关系</span></strong>\n\n<strong>外联js在css前面</strong>\n<pre class=\"lang:default decode:true\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;test&lt;/title&gt;\n      &lt;script src=\"H5FullscreenPage.js\" type =\"text/javascript\" &gt;&lt;/script &gt;\n      &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"stylesheet.css\" media=\"screen\"&gt;\n      &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"page-animation.css\" media=\"screen\"&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;img src=\"download-button.png\"&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</pre>\n<img class=\"alignnone\" style=\"height: 442px; width: 1221px;\" src=\"http://1.lvming6816077.sinaapp.com/testaa/xx1.png\" alt=\"\" />\n\n1 没有阻止css的并行加载但是影响了body里面img的并行加载\n\n<hr />\n\n<strong>外联js在css中间</strong>\n<pre class=\"lang:default decode:true\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;test&lt;/title&gt;\n      &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"stylesheet.css\" media=\"screen\"&gt;\n      &lt;script src=\"H5FullscreenPage.js\" type =\"text/javascript\" &gt;&lt;/script &gt;\n      &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"page-animation.css\" media=\"screen\"&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;img src=\"download-button.png\"&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</pre>\n<img class=\"alignnone\" style=\"height: 382px; width: 1208px;\" src=\"http://1.lvming6816077.sinaapp.com/testaa/xx2.png\" alt=\"\" />\n\n1 影响了css的并行加载和body里面img的并行加载\n\n<hr />\n\n<strong>外联js在css最后</strong>\n<pre class=\"lang:default decode:true \">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;test&lt;/title&gt;\n      &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"stylesheet.css\" media=\"screen\"&gt;\n      &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"page-animation.css\" media=\"screen\"&gt;\n      &lt;script src=\"H5FullscreenPage.js\" type =\"text/javascript\" &gt;&lt;/script &gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;img src=\"download-button.png\"&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</pre>\n&nbsp;\n\n<img class=\"alignnone\" style=\"height: 346px; width: 1228px;\" src=\"http://1.lvming6816077.sinaapp.com/testaa/xx3.png\" alt=\"\" />\n\n1 影响了css的并行加载和body里面img的并行加载\n\n<hr />\n\n<strong>内嵌js在css前面</strong>\n<pre class=\"lang:default decode:true \">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;test&lt;/title&gt;\n      &lt;script type =\"text/javascript\" &gt;\n      \tvar f = 1;\n          f++;\n      &lt;/script &gt;\n      &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"stylesheet.css\" media=\"screen\"&gt;\n      &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"page-animation.css\" media=\"screen\"&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;img src=\"download-button.png\"&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</pre>\n&nbsp;\n\n<img class=\"alignnone\" style=\"height: 451px; width: 1229px;\" src=\"http://1.lvming6816077.sinaapp.com/testaa/xx4.png\" alt=\"\" />\n\n1 没有影响css的并行加载也没有影响body里面img的并行加载\n\n<hr />\n\n<strong>内嵌js在css中间</strong>\n<pre class=\"lang:default decode:true \">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;test&lt;/title&gt;\n      &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"stylesheet.css\" media=\"screen\"&gt;\n      &lt;script type =\"text/javascript\" &gt;\n      \tvar f = 1;\n          f++;\n      &lt;/script &gt;\n      &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"page-animation.css\" media=\"screen\"&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;img src=\"download-button.png\"&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</pre>\n&nbsp;\n\n<img class=\"alignnone\" style=\"height: 437px; width: 1219px;\" src=\"http://1.lvming6816077.sinaapp.com/testaa/xx5.png\" alt=\"\" />\n\n1 影响了css的并行加载没有英雄body里面img的并行加载\n\n<hr />\n\n<strong>内嵌js在css最后</strong>\n<pre class=\"lang:default decode:true \">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;test&lt;/title&gt;\n      &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"stylesheet.css\" media=\"screen\"&gt;\n      &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"page-animation.css\" media=\"screen\"&gt;\n      &lt;script type =\"text/javascript\" &gt;\n      \tvar f = 1;\n          f++;\n      &lt;/script &gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;img src=\"download-button.png\"&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</pre>\n&nbsp;\n\n<img class=\"alignnone\" style=\"height: 350px; width: 1228px;\" src=\"http://1.lvming6816077.sinaapp.com/testaa/xx6.png\" alt=\"\" />\n\n1 影响了css和body里面img的并行加载。\n\n<hr />\n\n<strong>综上所述：</strong>\n\n<span style=\"font-family: verdana,arial,helvetica,sans-serif; font-size: 14px;\">当浏览器从服务器接收到了HTML文档，并把HTML在内存中转换成DOM树，在转换的过程中如果发现某个节点(node)上引用了CSS或者 IMAGE，就会再发1个request去请求CSS或image,然后继续执行下面的转换，而不需要等待request的返回，当request返回 后，只需要把返回的内容放入到DOM树中对应的位置就OK。但当引用了JS的时候，浏览器发送1个js request就会一直等待该request的返回。因为浏览器需要1个稳定的DOM树结构，而JS中很有可能有代码直接改变了DOM树结构，浏览器为了防止出现JS修改DOM树，需要重新构建DOM树的情况，所以 就会阻塞其他的下载和呈现.</span>\n\n&nbsp;\n\n<span style=\"font-size: 14px;\">这里的结论：</span>\n\n<span style=\"font-size: 14px;\">1 在head里面尽量不要引入javascript.</span>\n\n<span style=\"font-size: 14px;\">2 如果要引入js 尽量将js内嵌.</span>\n\n<span style=\"font-size: 14px;\">3 把内嵌js放在所有css的前面.</span>\n\n&nbsp;\n\n<strong><span style=\"color: #008080;\">后记</span></strong>\n\n<span style=\"font-size: 14px;\">1 本次的测试页面 </span><a href=\"http://1.lvming6816077.sinaapp.com/testaa/demo.html\">http://1.lvming6816077.sinaapp.com/testaa/demo.html</a>\n\n2 测试所用浏览器 chrome\n\n3 参考资料：<a href=\"http://www.zhihu.com/question/20357435/answer/14878543\">http://www.zhihu.com/question/20357435/answer/14878543</a>\n\n<a href=\"http://www.haorooms.com/post/web_xnyh_jscss\">http://www.haorooms.com/post/web_xnyh_jscss</a>\n\n4 如果有哪里说的不清楚或者错误的地方，欢迎留言反馈。","source":"_posts/web前端性能优化之Html-Css-Javascript.md","raw":"---\ntitle: web前端性能优化之Html Css Javascript\ndate: 2015-05-05 16:06:08\ntags:\n- 移动web\n- 性能优化\ncategories:\n- 530\n---\n<strong><span style=\"color: #008080;\">前言</span></strong>\n\nhtml css javascript可以算是前端必须掌握的东西了，但是我们的浏览器是怎样解析这些东西的呢 我们如何处理html css javascript这些东西来让我们的网页更加合理，在我这里做了一些实验，总结起来给大家看看。\n\n<!--more-->\n<strong><span style=\"color: #008080;\">最简单的页面</span></strong>\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>test</title>\n  </head>\n  <body>\n    <img src=\"download-button.png\">\n  </body>\n</html>\n```\n我们打开chrome的控制台查看timeline\n\n<img class=\"alignnone\" src=\"http://cdn.alloyteam.com/wp-content/uploads/2015/04/11.png\" alt=\"\" width=\"1073\" height=\"142\" />\n\n\n由上图 可得结论\n\n\n\n1 图中蓝色透明条标识浏览器从发起请求到接收到服务器返回第一个字节的时间，时间还是挺长的，而蓝色实体条则为真正的html页面下载的时间 还是很短的。\n\n\n2 图中红框内的这部分时间则表示浏览器从下载完成html之后开始构建dom，当发现一个image标签时所花费的时间，由此可见dom是顺序执行的，当发现image时便立即发起请求，而紫色透明条则是image发起请求时在网络传输时所消耗的时间。\n\n\n3 图中timeline蓝色竖线所处的时间为domComplete时间，红色竖线为dom的onload时间，由此可见两种事件的差异。而浏览器构建dom树所花费的时间可以算出即domComplete时间 减去 html下载完成后的时间大概80ms。\n\n\n<strong><span style=\"color: #008080;\">含有css的页面</span></strong>\n<pre class=\"lang:default decode:true  \">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;test&lt;/title&gt;\n    &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"stylesheet.css\" media=\"screen\"&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;img src=\"download-button.png\"&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</pre>\n我们打开chrome的控制台查看timeline\n\n<a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2015/05/2.png\"><img class=\"alignleft wp-image-623 size-full\" src=\"http://www.alloyteam.com/wp-content/uploads/2015/04/2.png\" alt=\"2\" width=\"1072\" height=\"196\" /></a>\n\n&nbsp;\n\n\n&nbsp;\n\n&nbsp;\n\n1 在添加了外部引入css之后，并没有发现什么异常，但是有一点指的注意，也就是红色竖线和蓝色竖线挨得更进了，这表明domComplete时间必须等待css解析完成，也就是构建dom树必须等待css解析完成，这也就解释了下图\n\n<a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2015/05/3.png\"><img class=\"alignnone wp-image-624 size-full\" src=\"http://www.alloyteam.com/wp-content/uploads/2015/04/3.png\" alt=\"3\" width=\"734\" height=\"348\" /></a>\n\n&nbsp;\n\n<hr />\n\n<strong><span style=\"color: #008080;\">含有javascript和css的页面</span></strong>\n<pre class=\"lang:default decode:true \">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;test&lt;/title&gt;\n      &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"stylesheet.css\" media=\"screen\"&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;img src=\"download-button.png\"&gt;\n  &lt;script type=\"text/javascript\" src=\"H5FullscreenPage.js\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</pre>\n&nbsp;\n\n我们打开chrome的控制台查看timeline\n\n<a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2015/05/4.png\"><img class=\"alignnone size-full wp-image-625\" src=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2015/05/4.png\" alt=\"4\" width=\"1221\" height=\"227\" /></a>\n\n&nbsp;\n\n1 图上显示在引入外部的js文件之后domComplete时间又被延后了，结合上面的renderTree，由于javascript代码可能会更改css属性或者是dom结构，所以在形成renderTree之前必须等待javascript解析完成才能接着构建renderTree。\n\n2 将javascript放在head内和body底部的区别也在于此，放在head里面，由于浏览器发现head里面有javascript标签就会暂时停止其他渲染行为，等待javascript下载并执行完成才能接着往下渲染，而这个时候由于在head里面这个时候页面是白的，如果将javascript放在页面底部，renderTree已经完成大部分，所以此时页面有内容呈现，即使遇到javascript阻塞渲染，也不会有白屏出现。\n\n<hr />\n\n<strong><span style=\"color: #008080;\">内嵌javascript的页面</span></strong>\n\n&nbsp;\n\n<a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2015/05/51.png\"><img class=\"alignnone size-full wp-image-626\" src=\"http://www.alloyteam.com/wp-content/uploads/2015/04/51.png\" alt=\"51\" width=\"1222\" height=\"213\" /></a>\n\n1 图上可以看到，由于内嵌了javascript，页面上减少了一个请求，导致html文档变大，消耗时间增多，但是domComplete时间提升的并不多。\n\n<hr />\n\n<span style=\"color: #008080;\"><strong>使用async的javascript</strong></span>\n<pre class=\"lang:default decode:true\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;test&lt;/title&gt;\n      &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"stylesheet.css\" media=\"screen\"&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;img src=\"download-button.png\"&gt;\n      &lt;script async src=\"H5FullscreenPage.js\" type =\"text/javascript\" &gt;&lt;/script &gt;\n  &lt;/body&gt;\n&lt;/html&gt;</pre>\n&nbsp;\n\n<a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2015/05/6.png\"><img class=\"alignnone size-full wp-image-627\" src=\"http://www.alloyteam.com/wp-content/uploads/2015/05/6.png\" alt=\"6\" width=\"1215\" height=\"348\" /></a>\n\n1 可以看到domComplete时间被大大提前 javascript也没有阻塞css和body里面img元素的并行下载。\n\n2 使用<a href=\"http://www.w3school.com.cn/tags/att_script_async.asp\">async</a>标识的script，浏览器将异步执行这中script不会阻塞正常的dom渲染，这时html5所支持的属性，另外<a href=\"http://www.w3school.com.cn/tags/att_script_defer.asp\">defer</a>也可以达到这种效果。\n\n<hr />\n\n<strong><span style=\"color: #008080;\">head里面js和css加载的关系</span></strong>\n\n<strong>外联js在css前面</strong>\n<pre class=\"lang:default decode:true\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;test&lt;/title&gt;\n      &lt;script src=\"H5FullscreenPage.js\" type =\"text/javascript\" &gt;&lt;/script &gt;\n      &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"stylesheet.css\" media=\"screen\"&gt;\n      &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"page-animation.css\" media=\"screen\"&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;img src=\"download-button.png\"&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</pre>\n<img class=\"alignnone\" style=\"height: 442px; width: 1221px;\" src=\"http://1.lvming6816077.sinaapp.com/testaa/xx1.png\" alt=\"\" />\n\n1 没有阻止css的并行加载但是影响了body里面img的并行加载\n\n<hr />\n\n<strong>外联js在css中间</strong>\n<pre class=\"lang:default decode:true\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;test&lt;/title&gt;\n      &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"stylesheet.css\" media=\"screen\"&gt;\n      &lt;script src=\"H5FullscreenPage.js\" type =\"text/javascript\" &gt;&lt;/script &gt;\n      &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"page-animation.css\" media=\"screen\"&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;img src=\"download-button.png\"&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</pre>\n<img class=\"alignnone\" style=\"height: 382px; width: 1208px;\" src=\"http://1.lvming6816077.sinaapp.com/testaa/xx2.png\" alt=\"\" />\n\n1 影响了css的并行加载和body里面img的并行加载\n\n<hr />\n\n<strong>外联js在css最后</strong>\n<pre class=\"lang:default decode:true \">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;test&lt;/title&gt;\n      &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"stylesheet.css\" media=\"screen\"&gt;\n      &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"page-animation.css\" media=\"screen\"&gt;\n      &lt;script src=\"H5FullscreenPage.js\" type =\"text/javascript\" &gt;&lt;/script &gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;img src=\"download-button.png\"&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</pre>\n&nbsp;\n\n<img class=\"alignnone\" style=\"height: 346px; width: 1228px;\" src=\"http://1.lvming6816077.sinaapp.com/testaa/xx3.png\" alt=\"\" />\n\n1 影响了css的并行加载和body里面img的并行加载\n\n<hr />\n\n<strong>内嵌js在css前面</strong>\n<pre class=\"lang:default decode:true \">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;test&lt;/title&gt;\n      &lt;script type =\"text/javascript\" &gt;\n      \tvar f = 1;\n          f++;\n      &lt;/script &gt;\n      &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"stylesheet.css\" media=\"screen\"&gt;\n      &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"page-animation.css\" media=\"screen\"&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;img src=\"download-button.png\"&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</pre>\n&nbsp;\n\n<img class=\"alignnone\" style=\"height: 451px; width: 1229px;\" src=\"http://1.lvming6816077.sinaapp.com/testaa/xx4.png\" alt=\"\" />\n\n1 没有影响css的并行加载也没有影响body里面img的并行加载\n\n<hr />\n\n<strong>内嵌js在css中间</strong>\n<pre class=\"lang:default decode:true \">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;test&lt;/title&gt;\n      &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"stylesheet.css\" media=\"screen\"&gt;\n      &lt;script type =\"text/javascript\" &gt;\n      \tvar f = 1;\n          f++;\n      &lt;/script &gt;\n      &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"page-animation.css\" media=\"screen\"&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;img src=\"download-button.png\"&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</pre>\n&nbsp;\n\n<img class=\"alignnone\" style=\"height: 437px; width: 1219px;\" src=\"http://1.lvming6816077.sinaapp.com/testaa/xx5.png\" alt=\"\" />\n\n1 影响了css的并行加载没有英雄body里面img的并行加载\n\n<hr />\n\n<strong>内嵌js在css最后</strong>\n<pre class=\"lang:default decode:true \">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;test&lt;/title&gt;\n      &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"stylesheet.css\" media=\"screen\"&gt;\n      &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"page-animation.css\" media=\"screen\"&gt;\n      &lt;script type =\"text/javascript\" &gt;\n      \tvar f = 1;\n          f++;\n      &lt;/script &gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;img src=\"download-button.png\"&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</pre>\n&nbsp;\n\n<img class=\"alignnone\" style=\"height: 350px; width: 1228px;\" src=\"http://1.lvming6816077.sinaapp.com/testaa/xx6.png\" alt=\"\" />\n\n1 影响了css和body里面img的并行加载。\n\n<hr />\n\n<strong>综上所述：</strong>\n\n<span style=\"font-family: verdana,arial,helvetica,sans-serif; font-size: 14px;\">当浏览器从服务器接收到了HTML文档，并把HTML在内存中转换成DOM树，在转换的过程中如果发现某个节点(node)上引用了CSS或者 IMAGE，就会再发1个request去请求CSS或image,然后继续执行下面的转换，而不需要等待request的返回，当request返回 后，只需要把返回的内容放入到DOM树中对应的位置就OK。但当引用了JS的时候，浏览器发送1个js request就会一直等待该request的返回。因为浏览器需要1个稳定的DOM树结构，而JS中很有可能有代码直接改变了DOM树结构，浏览器为了防止出现JS修改DOM树，需要重新构建DOM树的情况，所以 就会阻塞其他的下载和呈现.</span>\n\n&nbsp;\n\n<span style=\"font-size: 14px;\">这里的结论：</span>\n\n<span style=\"font-size: 14px;\">1 在head里面尽量不要引入javascript.</span>\n\n<span style=\"font-size: 14px;\">2 如果要引入js 尽量将js内嵌.</span>\n\n<span style=\"font-size: 14px;\">3 把内嵌js放在所有css的前面.</span>\n\n&nbsp;\n\n<strong><span style=\"color: #008080;\">后记</span></strong>\n\n<span style=\"font-size: 14px;\">1 本次的测试页面 </span><a href=\"http://1.lvming6816077.sinaapp.com/testaa/demo.html\">http://1.lvming6816077.sinaapp.com/testaa/demo.html</a>\n\n2 测试所用浏览器 chrome\n\n3 参考资料：<a href=\"http://www.zhihu.com/question/20357435/answer/14878543\">http://www.zhihu.com/question/20357435/answer/14878543</a>\n\n<a href=\"http://www.haorooms.com/post/web_xnyh_jscss\">http://www.haorooms.com/post/web_xnyh_jscss</a>\n\n4 如果有哪里说的不清楚或者错误的地方，欢迎留言反馈。","slug":"web前端性能优化之Html-Css-Javascript","published":1,"updated":"2017-04-30T09:25:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434q0s002b2wvjmdl85e6d","content":"<p><strong><span style=\"color: #008080;\">前言</span></strong></p>\n<p>html css javascript可以算是前端必须掌握的东西了，但是我们的浏览器是怎样解析这些东西的呢 我们如何处理html css javascript这些东西来让我们的网页更加合理，在我这里做了一些实验，总结起来给大家看看。</p>\n<a id=\"more\"></a>\n<p><strong><span style=\"color: #008080;\">最简单的页面</span></strong><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"download-button.png\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>我们打开chrome的控制台查看timeline</p>\n<p><img class=\"alignnone\" src=\"http://cdn.alloyteam.com/wp-content/uploads/2015/04/11.png\" alt width=\"1073\" height=\"142\"></p>\n<p>由上图 可得结论</p>\n<p>1 图中蓝色透明条标识浏览器从发起请求到接收到服务器返回第一个字节的时间，时间还是挺长的，而蓝色实体条则为真正的html页面下载的时间 还是很短的。</p>\n<p>2 图中红框内的这部分时间则表示浏览器从下载完成html之后开始构建dom，当发现一个image标签时所花费的时间，由此可见dom是顺序执行的，当发现image时便立即发起请求，而紫色透明条则是image发起请求时在网络传输时所消耗的时间。</p>\n<p>3 图中timeline蓝色竖线所处的时间为domComplete时间，红色竖线为dom的onload时间，由此可见两种事件的差异。而浏览器构建dom树所花费的时间可以算出即domComplete时间 减去 html下载完成后的时间大概80ms。</p>\n<p><strong><span style=\"color: #008080;\">含有css的页面</span></strong></p>\n<p><pre class=\"lang:default decode:true  \">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;test&lt;/title&gt;<br>    &lt;link rel=”stylesheet” type=”text/css” href=”stylesheet.css” media=”screen”&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;img src=”download-button.png”&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;</pre><br>我们打开chrome的控制台查看timeline</p>\n<p><a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2015/05/2.png\"><img class=\"alignleft wp-image-623 size-full\" src=\"http://www.alloyteam.com/wp-content/uploads/2015/04/2.png\" alt=\"2\" width=\"1072\" height=\"196\"></a></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>1 在添加了外部引入css之后，并没有发现什么异常，但是有一点指的注意，也就是红色竖线和蓝色竖线挨得更进了，这表明domComplete时间必须等待css解析完成，也就是构建dom树必须等待css解析完成，这也就解释了下图</p>\n<p><a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2015/05/3.png\"><img class=\"alignnone wp-image-624 size-full\" src=\"http://www.alloyteam.com/wp-content/uploads/2015/04/3.png\" alt=\"3\" width=\"734\" height=\"348\"></a></p>\n<p>&nbsp;</p>\n<hr>\n\n<p><strong><span style=\"color: #008080;\">含有javascript和css的页面</span></strong></p>\n<p><pre class=\"lang:default decode:true \">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;test&lt;/title&gt;<br>      &lt;link rel=”stylesheet” type=”text/css” href=”stylesheet.css” media=”screen”&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;img src=”download-button.png”&gt;<br>  &lt;script type=”text/javascript” src=”H5FullscreenPage.js”&gt;&lt;/script&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;</pre><br>&nbsp;</p>\n<p>我们打开chrome的控制台查看timeline</p>\n<p><a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2015/05/4.png\"><img class=\"alignnone size-full wp-image-625\" src=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2015/05/4.png\" alt=\"4\" width=\"1221\" height=\"227\"></a></p>\n<p>&nbsp;</p>\n<p>1 图上显示在引入外部的js文件之后domComplete时间又被延后了，结合上面的renderTree，由于javascript代码可能会更改css属性或者是dom结构，所以在形成renderTree之前必须等待javascript解析完成才能接着构建renderTree。</p>\n<p>2 将javascript放在head内和body底部的区别也在于此，放在head里面，由于浏览器发现head里面有javascript标签就会暂时停止其他渲染行为，等待javascript下载并执行完成才能接着往下渲染，而这个时候由于在head里面这个时候页面是白的，如果将javascript放在页面底部，renderTree已经完成大部分，所以此时页面有内容呈现，即使遇到javascript阻塞渲染，也不会有白屏出现。</p>\n<hr>\n\n<p><strong><span style=\"color: #008080;\">内嵌javascript的页面</span></strong></p>\n<p>&nbsp;</p>\n<p><a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2015/05/51.png\"><img class=\"alignnone size-full wp-image-626\" src=\"http://www.alloyteam.com/wp-content/uploads/2015/04/51.png\" alt=\"51\" width=\"1222\" height=\"213\"></a></p>\n<p>1 图上可以看到，由于内嵌了javascript，页面上减少了一个请求，导致html文档变大，消耗时间增多，但是domComplete时间提升的并不多。</p>\n<hr>\n\n<p><span style=\"color: #008080;\"><strong>使用async的javascript</strong></span></p>\n<p><pre class=\"lang:default decode:true\">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;test&lt;/title&gt;<br>      &lt;link rel=”stylesheet” type=”text/css” href=”stylesheet.css” media=”screen”&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;img src=”download-button.png”&gt;<br>      &lt;script async src=”H5FullscreenPage.js” type =”text/javascript” &gt;&lt;/script &gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;</pre><br>&nbsp;</p>\n<p><a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2015/05/6.png\"><img class=\"alignnone size-full wp-image-627\" src=\"http://www.alloyteam.com/wp-content/uploads/2015/05/6.png\" alt=\"6\" width=\"1215\" height=\"348\"></a></p>\n<p>1 可以看到domComplete时间被大大提前 javascript也没有阻塞css和body里面img元素的并行下载。</p>\n<p>2 使用<a href=\"http://www.w3school.com.cn/tags/att_script_async.asp\" target=\"_blank\" rel=\"noopener\">async</a>标识的script，浏览器将异步执行这中script不会阻塞正常的dom渲染，这时html5所支持的属性，另外<a href=\"http://www.w3school.com.cn/tags/att_script_defer.asp\" target=\"_blank\" rel=\"noopener\">defer</a>也可以达到这种效果。</p>\n<hr>\n\n<p><strong><span style=\"color: #008080;\">head里面js和css加载的关系</span></strong></p>\n<p><strong>外联js在css前面</strong></p>\n<p><pre class=\"lang:default decode:true\">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;test&lt;/title&gt;<br>      &lt;script src=”H5FullscreenPage.js” type =”text/javascript” &gt;&lt;/script &gt;<br>      &lt;link rel=”stylesheet” type=”text/css” href=”stylesheet.css” media=”screen”&gt;<br>      &lt;link rel=”stylesheet” type=”text/css” href=”page-animation.css” media=”screen”&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;img src=”download-button.png”&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;</pre><br><img class=\"alignnone\" style=\"height: 442px; width: 1221px;\" src=\"http://1.lvming6816077.sinaapp.com/testaa/xx1.png\" alt></p>\n<p>1 没有阻止css的并行加载但是影响了body里面img的并行加载</p>\n<hr>\n\n<p><strong>外联js在css中间</strong></p>\n<p><pre class=\"lang:default decode:true\">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;test&lt;/title&gt;<br>      &lt;link rel=”stylesheet” type=”text/css” href=”stylesheet.css” media=”screen”&gt;<br>      &lt;script src=”H5FullscreenPage.js” type =”text/javascript” &gt;&lt;/script &gt;<br>      &lt;link rel=”stylesheet” type=”text/css” href=”page-animation.css” media=”screen”&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;img src=”download-button.png”&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;</pre><br><img class=\"alignnone\" style=\"height: 382px; width: 1208px;\" src=\"http://1.lvming6816077.sinaapp.com/testaa/xx2.png\" alt></p>\n<p>1 影响了css的并行加载和body里面img的并行加载</p>\n<hr>\n\n<p><strong>外联js在css最后</strong></p>\n<p><pre class=\"lang:default decode:true \">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;test&lt;/title&gt;<br>      &lt;link rel=”stylesheet” type=”text/css” href=”stylesheet.css” media=”screen”&gt;<br>      &lt;link rel=”stylesheet” type=”text/css” href=”page-animation.css” media=”screen”&gt;<br>      &lt;script src=”H5FullscreenPage.js” type =”text/javascript” &gt;&lt;/script &gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;img src=”download-button.png”&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;</pre><br>&nbsp;</p>\n<p><img class=\"alignnone\" style=\"height: 346px; width: 1228px;\" src=\"http://1.lvming6816077.sinaapp.com/testaa/xx3.png\" alt></p>\n<p>1 影响了css的并行加载和body里面img的并行加载</p>\n<hr>\n\n<p><strong>内嵌js在css前面</strong></p>\n<p><pre class=\"lang:default decode:true \">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;test&lt;/title&gt;<br>      &lt;script type =”text/javascript” &gt;<br>          var f = 1;<br>          f++;<br>      &lt;/script &gt;<br>      &lt;link rel=”stylesheet” type=”text/css” href=”stylesheet.css” media=”screen”&gt;<br>      &lt;link rel=”stylesheet” type=”text/css” href=”page-animation.css” media=”screen”&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;img src=”download-button.png”&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;</pre><br>&nbsp;</p>\n<p><img class=\"alignnone\" style=\"height: 451px; width: 1229px;\" src=\"http://1.lvming6816077.sinaapp.com/testaa/xx4.png\" alt></p>\n<p>1 没有影响css的并行加载也没有影响body里面img的并行加载</p>\n<hr>\n\n<p><strong>内嵌js在css中间</strong></p>\n<p><pre class=\"lang:default decode:true \">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;test&lt;/title&gt;<br>      &lt;link rel=”stylesheet” type=”text/css” href=”stylesheet.css” media=”screen”&gt;<br>      &lt;script type =”text/javascript” &gt;<br>          var f = 1;<br>          f++;<br>      &lt;/script &gt;<br>      &lt;link rel=”stylesheet” type=”text/css” href=”page-animation.css” media=”screen”&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;img src=”download-button.png”&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;</pre><br>&nbsp;</p>\n<p><img class=\"alignnone\" style=\"height: 437px; width: 1219px;\" src=\"http://1.lvming6816077.sinaapp.com/testaa/xx5.png\" alt></p>\n<p>1 影响了css的并行加载没有英雄body里面img的并行加载</p>\n<hr>\n\n<p><strong>内嵌js在css最后</strong></p>\n<p><pre class=\"lang:default decode:true \">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;test&lt;/title&gt;<br>      &lt;link rel=”stylesheet” type=”text/css” href=”stylesheet.css” media=”screen”&gt;<br>      &lt;link rel=”stylesheet” type=”text/css” href=”page-animation.css” media=”screen”&gt;<br>      &lt;script type =”text/javascript” &gt;<br>          var f = 1;<br>          f++;<br>      &lt;/script &gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;img src=”download-button.png”&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;</pre><br>&nbsp;</p>\n<p><img class=\"alignnone\" style=\"height: 350px; width: 1228px;\" src=\"http://1.lvming6816077.sinaapp.com/testaa/xx6.png\" alt></p>\n<p>1 影响了css和body里面img的并行加载。</p>\n<hr>\n\n<p><strong>综上所述：</strong></p>\n<p><span style=\"font-family: verdana,arial,helvetica,sans-serif; font-size: 14px;\">当浏览器从服务器接收到了HTML文档，并把HTML在内存中转换成DOM树，在转换的过程中如果发现某个节点(node)上引用了CSS或者 IMAGE，就会再发1个request去请求CSS或image,然后继续执行下面的转换，而不需要等待request的返回，当request返回 后，只需要把返回的内容放入到DOM树中对应的位置就OK。但当引用了JS的时候，浏览器发送1个js request就会一直等待该request的返回。因为浏览器需要1个稳定的DOM树结构，而JS中很有可能有代码直接改变了DOM树结构，浏览器为了防止出现JS修改DOM树，需要重新构建DOM树的情况，所以 就会阻塞其他的下载和呈现.</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-size: 14px;\">这里的结论：</span></p>\n<p><span style=\"font-size: 14px;\">1 在head里面尽量不要引入javascript.</span></p>\n<p><span style=\"font-size: 14px;\">2 如果要引入js 尽量将js内嵌.</span></p>\n<p><span style=\"font-size: 14px;\">3 把内嵌js放在所有css的前面.</span></p>\n<p>&nbsp;</p>\n<p><strong><span style=\"color: #008080;\">后记</span></strong></p>\n<p><span style=\"font-size: 14px;\">1 本次的测试页面 </span><a href=\"http://1.lvming6816077.sinaapp.com/testaa/demo.html\" target=\"_blank\" rel=\"noopener\">http://1.lvming6816077.sinaapp.com/testaa/demo.html</a></p>\n<p>2 测试所用浏览器 chrome</p>\n<p>3 参考资料：<a href=\"http://www.zhihu.com/question/20357435/answer/14878543\" target=\"_blank\" rel=\"noopener\">http://www.zhihu.com/question/20357435/answer/14878543</a></p>\n<p><a href=\"http://www.haorooms.com/post/web_xnyh_jscss\" target=\"_blank\" rel=\"noopener\">http://www.haorooms.com/post/web_xnyh_jscss</a></p>\n<p>4 如果有哪里说的不清楚或者错误的地方，欢迎留言反馈。</p>\n","site":{"data":{}},"excerpt":"<p><strong><span style=\"color: #008080;\">前言</span></strong></p>\n<p>html css javascript可以算是前端必须掌握的东西了，但是我们的浏览器是怎样解析这些东西的呢 我们如何处理html css javascript这些东西来让我们的网页更加合理，在我这里做了一些实验，总结起来给大家看看。</p>","more":"<p><strong><span style=\"color: #008080;\">最简单的页面</span></strong><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"download-button.png\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>我们打开chrome的控制台查看timeline</p>\n<p><img class=\"alignnone\" src=\"http://cdn.alloyteam.com/wp-content/uploads/2015/04/11.png\" alt=\"\" width=\"1073\" height=\"142\"></p>\n<p>由上图 可得结论</p>\n<p>1 图中蓝色透明条标识浏览器从发起请求到接收到服务器返回第一个字节的时间，时间还是挺长的，而蓝色实体条则为真正的html页面下载的时间 还是很短的。</p>\n<p>2 图中红框内的这部分时间则表示浏览器从下载完成html之后开始构建dom，当发现一个image标签时所花费的时间，由此可见dom是顺序执行的，当发现image时便立即发起请求，而紫色透明条则是image发起请求时在网络传输时所消耗的时间。</p>\n<p>3 图中timeline蓝色竖线所处的时间为domComplete时间，红色竖线为dom的onload时间，由此可见两种事件的差异。而浏览器构建dom树所花费的时间可以算出即domComplete时间 减去 html下载完成后的时间大概80ms。</p>\n<p><strong><span style=\"color: #008080;\">含有css的页面</span></strong></p>\n<p><pre class=\"lang:default decode:true  \">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;test&lt;/title&gt;<br>    &lt;link rel=”stylesheet” type=”text/css” href=”stylesheet.css” media=”screen”&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;img src=”download-button.png”&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;</pre><br>我们打开chrome的控制台查看timeline</p>\n<p><a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2015/05/2.png\"><img class=\"alignleft wp-image-623 size-full\" src=\"http://www.alloyteam.com/wp-content/uploads/2015/04/2.png\" alt=\"2\" width=\"1072\" height=\"196\"></a></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>1 在添加了外部引入css之后，并没有发现什么异常，但是有一点指的注意，也就是红色竖线和蓝色竖线挨得更进了，这表明domComplete时间必须等待css解析完成，也就是构建dom树必须等待css解析完成，这也就解释了下图</p>\n<p><a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2015/05/3.png\"><img class=\"alignnone wp-image-624 size-full\" src=\"http://www.alloyteam.com/wp-content/uploads/2015/04/3.png\" alt=\"3\" width=\"734\" height=\"348\"></a></p>\n<p>&nbsp;</p>\n<hr>\n\n<p><strong><span style=\"color: #008080;\">含有javascript和css的页面</span></strong></p>\n<p><pre class=\"lang:default decode:true \">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;test&lt;/title&gt;<br>      &lt;link rel=”stylesheet” type=”text/css” href=”stylesheet.css” media=”screen”&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;img src=”download-button.png”&gt;<br>  &lt;script type=”text/javascript” src=”H5FullscreenPage.js”&gt;&lt;/script&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;</pre><br>&nbsp;</p>\n<p>我们打开chrome的控制台查看timeline</p>\n<p><a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2015/05/4.png\"><img class=\"alignnone size-full wp-image-625\" src=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2015/05/4.png\" alt=\"4\" width=\"1221\" height=\"227\"></a></p>\n<p>&nbsp;</p>\n<p>1 图上显示在引入外部的js文件之后domComplete时间又被延后了，结合上面的renderTree，由于javascript代码可能会更改css属性或者是dom结构，所以在形成renderTree之前必须等待javascript解析完成才能接着构建renderTree。</p>\n<p>2 将javascript放在head内和body底部的区别也在于此，放在head里面，由于浏览器发现head里面有javascript标签就会暂时停止其他渲染行为，等待javascript下载并执行完成才能接着往下渲染，而这个时候由于在head里面这个时候页面是白的，如果将javascript放在页面底部，renderTree已经完成大部分，所以此时页面有内容呈现，即使遇到javascript阻塞渲染，也不会有白屏出现。</p>\n<hr>\n\n<p><strong><span style=\"color: #008080;\">内嵌javascript的页面</span></strong></p>\n<p>&nbsp;</p>\n<p><a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2015/05/51.png\"><img class=\"alignnone size-full wp-image-626\" src=\"http://www.alloyteam.com/wp-content/uploads/2015/04/51.png\" alt=\"51\" width=\"1222\" height=\"213\"></a></p>\n<p>1 图上可以看到，由于内嵌了javascript，页面上减少了一个请求，导致html文档变大，消耗时间增多，但是domComplete时间提升的并不多。</p>\n<hr>\n\n<p><span style=\"color: #008080;\"><strong>使用async的javascript</strong></span></p>\n<p><pre class=\"lang:default decode:true\">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;test&lt;/title&gt;<br>      &lt;link rel=”stylesheet” type=”text/css” href=”stylesheet.css” media=”screen”&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;img src=”download-button.png”&gt;<br>      &lt;script async src=”H5FullscreenPage.js” type =”text/javascript” &gt;&lt;/script &gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;</pre><br>&nbsp;</p>\n<p><a href=\"http://www.nihaoshijie.com.cn/wp-content/uploads/2015/05/6.png\"><img class=\"alignnone size-full wp-image-627\" src=\"http://www.alloyteam.com/wp-content/uploads/2015/05/6.png\" alt=\"6\" width=\"1215\" height=\"348\"></a></p>\n<p>1 可以看到domComplete时间被大大提前 javascript也没有阻塞css和body里面img元素的并行下载。</p>\n<p>2 使用<a href=\"http://www.w3school.com.cn/tags/att_script_async.asp\" target=\"_blank\" rel=\"noopener\">async</a>标识的script，浏览器将异步执行这中script不会阻塞正常的dom渲染，这时html5所支持的属性，另外<a href=\"http://www.w3school.com.cn/tags/att_script_defer.asp\" target=\"_blank\" rel=\"noopener\">defer</a>也可以达到这种效果。</p>\n<hr>\n\n<p><strong><span style=\"color: #008080;\">head里面js和css加载的关系</span></strong></p>\n<p><strong>外联js在css前面</strong></p>\n<p><pre class=\"lang:default decode:true\">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;test&lt;/title&gt;<br>      &lt;script src=”H5FullscreenPage.js” type =”text/javascript” &gt;&lt;/script &gt;<br>      &lt;link rel=”stylesheet” type=”text/css” href=”stylesheet.css” media=”screen”&gt;<br>      &lt;link rel=”stylesheet” type=”text/css” href=”page-animation.css” media=”screen”&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;img src=”download-button.png”&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;</pre><br><img class=\"alignnone\" style=\"height: 442px; width: 1221px;\" src=\"http://1.lvming6816077.sinaapp.com/testaa/xx1.png\" alt=\"\"></p>\n<p>1 没有阻止css的并行加载但是影响了body里面img的并行加载</p>\n<hr>\n\n<p><strong>外联js在css中间</strong></p>\n<p><pre class=\"lang:default decode:true\">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;test&lt;/title&gt;<br>      &lt;link rel=”stylesheet” type=”text/css” href=”stylesheet.css” media=”screen”&gt;<br>      &lt;script src=”H5FullscreenPage.js” type =”text/javascript” &gt;&lt;/script &gt;<br>      &lt;link rel=”stylesheet” type=”text/css” href=”page-animation.css” media=”screen”&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;img src=”download-button.png”&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;</pre><br><img class=\"alignnone\" style=\"height: 382px; width: 1208px;\" src=\"http://1.lvming6816077.sinaapp.com/testaa/xx2.png\" alt=\"\"></p>\n<p>1 影响了css的并行加载和body里面img的并行加载</p>\n<hr>\n\n<p><strong>外联js在css最后</strong></p>\n<p><pre class=\"lang:default decode:true \">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;test&lt;/title&gt;<br>      &lt;link rel=”stylesheet” type=”text/css” href=”stylesheet.css” media=”screen”&gt;<br>      &lt;link rel=”stylesheet” type=”text/css” href=”page-animation.css” media=”screen”&gt;<br>      &lt;script src=”H5FullscreenPage.js” type =”text/javascript” &gt;&lt;/script &gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;img src=”download-button.png”&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;</pre><br>&nbsp;</p>\n<p><img class=\"alignnone\" style=\"height: 346px; width: 1228px;\" src=\"http://1.lvming6816077.sinaapp.com/testaa/xx3.png\" alt=\"\"></p>\n<p>1 影响了css的并行加载和body里面img的并行加载</p>\n<hr>\n\n<p><strong>内嵌js在css前面</strong></p>\n<p><pre class=\"lang:default decode:true \">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;test&lt;/title&gt;<br>      &lt;script type =”text/javascript” &gt;<br>          var f = 1;<br>          f++;<br>      &lt;/script &gt;<br>      &lt;link rel=”stylesheet” type=”text/css” href=”stylesheet.css” media=”screen”&gt;<br>      &lt;link rel=”stylesheet” type=”text/css” href=”page-animation.css” media=”screen”&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;img src=”download-button.png”&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;</pre><br>&nbsp;</p>\n<p><img class=\"alignnone\" style=\"height: 451px; width: 1229px;\" src=\"http://1.lvming6816077.sinaapp.com/testaa/xx4.png\" alt=\"\"></p>\n<p>1 没有影响css的并行加载也没有影响body里面img的并行加载</p>\n<hr>\n\n<p><strong>内嵌js在css中间</strong></p>\n<p><pre class=\"lang:default decode:true \">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;test&lt;/title&gt;<br>      &lt;link rel=”stylesheet” type=”text/css” href=”stylesheet.css” media=”screen”&gt;<br>      &lt;script type =”text/javascript” &gt;<br>          var f = 1;<br>          f++;<br>      &lt;/script &gt;<br>      &lt;link rel=”stylesheet” type=”text/css” href=”page-animation.css” media=”screen”&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;img src=”download-button.png”&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;</pre><br>&nbsp;</p>\n<p><img class=\"alignnone\" style=\"height: 437px; width: 1219px;\" src=\"http://1.lvming6816077.sinaapp.com/testaa/xx5.png\" alt=\"\"></p>\n<p>1 影响了css的并行加载没有英雄body里面img的并行加载</p>\n<hr>\n\n<p><strong>内嵌js在css最后</strong></p>\n<p><pre class=\"lang:default decode:true \">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;test&lt;/title&gt;<br>      &lt;link rel=”stylesheet” type=”text/css” href=”stylesheet.css” media=”screen”&gt;<br>      &lt;link rel=”stylesheet” type=”text/css” href=”page-animation.css” media=”screen”&gt;<br>      &lt;script type =”text/javascript” &gt;<br>          var f = 1;<br>          f++;<br>      &lt;/script &gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;img src=”download-button.png”&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;</pre><br>&nbsp;</p>\n<p><img class=\"alignnone\" style=\"height: 350px; width: 1228px;\" src=\"http://1.lvming6816077.sinaapp.com/testaa/xx6.png\" alt=\"\"></p>\n<p>1 影响了css和body里面img的并行加载。</p>\n<hr>\n\n<p><strong>综上所述：</strong></p>\n<p><span style=\"font-family: verdana,arial,helvetica,sans-serif; font-size: 14px;\">当浏览器从服务器接收到了HTML文档，并把HTML在内存中转换成DOM树，在转换的过程中如果发现某个节点(node)上引用了CSS或者 IMAGE，就会再发1个request去请求CSS或image,然后继续执行下面的转换，而不需要等待request的返回，当request返回 后，只需要把返回的内容放入到DOM树中对应的位置就OK。但当引用了JS的时候，浏览器发送1个js request就会一直等待该request的返回。因为浏览器需要1个稳定的DOM树结构，而JS中很有可能有代码直接改变了DOM树结构，浏览器为了防止出现JS修改DOM树，需要重新构建DOM树的情况，所以 就会阻塞其他的下载和呈现.</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-size: 14px;\">这里的结论：</span></p>\n<p><span style=\"font-size: 14px;\">1 在head里面尽量不要引入javascript.</span></p>\n<p><span style=\"font-size: 14px;\">2 如果要引入js 尽量将js内嵌.</span></p>\n<p><span style=\"font-size: 14px;\">3 把内嵌js放在所有css的前面.</span></p>\n<p>&nbsp;</p>\n<p><strong><span style=\"color: #008080;\">后记</span></strong></p>\n<p><span style=\"font-size: 14px;\">1 本次的测试页面 </span><a href=\"http://1.lvming6816077.sinaapp.com/testaa/demo.html\" target=\"_blank\" rel=\"noopener\">http://1.lvming6816077.sinaapp.com/testaa/demo.html</a></p>\n<p>2 测试所用浏览器 chrome</p>\n<p>3 参考资料：<a href=\"http://www.zhihu.com/question/20357435/answer/14878543\" target=\"_blank\" rel=\"noopener\">http://www.zhihu.com/question/20357435/answer/14878543</a></p>\n<p><a href=\"http://www.haorooms.com/post/web_xnyh_jscss\" target=\"_blank\" rel=\"noopener\">http://www.haorooms.com/post/web_xnyh_jscss</a></p>\n<p>4 如果有哪里说的不清楚或者错误的地方，欢迎留言反馈。</p>"},{"title":"关于浏览器的工作原理","date":"2014-07-24T09:17:59.000Z","_content":"看过不少文章之后，自己也想尝试写下浏览器到底是如何解析页面的，这对前端工程师来说，应该也算有点帮助。\n\n\n<h2>什么是渲染引擎？</h2>\n大家都见过webkit吧，有时候我们在写css3时需要兼容不同浏览器，所以就要写不同的前缀，那么这个webkit就是一种渲染引擎，不同的浏览器可能有不同的渲染引擎,下面只列出一些常用的。\n<!--more-->\n<strong>Trident：</strong>\n\n<span style=\"color: #323e32;\">· Internet Explorer（IE）</span><br style=\"color: #323e32;\" /><span style=\"color: #323e32;\">· 傲游</span><br style=\"color: #323e32;\" />\n<strong>Gecko：</strong>\n\n<span style=\"color: #323e32;\">· Firefox</span><br style=\"color: #323e32;\" /><span style=\"color: #323e32;\">· 网景（6至9）</span><br style=\"color: #323e32;\" />\n<strong>KHTML(webkit):</strong>\n\n<span style=\"color: #323e32;\">· Safari</span><br style=\"color: #323e32;\" /><span style=\"color: #323e32;\">· Google Chrome</span><br style=\"color: #323e32;\" />\n<strong><span style=\"color: #000000;\">Presto：</span></strong>\n\n<span style=\"color: #323e32;\">· <span style=\"color: #000000;\">Opera</span></span>\n\n其中，渲染引擎包括了浏览器的核心功能，例如html解释器，css解释器，布局和javascript引擎，例如webkit所用的js引擎就是大名鼎鼎的v8，正是由于浏览器所用的渲染引擎不同，才导致了那么多的浏览器兼容性问题。\n\n&nbsp;\n<h2>浏览器是如何工作的：</h2>\n<img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/webprocess.png\" alt=\"\" width=\"800\" height=\"311\" />\n\n上面这个图是我从网上找过之后修改的。\n\n首先流程说一下：\n\n1. 当浏览器通过网络下载到html页面后，开始进行解析，首先要经过html解释器。\n\n2. 在解析html时，发现了css标签和javascript标签，便调用css解释器和javascript引擎，而在解析html的同时，会把html生成dom树。\n\n3. 由于javascript可能对html页面进行修改，所以javascript引擎，html页面，dom树3个是循环过程。\n\n4. css解释器在工作的时候例如webkit css phaser，可以看下图：\n\n<img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/css-phaser.png\" alt=\"\" width=\"500\" height=\"393\" />\n\n可以看到，对css的解析是分两条线，分别解析selectors和declaration最后把得到的结果加在dom树上。\n\n5.DOM之后，需要将其中的元素对象同样式信息结合起来，计算它们的大小位置等布局信息，形成一个能够表示这所有信息的内部表示模型。\n\n6. 把前几布的结果综合起来，就可以进行绘制，从而展现出页面。\n\n7. 最后解释图中虚线箭头的指向含义。它们表示在渲染过程中，每个阶段可能使用到的其他模块。在网页内容的下载中，需要使用到网络和存储，这个是显而易见地。但计算布局和绘图的时候，需要使用2D/3D的图形模块，同时因为要生成最后的可视化结果，这时候需要开始解码音频视频和图片，同其它内容一起绘制到最后的图像中。\n\n其中：\n\n<img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/20130921092322593.jpg\" alt=\"\" width=\"576\" height=\"96\" />\n\n就是渲染引擎 webkit。\n<h2>由此可见，可以总结出以下问题：</h2>\n1. 浏览器一般常驻3条线程：js引擎线程，GUI渲染线程，和浏览器事件触发线程。\n\n2. 其中GUI渲染线程和js引擎线程是互斥的，所以说，让浏览器解析js时，是无法继续渲染页面的，所以问题也就是一般吧js放在body底部的原因。\n\n3. 而为什么GUI渲染线程和js引擎线程是互斥的？我想是因为在解析js时，可能会对页面结构进行修改，所以渲染线程需要挂起，来等待js解析完毕才能执行页面渲染。\n\n4. css是并行加载的，但是并行也有加载限制，例如浏览器在对同一域名下下载css有个数限制，所以就会有一些静态文件需要放在不同的的域名下来加载，提高速度。可看下图：\n\n<img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/4d086e061d950a7b69e4cf8608d162d9f3d3c99b.jpg\" alt=\"\" width=\"262\" height=\"232\" />\n\n5. 在css里如果写import来引入，会打断css的并行下载，这样不利于页面渲染，和css的解析。\n\n6. reflow和repaint分别对应上个流程图的html解释和绘制阶段，所以：\n\n<ul>\n\t<li>当 DOM 元素的属性发生变化 (如 color) 时,而这些属性只是影响元素的外观风格，浏览器会通知 render 重描相应的元素，此过程称为 Repaint<b>。</b></li>\n\t<li>如果该次变化涉及元素布局 (如 width)，浏览器则抛弃原有属性，重新计算并把结果传递给 render 以重新描绘页面元素, 此过程称为 Reflow。</li>\n\t<li>Reflow必将引起Repaint，而Repaint不一定会引起Reflow 。</li>\n</ul>\n<h2>总结：</h2>\n\n同过了解浏览器的工作原理来对页面进行性能优化是必须的。\n\n\n参考：<a href=\"http://blog.csdn.net/milado_nju/article/details/11661311\" target=\"_blank\">http://blog.csdn.net/milado_nju/article/details/11661311</a>\n<p style=\"padding-left: 30px;\"><a href=\"http://wenku.baidu.com/link?url=__Ta164STKm3n2O4IL83jA7SFaou6ryqoD4Ii-LFJsJpHIDaZKQ2wHTdK5aw-06FGqOZ2dRYd5DmT87SeQAndfa5EMotGU_iyaCQKk4imtq\" target=\"_blank\">http://wenku.baidu.com/link?url=__Ta164STKm3n2O4IL83jA7SFaou6ryqoD4Ii-LFJsJpHIDaZKQ2wHTdK5aw-06FGqOZ2dRYd5DmT87SeQAndfa5EMotGU_iyaCQKk4imtq</a></p>\n&nbsp;","source":"_posts/关于浏览器的工作原理.md","raw":"---\ntitle: 关于浏览器的工作原理\ndate: 2014-07-24 17:17:59\ntags:\n- 浏览器\ncategories:\n- 322\n---\n看过不少文章之后，自己也想尝试写下浏览器到底是如何解析页面的，这对前端工程师来说，应该也算有点帮助。\n\n\n<h2>什么是渲染引擎？</h2>\n大家都见过webkit吧，有时候我们在写css3时需要兼容不同浏览器，所以就要写不同的前缀，那么这个webkit就是一种渲染引擎，不同的浏览器可能有不同的渲染引擎,下面只列出一些常用的。\n<!--more-->\n<strong>Trident：</strong>\n\n<span style=\"color: #323e32;\">· Internet Explorer（IE）</span><br style=\"color: #323e32;\" /><span style=\"color: #323e32;\">· 傲游</span><br style=\"color: #323e32;\" />\n<strong>Gecko：</strong>\n\n<span style=\"color: #323e32;\">· Firefox</span><br style=\"color: #323e32;\" /><span style=\"color: #323e32;\">· 网景（6至9）</span><br style=\"color: #323e32;\" />\n<strong>KHTML(webkit):</strong>\n\n<span style=\"color: #323e32;\">· Safari</span><br style=\"color: #323e32;\" /><span style=\"color: #323e32;\">· Google Chrome</span><br style=\"color: #323e32;\" />\n<strong><span style=\"color: #000000;\">Presto：</span></strong>\n\n<span style=\"color: #323e32;\">· <span style=\"color: #000000;\">Opera</span></span>\n\n其中，渲染引擎包括了浏览器的核心功能，例如html解释器，css解释器，布局和javascript引擎，例如webkit所用的js引擎就是大名鼎鼎的v8，正是由于浏览器所用的渲染引擎不同，才导致了那么多的浏览器兼容性问题。\n\n&nbsp;\n<h2>浏览器是如何工作的：</h2>\n<img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/webprocess.png\" alt=\"\" width=\"800\" height=\"311\" />\n\n上面这个图是我从网上找过之后修改的。\n\n首先流程说一下：\n\n1. 当浏览器通过网络下载到html页面后，开始进行解析，首先要经过html解释器。\n\n2. 在解析html时，发现了css标签和javascript标签，便调用css解释器和javascript引擎，而在解析html的同时，会把html生成dom树。\n\n3. 由于javascript可能对html页面进行修改，所以javascript引擎，html页面，dom树3个是循环过程。\n\n4. css解释器在工作的时候例如webkit css phaser，可以看下图：\n\n<img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/css-phaser.png\" alt=\"\" width=\"500\" height=\"393\" />\n\n可以看到，对css的解析是分两条线，分别解析selectors和declaration最后把得到的结果加在dom树上。\n\n5.DOM之后，需要将其中的元素对象同样式信息结合起来，计算它们的大小位置等布局信息，形成一个能够表示这所有信息的内部表示模型。\n\n6. 把前几布的结果综合起来，就可以进行绘制，从而展现出页面。\n\n7. 最后解释图中虚线箭头的指向含义。它们表示在渲染过程中，每个阶段可能使用到的其他模块。在网页内容的下载中，需要使用到网络和存储，这个是显而易见地。但计算布局和绘图的时候，需要使用2D/3D的图形模块，同时因为要生成最后的可视化结果，这时候需要开始解码音频视频和图片，同其它内容一起绘制到最后的图像中。\n\n其中：\n\n<img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/20130921092322593.jpg\" alt=\"\" width=\"576\" height=\"96\" />\n\n就是渲染引擎 webkit。\n<h2>由此可见，可以总结出以下问题：</h2>\n1. 浏览器一般常驻3条线程：js引擎线程，GUI渲染线程，和浏览器事件触发线程。\n\n2. 其中GUI渲染线程和js引擎线程是互斥的，所以说，让浏览器解析js时，是无法继续渲染页面的，所以问题也就是一般吧js放在body底部的原因。\n\n3. 而为什么GUI渲染线程和js引擎线程是互斥的？我想是因为在解析js时，可能会对页面结构进行修改，所以渲染线程需要挂起，来等待js解析完毕才能执行页面渲染。\n\n4. css是并行加载的，但是并行也有加载限制，例如浏览器在对同一域名下下载css有个数限制，所以就会有一些静态文件需要放在不同的的域名下来加载，提高速度。可看下图：\n\n<img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/4d086e061d950a7b69e4cf8608d162d9f3d3c99b.jpg\" alt=\"\" width=\"262\" height=\"232\" />\n\n5. 在css里如果写import来引入，会打断css的并行下载，这样不利于页面渲染，和css的解析。\n\n6. reflow和repaint分别对应上个流程图的html解释和绘制阶段，所以：\n\n<ul>\n\t<li>当 DOM 元素的属性发生变化 (如 color) 时,而这些属性只是影响元素的外观风格，浏览器会通知 render 重描相应的元素，此过程称为 Repaint<b>。</b></li>\n\t<li>如果该次变化涉及元素布局 (如 width)，浏览器则抛弃原有属性，重新计算并把结果传递给 render 以重新描绘页面元素, 此过程称为 Reflow。</li>\n\t<li>Reflow必将引起Repaint，而Repaint不一定会引起Reflow 。</li>\n</ul>\n<h2>总结：</h2>\n\n同过了解浏览器的工作原理来对页面进行性能优化是必须的。\n\n\n参考：<a href=\"http://blog.csdn.net/milado_nju/article/details/11661311\" target=\"_blank\">http://blog.csdn.net/milado_nju/article/details/11661311</a>\n<p style=\"padding-left: 30px;\"><a href=\"http://wenku.baidu.com/link?url=__Ta164STKm3n2O4IL83jA7SFaou6ryqoD4Ii-LFJsJpHIDaZKQ2wHTdK5aw-06FGqOZ2dRYd5DmT87SeQAndfa5EMotGU_iyaCQKk4imtq\" target=\"_blank\">http://wenku.baidu.com/link?url=__Ta164STKm3n2O4IL83jA7SFaou6ryqoD4Ii-LFJsJpHIDaZKQ2wHTdK5aw-06FGqOZ2dRYd5DmT87SeQAndfa5EMotGU_iyaCQKk4imtq</a></p>\n&nbsp;","slug":"关于浏览器的工作原理","published":1,"updated":"2019-04-02T16:52:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434q0u002e2wvjwswk0vbb","content":"<p>看过不少文章之后，自己也想尝试写下浏览器到底是如何解析页面的，这对前端工程师来说，应该也算有点帮助。</p>\n<h2><span id=\"什么是渲染引擎\">什么是渲染引擎？</span></h2><br>大家都见过webkit吧，有时候我们在写css3时需要兼容不同浏览器，所以就要写不同的前缀，那么这个webkit就是一种渲染引擎，不同的浏览器可能有不同的渲染引擎,下面只列出一些常用的。<br><a id=\"more\"></a><br><strong>Trident：</strong><br><br><span style=\"color: #323e32;\">· Internet Explorer（IE）</span><br style=\"color: #323e32;\"><span style=\"color: #323e32;\">· 傲游</span><br style=\"color: #323e32;\"><br><strong>Gecko：</strong><br><br><span style=\"color: #323e32;\">· Firefox</span><br style=\"color: #323e32;\"><span style=\"color: #323e32;\">· 网景（6至9）</span><br style=\"color: #323e32;\"><br><strong>KHTML(webkit):</strong><br><br><span style=\"color: #323e32;\">· Safari</span><br style=\"color: #323e32;\"><span style=\"color: #323e32;\">· Google Chrome</span><br style=\"color: #323e32;\"><br><strong><span style=\"color: #000000;\">Presto：</span></strong><br><br><span style=\"color: #323e32;\">· <span style=\"color: #000000;\">Opera</span></span><br><br>其中，渲染引擎包括了浏览器的核心功能，例如html解释器，css解释器，布局和javascript引擎，例如webkit所用的js引擎就是大名鼎鼎的v8，正是由于浏览器所用的渲染引擎不同，才导致了那么多的浏览器兼容性问题。<br><br>&nbsp;<br><h2><span id=\"浏览器是如何工作的\">浏览器是如何工作的：</span></h2><br><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/webprocess.png\" alt width=\"800\" height=\"311\"><br><br>上面这个图是我从网上找过之后修改的。<br><br>首先流程说一下：<br><br>1. 当浏览器通过网络下载到html页面后，开始进行解析，首先要经过html解释器。<br><br>2. 在解析html时，发现了css标签和javascript标签，便调用css解释器和javascript引擎，而在解析html的同时，会把html生成dom树。<br><br>3. 由于javascript可能对html页面进行修改，所以javascript引擎，html页面，dom树3个是循环过程。<br><br>4. css解释器在工作的时候例如webkit css phaser，可以看下图：<br><br><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/css-phaser.png\" alt width=\"500\" height=\"393\"><br><br>可以看到，对css的解析是分两条线，分别解析selectors和declaration最后把得到的结果加在dom树上。<br><br>5.DOM之后，需要将其中的元素对象同样式信息结合起来，计算它们的大小位置等布局信息，形成一个能够表示这所有信息的内部表示模型。<br><br>6. 把前几布的结果综合起来，就可以进行绘制，从而展现出页面。<br><br>7. 最后解释图中虚线箭头的指向含义。它们表示在渲染过程中，每个阶段可能使用到的其他模块。在网页内容的下载中，需要使用到网络和存储，这个是显而易见地。但计算布局和绘图的时候，需要使用2D/3D的图形模块，同时因为要生成最后的可视化结果，这时候需要开始解码音频视频和图片，同其它内容一起绘制到最后的图像中。<br><br>其中：<br><br><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/20130921092322593.jpg\" alt width=\"576\" height=\"96\"><br><br>就是渲染引擎 webkit。<br><h2><span id=\"由此可见可以总结出以下问题\">由此可见，可以总结出以下问题：</span></h2><br>1. 浏览器一般常驻3条线程：js引擎线程，GUI渲染线程，和浏览器事件触发线程。<br><br>2. 其中GUI渲染线程和js引擎线程是互斥的，所以说，让浏览器解析js时，是无法继续渲染页面的，所以问题也就是一般吧js放在body底部的原因。<br><br>3. 而为什么GUI渲染线程和js引擎线程是互斥的？我想是因为在解析js时，可能会对页面结构进行修改，所以渲染线程需要挂起，来等待js解析完毕才能执行页面渲染。<br><br>4. css是并行加载的，但是并行也有加载限制，例如浏览器在对同一域名下下载css有个数限制，所以就会有一些静态文件需要放在不同的的域名下来加载，提高速度。可看下图：<br><br><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/4d086e061d950a7b69e4cf8608d162d9f3d3c99b.jpg\" alt width=\"262\" height=\"232\"><br><br>5. 在css里如果写import来引入，会打断css的并行下载，这样不利于页面渲染，和css的解析。<br><br>6. reflow和repaint分别对应上个流程图的html解释和绘制阶段，所以：<br><br><ul><br>    <li>当 DOM 元素的属性发生变化 (如 color) 时,而这些属性只是影响元素的外观风格，浏览器会通知 render 重描相应的元素，此过程称为 Repaint<b>。</b></li><br>    <li>如果该次变化涉及元素布局 (如 width)，浏览器则抛弃原有属性，重新计算并把结果传递给 render 以重新描绘页面元素, 此过程称为 Reflow。</li><br>    <li>Reflow必将引起Repaint，而Repaint不一定会引起Reflow 。</li><br></ul><br><h2><span id=\"总结\">总结：</span></h2>\n\n<p>同过了解浏览器的工作原理来对页面进行性能优化是必须的。</p>\n<p>参考：<a href=\"http://blog.csdn.net/milado_nju/article/details/11661311\" target=\"_blank\">http://blog.csdn.net/milado_nju/article/details/11661311</a></p>\n<p></p><p style=\"padding-left: 30px;\"><a href=\"http://wenku.baidu.com/link?url=__Ta164STKm3n2O4IL83jA7SFaou6ryqoD4Ii-LFJsJpHIDaZKQ2wHTdK5aw-06FGqOZ2dRYd5DmT87SeQAndfa5EMotGU_iyaCQKk4imtq\" target=\"_blank\">http://wenku.baidu.com/link?url=__Ta164STKm3n2O4IL83jA7SFaou6ryqoD4Ii-LFJsJpHIDaZKQ2wHTdK5aw-06FGqOZ2dRYd5DmT87SeQAndfa5EMotGU_iyaCQKk4imtq</a></p><br>&nbsp;<p></p>\n","site":{"data":{}},"excerpt":"<p>看过不少文章之后，自己也想尝试写下浏览器到底是如何解析页面的，这对前端工程师来说，应该也算有点帮助。</p>\n<h2>什么是渲染引擎？</h2><br>大家都见过webkit吧，有时候我们在写css3时需要兼容不同浏览器，所以就要写不同的前缀，那么这个webkit就是一种渲染引擎，不同的浏览器可能有不同的渲染引擎,下面只列出一些常用的。<br>","more":"<br><strong>Trident：</strong><br><br><span style=\"color: #323e32;\">· Internet Explorer（IE）</span><br style=\"color: #323e32;\"><span style=\"color: #323e32;\">· 傲游</span><br style=\"color: #323e32;\"><br><strong>Gecko：</strong><br><br><span style=\"color: #323e32;\">· Firefox</span><br style=\"color: #323e32;\"><span style=\"color: #323e32;\">· 网景（6至9）</span><br style=\"color: #323e32;\"><br><strong>KHTML(webkit):</strong><br><br><span style=\"color: #323e32;\">· Safari</span><br style=\"color: #323e32;\"><span style=\"color: #323e32;\">· Google Chrome</span><br style=\"color: #323e32;\"><br><strong><span style=\"color: #000000;\">Presto：</span></strong><br><br><span style=\"color: #323e32;\">· <span style=\"color: #000000;\">Opera</span></span><br><br>其中，渲染引擎包括了浏览器的核心功能，例如html解释器，css解释器，布局和javascript引擎，例如webkit所用的js引擎就是大名鼎鼎的v8，正是由于浏览器所用的渲染引擎不同，才导致了那么多的浏览器兼容性问题。<br><br>&nbsp;<br><h2>浏览器是如何工作的：</h2><br><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/webprocess.png\" alt=\"\" width=\"800\" height=\"311\"><br><br>上面这个图是我从网上找过之后修改的。<br><br>首先流程说一下：<br><br>1. 当浏览器通过网络下载到html页面后，开始进行解析，首先要经过html解释器。<br><br>2. 在解析html时，发现了css标签和javascript标签，便调用css解释器和javascript引擎，而在解析html的同时，会把html生成dom树。<br><br>3. 由于javascript可能对html页面进行修改，所以javascript引擎，html页面，dom树3个是循环过程。<br><br>4. css解释器在工作的时候例如webkit css phaser，可以看下图：<br><br><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/css-phaser.png\" alt=\"\" width=\"500\" height=\"393\"><br><br>可以看到，对css的解析是分两条线，分别解析selectors和declaration最后把得到的结果加在dom树上。<br><br>5.DOM之后，需要将其中的元素对象同样式信息结合起来，计算它们的大小位置等布局信息，形成一个能够表示这所有信息的内部表示模型。<br><br>6. 把前几布的结果综合起来，就可以进行绘制，从而展现出页面。<br><br>7. 最后解释图中虚线箭头的指向含义。它们表示在渲染过程中，每个阶段可能使用到的其他模块。在网页内容的下载中，需要使用到网络和存储，这个是显而易见地。但计算布局和绘图的时候，需要使用2D/3D的图形模块，同时因为要生成最后的可视化结果，这时候需要开始解码音频视频和图片，同其它内容一起绘制到最后的图像中。<br><br>其中：<br><br><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/20130921092322593.jpg\" alt=\"\" width=\"576\" height=\"96\"><br><br>就是渲染引擎 webkit。<br><h2>由此可见，可以总结出以下问题：</h2><br>1. 浏览器一般常驻3条线程：js引擎线程，GUI渲染线程，和浏览器事件触发线程。<br><br>2. 其中GUI渲染线程和js引擎线程是互斥的，所以说，让浏览器解析js时，是无法继续渲染页面的，所以问题也就是一般吧js放在body底部的原因。<br><br>3. 而为什么GUI渲染线程和js引擎线程是互斥的？我想是因为在解析js时，可能会对页面结构进行修改，所以渲染线程需要挂起，来等待js解析完毕才能执行页面渲染。<br><br>4. css是并行加载的，但是并行也有加载限制，例如浏览器在对同一域名下下载css有个数限制，所以就会有一些静态文件需要放在不同的的域名下来加载，提高速度。可看下图：<br><br><img class=\"alignnone\" src=\"http://qiniu.nihaoshijie.com.cn/4d086e061d950a7b69e4cf8608d162d9f3d3c99b.jpg\" alt=\"\" width=\"262\" height=\"232\"><br><br>5. 在css里如果写import来引入，会打断css的并行下载，这样不利于页面渲染，和css的解析。<br><br>6. reflow和repaint分别对应上个流程图的html解释和绘制阶段，所以：<br><br><ul><br>    <li>当 DOM 元素的属性发生变化 (如 color) 时,而这些属性只是影响元素的外观风格，浏览器会通知 render 重描相应的元素，此过程称为 Repaint<b>。</b></li><br>    <li>如果该次变化涉及元素布局 (如 width)，浏览器则抛弃原有属性，重新计算并把结果传递给 render 以重新描绘页面元素, 此过程称为 Reflow。</li><br>    <li>Reflow必将引起Repaint，而Repaint不一定会引起Reflow 。</li><br></ul><br><h2>总结：</h2>\n\n<p>同过了解浏览器的工作原理来对页面进行性能优化是必须的。</p>\n<p>参考：<a href=\"http://blog.csdn.net/milado_nju/article/details/11661311\" target=\"_blank\">http://blog.csdn.net/milado_nju/article/details/11661311</a></p>\n<p></p><p style=\"padding-left: 30px;\"><a href=\"http://wenku.baidu.com/link?url=__Ta164STKm3n2O4IL83jA7SFaou6ryqoD4Ii-LFJsJpHIDaZKQ2wHTdK5aw-06FGqOZ2dRYd5DmT87SeQAndfa5EMotGU_iyaCQKk4imtq\" target=\"_blank\">http://wenku.baidu.com/link?url=__Ta164STKm3n2O4IL83jA7SFaou6ryqoD4Ii-LFJsJpHIDaZKQ2wHTdK5aw-06FGqOZ2dRYd5DmT87SeQAndfa5EMotGU_iyaCQKk4imtq</a></p><br>&nbsp;<p></p>"},{"title":"前端开发与架构师","date":"2020-05-01T09:26:17.000Z","_content":"\n前端架构师,听起来就是个很高大上的职位，在大多数程序员的眼中，架构师一般从事后端开发，Java或者C++出身，它们往往拥有这十八般武艺，可以解决业务中出现的各种问题。好像架构师就从来没有和前端有过关系，那么真的是这样么，通读此文，便可豁然开朗。\n\n### 前端的意义：\n\n首先，我们先来谈谈本职工作，前端的意义。前端源自用户界面，是最先和用户接触的地方，也是衡量一个项目产品好坏的第一道关口。\n\n#### 到底什么是前端\n从最早的DOS系统说起，那时是没有前端的概念的，大多数的软件界面显示的都是冷冰冰的黑底白字的控制台命令，于是，慢慢的不仅是用户，就连广大的程序员也不满足现状，开发出一套图形化的用户界面，让一些功能更加便于操作。那时前端叫做GUI(图形用户界面)。还没有区分出多端的概念，大多数是基于操作系统开发出的原生界面。\n\n<!--more-->\n\n![图片描述](https://user-gold-cdn.xitu.io/2019/9/12/16d22dcf38da3cd5?w=1280&h=806&f=png&s=120978)\n上图来自DOS系统经典软件*DOS Navigator*\n\n随着互联网的发展，第一代浏览器Netscape(网景浏览器)的诞生以及后续的IE系列浏览器的到来，”网上冲浪“这个词逐渐进入到大多数的用户生活中。直到现在大行其道浏览器Chrome，以及国内各种百花齐放的浏览器。主要给浏览器服务，实现各种特效的JavaScript语言，迎来了第一波春天。\n![图片描述](https://user-gold-cdn.xitu.io/2019/9/12/16d22dcf38ee1b90?w=1238&h=938&f=png&s=1258146)\n上图来自*网景浏览器*\n\n直到现在，前端逐渐拆分成：\n\nweb前端(HTML+CSS+JavaScript)，客户端前端(Android和iOS)。\n\n又或者是网页重构工程师，JS工程师，UI/UX，切图仔等等。\n\n那么归根这些都是为前端服务的，说了这么多，那么前端的价值到底在哪里呢？\n\n#### 前端的价值在哪呢？\n\n* 实现界面交互。\n* 提升用户体验。\n\n第一点是前端的本职工作，是在功能上和后端的主要区分，也是前端岗位存在的原因。第二点也不必多说，前端做得好，对用户体验是有益的。如果说后端的目标和价值体现在服务的高性能、高可用、可扩展、安全。那么前端的价值体现就是“用户”二字。\n\n![图片描述](https://user-gold-cdn.xitu.io/2019/9/12/16d22dcf38baa6ae?w=291&h=291&f=png&s=17557)\n\n所以作为一个合格的前端开发，让用户用的舒心(爽)就是目标，所以要想完全体现你的价值，你需要循序渐进的完成下面几个步骤：\n\n1. 根据产品的逻辑和需求，完成对应业务的前端页面UI展示，与用户交互。\n2. 编写可维护性高的代码，减少BUG的产生，保证良好的用户体验。\n3. 在完成功能的同时，能够熟悉现有业务，并提出可持续改进的地方，并付诸实施优化。\n\n看了上面的几条，是不是有种似曾相识的感觉，是不是很像一则招聘信息的JD。其实没错，作为一个企业来讲，招聘一名前端开发，肯定要能够为企业带来价值，这本身也是你的价值体现。\n\n但是，我想说的是，看似简简单单的3条内容，你真的理解么。第一条和第二条是你技术上的能力体现，这部分完全靠你的技术积累，那么第三条便是你主关能动性的体现，这部分可发挥的地方很多，一个新人和一个工作经验丰富的人差距可能就体现在这里，具体我们后面再说。\n\n但是，还想说的是，单纯的完成上面的3条步骤，那么还是只能说明你是一个合格的前端开发，这与架构师还是有一定的距离的。\n\n\n#### 前端价值体现真的很重要么？\n\n好吧，上面我们了解了前端的价值，并且各位前端开发还在辛辛苦苦的体现着自己的价值，但是让人纠结的，前端是有价值，但这价值真的很重要吗？\n\n##### 和非前端之外的技术相比\n\n对于一个成熟的产品业务而言，前端往往是很薄的一层，这一层赋予你的功能，大多是就是页面的UI展示和用户交互。\n虽说前端是产品和用户之间的第一道关口，但也只是第一道关口，后面可能还有十几道关口。例如搞后端逻辑的，搞底层数据库的，搞网络安全的，搞运维的，搞大数据分析的，或者是现在流行的机器学习的相关人员。每一个相关模块都自己独立的技术体系，可以说这些缺一不可。\n所以，前端和这些前端之外的技术相比，就体现的并不是那么”非你不可“了。就是说前端的确有价值，但放在全局来看，前端产生的价值并非核心价值。\n\n##### 对产品业务的重要性\n\n举一个现在比较实际的例子，对于前端开发而言，在一些一线的互联网企业例如BAT等等，这些公司对前端开发的重视程度还是不错的，有着自己的产品业务线，整个前端技术有着不错的氛围，并且能够使用前端技术持续提升产品的用户体验。\n但是对于一些其他的中小型公司或者企业(我相信各位并非都来自BAT吧)，很多前端开发的技术含量并不是很高，特别是对于一些toB的业务来说，核心的功能都来自于后端，来自于数据库的优化。或者是对于一些比较突出亮点的AI功能性产品，这些产品的核心竞争力甚至可能来自于硬件和算法。而前端在里面扮演的角色大多数是UI展示，数据可视化等等这些。而且很多工作属于重复性劳动，甚至有些可能还被后端开发来兼职做了。\n所以，对于一个业务的重要性而言，前端能够体现其价值的地方还是很有限的。\n\n当然，这里说了这么多，并不是给大家传输一种：前端不行了，赶快转行吧，这种思想，当然我们还是要吃饭的，这里想说的是让大家时刻保持一种危机感，只有这种危机感，才是让我们不断的对技术进行深究和进阶，不断发展不断前行的动力。\n\n### 前端技术的进阶：\n\n在成为一名架构师之前，你需要有充分的技术储备，这些技术储备可能不止限制于前端技术。当然这里，我先介绍一些前端技术需要如何去进阶。\n\n#### 性能优化\n\n在大厂工作过的同仁应该都知道，性能优化是一个敲门砖，因为如果去衡量一个前端开发是否真正的有经验，性能优化是一个分水岭，其相关流程主要涵盖：\n1. 首先是如何发现问题。\n2. 发现问题之后，是如何分析其中原因。\n3. 找到原因之后，采用的解决办法。\n4. 解决之后，是否真实的对用户体验有所提升。\n\n从这些问题中，可以衍生出各种值得深究的问题，并且可以从中找出一些方法论问题，所以性能优化是一项非常重要的点，当然，我们在这里就不说具体有哪些优化了，推荐读一读[《移动web性能优化从入门到进阶》](https://juejin.im/post/5c931c4a6fb9a070dc28923b)这篇文章。\n\n#### 对框架的理解\n\n> 如果你想成为一名架构师，不能只停留在框架的 API 使用层面。\n\n对于当下最流行的3个前端框架Vue，React，Angular来说，掌握其基本的用法是必要的，但是也是最简单的，现在网上有各种各样的课程，可以让一个刚毕业的实习生就能轻松入门，并达道做项目的能力。所以说，为什么一个需求，给一个实习生就能做，为什么要选择你呢？\n\n所以，掌握框架的原理，并理解其中的思想，举一反三，是和大多数前端程序员拉开差距的关键所在，在这里给大家以Vue举几个例子，看看你是否真正掌握。\n1. Vue中的双向绑定，只是简单的`Object.defineProperty()`么？\n2. Vue的数据依赖是如何实现的？\n3. Vue的computed和watch到底有何本质区别？\n4. keep-alive的实现原理？\n\n大家不妨试试去理解一下这几个问题的根本点，试试从源码里来找到答案。理解源码的同时，有利于对框架本身的理解，对于提升解决问题的能力，以及减少出现BUG的几率，有所帮助。\n\n#### 深入Node.js领域\n\nNode.js是让前端工程师能够触及后端逻辑的一个利器，也给了我们抢后端饭碗的正当理由，但是这里的Node.js并不是单独的指后端逻辑的开发。例如现在的前端工程化体系中，扮演重要角色的webpack，parcel，vue-cli等等，或者是现在让JavaScript能够开发PC桌面程序的Electron，都和Node.js密不可分，在这里给大家举几个例子，可以尝试一下从这几个点来进阶：\n1. 与浏览器端的JavaScript不同，Node.js后端是直面服务器的，如何定位和分析内存泄漏问题。\n2. 尝试写一些webpack插件。\n\n#### Canvas与WebGL\n\nWebGL是基于OpenGL的Web3D图形规范，是一套JavaScript的API。简单来说，可以把它看成是3D版的Canvas，当然，提到这个方向，可能有些人会觉得有点偏了。的确对于大多数前端开发来说，使用WebGL相关的3D处理技术和算法，并不需要掌握复杂的算法或者数学知识，只需要学会three.js就行了。\n但是基于Canvas或者WebGL可以提供给我们针对一些特定问题的解决方案。同样在这里给大家举几个例子：\n1. 实现一个刮刮卡或者涂鸦墙的业务需求。\n2. 图片上传时进行压缩和裁剪。\n3. 在实现帧动画方面，使用CSS3和Canvas的选择。\n\n上面几个场景，就好比你拿到这些需求时，如果你根本不了解Canvas或者WebGL，你可能根本想不到有这些技术方案可以解决这些问题，所以，并不是说对Canvas或WebGL理解的多么透彻，但是作为一个架构师而言，你需要有一些技术广度，来拓宽你的技术栈，也就提升了你解决问题的能力。\n\n### 通往架构师之路：\n\n说道这里，好像才进入正题。基本的进阶知识是你晋升成为成为高级前端的必要条件，但却不是你成为一名架构师的核心。正所谓一专多长，首先你得先精通一门。前端知识的进阶正是通往架构师的突破口，所以首先需要明白一点：掌握前端技术的同时，你还要学了解前端技术之外的技能。跳出前端这个思维，才能看到的更多。那么如果你想从一个前端资深人员进阶架构师，来看看下面的内容吧。\n\n#### 跨界\n\n如果你只会写前端页面，那么无论你的功力练到多么炉火纯青的地步，那么也只能称为你是一个HTML高手。\n真正的架构师是需要有跨界的能力的，随着技术的持续完善，这种通过岗位变迁实现技术架构升级的情况会越来越少。而架构层面新的变化将来自于岗位自发的对自身工作内容、职责的重新定义，也就是这里说的边界。所以说并不是你作为一个前端开发岗位，你就不能干前端之外的事了，要尝试跳出边界来思考和解决问题。\n\n页面的秒开是衡量一个前端优化的重要指标，我们以这个优化点来总结一下从哪些方面跨：\n\n1. 提升速度，从服务端渲染着手，可以利用Node.js往后端跨。\n2. 提升移动web的H5页面的启动耗时，从webview着手，利用iOS和Android技能往客户端跨。\n\n用户交互操作体验，也是衡量前端优化的重要指标，我们以这个优化点来总结一下从哪些方面跨：\n\n1. 提升用户交互体验，尝试将web页面客户端化，基于React Native或者Weex，也可以往客户端跨。\n2. 提升页面动画效果，编写高性能的前端动画，也可以往UI动效设计跨。\n\n合理的跨界，可以让架构师对于业务的整体有深层次的认识，针对各种问题可以提出非前端之外的解决方案。\n\n#### 尝鲜\n\n技术是不断发展的，作为一个架构师，不断学习新的技术是非常重要的，这里所说的尝鲜，就是要对技术保持一定的热情，不能只满足于现状，说白了讲就是要不断的学。\n\n1. 习惯了jQuery开发页面，不妨试试Vue，React。\n2. 写了很久的ES5代码，学学ES6也不错。\n3. 沉醉在HTML，CSS，JavaScript开发页面，不妨学学Flutter。\n4. 打造高性能的Web App，试试Service Worker。\n5. 从HTTP协议触发，改造升级spdy和HTTP2，尝试一下HTTP3。\n6. 尝试一下新的编程语言：WebAssembly。\n7. 知道为服务，但你知道微前端吗。\n\n上面列举的尝鲜技能，是完全可以从一个前端的角度触发，来不断深入的，保持对每一个新技术的求知欲，是一名架构师必不可少的。\n\n#### 工具和平台化建设\n\n> 只会写代码的程序员只能叫码农。\n\n当技术达到一定的高度时，能够为业务再次提升的能力就会逐渐变少，那么我们不如跳出技术本身，来改善业务周边的工具平台，同样来为业务服务。作为一名架构师，要有这种能力。\n\n提到工具平台，大家很快就能跟自己的团队里面的一些工具联系起来。这里主要跟大家探讨一下，我们的工具体系要用什么的思路去规划和review，也看一下我们还有那些可以进一步去完善的点。\n![图片描述](https://user-gold-cdn.xitu.io/2019/9/12/16d22dcf393b5fbb?w=851&h=281&f=png&s=35036)\n\n为了通俗一点，同样举几个工具平台的例子：\n1. 针对开发调试，需要有一些提升开发效率的工具，例如移动web常用的Fiddler，或者是小程序模拟器。\n2. 针对性能检测，需要有一些能够进行压力测试，发布后线上回归测试的工具，例如腾讯wetest等。\n3. 针对统计分析，每个业务都需要能够提供给产品人员观察数据的工具，当然由于数据敏感性，这里一般每个团队有内部的工具，对外的类似工具例如Google分析等。\n\n可以看出来工具平台主要就是围绕我们的研发流程中的每一步关键节点去建设起来的，结合起来说，我们可以称之为工程化。工程化是这几年非常热门的概念，对前端来讲也是一个很明确的前端发展方向，其实工具平台的完善过程就是架构工程化的推进过程。\n\n![图片描述](https://user-gold-cdn.xitu.io/2019/9/12/16d22dcf39285a31?w=851&h=281&f=png&s=42311)\n\n身为一名架构师，你需要有敏锐的嗅觉来洞悉这些节点。并且在适当的时机能够做出对业务有提升的工具平台，要做到遇到重复性的问题时，想想是不是开发出一款自动化工具平台来处理，这才是代码之外对业务提升解决方案。\n\n#### 流程和规范化\n\n身为一名架构师，对流程的制定和规范，是非常重要的。不要小瞧规范的威力，可以极大的提升开发效率，真正优秀的规范不会让使用者感到约束，而是能帮助他们快速定位问题，提升效率。\n这里的规范，总结起来可以分为成：\n1. 结构的规范：对项目的代码结构，不管前后端，合理的分层和组件化是非常必要的。\n2. 编码的规范：这里主要就是代码codereview了，定期的进行codeview的同时，最好可以使用一些自动化工具。\n3. 流程的规范：项目的评审，研发，测试，发布这些阶段都需要有流程来约束，这些需要结合自身团队的实际情况来制定。\n4. 规范的落地：对于规范来说最关键的是执行落地，在制定完规范的同时，要不时的回顾是否切实的落地，这个应该是团队里每个成员坚持的基本准则。\n\n![图片描述](https://user-gold-cdn.xitu.io/2019/9/12/16d22dcf39954e66?w=321&h=212&f=png&s=13114)\n\n#### 方法论\n\n所谓方法论，可能单单说起来是比较抽象的，这里的方法论，主要是指在完成一项小的需求，或者是承接一个重大的项目，在具体的实施过程中，要有一定的方法和技巧，相信大家都看过《穹顶之下》这个视频，就是很强的方法论体现。其实说白了讲就是做事要有套路，这里就举一个性能优化的例子。\n在性能优化时，我们如何证明优化是有效果的，可以采用“三明治法则”(自己起的名字)：\n\n1. 首先优化前，我们需要找到问题的现状，并且要有数据能够佐证优化前的状态。所以就要学会去收集数据。\n2. 有了数据之后，我们在进行对数据分析的同时，就需要找到问题出现的原因，并且付诸实施解决。这个阶段，就需要记录具体的优化原理。\n3. 优化之后，就要想方设法去验证，并且在验证过程中，同样需要收集数据。\n\n到此，我们就有了 优化前数据，优化的原理，优化后的数据。通过数据对比，我们就可以很轻易的去佐证我们这次优化是有成效的，并且可以做出一份很漂亮的总结，作为一名架构师而言，这是一个很好的树立威信的场景体现。\n\n我们可以在发散开来，上面的三步骤可以再次迭代，也就是说，第一次优化，我们达到了效果，但是深究之后，还可以再次进行优化，每次优化都有数据佐证，这就是性能优化的方法论。\n\n#### 安全意识\n\n这里为什么要把安全单独拿出来说呢，因为对于一个业务而言，安全是第一要素，就好比一个国家，安全稳定才是发展一切的前提，一旦业务出现安全问题，就可能瞬间损失掉全部，代价是非常惨重的。所以作为一名架构师，必须要保证业务的稳定性，可以总结以下几点：\n1. 对低级的的代码安全问题，要坚决说不，例如前端里面的xss，csrf这些问题。\n2. 对大型运营类活动需求，要有容灾意识和备份，例如在准备了一套方案的同时，要有可选的备用方案。\n3. 尝试使用工具化来解决和预防安全问题，例如BAT这种大型企业，在运维和代码层面，都有一层保障机制，如腾讯的门神系统等。\n\n#### 团队合作\n\n> 没有完美的个人，却有完美的团队。\n\n即使是一名架构师，我相信他也不是一直在一个人战斗，一个优秀的产品业务，总是诞生于团队，所以时刻保持和团队人员的沟通是必不可少的，这些沟通不限于日常的文字，或者会议，甚至私下的团建活动，都是可以相互了解的。\n所以团队合作的目的就是让团队中的每个人都能明确自己的职责，并发挥出最大的价值，架构师有义务来维护这种合作关系。并且对你的认同，也是团队成员赋予你的，维护良好的氛围，才能让团队成员信服。\n\n最后，总结一下，对前端架构师理解的一些误区：\n\n1. 架构师并不等于全栈工程师。\n2. 架构师切忌完全脱离代码，但是也不要一直闷着头写代码。\n3. 架构师应当跳出技术本身，从全局的角度来看的业务，发现并解决问题。\n4. 任何项目的架构都不是一开始制定好就是一成不变的，它应该是不断迭代和演进的，架构师有义务来保证架构的创新性。\n\n\n最后，希望各位前端同仁，能够在成为架构师的道路上，披荆斩棘，一帆风顺！\n\n欢迎关注新书：\n[《HTML5移动Web+Vue.js应用开发实战》](https://detail.tmall.com/item.htm?spm=a230r.1.14.1.52fe5594vGYpMr&id=620482199343&ns=1&abbucket=17)\n\n\n","source":"_posts/前端开发与架构师.md","raw":"---\ntitle: 前端开发与架构师\ndate: 2020-04-31 17:26:17\ntags:\n- 架构师\n- 前端\ncategories:\n- 1110\n\n---\n\n前端架构师,听起来就是个很高大上的职位，在大多数程序员的眼中，架构师一般从事后端开发，Java或者C++出身，它们往往拥有这十八般武艺，可以解决业务中出现的各种问题。好像架构师就从来没有和前端有过关系，那么真的是这样么，通读此文，便可豁然开朗。\n\n### 前端的意义：\n\n首先，我们先来谈谈本职工作，前端的意义。前端源自用户界面，是最先和用户接触的地方，也是衡量一个项目产品好坏的第一道关口。\n\n#### 到底什么是前端\n从最早的DOS系统说起，那时是没有前端的概念的，大多数的软件界面显示的都是冷冰冰的黑底白字的控制台命令，于是，慢慢的不仅是用户，就连广大的程序员也不满足现状，开发出一套图形化的用户界面，让一些功能更加便于操作。那时前端叫做GUI(图形用户界面)。还没有区分出多端的概念，大多数是基于操作系统开发出的原生界面。\n\n<!--more-->\n\n![图片描述](https://user-gold-cdn.xitu.io/2019/9/12/16d22dcf38da3cd5?w=1280&h=806&f=png&s=120978)\n上图来自DOS系统经典软件*DOS Navigator*\n\n随着互联网的发展，第一代浏览器Netscape(网景浏览器)的诞生以及后续的IE系列浏览器的到来，”网上冲浪“这个词逐渐进入到大多数的用户生活中。直到现在大行其道浏览器Chrome，以及国内各种百花齐放的浏览器。主要给浏览器服务，实现各种特效的JavaScript语言，迎来了第一波春天。\n![图片描述](https://user-gold-cdn.xitu.io/2019/9/12/16d22dcf38ee1b90?w=1238&h=938&f=png&s=1258146)\n上图来自*网景浏览器*\n\n直到现在，前端逐渐拆分成：\n\nweb前端(HTML+CSS+JavaScript)，客户端前端(Android和iOS)。\n\n又或者是网页重构工程师，JS工程师，UI/UX，切图仔等等。\n\n那么归根这些都是为前端服务的，说了这么多，那么前端的价值到底在哪里呢？\n\n#### 前端的价值在哪呢？\n\n* 实现界面交互。\n* 提升用户体验。\n\n第一点是前端的本职工作，是在功能上和后端的主要区分，也是前端岗位存在的原因。第二点也不必多说，前端做得好，对用户体验是有益的。如果说后端的目标和价值体现在服务的高性能、高可用、可扩展、安全。那么前端的价值体现就是“用户”二字。\n\n![图片描述](https://user-gold-cdn.xitu.io/2019/9/12/16d22dcf38baa6ae?w=291&h=291&f=png&s=17557)\n\n所以作为一个合格的前端开发，让用户用的舒心(爽)就是目标，所以要想完全体现你的价值，你需要循序渐进的完成下面几个步骤：\n\n1. 根据产品的逻辑和需求，完成对应业务的前端页面UI展示，与用户交互。\n2. 编写可维护性高的代码，减少BUG的产生，保证良好的用户体验。\n3. 在完成功能的同时，能够熟悉现有业务，并提出可持续改进的地方，并付诸实施优化。\n\n看了上面的几条，是不是有种似曾相识的感觉，是不是很像一则招聘信息的JD。其实没错，作为一个企业来讲，招聘一名前端开发，肯定要能够为企业带来价值，这本身也是你的价值体现。\n\n但是，我想说的是，看似简简单单的3条内容，你真的理解么。第一条和第二条是你技术上的能力体现，这部分完全靠你的技术积累，那么第三条便是你主关能动性的体现，这部分可发挥的地方很多，一个新人和一个工作经验丰富的人差距可能就体现在这里，具体我们后面再说。\n\n但是，还想说的是，单纯的完成上面的3条步骤，那么还是只能说明你是一个合格的前端开发，这与架构师还是有一定的距离的。\n\n\n#### 前端价值体现真的很重要么？\n\n好吧，上面我们了解了前端的价值，并且各位前端开发还在辛辛苦苦的体现着自己的价值，但是让人纠结的，前端是有价值，但这价值真的很重要吗？\n\n##### 和非前端之外的技术相比\n\n对于一个成熟的产品业务而言，前端往往是很薄的一层，这一层赋予你的功能，大多是就是页面的UI展示和用户交互。\n虽说前端是产品和用户之间的第一道关口，但也只是第一道关口，后面可能还有十几道关口。例如搞后端逻辑的，搞底层数据库的，搞网络安全的，搞运维的，搞大数据分析的，或者是现在流行的机器学习的相关人员。每一个相关模块都自己独立的技术体系，可以说这些缺一不可。\n所以，前端和这些前端之外的技术相比，就体现的并不是那么”非你不可“了。就是说前端的确有价值，但放在全局来看，前端产生的价值并非核心价值。\n\n##### 对产品业务的重要性\n\n举一个现在比较实际的例子，对于前端开发而言，在一些一线的互联网企业例如BAT等等，这些公司对前端开发的重视程度还是不错的，有着自己的产品业务线，整个前端技术有着不错的氛围，并且能够使用前端技术持续提升产品的用户体验。\n但是对于一些其他的中小型公司或者企业(我相信各位并非都来自BAT吧)，很多前端开发的技术含量并不是很高，特别是对于一些toB的业务来说，核心的功能都来自于后端，来自于数据库的优化。或者是对于一些比较突出亮点的AI功能性产品，这些产品的核心竞争力甚至可能来自于硬件和算法。而前端在里面扮演的角色大多数是UI展示，数据可视化等等这些。而且很多工作属于重复性劳动，甚至有些可能还被后端开发来兼职做了。\n所以，对于一个业务的重要性而言，前端能够体现其价值的地方还是很有限的。\n\n当然，这里说了这么多，并不是给大家传输一种：前端不行了，赶快转行吧，这种思想，当然我们还是要吃饭的，这里想说的是让大家时刻保持一种危机感，只有这种危机感，才是让我们不断的对技术进行深究和进阶，不断发展不断前行的动力。\n\n### 前端技术的进阶：\n\n在成为一名架构师之前，你需要有充分的技术储备，这些技术储备可能不止限制于前端技术。当然这里，我先介绍一些前端技术需要如何去进阶。\n\n#### 性能优化\n\n在大厂工作过的同仁应该都知道，性能优化是一个敲门砖，因为如果去衡量一个前端开发是否真正的有经验，性能优化是一个分水岭，其相关流程主要涵盖：\n1. 首先是如何发现问题。\n2. 发现问题之后，是如何分析其中原因。\n3. 找到原因之后，采用的解决办法。\n4. 解决之后，是否真实的对用户体验有所提升。\n\n从这些问题中，可以衍生出各种值得深究的问题，并且可以从中找出一些方法论问题，所以性能优化是一项非常重要的点，当然，我们在这里就不说具体有哪些优化了，推荐读一读[《移动web性能优化从入门到进阶》](https://juejin.im/post/5c931c4a6fb9a070dc28923b)这篇文章。\n\n#### 对框架的理解\n\n> 如果你想成为一名架构师，不能只停留在框架的 API 使用层面。\n\n对于当下最流行的3个前端框架Vue，React，Angular来说，掌握其基本的用法是必要的，但是也是最简单的，现在网上有各种各样的课程，可以让一个刚毕业的实习生就能轻松入门，并达道做项目的能力。所以说，为什么一个需求，给一个实习生就能做，为什么要选择你呢？\n\n所以，掌握框架的原理，并理解其中的思想，举一反三，是和大多数前端程序员拉开差距的关键所在，在这里给大家以Vue举几个例子，看看你是否真正掌握。\n1. Vue中的双向绑定，只是简单的`Object.defineProperty()`么？\n2. Vue的数据依赖是如何实现的？\n3. Vue的computed和watch到底有何本质区别？\n4. keep-alive的实现原理？\n\n大家不妨试试去理解一下这几个问题的根本点，试试从源码里来找到答案。理解源码的同时，有利于对框架本身的理解，对于提升解决问题的能力，以及减少出现BUG的几率，有所帮助。\n\n#### 深入Node.js领域\n\nNode.js是让前端工程师能够触及后端逻辑的一个利器，也给了我们抢后端饭碗的正当理由，但是这里的Node.js并不是单独的指后端逻辑的开发。例如现在的前端工程化体系中，扮演重要角色的webpack，parcel，vue-cli等等，或者是现在让JavaScript能够开发PC桌面程序的Electron，都和Node.js密不可分，在这里给大家举几个例子，可以尝试一下从这几个点来进阶：\n1. 与浏览器端的JavaScript不同，Node.js后端是直面服务器的，如何定位和分析内存泄漏问题。\n2. 尝试写一些webpack插件。\n\n#### Canvas与WebGL\n\nWebGL是基于OpenGL的Web3D图形规范，是一套JavaScript的API。简单来说，可以把它看成是3D版的Canvas，当然，提到这个方向，可能有些人会觉得有点偏了。的确对于大多数前端开发来说，使用WebGL相关的3D处理技术和算法，并不需要掌握复杂的算法或者数学知识，只需要学会three.js就行了。\n但是基于Canvas或者WebGL可以提供给我们针对一些特定问题的解决方案。同样在这里给大家举几个例子：\n1. 实现一个刮刮卡或者涂鸦墙的业务需求。\n2. 图片上传时进行压缩和裁剪。\n3. 在实现帧动画方面，使用CSS3和Canvas的选择。\n\n上面几个场景，就好比你拿到这些需求时，如果你根本不了解Canvas或者WebGL，你可能根本想不到有这些技术方案可以解决这些问题，所以，并不是说对Canvas或WebGL理解的多么透彻，但是作为一个架构师而言，你需要有一些技术广度，来拓宽你的技术栈，也就提升了你解决问题的能力。\n\n### 通往架构师之路：\n\n说道这里，好像才进入正题。基本的进阶知识是你晋升成为成为高级前端的必要条件，但却不是你成为一名架构师的核心。正所谓一专多长，首先你得先精通一门。前端知识的进阶正是通往架构师的突破口，所以首先需要明白一点：掌握前端技术的同时，你还要学了解前端技术之外的技能。跳出前端这个思维，才能看到的更多。那么如果你想从一个前端资深人员进阶架构师，来看看下面的内容吧。\n\n#### 跨界\n\n如果你只会写前端页面，那么无论你的功力练到多么炉火纯青的地步，那么也只能称为你是一个HTML高手。\n真正的架构师是需要有跨界的能力的，随着技术的持续完善，这种通过岗位变迁实现技术架构升级的情况会越来越少。而架构层面新的变化将来自于岗位自发的对自身工作内容、职责的重新定义，也就是这里说的边界。所以说并不是你作为一个前端开发岗位，你就不能干前端之外的事了，要尝试跳出边界来思考和解决问题。\n\n页面的秒开是衡量一个前端优化的重要指标，我们以这个优化点来总结一下从哪些方面跨：\n\n1. 提升速度，从服务端渲染着手，可以利用Node.js往后端跨。\n2. 提升移动web的H5页面的启动耗时，从webview着手，利用iOS和Android技能往客户端跨。\n\n用户交互操作体验，也是衡量前端优化的重要指标，我们以这个优化点来总结一下从哪些方面跨：\n\n1. 提升用户交互体验，尝试将web页面客户端化，基于React Native或者Weex，也可以往客户端跨。\n2. 提升页面动画效果，编写高性能的前端动画，也可以往UI动效设计跨。\n\n合理的跨界，可以让架构师对于业务的整体有深层次的认识，针对各种问题可以提出非前端之外的解决方案。\n\n#### 尝鲜\n\n技术是不断发展的，作为一个架构师，不断学习新的技术是非常重要的，这里所说的尝鲜，就是要对技术保持一定的热情，不能只满足于现状，说白了讲就是要不断的学。\n\n1. 习惯了jQuery开发页面，不妨试试Vue，React。\n2. 写了很久的ES5代码，学学ES6也不错。\n3. 沉醉在HTML，CSS，JavaScript开发页面，不妨学学Flutter。\n4. 打造高性能的Web App，试试Service Worker。\n5. 从HTTP协议触发，改造升级spdy和HTTP2，尝试一下HTTP3。\n6. 尝试一下新的编程语言：WebAssembly。\n7. 知道为服务，但你知道微前端吗。\n\n上面列举的尝鲜技能，是完全可以从一个前端的角度触发，来不断深入的，保持对每一个新技术的求知欲，是一名架构师必不可少的。\n\n#### 工具和平台化建设\n\n> 只会写代码的程序员只能叫码农。\n\n当技术达到一定的高度时，能够为业务再次提升的能力就会逐渐变少，那么我们不如跳出技术本身，来改善业务周边的工具平台，同样来为业务服务。作为一名架构师，要有这种能力。\n\n提到工具平台，大家很快就能跟自己的团队里面的一些工具联系起来。这里主要跟大家探讨一下，我们的工具体系要用什么的思路去规划和review，也看一下我们还有那些可以进一步去完善的点。\n![图片描述](https://user-gold-cdn.xitu.io/2019/9/12/16d22dcf393b5fbb?w=851&h=281&f=png&s=35036)\n\n为了通俗一点，同样举几个工具平台的例子：\n1. 针对开发调试，需要有一些提升开发效率的工具，例如移动web常用的Fiddler，或者是小程序模拟器。\n2. 针对性能检测，需要有一些能够进行压力测试，发布后线上回归测试的工具，例如腾讯wetest等。\n3. 针对统计分析，每个业务都需要能够提供给产品人员观察数据的工具，当然由于数据敏感性，这里一般每个团队有内部的工具，对外的类似工具例如Google分析等。\n\n可以看出来工具平台主要就是围绕我们的研发流程中的每一步关键节点去建设起来的，结合起来说，我们可以称之为工程化。工程化是这几年非常热门的概念，对前端来讲也是一个很明确的前端发展方向，其实工具平台的完善过程就是架构工程化的推进过程。\n\n![图片描述](https://user-gold-cdn.xitu.io/2019/9/12/16d22dcf39285a31?w=851&h=281&f=png&s=42311)\n\n身为一名架构师，你需要有敏锐的嗅觉来洞悉这些节点。并且在适当的时机能够做出对业务有提升的工具平台，要做到遇到重复性的问题时，想想是不是开发出一款自动化工具平台来处理，这才是代码之外对业务提升解决方案。\n\n#### 流程和规范化\n\n身为一名架构师，对流程的制定和规范，是非常重要的。不要小瞧规范的威力，可以极大的提升开发效率，真正优秀的规范不会让使用者感到约束，而是能帮助他们快速定位问题，提升效率。\n这里的规范，总结起来可以分为成：\n1. 结构的规范：对项目的代码结构，不管前后端，合理的分层和组件化是非常必要的。\n2. 编码的规范：这里主要就是代码codereview了，定期的进行codeview的同时，最好可以使用一些自动化工具。\n3. 流程的规范：项目的评审，研发，测试，发布这些阶段都需要有流程来约束，这些需要结合自身团队的实际情况来制定。\n4. 规范的落地：对于规范来说最关键的是执行落地，在制定完规范的同时，要不时的回顾是否切实的落地，这个应该是团队里每个成员坚持的基本准则。\n\n![图片描述](https://user-gold-cdn.xitu.io/2019/9/12/16d22dcf39954e66?w=321&h=212&f=png&s=13114)\n\n#### 方法论\n\n所谓方法论，可能单单说起来是比较抽象的，这里的方法论，主要是指在完成一项小的需求，或者是承接一个重大的项目，在具体的实施过程中，要有一定的方法和技巧，相信大家都看过《穹顶之下》这个视频，就是很强的方法论体现。其实说白了讲就是做事要有套路，这里就举一个性能优化的例子。\n在性能优化时，我们如何证明优化是有效果的，可以采用“三明治法则”(自己起的名字)：\n\n1. 首先优化前，我们需要找到问题的现状，并且要有数据能够佐证优化前的状态。所以就要学会去收集数据。\n2. 有了数据之后，我们在进行对数据分析的同时，就需要找到问题出现的原因，并且付诸实施解决。这个阶段，就需要记录具体的优化原理。\n3. 优化之后，就要想方设法去验证，并且在验证过程中，同样需要收集数据。\n\n到此，我们就有了 优化前数据，优化的原理，优化后的数据。通过数据对比，我们就可以很轻易的去佐证我们这次优化是有成效的，并且可以做出一份很漂亮的总结，作为一名架构师而言，这是一个很好的树立威信的场景体现。\n\n我们可以在发散开来，上面的三步骤可以再次迭代，也就是说，第一次优化，我们达到了效果，但是深究之后，还可以再次进行优化，每次优化都有数据佐证，这就是性能优化的方法论。\n\n#### 安全意识\n\n这里为什么要把安全单独拿出来说呢，因为对于一个业务而言，安全是第一要素，就好比一个国家，安全稳定才是发展一切的前提，一旦业务出现安全问题，就可能瞬间损失掉全部，代价是非常惨重的。所以作为一名架构师，必须要保证业务的稳定性，可以总结以下几点：\n1. 对低级的的代码安全问题，要坚决说不，例如前端里面的xss，csrf这些问题。\n2. 对大型运营类活动需求，要有容灾意识和备份，例如在准备了一套方案的同时，要有可选的备用方案。\n3. 尝试使用工具化来解决和预防安全问题，例如BAT这种大型企业，在运维和代码层面，都有一层保障机制，如腾讯的门神系统等。\n\n#### 团队合作\n\n> 没有完美的个人，却有完美的团队。\n\n即使是一名架构师，我相信他也不是一直在一个人战斗，一个优秀的产品业务，总是诞生于团队，所以时刻保持和团队人员的沟通是必不可少的，这些沟通不限于日常的文字，或者会议，甚至私下的团建活动，都是可以相互了解的。\n所以团队合作的目的就是让团队中的每个人都能明确自己的职责，并发挥出最大的价值，架构师有义务来维护这种合作关系。并且对你的认同，也是团队成员赋予你的，维护良好的氛围，才能让团队成员信服。\n\n最后，总结一下，对前端架构师理解的一些误区：\n\n1. 架构师并不等于全栈工程师。\n2. 架构师切忌完全脱离代码，但是也不要一直闷着头写代码。\n3. 架构师应当跳出技术本身，从全局的角度来看的业务，发现并解决问题。\n4. 任何项目的架构都不是一开始制定好就是一成不变的，它应该是不断迭代和演进的，架构师有义务来保证架构的创新性。\n\n\n最后，希望各位前端同仁，能够在成为架构师的道路上，披荆斩棘，一帆风顺！\n\n欢迎关注新书：\n[《HTML5移动Web+Vue.js应用开发实战》](https://detail.tmall.com/item.htm?spm=a230r.1.14.1.52fe5594vGYpMr&id=620482199343&ns=1&abbucket=17)\n\n\n","slug":"前端开发与架构师","published":1,"updated":"2020-07-26T04:16:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434q0w002h2wvjzrf1pls4","content":"<p>前端架构师,听起来就是个很高大上的职位，在大多数程序员的眼中，架构师一般从事后端开发，Java或者C++出身，它们往往拥有这十八般武艺，可以解决业务中出现的各种问题。好像架构师就从来没有和前端有过关系，那么真的是这样么，通读此文，便可豁然开朗。</p>\n<h3><span id=\"前端的意义\">前端的意义：</span></h3><p>首先，我们先来谈谈本职工作，前端的意义。前端源自用户界面，是最先和用户接触的地方，也是衡量一个项目产品好坏的第一道关口。</p>\n<h4><span id=\"到底什么是前端\">到底什么是前端</span></h4><p>从最早的DOS系统说起，那时是没有前端的概念的，大多数的软件界面显示的都是冷冰冰的黑底白字的控制台命令，于是，慢慢的不仅是用户，就连广大的程序员也不满足现状，开发出一套图形化的用户界面，让一些功能更加便于操作。那时前端叫做GUI(图形用户界面)。还没有区分出多端的概念，大多数是基于操作系统开发出的原生界面。</p>\n<a id=\"more\"></a>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/9/12/16d22dcf38da3cd5?w=1280&amp;h=806&amp;f=png&amp;s=120978\" alt=\"图片描述\"><br>上图来自DOS系统经典软件<em>DOS Navigator</em></p>\n<p>随着互联网的发展，第一代浏览器Netscape(网景浏览器)的诞生以及后续的IE系列浏览器的到来，”网上冲浪“这个词逐渐进入到大多数的用户生活中。直到现在大行其道浏览器Chrome，以及国内各种百花齐放的浏览器。主要给浏览器服务，实现各种特效的JavaScript语言，迎来了第一波春天。<br><img src=\"https://user-gold-cdn.xitu.io/2019/9/12/16d22dcf38ee1b90?w=1238&amp;h=938&amp;f=png&amp;s=1258146\" alt=\"图片描述\"><br>上图来自<em>网景浏览器</em></p>\n<p>直到现在，前端逐渐拆分成：</p>\n<p>web前端(HTML+CSS+JavaScript)，客户端前端(Android和iOS)。</p>\n<p>又或者是网页重构工程师，JS工程师，UI/UX，切图仔等等。</p>\n<p>那么归根这些都是为前端服务的，说了这么多，那么前端的价值到底在哪里呢？</p>\n<h4><span id=\"前端的价值在哪呢\">前端的价值在哪呢？</span></h4><ul>\n<li>实现界面交互。</li>\n<li>提升用户体验。</li>\n</ul>\n<p>第一点是前端的本职工作，是在功能上和后端的主要区分，也是前端岗位存在的原因。第二点也不必多说，前端做得好，对用户体验是有益的。如果说后端的目标和价值体现在服务的高性能、高可用、可扩展、安全。那么前端的价值体现就是“用户”二字。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/9/12/16d22dcf38baa6ae?w=291&amp;h=291&amp;f=png&amp;s=17557\" alt=\"图片描述\"></p>\n<p>所以作为一个合格的前端开发，让用户用的舒心(爽)就是目标，所以要想完全体现你的价值，你需要循序渐进的完成下面几个步骤：</p>\n<ol>\n<li>根据产品的逻辑和需求，完成对应业务的前端页面UI展示，与用户交互。</li>\n<li>编写可维护性高的代码，减少BUG的产生，保证良好的用户体验。</li>\n<li>在完成功能的同时，能够熟悉现有业务，并提出可持续改进的地方，并付诸实施优化。</li>\n</ol>\n<p>看了上面的几条，是不是有种似曾相识的感觉，是不是很像一则招聘信息的JD。其实没错，作为一个企业来讲，招聘一名前端开发，肯定要能够为企业带来价值，这本身也是你的价值体现。</p>\n<p>但是，我想说的是，看似简简单单的3条内容，你真的理解么。第一条和第二条是你技术上的能力体现，这部分完全靠你的技术积累，那么第三条便是你主关能动性的体现，这部分可发挥的地方很多，一个新人和一个工作经验丰富的人差距可能就体现在这里，具体我们后面再说。</p>\n<p>但是，还想说的是，单纯的完成上面的3条步骤，那么还是只能说明你是一个合格的前端开发，这与架构师还是有一定的距离的。</p>\n<h4><span id=\"前端价值体现真的很重要么\">前端价值体现真的很重要么？</span></h4><p>好吧，上面我们了解了前端的价值，并且各位前端开发还在辛辛苦苦的体现着自己的价值，但是让人纠结的，前端是有价值，但这价值真的很重要吗？</p>\n<h5><span id=\"和非前端之外的技术相比\">和非前端之外的技术相比</span></h5><p>对于一个成熟的产品业务而言，前端往往是很薄的一层，这一层赋予你的功能，大多是就是页面的UI展示和用户交互。<br>虽说前端是产品和用户之间的第一道关口，但也只是第一道关口，后面可能还有十几道关口。例如搞后端逻辑的，搞底层数据库的，搞网络安全的，搞运维的，搞大数据分析的，或者是现在流行的机器学习的相关人员。每一个相关模块都自己独立的技术体系，可以说这些缺一不可。<br>所以，前端和这些前端之外的技术相比，就体现的并不是那么”非你不可“了。就是说前端的确有价值，但放在全局来看，前端产生的价值并非核心价值。</p>\n<h5><span id=\"对产品业务的重要性\">对产品业务的重要性</span></h5><p>举一个现在比较实际的例子，对于前端开发而言，在一些一线的互联网企业例如BAT等等，这些公司对前端开发的重视程度还是不错的，有着自己的产品业务线，整个前端技术有着不错的氛围，并且能够使用前端技术持续提升产品的用户体验。<br>但是对于一些其他的中小型公司或者企业(我相信各位并非都来自BAT吧)，很多前端开发的技术含量并不是很高，特别是对于一些toB的业务来说，核心的功能都来自于后端，来自于数据库的优化。或者是对于一些比较突出亮点的AI功能性产品，这些产品的核心竞争力甚至可能来自于硬件和算法。而前端在里面扮演的角色大多数是UI展示，数据可视化等等这些。而且很多工作属于重复性劳动，甚至有些可能还被后端开发来兼职做了。<br>所以，对于一个业务的重要性而言，前端能够体现其价值的地方还是很有限的。</p>\n<p>当然，这里说了这么多，并不是给大家传输一种：前端不行了，赶快转行吧，这种思想，当然我们还是要吃饭的，这里想说的是让大家时刻保持一种危机感，只有这种危机感，才是让我们不断的对技术进行深究和进阶，不断发展不断前行的动力。</p>\n<h3><span id=\"前端技术的进阶\">前端技术的进阶：</span></h3><p>在成为一名架构师之前，你需要有充分的技术储备，这些技术储备可能不止限制于前端技术。当然这里，我先介绍一些前端技术需要如何去进阶。</p>\n<h4><span id=\"性能优化\">性能优化</span></h4><p>在大厂工作过的同仁应该都知道，性能优化是一个敲门砖，因为如果去衡量一个前端开发是否真正的有经验，性能优化是一个分水岭，其相关流程主要涵盖：</p>\n<ol>\n<li>首先是如何发现问题。</li>\n<li>发现问题之后，是如何分析其中原因。</li>\n<li>找到原因之后，采用的解决办法。</li>\n<li>解决之后，是否真实的对用户体验有所提升。</li>\n</ol>\n<p>从这些问题中，可以衍生出各种值得深究的问题，并且可以从中找出一些方法论问题，所以性能优化是一项非常重要的点，当然，我们在这里就不说具体有哪些优化了，推荐读一读<a href=\"https://juejin.im/post/5c931c4a6fb9a070dc28923b\" target=\"_blank\" rel=\"noopener\">《移动web性能优化从入门到进阶》</a>这篇文章。</p>\n<h4><span id=\"对框架的理解\">对框架的理解</span></h4><blockquote>\n<p>如果你想成为一名架构师，不能只停留在框架的 API 使用层面。</p>\n</blockquote>\n<p>对于当下最流行的3个前端框架Vue，React，Angular来说，掌握其基本的用法是必要的，但是也是最简单的，现在网上有各种各样的课程，可以让一个刚毕业的实习生就能轻松入门，并达道做项目的能力。所以说，为什么一个需求，给一个实习生就能做，为什么要选择你呢？</p>\n<p>所以，掌握框架的原理，并理解其中的思想，举一反三，是和大多数前端程序员拉开差距的关键所在，在这里给大家以Vue举几个例子，看看你是否真正掌握。</p>\n<ol>\n<li>Vue中的双向绑定，只是简单的<code>Object.defineProperty()</code>么？</li>\n<li>Vue的数据依赖是如何实现的？</li>\n<li>Vue的computed和watch到底有何本质区别？</li>\n<li>keep-alive的实现原理？</li>\n</ol>\n<p>大家不妨试试去理解一下这几个问题的根本点，试试从源码里来找到答案。理解源码的同时，有利于对框架本身的理解，对于提升解决问题的能力，以及减少出现BUG的几率，有所帮助。</p>\n<h4><span id=\"深入nodejs领域\">深入Node.js领域</span></h4><p>Node.js是让前端工程师能够触及后端逻辑的一个利器，也给了我们抢后端饭碗的正当理由，但是这里的Node.js并不是单独的指后端逻辑的开发。例如现在的前端工程化体系中，扮演重要角色的webpack，parcel，vue-cli等等，或者是现在让JavaScript能够开发PC桌面程序的Electron，都和Node.js密不可分，在这里给大家举几个例子，可以尝试一下从这几个点来进阶：</p>\n<ol>\n<li>与浏览器端的JavaScript不同，Node.js后端是直面服务器的，如何定位和分析内存泄漏问题。</li>\n<li>尝试写一些webpack插件。</li>\n</ol>\n<h4><span id=\"canvas与webgl\">Canvas与WebGL</span></h4><p>WebGL是基于OpenGL的Web3D图形规范，是一套JavaScript的API。简单来说，可以把它看成是3D版的Canvas，当然，提到这个方向，可能有些人会觉得有点偏了。的确对于大多数前端开发来说，使用WebGL相关的3D处理技术和算法，并不需要掌握复杂的算法或者数学知识，只需要学会three.js就行了。<br>但是基于Canvas或者WebGL可以提供给我们针对一些特定问题的解决方案。同样在这里给大家举几个例子：</p>\n<ol>\n<li>实现一个刮刮卡或者涂鸦墙的业务需求。</li>\n<li>图片上传时进行压缩和裁剪。</li>\n<li>在实现帧动画方面，使用CSS3和Canvas的选择。</li>\n</ol>\n<p>上面几个场景，就好比你拿到这些需求时，如果你根本不了解Canvas或者WebGL，你可能根本想不到有这些技术方案可以解决这些问题，所以，并不是说对Canvas或WebGL理解的多么透彻，但是作为一个架构师而言，你需要有一些技术广度，来拓宽你的技术栈，也就提升了你解决问题的能力。</p>\n<h3><span id=\"通往架构师之路\">通往架构师之路：</span></h3><p>说道这里，好像才进入正题。基本的进阶知识是你晋升成为成为高级前端的必要条件，但却不是你成为一名架构师的核心。正所谓一专多长，首先你得先精通一门。前端知识的进阶正是通往架构师的突破口，所以首先需要明白一点：掌握前端技术的同时，你还要学了解前端技术之外的技能。跳出前端这个思维，才能看到的更多。那么如果你想从一个前端资深人员进阶架构师，来看看下面的内容吧。</p>\n<h4><span id=\"跨界\">跨界</span></h4><p>如果你只会写前端页面，那么无论你的功力练到多么炉火纯青的地步，那么也只能称为你是一个HTML高手。<br>真正的架构师是需要有跨界的能力的，随着技术的持续完善，这种通过岗位变迁实现技术架构升级的情况会越来越少。而架构层面新的变化将来自于岗位自发的对自身工作内容、职责的重新定义，也就是这里说的边界。所以说并不是你作为一个前端开发岗位，你就不能干前端之外的事了，要尝试跳出边界来思考和解决问题。</p>\n<p>页面的秒开是衡量一个前端优化的重要指标，我们以这个优化点来总结一下从哪些方面跨：</p>\n<ol>\n<li>提升速度，从服务端渲染着手，可以利用Node.js往后端跨。</li>\n<li>提升移动web的H5页面的启动耗时，从webview着手，利用iOS和Android技能往客户端跨。</li>\n</ol>\n<p>用户交互操作体验，也是衡量前端优化的重要指标，我们以这个优化点来总结一下从哪些方面跨：</p>\n<ol>\n<li>提升用户交互体验，尝试将web页面客户端化，基于React Native或者Weex，也可以往客户端跨。</li>\n<li>提升页面动画效果，编写高性能的前端动画，也可以往UI动效设计跨。</li>\n</ol>\n<p>合理的跨界，可以让架构师对于业务的整体有深层次的认识，针对各种问题可以提出非前端之外的解决方案。</p>\n<h4><span id=\"尝鲜\">尝鲜</span></h4><p>技术是不断发展的，作为一个架构师，不断学习新的技术是非常重要的，这里所说的尝鲜，就是要对技术保持一定的热情，不能只满足于现状，说白了讲就是要不断的学。</p>\n<ol>\n<li>习惯了jQuery开发页面，不妨试试Vue，React。</li>\n<li>写了很久的ES5代码，学学ES6也不错。</li>\n<li>沉醉在HTML，CSS，JavaScript开发页面，不妨学学Flutter。</li>\n<li>打造高性能的Web App，试试Service Worker。</li>\n<li>从HTTP协议触发，改造升级spdy和HTTP2，尝试一下HTTP3。</li>\n<li>尝试一下新的编程语言：WebAssembly。</li>\n<li>知道为服务，但你知道微前端吗。</li>\n</ol>\n<p>上面列举的尝鲜技能，是完全可以从一个前端的角度触发，来不断深入的，保持对每一个新技术的求知欲，是一名架构师必不可少的。</p>\n<h4><span id=\"工具和平台化建设\">工具和平台化建设</span></h4><blockquote>\n<p>只会写代码的程序员只能叫码农。</p>\n</blockquote>\n<p>当技术达到一定的高度时，能够为业务再次提升的能力就会逐渐变少，那么我们不如跳出技术本身，来改善业务周边的工具平台，同样来为业务服务。作为一名架构师，要有这种能力。</p>\n<p>提到工具平台，大家很快就能跟自己的团队里面的一些工具联系起来。这里主要跟大家探讨一下，我们的工具体系要用什么的思路去规划和review，也看一下我们还有那些可以进一步去完善的点。<br><img src=\"https://user-gold-cdn.xitu.io/2019/9/12/16d22dcf393b5fbb?w=851&amp;h=281&amp;f=png&amp;s=35036\" alt=\"图片描述\"></p>\n<p>为了通俗一点，同样举几个工具平台的例子：</p>\n<ol>\n<li>针对开发调试，需要有一些提升开发效率的工具，例如移动web常用的Fiddler，或者是小程序模拟器。</li>\n<li>针对性能检测，需要有一些能够进行压力测试，发布后线上回归测试的工具，例如腾讯wetest等。</li>\n<li>针对统计分析，每个业务都需要能够提供给产品人员观察数据的工具，当然由于数据敏感性，这里一般每个团队有内部的工具，对外的类似工具例如Google分析等。</li>\n</ol>\n<p>可以看出来工具平台主要就是围绕我们的研发流程中的每一步关键节点去建设起来的，结合起来说，我们可以称之为工程化。工程化是这几年非常热门的概念，对前端来讲也是一个很明确的前端发展方向，其实工具平台的完善过程就是架构工程化的推进过程。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/9/12/16d22dcf39285a31?w=851&amp;h=281&amp;f=png&amp;s=42311\" alt=\"图片描述\"></p>\n<p>身为一名架构师，你需要有敏锐的嗅觉来洞悉这些节点。并且在适当的时机能够做出对业务有提升的工具平台，要做到遇到重复性的问题时，想想是不是开发出一款自动化工具平台来处理，这才是代码之外对业务提升解决方案。</p>\n<h4><span id=\"流程和规范化\">流程和规范化</span></h4><p>身为一名架构师，对流程的制定和规范，是非常重要的。不要小瞧规范的威力，可以极大的提升开发效率，真正优秀的规范不会让使用者感到约束，而是能帮助他们快速定位问题，提升效率。<br>这里的规范，总结起来可以分为成：</p>\n<ol>\n<li>结构的规范：对项目的代码结构，不管前后端，合理的分层和组件化是非常必要的。</li>\n<li>编码的规范：这里主要就是代码codereview了，定期的进行codeview的同时，最好可以使用一些自动化工具。</li>\n<li>流程的规范：项目的评审，研发，测试，发布这些阶段都需要有流程来约束，这些需要结合自身团队的实际情况来制定。</li>\n<li>规范的落地：对于规范来说最关键的是执行落地，在制定完规范的同时，要不时的回顾是否切实的落地，这个应该是团队里每个成员坚持的基本准则。</li>\n</ol>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/9/12/16d22dcf39954e66?w=321&amp;h=212&amp;f=png&amp;s=13114\" alt=\"图片描述\"></p>\n<h4><span id=\"方法论\">方法论</span></h4><p>所谓方法论，可能单单说起来是比较抽象的，这里的方法论，主要是指在完成一项小的需求，或者是承接一个重大的项目，在具体的实施过程中，要有一定的方法和技巧，相信大家都看过《穹顶之下》这个视频，就是很强的方法论体现。其实说白了讲就是做事要有套路，这里就举一个性能优化的例子。<br>在性能优化时，我们如何证明优化是有效果的，可以采用“三明治法则”(自己起的名字)：</p>\n<ol>\n<li>首先优化前，我们需要找到问题的现状，并且要有数据能够佐证优化前的状态。所以就要学会去收集数据。</li>\n<li>有了数据之后，我们在进行对数据分析的同时，就需要找到问题出现的原因，并且付诸实施解决。这个阶段，就需要记录具体的优化原理。</li>\n<li>优化之后，就要想方设法去验证，并且在验证过程中，同样需要收集数据。</li>\n</ol>\n<p>到此，我们就有了 优化前数据，优化的原理，优化后的数据。通过数据对比，我们就可以很轻易的去佐证我们这次优化是有成效的，并且可以做出一份很漂亮的总结，作为一名架构师而言，这是一个很好的树立威信的场景体现。</p>\n<p>我们可以在发散开来，上面的三步骤可以再次迭代，也就是说，第一次优化，我们达到了效果，但是深究之后，还可以再次进行优化，每次优化都有数据佐证，这就是性能优化的方法论。</p>\n<h4><span id=\"安全意识\">安全意识</span></h4><p>这里为什么要把安全单独拿出来说呢，因为对于一个业务而言，安全是第一要素，就好比一个国家，安全稳定才是发展一切的前提，一旦业务出现安全问题，就可能瞬间损失掉全部，代价是非常惨重的。所以作为一名架构师，必须要保证业务的稳定性，可以总结以下几点：</p>\n<ol>\n<li>对低级的的代码安全问题，要坚决说不，例如前端里面的xss，csrf这些问题。</li>\n<li>对大型运营类活动需求，要有容灾意识和备份，例如在准备了一套方案的同时，要有可选的备用方案。</li>\n<li>尝试使用工具化来解决和预防安全问题，例如BAT这种大型企业，在运维和代码层面，都有一层保障机制，如腾讯的门神系统等。</li>\n</ol>\n<h4><span id=\"团队合作\">团队合作</span></h4><blockquote>\n<p>没有完美的个人，却有完美的团队。</p>\n</blockquote>\n<p>即使是一名架构师，我相信他也不是一直在一个人战斗，一个优秀的产品业务，总是诞生于团队，所以时刻保持和团队人员的沟通是必不可少的，这些沟通不限于日常的文字，或者会议，甚至私下的团建活动，都是可以相互了解的。<br>所以团队合作的目的就是让团队中的每个人都能明确自己的职责，并发挥出最大的价值，架构师有义务来维护这种合作关系。并且对你的认同，也是团队成员赋予你的，维护良好的氛围，才能让团队成员信服。</p>\n<p>最后，总结一下，对前端架构师理解的一些误区：</p>\n<ol>\n<li>架构师并不等于全栈工程师。</li>\n<li>架构师切忌完全脱离代码，但是也不要一直闷着头写代码。</li>\n<li>架构师应当跳出技术本身，从全局的角度来看的业务，发现并解决问题。</li>\n<li>任何项目的架构都不是一开始制定好就是一成不变的，它应该是不断迭代和演进的，架构师有义务来保证架构的创新性。</li>\n</ol>\n<p>最后，希望各位前端同仁，能够在成为架构师的道路上，披荆斩棘，一帆风顺！</p>\n<p>欢迎关注新书：<br><a href=\"https://detail.tmall.com/item.htm?spm=a230r.1.14.1.52fe5594vGYpMr&amp;id=620482199343&amp;ns=1&amp;abbucket=17\" target=\"_blank\" rel=\"noopener\">《HTML5移动Web+Vue.js应用开发实战》</a></p>\n","site":{"data":{}},"excerpt":"<p>前端架构师,听起来就是个很高大上的职位，在大多数程序员的眼中，架构师一般从事后端开发，Java或者C++出身，它们往往拥有这十八般武艺，可以解决业务中出现的各种问题。好像架构师就从来没有和前端有过关系，那么真的是这样么，通读此文，便可豁然开朗。</p>\n<h3 id=\"前端的意义：\"><a href=\"#前端的意义：\" class=\"headerlink\" title=\"前端的意义：\"></a>前端的意义：</h3><p>首先，我们先来谈谈本职工作，前端的意义。前端源自用户界面，是最先和用户接触的地方，也是衡量一个项目产品好坏的第一道关口。</p>\n<h4 id=\"到底什么是前端\"><a href=\"#到底什么是前端\" class=\"headerlink\" title=\"到底什么是前端\"></a>到底什么是前端</h4><p>从最早的DOS系统说起，那时是没有前端的概念的，大多数的软件界面显示的都是冷冰冰的黑底白字的控制台命令，于是，慢慢的不仅是用户，就连广大的程序员也不满足现状，开发出一套图形化的用户界面，让一些功能更加便于操作。那时前端叫做GUI(图形用户界面)。还没有区分出多端的概念，大多数是基于操作系统开发出的原生界面。</p>","more":"<p><img src=\"https://user-gold-cdn.xitu.io/2019/9/12/16d22dcf38da3cd5?w=1280&amp;h=806&amp;f=png&amp;s=120978\" alt=\"图片描述\"><br>上图来自DOS系统经典软件<em>DOS Navigator</em></p>\n<p>随着互联网的发展，第一代浏览器Netscape(网景浏览器)的诞生以及后续的IE系列浏览器的到来，”网上冲浪“这个词逐渐进入到大多数的用户生活中。直到现在大行其道浏览器Chrome，以及国内各种百花齐放的浏览器。主要给浏览器服务，实现各种特效的JavaScript语言，迎来了第一波春天。<br><img src=\"https://user-gold-cdn.xitu.io/2019/9/12/16d22dcf38ee1b90?w=1238&amp;h=938&amp;f=png&amp;s=1258146\" alt=\"图片描述\"><br>上图来自<em>网景浏览器</em></p>\n<p>直到现在，前端逐渐拆分成：</p>\n<p>web前端(HTML+CSS+JavaScript)，客户端前端(Android和iOS)。</p>\n<p>又或者是网页重构工程师，JS工程师，UI/UX，切图仔等等。</p>\n<p>那么归根这些都是为前端服务的，说了这么多，那么前端的价值到底在哪里呢？</p>\n<h4 id=\"前端的价值在哪呢？\"><a href=\"#前端的价值在哪呢？\" class=\"headerlink\" title=\"前端的价值在哪呢？\"></a>前端的价值在哪呢？</h4><ul>\n<li>实现界面交互。</li>\n<li>提升用户体验。</li>\n</ul>\n<p>第一点是前端的本职工作，是在功能上和后端的主要区分，也是前端岗位存在的原因。第二点也不必多说，前端做得好，对用户体验是有益的。如果说后端的目标和价值体现在服务的高性能、高可用、可扩展、安全。那么前端的价值体现就是“用户”二字。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/9/12/16d22dcf38baa6ae?w=291&amp;h=291&amp;f=png&amp;s=17557\" alt=\"图片描述\"></p>\n<p>所以作为一个合格的前端开发，让用户用的舒心(爽)就是目标，所以要想完全体现你的价值，你需要循序渐进的完成下面几个步骤：</p>\n<ol>\n<li>根据产品的逻辑和需求，完成对应业务的前端页面UI展示，与用户交互。</li>\n<li>编写可维护性高的代码，减少BUG的产生，保证良好的用户体验。</li>\n<li>在完成功能的同时，能够熟悉现有业务，并提出可持续改进的地方，并付诸实施优化。</li>\n</ol>\n<p>看了上面的几条，是不是有种似曾相识的感觉，是不是很像一则招聘信息的JD。其实没错，作为一个企业来讲，招聘一名前端开发，肯定要能够为企业带来价值，这本身也是你的价值体现。</p>\n<p>但是，我想说的是，看似简简单单的3条内容，你真的理解么。第一条和第二条是你技术上的能力体现，这部分完全靠你的技术积累，那么第三条便是你主关能动性的体现，这部分可发挥的地方很多，一个新人和一个工作经验丰富的人差距可能就体现在这里，具体我们后面再说。</p>\n<p>但是，还想说的是，单纯的完成上面的3条步骤，那么还是只能说明你是一个合格的前端开发，这与架构师还是有一定的距离的。</p>\n<h4 id=\"前端价值体现真的很重要么？\"><a href=\"#前端价值体现真的很重要么？\" class=\"headerlink\" title=\"前端价值体现真的很重要么？\"></a>前端价值体现真的很重要么？</h4><p>好吧，上面我们了解了前端的价值，并且各位前端开发还在辛辛苦苦的体现着自己的价值，但是让人纠结的，前端是有价值，但这价值真的很重要吗？</p>\n<h5 id=\"和非前端之外的技术相比\"><a href=\"#和非前端之外的技术相比\" class=\"headerlink\" title=\"和非前端之外的技术相比\"></a>和非前端之外的技术相比</h5><p>对于一个成熟的产品业务而言，前端往往是很薄的一层，这一层赋予你的功能，大多是就是页面的UI展示和用户交互。<br>虽说前端是产品和用户之间的第一道关口，但也只是第一道关口，后面可能还有十几道关口。例如搞后端逻辑的，搞底层数据库的，搞网络安全的，搞运维的，搞大数据分析的，或者是现在流行的机器学习的相关人员。每一个相关模块都自己独立的技术体系，可以说这些缺一不可。<br>所以，前端和这些前端之外的技术相比，就体现的并不是那么”非你不可“了。就是说前端的确有价值，但放在全局来看，前端产生的价值并非核心价值。</p>\n<h5 id=\"对产品业务的重要性\"><a href=\"#对产品业务的重要性\" class=\"headerlink\" title=\"对产品业务的重要性\"></a>对产品业务的重要性</h5><p>举一个现在比较实际的例子，对于前端开发而言，在一些一线的互联网企业例如BAT等等，这些公司对前端开发的重视程度还是不错的，有着自己的产品业务线，整个前端技术有着不错的氛围，并且能够使用前端技术持续提升产品的用户体验。<br>但是对于一些其他的中小型公司或者企业(我相信各位并非都来自BAT吧)，很多前端开发的技术含量并不是很高，特别是对于一些toB的业务来说，核心的功能都来自于后端，来自于数据库的优化。或者是对于一些比较突出亮点的AI功能性产品，这些产品的核心竞争力甚至可能来自于硬件和算法。而前端在里面扮演的角色大多数是UI展示，数据可视化等等这些。而且很多工作属于重复性劳动，甚至有些可能还被后端开发来兼职做了。<br>所以，对于一个业务的重要性而言，前端能够体现其价值的地方还是很有限的。</p>\n<p>当然，这里说了这么多，并不是给大家传输一种：前端不行了，赶快转行吧，这种思想，当然我们还是要吃饭的，这里想说的是让大家时刻保持一种危机感，只有这种危机感，才是让我们不断的对技术进行深究和进阶，不断发展不断前行的动力。</p>\n<h3 id=\"前端技术的进阶：\"><a href=\"#前端技术的进阶：\" class=\"headerlink\" title=\"前端技术的进阶：\"></a>前端技术的进阶：</h3><p>在成为一名架构师之前，你需要有充分的技术储备，这些技术储备可能不止限制于前端技术。当然这里，我先介绍一些前端技术需要如何去进阶。</p>\n<h4 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h4><p>在大厂工作过的同仁应该都知道，性能优化是一个敲门砖，因为如果去衡量一个前端开发是否真正的有经验，性能优化是一个分水岭，其相关流程主要涵盖：</p>\n<ol>\n<li>首先是如何发现问题。</li>\n<li>发现问题之后，是如何分析其中原因。</li>\n<li>找到原因之后，采用的解决办法。</li>\n<li>解决之后，是否真实的对用户体验有所提升。</li>\n</ol>\n<p>从这些问题中，可以衍生出各种值得深究的问题，并且可以从中找出一些方法论问题，所以性能优化是一项非常重要的点，当然，我们在这里就不说具体有哪些优化了，推荐读一读<a href=\"https://juejin.im/post/5c931c4a6fb9a070dc28923b\" target=\"_blank\" rel=\"noopener\">《移动web性能优化从入门到进阶》</a>这篇文章。</p>\n<h4 id=\"对框架的理解\"><a href=\"#对框架的理解\" class=\"headerlink\" title=\"对框架的理解\"></a>对框架的理解</h4><blockquote>\n<p>如果你想成为一名架构师，不能只停留在框架的 API 使用层面。</p>\n</blockquote>\n<p>对于当下最流行的3个前端框架Vue，React，Angular来说，掌握其基本的用法是必要的，但是也是最简单的，现在网上有各种各样的课程，可以让一个刚毕业的实习生就能轻松入门，并达道做项目的能力。所以说，为什么一个需求，给一个实习生就能做，为什么要选择你呢？</p>\n<p>所以，掌握框架的原理，并理解其中的思想，举一反三，是和大多数前端程序员拉开差距的关键所在，在这里给大家以Vue举几个例子，看看你是否真正掌握。</p>\n<ol>\n<li>Vue中的双向绑定，只是简单的<code>Object.defineProperty()</code>么？</li>\n<li>Vue的数据依赖是如何实现的？</li>\n<li>Vue的computed和watch到底有何本质区别？</li>\n<li>keep-alive的实现原理？</li>\n</ol>\n<p>大家不妨试试去理解一下这几个问题的根本点，试试从源码里来找到答案。理解源码的同时，有利于对框架本身的理解，对于提升解决问题的能力，以及减少出现BUG的几率，有所帮助。</p>\n<h4 id=\"深入Node-js领域\"><a href=\"#深入Node-js领域\" class=\"headerlink\" title=\"深入Node.js领域\"></a>深入Node.js领域</h4><p>Node.js是让前端工程师能够触及后端逻辑的一个利器，也给了我们抢后端饭碗的正当理由，但是这里的Node.js并不是单独的指后端逻辑的开发。例如现在的前端工程化体系中，扮演重要角色的webpack，parcel，vue-cli等等，或者是现在让JavaScript能够开发PC桌面程序的Electron，都和Node.js密不可分，在这里给大家举几个例子，可以尝试一下从这几个点来进阶：</p>\n<ol>\n<li>与浏览器端的JavaScript不同，Node.js后端是直面服务器的，如何定位和分析内存泄漏问题。</li>\n<li>尝试写一些webpack插件。</li>\n</ol>\n<h4 id=\"Canvas与WebGL\"><a href=\"#Canvas与WebGL\" class=\"headerlink\" title=\"Canvas与WebGL\"></a>Canvas与WebGL</h4><p>WebGL是基于OpenGL的Web3D图形规范，是一套JavaScript的API。简单来说，可以把它看成是3D版的Canvas，当然，提到这个方向，可能有些人会觉得有点偏了。的确对于大多数前端开发来说，使用WebGL相关的3D处理技术和算法，并不需要掌握复杂的算法或者数学知识，只需要学会three.js就行了。<br>但是基于Canvas或者WebGL可以提供给我们针对一些特定问题的解决方案。同样在这里给大家举几个例子：</p>\n<ol>\n<li>实现一个刮刮卡或者涂鸦墙的业务需求。</li>\n<li>图片上传时进行压缩和裁剪。</li>\n<li>在实现帧动画方面，使用CSS3和Canvas的选择。</li>\n</ol>\n<p>上面几个场景，就好比你拿到这些需求时，如果你根本不了解Canvas或者WebGL，你可能根本想不到有这些技术方案可以解决这些问题，所以，并不是说对Canvas或WebGL理解的多么透彻，但是作为一个架构师而言，你需要有一些技术广度，来拓宽你的技术栈，也就提升了你解决问题的能力。</p>\n<h3 id=\"通往架构师之路：\"><a href=\"#通往架构师之路：\" class=\"headerlink\" title=\"通往架构师之路：\"></a>通往架构师之路：</h3><p>说道这里，好像才进入正题。基本的进阶知识是你晋升成为成为高级前端的必要条件，但却不是你成为一名架构师的核心。正所谓一专多长，首先你得先精通一门。前端知识的进阶正是通往架构师的突破口，所以首先需要明白一点：掌握前端技术的同时，你还要学了解前端技术之外的技能。跳出前端这个思维，才能看到的更多。那么如果你想从一个前端资深人员进阶架构师，来看看下面的内容吧。</p>\n<h4 id=\"跨界\"><a href=\"#跨界\" class=\"headerlink\" title=\"跨界\"></a>跨界</h4><p>如果你只会写前端页面，那么无论你的功力练到多么炉火纯青的地步，那么也只能称为你是一个HTML高手。<br>真正的架构师是需要有跨界的能力的，随着技术的持续完善，这种通过岗位变迁实现技术架构升级的情况会越来越少。而架构层面新的变化将来自于岗位自发的对自身工作内容、职责的重新定义，也就是这里说的边界。所以说并不是你作为一个前端开发岗位，你就不能干前端之外的事了，要尝试跳出边界来思考和解决问题。</p>\n<p>页面的秒开是衡量一个前端优化的重要指标，我们以这个优化点来总结一下从哪些方面跨：</p>\n<ol>\n<li>提升速度，从服务端渲染着手，可以利用Node.js往后端跨。</li>\n<li>提升移动web的H5页面的启动耗时，从webview着手，利用iOS和Android技能往客户端跨。</li>\n</ol>\n<p>用户交互操作体验，也是衡量前端优化的重要指标，我们以这个优化点来总结一下从哪些方面跨：</p>\n<ol>\n<li>提升用户交互体验，尝试将web页面客户端化，基于React Native或者Weex，也可以往客户端跨。</li>\n<li>提升页面动画效果，编写高性能的前端动画，也可以往UI动效设计跨。</li>\n</ol>\n<p>合理的跨界，可以让架构师对于业务的整体有深层次的认识，针对各种问题可以提出非前端之外的解决方案。</p>\n<h4 id=\"尝鲜\"><a href=\"#尝鲜\" class=\"headerlink\" title=\"尝鲜\"></a>尝鲜</h4><p>技术是不断发展的，作为一个架构师，不断学习新的技术是非常重要的，这里所说的尝鲜，就是要对技术保持一定的热情，不能只满足于现状，说白了讲就是要不断的学。</p>\n<ol>\n<li>习惯了jQuery开发页面，不妨试试Vue，React。</li>\n<li>写了很久的ES5代码，学学ES6也不错。</li>\n<li>沉醉在HTML，CSS，JavaScript开发页面，不妨学学Flutter。</li>\n<li>打造高性能的Web App，试试Service Worker。</li>\n<li>从HTTP协议触发，改造升级spdy和HTTP2，尝试一下HTTP3。</li>\n<li>尝试一下新的编程语言：WebAssembly。</li>\n<li>知道为服务，但你知道微前端吗。</li>\n</ol>\n<p>上面列举的尝鲜技能，是完全可以从一个前端的角度触发，来不断深入的，保持对每一个新技术的求知欲，是一名架构师必不可少的。</p>\n<h4 id=\"工具和平台化建设\"><a href=\"#工具和平台化建设\" class=\"headerlink\" title=\"工具和平台化建设\"></a>工具和平台化建设</h4><blockquote>\n<p>只会写代码的程序员只能叫码农。</p>\n</blockquote>\n<p>当技术达到一定的高度时，能够为业务再次提升的能力就会逐渐变少，那么我们不如跳出技术本身，来改善业务周边的工具平台，同样来为业务服务。作为一名架构师，要有这种能力。</p>\n<p>提到工具平台，大家很快就能跟自己的团队里面的一些工具联系起来。这里主要跟大家探讨一下，我们的工具体系要用什么的思路去规划和review，也看一下我们还有那些可以进一步去完善的点。<br><img src=\"https://user-gold-cdn.xitu.io/2019/9/12/16d22dcf393b5fbb?w=851&amp;h=281&amp;f=png&amp;s=35036\" alt=\"图片描述\"></p>\n<p>为了通俗一点，同样举几个工具平台的例子：</p>\n<ol>\n<li>针对开发调试，需要有一些提升开发效率的工具，例如移动web常用的Fiddler，或者是小程序模拟器。</li>\n<li>针对性能检测，需要有一些能够进行压力测试，发布后线上回归测试的工具，例如腾讯wetest等。</li>\n<li>针对统计分析，每个业务都需要能够提供给产品人员观察数据的工具，当然由于数据敏感性，这里一般每个团队有内部的工具，对外的类似工具例如Google分析等。</li>\n</ol>\n<p>可以看出来工具平台主要就是围绕我们的研发流程中的每一步关键节点去建设起来的，结合起来说，我们可以称之为工程化。工程化是这几年非常热门的概念，对前端来讲也是一个很明确的前端发展方向，其实工具平台的完善过程就是架构工程化的推进过程。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/9/12/16d22dcf39285a31?w=851&amp;h=281&amp;f=png&amp;s=42311\" alt=\"图片描述\"></p>\n<p>身为一名架构师，你需要有敏锐的嗅觉来洞悉这些节点。并且在适当的时机能够做出对业务有提升的工具平台，要做到遇到重复性的问题时，想想是不是开发出一款自动化工具平台来处理，这才是代码之外对业务提升解决方案。</p>\n<h4 id=\"流程和规范化\"><a href=\"#流程和规范化\" class=\"headerlink\" title=\"流程和规范化\"></a>流程和规范化</h4><p>身为一名架构师，对流程的制定和规范，是非常重要的。不要小瞧规范的威力，可以极大的提升开发效率，真正优秀的规范不会让使用者感到约束，而是能帮助他们快速定位问题，提升效率。<br>这里的规范，总结起来可以分为成：</p>\n<ol>\n<li>结构的规范：对项目的代码结构，不管前后端，合理的分层和组件化是非常必要的。</li>\n<li>编码的规范：这里主要就是代码codereview了，定期的进行codeview的同时，最好可以使用一些自动化工具。</li>\n<li>流程的规范：项目的评审，研发，测试，发布这些阶段都需要有流程来约束，这些需要结合自身团队的实际情况来制定。</li>\n<li>规范的落地：对于规范来说最关键的是执行落地，在制定完规范的同时，要不时的回顾是否切实的落地，这个应该是团队里每个成员坚持的基本准则。</li>\n</ol>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/9/12/16d22dcf39954e66?w=321&amp;h=212&amp;f=png&amp;s=13114\" alt=\"图片描述\"></p>\n<h4 id=\"方法论\"><a href=\"#方法论\" class=\"headerlink\" title=\"方法论\"></a>方法论</h4><p>所谓方法论，可能单单说起来是比较抽象的，这里的方法论，主要是指在完成一项小的需求，或者是承接一个重大的项目，在具体的实施过程中，要有一定的方法和技巧，相信大家都看过《穹顶之下》这个视频，就是很强的方法论体现。其实说白了讲就是做事要有套路，这里就举一个性能优化的例子。<br>在性能优化时，我们如何证明优化是有效果的，可以采用“三明治法则”(自己起的名字)：</p>\n<ol>\n<li>首先优化前，我们需要找到问题的现状，并且要有数据能够佐证优化前的状态。所以就要学会去收集数据。</li>\n<li>有了数据之后，我们在进行对数据分析的同时，就需要找到问题出现的原因，并且付诸实施解决。这个阶段，就需要记录具体的优化原理。</li>\n<li>优化之后，就要想方设法去验证，并且在验证过程中，同样需要收集数据。</li>\n</ol>\n<p>到此，我们就有了 优化前数据，优化的原理，优化后的数据。通过数据对比，我们就可以很轻易的去佐证我们这次优化是有成效的，并且可以做出一份很漂亮的总结，作为一名架构师而言，这是一个很好的树立威信的场景体现。</p>\n<p>我们可以在发散开来，上面的三步骤可以再次迭代，也就是说，第一次优化，我们达到了效果，但是深究之后，还可以再次进行优化，每次优化都有数据佐证，这就是性能优化的方法论。</p>\n<h4 id=\"安全意识\"><a href=\"#安全意识\" class=\"headerlink\" title=\"安全意识\"></a>安全意识</h4><p>这里为什么要把安全单独拿出来说呢，因为对于一个业务而言，安全是第一要素，就好比一个国家，安全稳定才是发展一切的前提，一旦业务出现安全问题，就可能瞬间损失掉全部，代价是非常惨重的。所以作为一名架构师，必须要保证业务的稳定性，可以总结以下几点：</p>\n<ol>\n<li>对低级的的代码安全问题，要坚决说不，例如前端里面的xss，csrf这些问题。</li>\n<li>对大型运营类活动需求，要有容灾意识和备份，例如在准备了一套方案的同时，要有可选的备用方案。</li>\n<li>尝试使用工具化来解决和预防安全问题，例如BAT这种大型企业，在运维和代码层面，都有一层保障机制，如腾讯的门神系统等。</li>\n</ol>\n<h4 id=\"团队合作\"><a href=\"#团队合作\" class=\"headerlink\" title=\"团队合作\"></a>团队合作</h4><blockquote>\n<p>没有完美的个人，却有完美的团队。</p>\n</blockquote>\n<p>即使是一名架构师，我相信他也不是一直在一个人战斗，一个优秀的产品业务，总是诞生于团队，所以时刻保持和团队人员的沟通是必不可少的，这些沟通不限于日常的文字，或者会议，甚至私下的团建活动，都是可以相互了解的。<br>所以团队合作的目的就是让团队中的每个人都能明确自己的职责，并发挥出最大的价值，架构师有义务来维护这种合作关系。并且对你的认同，也是团队成员赋予你的，维护良好的氛围，才能让团队成员信服。</p>\n<p>最后，总结一下，对前端架构师理解的一些误区：</p>\n<ol>\n<li>架构师并不等于全栈工程师。</li>\n<li>架构师切忌完全脱离代码，但是也不要一直闷着头写代码。</li>\n<li>架构师应当跳出技术本身，从全局的角度来看的业务，发现并解决问题。</li>\n<li>任何项目的架构都不是一开始制定好就是一成不变的，它应该是不断迭代和演进的，架构师有义务来保证架构的创新性。</li>\n</ol>\n<p>最后，希望各位前端同仁，能够在成为架构师的道路上，披荆斩棘，一帆风顺！</p>\n<p>欢迎关注新书：<br><a href=\"https://detail.tmall.com/item.htm?spm=a230r.1.14.1.52fe5594vGYpMr&amp;id=620482199343&amp;ns=1&amp;abbucket=17\" target=\"_blank\" rel=\"noopener\">《HTML5移动Web+Vue.js应用开发实战》</a></p>"},{"title":"前端算法--二叉树遍历","date":"2021-02-26T09:26:17.000Z","_content":"\n## 二叉树基本概念\n\n二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。\n<!--more-->\n二叉树特点是每个结点最多只能有两棵子树，且有左右之分。\n\n![!()[]](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb0cc313a4534904a8cf32ddeaf8093b~tplv-k3u1fbpfcp-watermark.image)\n\n对于JavaScript来说，原生是没有二叉树这个数据结构的，所以需要自己来创建二叉树对象类来生成二叉树的结构，如下代码所示：\n\n```javascript\n// 二叉树节点的构造函数\nfunction TreeNode(val, left, right) {\n    this.val = (val===undefined ? 0 : val)\n    this.left = (left===undefined ? null : left)\n    this.right = (right===undefined ? null : right)\n}\n\n```\n\n上面结构是一个二叉树的一个节点`TreeNode`类型的对象，每个节点有`val`表示当前的节点值，`left`和`right`表示左节点和右节点，他们分别又是新的`TreeNode`类型的对象，一个二叉树就是由若干个节点构成。其中，叶子结点：也称为终端结点，没有子树的结点。\n\n由于二叉树本书并不是一个线性结构，不像数组我们可以很方便的用线性的数据结构来表示，对于二叉树而言，一般在代码中，我们能拿到的只是一个根节点的对象`root`，从根节点通过遍历来的得到完成的二叉树数据。\n\n所以遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有结点，使每一个结点都被访问一次，而且只被访问一次。由于二叉树是非线性结构，因此，树的遍历实质上是将二叉树的各个结点转换成为一个线性序列来表示。\n\n## 遍历类型\n\n由于二叉树每个节点又不同的方向，所以我们必须指定一个遍历的顺序，不同的遍历顺序得到的结果也不一样，所以一般分为`前序遍历`，`中序遍历`，`后续遍历`，`层序遍历`。\n\n对于`前序遍历`，`中序遍历`，`后续遍历`而言，是以根节点为主，根在前表示前序，根在中间表示中序，根在后，表示后续，而左右两个节点按照左在前，右在后的顺序，所以，这三种遍历的方式他们的顺序分别是：\n\n* 前序遍历：访问根结点->遍历左子树->遍历右子树\n* 后续遍历：遍历左子树->遍历右子树->访问根结点\n* 中序遍历：遍历左子树->访问根结点->遍历右子树\n\n如下图二叉树：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68cc9f27f25e45dfa34a51049ea5ba61~tplv-k3u1fbpfcp-watermark.image)\n\n* 前序遍历结果：0137849256\n* 后续遍历结果：7839415620\n* 中序遍历结果：7381940526\n\n而层序遍历则更好理解，即从上往下一层一层遍历，每层按照从左往右遍历，因此上图的二叉树层序遍历结果就是：\n\n* 层序遍历结果：0123456789\n\n## 代码实现\n\n对于二叉树这种结构，因为它的每个节点都有两个指向新的节点，所以我们很容易联想到使用**递归**来遍历一个二叉树，思路很简单，如下：\n\n```javascript\nvar loop = function(root){\n    // 当前节点为空，表示达到了叶子节点\n    if (root == null) return\n    // 接着找左子树\n    loop(root.left)\n    // 接着找右子树\n    loop(root.right)\n}\nloop(root)\n```\n\n对于`前序遍历`，`中序遍历`，`后续遍历`而言，分别在对应的位置访问节点的值即可，如下：\n\n```javascript\nvar preorder = []// 前序结果\nvar inorder = []// 中序结果\nvar postorder = []// 后序结果\n\nvar loop = function(root){\n    // 当前节点为空，表示达到了叶子节点\n    if (root == null) return\n\n    preorder.push(root.val)  // 前序\n    loop(root.left)\n    inorder.push(root.val)// 中序\n    loop(root.right)\n    postorder.push(root.val)// 后序\n}\nloop(root)\n```\n\n递归的方法来遍历二叉树，其实是利用了**深度优先**搜索的思路，即从一个节点开始一直到他的左右节点，再次从左右节点再次深入，直到找到叶子节点或者根节点为止。\n\n但是对于`层序遍历`来说，递归的思路就不是很适用了，思想是从上到下一层一层搜索，它更像是一种**广度优先**搜索的思路，即从一个节点开始所说它的所有左右节点，然后下一层每个节点的所有左右节点，利用这种思想，我们可以借助一个**队列**的数据结构来实现层序遍历。\n\n队列是一种线性的数据结构，遵循先进先出的规则，在JavaScript中，由于没有队列这种数据结构，我们可以用数组Array来进行模拟，入下：\n\n```javascript\nvar queue = [] // 队列 (左边队头，右边队尾)\nqueue.push(1)// 入队1\nqueue.push(2)// 入队2\nqueue.push(3)// 入队3\n\n//此时队列元素：[1,2,3]\n\nqueue.shift()// 出队1\nqueue.shift()// 出队2\n```\n\n层序遍历的思想就是：\n\n* 根节点入队，然后遍历队列。\n* 访问根节点，根节点出队，同时将根节点作为当前元素，分别将当前元素的左节点入队，右节点入队。（第一层结束）。\n* 记录当前此时队列的元素个数，将上一步的左节点作为当前元素，访问当前元素的值，当前元素出队（元素个数减一），同时分别将当前元素的左节点入队，右节点入队。\n* 依此重复上述操作，直到记录的元素个数为0时，表示此层结束。\n* 每层都重复上述操作，直到整个队列为空时，则遍历结束。\n\n转换成代码，如下：\n\n```javascript\nvar levelOrder1 = function(root) {\n    if (root == null) return []\n    var arr = []\n    arr.push(root) // 根节点入队\n    var res = []\n\n    while (arr.length) {\n        var len = arr.length\n        var floor = []// 存储每一层的数据\n        while (len) {\n            var temp = arr.shift()// 当前元素出队\n            if (!temp) break\n            // 每一层数据\n            floor.push(temp.val)\n\n            // 左节点入队\n            if (temp.left) {\n                arr.push(temp.left)\n            }\n            // 右节点入队\n            if (temp.right) {\n                arr.push(temp.right)\n            }\n\n            len--\n        }\n        // 存储每一层数据\n        res.push(floor)\n    }\n\n    return res\n}\n```\n\n对于`前序遍历`，`中序遍历`，`后续遍历`而言，如果不使用递归，我们可以利用**栈**来获取遍历结果，栈是一种线性的数据结构，遵循先进后出的规则，在JavaScript中，由于没有栈这种数据结构，我们可以用数组Array来进行模拟，入下：\n\n```javascript\nvar stack = [] // 栈\nstack.push(1)// 入栈1\nstack.push(2)// 入栈2\nstack.push(3)// 入栈3\n\n//此时栈内元素：[1,2,3]\n\nstack.pop()// 出栈3\nstack.pop()// 出栈2\n```\n\n前序遍历：\n\n* 根节点入栈，依此取出栈顶元素。\n* 访问栈顶元素，同时出栈，将栈顶元素作为当前元素，当前元素右节点入栈，左节点入栈（注意：右先入那么右后出）。\n* 重复上述操作，直到整个栈为空时，则遍历结束。\n\n```javascript\nvar preorderTraversal = function(root) {\n    var arr = []\n    arr.push(root)\n    var res = []\n    while (arr.length) {\n        var temp = arr.pop()\n        if (!temp) break\n\n        res.push(temp.val)\n\n        if (temp.right) {\n            arr.push(temp.right)\n        }\n\n        if (temp.left) {\n            arr.push(temp.left)\n        }\n        \n    }\n\n    return res\n};\n```\n\n中序遍历：\n\n* 循环将根节点和其的左子树入栈。\n* 直到左子树为空时，访问栈顶元素，同时将栈顶元素作为当前元素，并出栈。\n* 开始访问右子树，循环出栈直到整个栈为空时，则遍历结束。\n\n```javascript\nvar inorderTraversal = function(root) {\n    var res = []\n    var arr = []\n\n    while(arr.length || root) {\n        if (root) {\n            arr.push(root)\n            root = root.left\n        } else {\n            var temp = arr.pop()\n            res.push(temp.val)\n            root = temp.right\n        }\n    }\n\n    return res\n};\n```\n\n后序遍历：\n\n和前序遍历思想相反。\n\n```javascript\nvar postorderTraversal = function(root) {\n    var arr = []\n    arr.push(root)\n    var res = []\n    while(arr.length) {\n        var temp = arr.pop()\n        if (!temp) break\n        res.unshift(temp.val)// 从前往后塞入数据\n        if(temp.left) {// 左节点先入栈\n            arr.push(temp.left)\n        }\n        if(temp.right) {\n            arr.push(temp.right)\n        }\n    }\n\n    return res\n};\n```\n\n## 复杂度分析：\n\n二叉树遍历的递归实现，每个结点只需遍历一次，故时间复杂度为O(n)。而使用了递归，最差情况下递归调用的深度为O(n)，所以空间复杂度为O(n)。\n\n二叉树遍历的非递归实现，每个结点只需遍历一次，故时间复杂度为O(n)。而使用了栈，空间复杂度为二叉树的高度，故空间复杂度为O(n)。\n\n二叉树遍历时基本的二叉树操作，掌握好遍历技巧是进行后续二叉树相关操作的基础。\n\n\n\n\n\n","source":"_posts/前端算法--二叉树遍历.md","raw":"---\ntitle: 前端算法--二叉树遍历\ndate: 2021-02-26 17:26:17\ntags:\n- 算法\n- 二叉树遍历\ncategories:\n- 12092\n\n---\n\n## 二叉树基本概念\n\n二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。\n<!--more-->\n二叉树特点是每个结点最多只能有两棵子树，且有左右之分。\n\n![!()[]](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb0cc313a4534904a8cf32ddeaf8093b~tplv-k3u1fbpfcp-watermark.image)\n\n对于JavaScript来说，原生是没有二叉树这个数据结构的，所以需要自己来创建二叉树对象类来生成二叉树的结构，如下代码所示：\n\n```javascript\n// 二叉树节点的构造函数\nfunction TreeNode(val, left, right) {\n    this.val = (val===undefined ? 0 : val)\n    this.left = (left===undefined ? null : left)\n    this.right = (right===undefined ? null : right)\n}\n\n```\n\n上面结构是一个二叉树的一个节点`TreeNode`类型的对象，每个节点有`val`表示当前的节点值，`left`和`right`表示左节点和右节点，他们分别又是新的`TreeNode`类型的对象，一个二叉树就是由若干个节点构成。其中，叶子结点：也称为终端结点，没有子树的结点。\n\n由于二叉树本书并不是一个线性结构，不像数组我们可以很方便的用线性的数据结构来表示，对于二叉树而言，一般在代码中，我们能拿到的只是一个根节点的对象`root`，从根节点通过遍历来的得到完成的二叉树数据。\n\n所以遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有结点，使每一个结点都被访问一次，而且只被访问一次。由于二叉树是非线性结构，因此，树的遍历实质上是将二叉树的各个结点转换成为一个线性序列来表示。\n\n## 遍历类型\n\n由于二叉树每个节点又不同的方向，所以我们必须指定一个遍历的顺序，不同的遍历顺序得到的结果也不一样，所以一般分为`前序遍历`，`中序遍历`，`后续遍历`，`层序遍历`。\n\n对于`前序遍历`，`中序遍历`，`后续遍历`而言，是以根节点为主，根在前表示前序，根在中间表示中序，根在后，表示后续，而左右两个节点按照左在前，右在后的顺序，所以，这三种遍历的方式他们的顺序分别是：\n\n* 前序遍历：访问根结点->遍历左子树->遍历右子树\n* 后续遍历：遍历左子树->遍历右子树->访问根结点\n* 中序遍历：遍历左子树->访问根结点->遍历右子树\n\n如下图二叉树：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68cc9f27f25e45dfa34a51049ea5ba61~tplv-k3u1fbpfcp-watermark.image)\n\n* 前序遍历结果：0137849256\n* 后续遍历结果：7839415620\n* 中序遍历结果：7381940526\n\n而层序遍历则更好理解，即从上往下一层一层遍历，每层按照从左往右遍历，因此上图的二叉树层序遍历结果就是：\n\n* 层序遍历结果：0123456789\n\n## 代码实现\n\n对于二叉树这种结构，因为它的每个节点都有两个指向新的节点，所以我们很容易联想到使用**递归**来遍历一个二叉树，思路很简单，如下：\n\n```javascript\nvar loop = function(root){\n    // 当前节点为空，表示达到了叶子节点\n    if (root == null) return\n    // 接着找左子树\n    loop(root.left)\n    // 接着找右子树\n    loop(root.right)\n}\nloop(root)\n```\n\n对于`前序遍历`，`中序遍历`，`后续遍历`而言，分别在对应的位置访问节点的值即可，如下：\n\n```javascript\nvar preorder = []// 前序结果\nvar inorder = []// 中序结果\nvar postorder = []// 后序结果\n\nvar loop = function(root){\n    // 当前节点为空，表示达到了叶子节点\n    if (root == null) return\n\n    preorder.push(root.val)  // 前序\n    loop(root.left)\n    inorder.push(root.val)// 中序\n    loop(root.right)\n    postorder.push(root.val)// 后序\n}\nloop(root)\n```\n\n递归的方法来遍历二叉树，其实是利用了**深度优先**搜索的思路，即从一个节点开始一直到他的左右节点，再次从左右节点再次深入，直到找到叶子节点或者根节点为止。\n\n但是对于`层序遍历`来说，递归的思路就不是很适用了，思想是从上到下一层一层搜索，它更像是一种**广度优先**搜索的思路，即从一个节点开始所说它的所有左右节点，然后下一层每个节点的所有左右节点，利用这种思想，我们可以借助一个**队列**的数据结构来实现层序遍历。\n\n队列是一种线性的数据结构，遵循先进先出的规则，在JavaScript中，由于没有队列这种数据结构，我们可以用数组Array来进行模拟，入下：\n\n```javascript\nvar queue = [] // 队列 (左边队头，右边队尾)\nqueue.push(1)// 入队1\nqueue.push(2)// 入队2\nqueue.push(3)// 入队3\n\n//此时队列元素：[1,2,3]\n\nqueue.shift()// 出队1\nqueue.shift()// 出队2\n```\n\n层序遍历的思想就是：\n\n* 根节点入队，然后遍历队列。\n* 访问根节点，根节点出队，同时将根节点作为当前元素，分别将当前元素的左节点入队，右节点入队。（第一层结束）。\n* 记录当前此时队列的元素个数，将上一步的左节点作为当前元素，访问当前元素的值，当前元素出队（元素个数减一），同时分别将当前元素的左节点入队，右节点入队。\n* 依此重复上述操作，直到记录的元素个数为0时，表示此层结束。\n* 每层都重复上述操作，直到整个队列为空时，则遍历结束。\n\n转换成代码，如下：\n\n```javascript\nvar levelOrder1 = function(root) {\n    if (root == null) return []\n    var arr = []\n    arr.push(root) // 根节点入队\n    var res = []\n\n    while (arr.length) {\n        var len = arr.length\n        var floor = []// 存储每一层的数据\n        while (len) {\n            var temp = arr.shift()// 当前元素出队\n            if (!temp) break\n            // 每一层数据\n            floor.push(temp.val)\n\n            // 左节点入队\n            if (temp.left) {\n                arr.push(temp.left)\n            }\n            // 右节点入队\n            if (temp.right) {\n                arr.push(temp.right)\n            }\n\n            len--\n        }\n        // 存储每一层数据\n        res.push(floor)\n    }\n\n    return res\n}\n```\n\n对于`前序遍历`，`中序遍历`，`后续遍历`而言，如果不使用递归，我们可以利用**栈**来获取遍历结果，栈是一种线性的数据结构，遵循先进后出的规则，在JavaScript中，由于没有栈这种数据结构，我们可以用数组Array来进行模拟，入下：\n\n```javascript\nvar stack = [] // 栈\nstack.push(1)// 入栈1\nstack.push(2)// 入栈2\nstack.push(3)// 入栈3\n\n//此时栈内元素：[1,2,3]\n\nstack.pop()// 出栈3\nstack.pop()// 出栈2\n```\n\n前序遍历：\n\n* 根节点入栈，依此取出栈顶元素。\n* 访问栈顶元素，同时出栈，将栈顶元素作为当前元素，当前元素右节点入栈，左节点入栈（注意：右先入那么右后出）。\n* 重复上述操作，直到整个栈为空时，则遍历结束。\n\n```javascript\nvar preorderTraversal = function(root) {\n    var arr = []\n    arr.push(root)\n    var res = []\n    while (arr.length) {\n        var temp = arr.pop()\n        if (!temp) break\n\n        res.push(temp.val)\n\n        if (temp.right) {\n            arr.push(temp.right)\n        }\n\n        if (temp.left) {\n            arr.push(temp.left)\n        }\n        \n    }\n\n    return res\n};\n```\n\n中序遍历：\n\n* 循环将根节点和其的左子树入栈。\n* 直到左子树为空时，访问栈顶元素，同时将栈顶元素作为当前元素，并出栈。\n* 开始访问右子树，循环出栈直到整个栈为空时，则遍历结束。\n\n```javascript\nvar inorderTraversal = function(root) {\n    var res = []\n    var arr = []\n\n    while(arr.length || root) {\n        if (root) {\n            arr.push(root)\n            root = root.left\n        } else {\n            var temp = arr.pop()\n            res.push(temp.val)\n            root = temp.right\n        }\n    }\n\n    return res\n};\n```\n\n后序遍历：\n\n和前序遍历思想相反。\n\n```javascript\nvar postorderTraversal = function(root) {\n    var arr = []\n    arr.push(root)\n    var res = []\n    while(arr.length) {\n        var temp = arr.pop()\n        if (!temp) break\n        res.unshift(temp.val)// 从前往后塞入数据\n        if(temp.left) {// 左节点先入栈\n            arr.push(temp.left)\n        }\n        if(temp.right) {\n            arr.push(temp.right)\n        }\n    }\n\n    return res\n};\n```\n\n## 复杂度分析：\n\n二叉树遍历的递归实现，每个结点只需遍历一次，故时间复杂度为O(n)。而使用了递归，最差情况下递归调用的深度为O(n)，所以空间复杂度为O(n)。\n\n二叉树遍历的非递归实现，每个结点只需遍历一次，故时间复杂度为O(n)。而使用了栈，空间复杂度为二叉树的高度，故空间复杂度为O(n)。\n\n二叉树遍历时基本的二叉树操作，掌握好遍历技巧是进行后续二叉树相关操作的基础。\n\n\n\n\n\n","slug":"前端算法--二叉树遍历","published":1,"updated":"2021-12-10T16:12:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434q0x002k2wvj1bh5otoe","content":"<h2><span id=\"二叉树基本概念\">二叉树基本概念</span></h2><p>二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。<br><a id=\"more\"></a><br>二叉树特点是每个结点最多只能有两棵子树，且有左右之分。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb0cc313a4534904a8cf32ddeaf8093b~tplv-k3u1fbpfcp-watermark.image\" alt=\"!()[]\"></p>\n<p>对于JavaScript来说，原生是没有二叉树这个数据结构的，所以需要自己来创建二叉树对象类来生成二叉树的结构，如下代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 二叉树节点的构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">TreeNode</span>(<span class=\"params\">val, left, right</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.val = (val===<span class=\"literal\">undefined</span> ? <span class=\"number\">0</span> : val)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.left = (left===<span class=\"literal\">undefined</span> ? <span class=\"literal\">null</span> : left)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.right = (right===<span class=\"literal\">undefined</span> ? <span class=\"literal\">null</span> : right)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面结构是一个二叉树的一个节点<code>TreeNode</code>类型的对象，每个节点有<code>val</code>表示当前的节点值，<code>left</code>和<code>right</code>表示左节点和右节点，他们分别又是新的<code>TreeNode</code>类型的对象，一个二叉树就是由若干个节点构成。其中，叶子结点：也称为终端结点，没有子树的结点。</p>\n<p>由于二叉树本书并不是一个线性结构，不像数组我们可以很方便的用线性的数据结构来表示，对于二叉树而言，一般在代码中，我们能拿到的只是一个根节点的对象<code>root</code>，从根节点通过遍历来的得到完成的二叉树数据。</p>\n<p>所以遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有结点，使每一个结点都被访问一次，而且只被访问一次。由于二叉树是非线性结构，因此，树的遍历实质上是将二叉树的各个结点转换成为一个线性序列来表示。</p>\n<h2><span id=\"遍历类型\">遍历类型</span></h2><p>由于二叉树每个节点又不同的方向，所以我们必须指定一个遍历的顺序，不同的遍历顺序得到的结果也不一样，所以一般分为<code>前序遍历</code>，<code>中序遍历</code>，<code>后续遍历</code>，<code>层序遍历</code>。</p>\n<p>对于<code>前序遍历</code>，<code>中序遍历</code>，<code>后续遍历</code>而言，是以根节点为主，根在前表示前序，根在中间表示中序，根在后，表示后续，而左右两个节点按照左在前，右在后的顺序，所以，这三种遍历的方式他们的顺序分别是：</p>\n<ul>\n<li>前序遍历：访问根结点-&gt;遍历左子树-&gt;遍历右子树</li>\n<li>后续遍历：遍历左子树-&gt;遍历右子树-&gt;访问根结点</li>\n<li>中序遍历：遍历左子树-&gt;访问根结点-&gt;遍历右子树</li>\n</ul>\n<p>如下图二叉树：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68cc9f27f25e45dfa34a51049ea5ba61~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<ul>\n<li>前序遍历结果：0137849256</li>\n<li>后续遍历结果：7839415620</li>\n<li>中序遍历结果：7381940526</li>\n</ul>\n<p>而层序遍历则更好理解，即从上往下一层一层遍历，每层按照从左往右遍历，因此上图的二叉树层序遍历结果就是：</p>\n<ul>\n<li>层序遍历结果：0123456789</li>\n</ul>\n<h2><span id=\"代码实现\">代码实现</span></h2><p>对于二叉树这种结构，因为它的每个节点都有两个指向新的节点，所以我们很容易联想到使用<strong>递归</strong>来遍历一个二叉树，思路很简单，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> loop = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">root</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前节点为空，表示达到了叶子节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"comment\">// 接着找左子树</span></span><br><span class=\"line\">    loop(root.left)</span><br><span class=\"line\">    <span class=\"comment\">// 接着找右子树</span></span><br><span class=\"line\">    loop(root.right)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">loop(root)</span><br></pre></td></tr></table></figure>\n<p>对于<code>前序遍历</code>，<code>中序遍历</code>，<code>后续遍历</code>而言，分别在对应的位置访问节点的值即可，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> preorder = []<span class=\"comment\">// 前序结果</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> inorder = []<span class=\"comment\">// 中序结果</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> postorder = []<span class=\"comment\">// 后序结果</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> loop = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">root</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前节点为空，表示达到了叶子节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">    preorder.push(root.val)  <span class=\"comment\">// 前序</span></span><br><span class=\"line\">    loop(root.left)</span><br><span class=\"line\">    inorder.push(root.val)<span class=\"comment\">// 中序</span></span><br><span class=\"line\">    loop(root.right)</span><br><span class=\"line\">    postorder.push(root.val)<span class=\"comment\">// 后序</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">loop(root)</span><br></pre></td></tr></table></figure>\n<p>递归的方法来遍历二叉树，其实是利用了<strong>深度优先</strong>搜索的思路，即从一个节点开始一直到他的左右节点，再次从左右节点再次深入，直到找到叶子节点或者根节点为止。</p>\n<p>但是对于<code>层序遍历</code>来说，递归的思路就不是很适用了，思想是从上到下一层一层搜索，它更像是一种<strong>广度优先</strong>搜索的思路，即从一个节点开始所说它的所有左右节点，然后下一层每个节点的所有左右节点，利用这种思想，我们可以借助一个<strong>队列</strong>的数据结构来实现层序遍历。</p>\n<p>队列是一种线性的数据结构，遵循先进先出的规则，在JavaScript中，由于没有队列这种数据结构，我们可以用数组Array来进行模拟，入下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> queue = [] <span class=\"comment\">// 队列 (左边队头，右边队尾)</span></span><br><span class=\"line\">queue.push(<span class=\"number\">1</span>)<span class=\"comment\">// 入队1</span></span><br><span class=\"line\">queue.push(<span class=\"number\">2</span>)<span class=\"comment\">// 入队2</span></span><br><span class=\"line\">queue.push(<span class=\"number\">3</span>)<span class=\"comment\">// 入队3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//此时队列元素：[1,2,3]</span></span><br><span class=\"line\"></span><br><span class=\"line\">queue.shift()<span class=\"comment\">// 出队1</span></span><br><span class=\"line\">queue.shift()<span class=\"comment\">// 出队2</span></span><br></pre></td></tr></table></figure>\n<p>层序遍历的思想就是：</p>\n<ul>\n<li>根节点入队，然后遍历队列。</li>\n<li>访问根节点，根节点出队，同时将根节点作为当前元素，分别将当前元素的左节点入队，右节点入队。（第一层结束）。</li>\n<li>记录当前此时队列的元素个数，将上一步的左节点作为当前元素，访问当前元素的值，当前元素出队（元素个数减一），同时分别将当前元素的左节点入队，右节点入队。</li>\n<li>依此重复上述操作，直到记录的元素个数为0时，表示此层结束。</li>\n<li>每层都重复上述操作，直到整个队列为空时，则遍历结束。</li>\n</ul>\n<p>转换成代码，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> levelOrder1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">root</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> []</span><br><span class=\"line\">    <span class=\"keyword\">var</span> arr = []</span><br><span class=\"line\">    arr.push(root) <span class=\"comment\">// 根节点入队</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> res = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (arr.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> len = arr.length</span><br><span class=\"line\">        <span class=\"keyword\">var</span> floor = []<span class=\"comment\">// 存储每一层的数据</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (len) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> temp = arr.shift()<span class=\"comment\">// 当前元素出队</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!temp) <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"comment\">// 每一层数据</span></span><br><span class=\"line\">            floor.push(temp.val)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 左节点入队</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (temp.left) &#123;</span><br><span class=\"line\">                arr.push(temp.left)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 右节点入队</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (temp.right) &#123;</span><br><span class=\"line\">                arr.push(temp.right)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            len--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 存储每一层数据</span></span><br><span class=\"line\">        res.push(floor)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于<code>前序遍历</code>，<code>中序遍历</code>，<code>后续遍历</code>而言，如果不使用递归，我们可以利用<strong>栈</strong>来获取遍历结果，栈是一种线性的数据结构，遵循先进后出的规则，在JavaScript中，由于没有栈这种数据结构，我们可以用数组Array来进行模拟，入下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> stack = [] <span class=\"comment\">// 栈</span></span><br><span class=\"line\">stack.push(<span class=\"number\">1</span>)<span class=\"comment\">// 入栈1</span></span><br><span class=\"line\">stack.push(<span class=\"number\">2</span>)<span class=\"comment\">// 入栈2</span></span><br><span class=\"line\">stack.push(<span class=\"number\">3</span>)<span class=\"comment\">// 入栈3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//此时栈内元素：[1,2,3]</span></span><br><span class=\"line\"></span><br><span class=\"line\">stack.pop()<span class=\"comment\">// 出栈3</span></span><br><span class=\"line\">stack.pop()<span class=\"comment\">// 出栈2</span></span><br></pre></td></tr></table></figure>\n<p>前序遍历：</p>\n<ul>\n<li>根节点入栈，依此取出栈顶元素。</li>\n<li>访问栈顶元素，同时出栈，将栈顶元素作为当前元素，当前元素右节点入栈，左节点入栈（注意：右先入那么右后出）。</li>\n<li>重复上述操作，直到整个栈为空时，则遍历结束。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> preorderTraversal = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">root</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> arr = []</span><br><span class=\"line\">    arr.push(root)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> res = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (arr.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> temp = arr.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!temp) <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">        res.push(temp.val)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (temp.right) &#123;</span><br><span class=\"line\">            arr.push(temp.right)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (temp.left) &#123;</span><br><span class=\"line\">            arr.push(temp.left)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>中序遍历：</p>\n<ul>\n<li>循环将根节点和其的左子树入栈。</li>\n<li>直到左子树为空时，访问栈顶元素，同时将栈顶元素作为当前元素，并出栈。</li>\n<li>开始访问右子树，循环出栈直到整个栈为空时，则遍历结束。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> inorderTraversal = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">root</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> res = []</span><br><span class=\"line\">    <span class=\"keyword\">var</span> arr = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(arr.length || root) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root) &#123;</span><br><span class=\"line\">            arr.push(root)</span><br><span class=\"line\">            root = root.left</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> temp = arr.pop()</span><br><span class=\"line\">            res.push(temp.val)</span><br><span class=\"line\">            root = temp.right</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>后序遍历：</p>\n<p>和前序遍历思想相反。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> postorderTraversal = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">root</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> arr = []</span><br><span class=\"line\">    arr.push(root)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> res = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(arr.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> temp = arr.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!temp) <span class=\"keyword\">break</span></span><br><span class=\"line\">        res.unshift(temp.val)<span class=\"comment\">// 从前往后塞入数据</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(temp.left) &#123;<span class=\"comment\">// 左节点先入栈</span></span><br><span class=\"line\">            arr.push(temp.left)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(temp.right) &#123;</span><br><span class=\"line\">            arr.push(temp.right)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"复杂度分析\">复杂度分析：</span></h2><p>二叉树遍历的递归实现，每个结点只需遍历一次，故时间复杂度为O(n)。而使用了递归，最差情况下递归调用的深度为O(n)，所以空间复杂度为O(n)。</p>\n<p>二叉树遍历的非递归实现，每个结点只需遍历一次，故时间复杂度为O(n)。而使用了栈，空间复杂度为二叉树的高度，故空间复杂度为O(n)。</p>\n<p>二叉树遍历时基本的二叉树操作，掌握好遍历技巧是进行后续二叉树相关操作的基础。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"二叉树基本概念\"><a href=\"#二叉树基本概念\" class=\"headerlink\" title=\"二叉树基本概念\"></a>二叉树基本概念</h2><p>二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。<br>","more":"<br>二叉树特点是每个结点最多只能有两棵子树，且有左右之分。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb0cc313a4534904a8cf32ddeaf8093b~tplv-k3u1fbpfcp-watermark.image\" alt=\"!()[]\"></p>\n<p>对于JavaScript来说，原生是没有二叉树这个数据结构的，所以需要自己来创建二叉树对象类来生成二叉树的结构，如下代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 二叉树节点的构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">TreeNode</span>(<span class=\"params\">val, left, right</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.val = (val===<span class=\"literal\">undefined</span> ? <span class=\"number\">0</span> : val)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.left = (left===<span class=\"literal\">undefined</span> ? <span class=\"literal\">null</span> : left)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.right = (right===<span class=\"literal\">undefined</span> ? <span class=\"literal\">null</span> : right)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面结构是一个二叉树的一个节点<code>TreeNode</code>类型的对象，每个节点有<code>val</code>表示当前的节点值，<code>left</code>和<code>right</code>表示左节点和右节点，他们分别又是新的<code>TreeNode</code>类型的对象，一个二叉树就是由若干个节点构成。其中，叶子结点：也称为终端结点，没有子树的结点。</p>\n<p>由于二叉树本书并不是一个线性结构，不像数组我们可以很方便的用线性的数据结构来表示，对于二叉树而言，一般在代码中，我们能拿到的只是一个根节点的对象<code>root</code>，从根节点通过遍历来的得到完成的二叉树数据。</p>\n<p>所以遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有结点，使每一个结点都被访问一次，而且只被访问一次。由于二叉树是非线性结构，因此，树的遍历实质上是将二叉树的各个结点转换成为一个线性序列来表示。</p>\n<h2 id=\"遍历类型\"><a href=\"#遍历类型\" class=\"headerlink\" title=\"遍历类型\"></a>遍历类型</h2><p>由于二叉树每个节点又不同的方向，所以我们必须指定一个遍历的顺序，不同的遍历顺序得到的结果也不一样，所以一般分为<code>前序遍历</code>，<code>中序遍历</code>，<code>后续遍历</code>，<code>层序遍历</code>。</p>\n<p>对于<code>前序遍历</code>，<code>中序遍历</code>，<code>后续遍历</code>而言，是以根节点为主，根在前表示前序，根在中间表示中序，根在后，表示后续，而左右两个节点按照左在前，右在后的顺序，所以，这三种遍历的方式他们的顺序分别是：</p>\n<ul>\n<li>前序遍历：访问根结点-&gt;遍历左子树-&gt;遍历右子树</li>\n<li>后续遍历：遍历左子树-&gt;遍历右子树-&gt;访问根结点</li>\n<li>中序遍历：遍历左子树-&gt;访问根结点-&gt;遍历右子树</li>\n</ul>\n<p>如下图二叉树：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68cc9f27f25e45dfa34a51049ea5ba61~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<ul>\n<li>前序遍历结果：0137849256</li>\n<li>后续遍历结果：7839415620</li>\n<li>中序遍历结果：7381940526</li>\n</ul>\n<p>而层序遍历则更好理解，即从上往下一层一层遍历，每层按照从左往右遍历，因此上图的二叉树层序遍历结果就是：</p>\n<ul>\n<li>层序遍历结果：0123456789</li>\n</ul>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>对于二叉树这种结构，因为它的每个节点都有两个指向新的节点，所以我们很容易联想到使用<strong>递归</strong>来遍历一个二叉树，思路很简单，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> loop = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">root</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前节点为空，表示达到了叶子节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"comment\">// 接着找左子树</span></span><br><span class=\"line\">    loop(root.left)</span><br><span class=\"line\">    <span class=\"comment\">// 接着找右子树</span></span><br><span class=\"line\">    loop(root.right)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">loop(root)</span><br></pre></td></tr></table></figure>\n<p>对于<code>前序遍历</code>，<code>中序遍历</code>，<code>后续遍历</code>而言，分别在对应的位置访问节点的值即可，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> preorder = []<span class=\"comment\">// 前序结果</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> inorder = []<span class=\"comment\">// 中序结果</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> postorder = []<span class=\"comment\">// 后序结果</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> loop = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">root</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前节点为空，表示达到了叶子节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">    preorder.push(root.val)  <span class=\"comment\">// 前序</span></span><br><span class=\"line\">    loop(root.left)</span><br><span class=\"line\">    inorder.push(root.val)<span class=\"comment\">// 中序</span></span><br><span class=\"line\">    loop(root.right)</span><br><span class=\"line\">    postorder.push(root.val)<span class=\"comment\">// 后序</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">loop(root)</span><br></pre></td></tr></table></figure>\n<p>递归的方法来遍历二叉树，其实是利用了<strong>深度优先</strong>搜索的思路，即从一个节点开始一直到他的左右节点，再次从左右节点再次深入，直到找到叶子节点或者根节点为止。</p>\n<p>但是对于<code>层序遍历</code>来说，递归的思路就不是很适用了，思想是从上到下一层一层搜索，它更像是一种<strong>广度优先</strong>搜索的思路，即从一个节点开始所说它的所有左右节点，然后下一层每个节点的所有左右节点，利用这种思想，我们可以借助一个<strong>队列</strong>的数据结构来实现层序遍历。</p>\n<p>队列是一种线性的数据结构，遵循先进先出的规则，在JavaScript中，由于没有队列这种数据结构，我们可以用数组Array来进行模拟，入下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> queue = [] <span class=\"comment\">// 队列 (左边队头，右边队尾)</span></span><br><span class=\"line\">queue.push(<span class=\"number\">1</span>)<span class=\"comment\">// 入队1</span></span><br><span class=\"line\">queue.push(<span class=\"number\">2</span>)<span class=\"comment\">// 入队2</span></span><br><span class=\"line\">queue.push(<span class=\"number\">3</span>)<span class=\"comment\">// 入队3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//此时队列元素：[1,2,3]</span></span><br><span class=\"line\"></span><br><span class=\"line\">queue.shift()<span class=\"comment\">// 出队1</span></span><br><span class=\"line\">queue.shift()<span class=\"comment\">// 出队2</span></span><br></pre></td></tr></table></figure>\n<p>层序遍历的思想就是：</p>\n<ul>\n<li>根节点入队，然后遍历队列。</li>\n<li>访问根节点，根节点出队，同时将根节点作为当前元素，分别将当前元素的左节点入队，右节点入队。（第一层结束）。</li>\n<li>记录当前此时队列的元素个数，将上一步的左节点作为当前元素，访问当前元素的值，当前元素出队（元素个数减一），同时分别将当前元素的左节点入队，右节点入队。</li>\n<li>依此重复上述操作，直到记录的元素个数为0时，表示此层结束。</li>\n<li>每层都重复上述操作，直到整个队列为空时，则遍历结束。</li>\n</ul>\n<p>转换成代码，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> levelOrder1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">root</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> []</span><br><span class=\"line\">    <span class=\"keyword\">var</span> arr = []</span><br><span class=\"line\">    arr.push(root) <span class=\"comment\">// 根节点入队</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> res = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (arr.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> len = arr.length</span><br><span class=\"line\">        <span class=\"keyword\">var</span> floor = []<span class=\"comment\">// 存储每一层的数据</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (len) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> temp = arr.shift()<span class=\"comment\">// 当前元素出队</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!temp) <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"comment\">// 每一层数据</span></span><br><span class=\"line\">            floor.push(temp.val)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 左节点入队</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (temp.left) &#123;</span><br><span class=\"line\">                arr.push(temp.left)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 右节点入队</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (temp.right) &#123;</span><br><span class=\"line\">                arr.push(temp.right)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            len--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 存储每一层数据</span></span><br><span class=\"line\">        res.push(floor)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于<code>前序遍历</code>，<code>中序遍历</code>，<code>后续遍历</code>而言，如果不使用递归，我们可以利用<strong>栈</strong>来获取遍历结果，栈是一种线性的数据结构，遵循先进后出的规则，在JavaScript中，由于没有栈这种数据结构，我们可以用数组Array来进行模拟，入下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> stack = [] <span class=\"comment\">// 栈</span></span><br><span class=\"line\">stack.push(<span class=\"number\">1</span>)<span class=\"comment\">// 入栈1</span></span><br><span class=\"line\">stack.push(<span class=\"number\">2</span>)<span class=\"comment\">// 入栈2</span></span><br><span class=\"line\">stack.push(<span class=\"number\">3</span>)<span class=\"comment\">// 入栈3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//此时栈内元素：[1,2,3]</span></span><br><span class=\"line\"></span><br><span class=\"line\">stack.pop()<span class=\"comment\">// 出栈3</span></span><br><span class=\"line\">stack.pop()<span class=\"comment\">// 出栈2</span></span><br></pre></td></tr></table></figure>\n<p>前序遍历：</p>\n<ul>\n<li>根节点入栈，依此取出栈顶元素。</li>\n<li>访问栈顶元素，同时出栈，将栈顶元素作为当前元素，当前元素右节点入栈，左节点入栈（注意：右先入那么右后出）。</li>\n<li>重复上述操作，直到整个栈为空时，则遍历结束。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> preorderTraversal = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">root</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> arr = []</span><br><span class=\"line\">    arr.push(root)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> res = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (arr.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> temp = arr.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!temp) <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">        res.push(temp.val)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (temp.right) &#123;</span><br><span class=\"line\">            arr.push(temp.right)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (temp.left) &#123;</span><br><span class=\"line\">            arr.push(temp.left)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>中序遍历：</p>\n<ul>\n<li>循环将根节点和其的左子树入栈。</li>\n<li>直到左子树为空时，访问栈顶元素，同时将栈顶元素作为当前元素，并出栈。</li>\n<li>开始访问右子树，循环出栈直到整个栈为空时，则遍历结束。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> inorderTraversal = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">root</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> res = []</span><br><span class=\"line\">    <span class=\"keyword\">var</span> arr = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(arr.length || root) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root) &#123;</span><br><span class=\"line\">            arr.push(root)</span><br><span class=\"line\">            root = root.left</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> temp = arr.pop()</span><br><span class=\"line\">            res.push(temp.val)</span><br><span class=\"line\">            root = temp.right</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>后序遍历：</p>\n<p>和前序遍历思想相反。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> postorderTraversal = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">root</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> arr = []</span><br><span class=\"line\">    arr.push(root)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> res = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(arr.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> temp = arr.pop()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!temp) <span class=\"keyword\">break</span></span><br><span class=\"line\">        res.unshift(temp.val)<span class=\"comment\">// 从前往后塞入数据</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(temp.left) &#123;<span class=\"comment\">// 左节点先入栈</span></span><br><span class=\"line\">            arr.push(temp.left)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(temp.right) &#123;</span><br><span class=\"line\">            arr.push(temp.right)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度分析：\"><a href=\"#复杂度分析：\" class=\"headerlink\" title=\"复杂度分析：\"></a>复杂度分析：</h2><p>二叉树遍历的递归实现，每个结点只需遍历一次，故时间复杂度为O(n)。而使用了递归，最差情况下递归调用的深度为O(n)，所以空间复杂度为O(n)。</p>\n<p>二叉树遍历的非递归实现，每个结点只需遍历一次，故时间复杂度为O(n)。而使用了栈，空间复杂度为二叉树的高度，故空间复杂度为O(n)。</p>\n<p>二叉树遍历时基本的二叉树操作，掌握好遍历技巧是进行后续二叉树相关操作的基础。</p>"},{"title":"前端算法--回文串","date":"2021-05-26T09:26:17.000Z","_content":"\n**题目描述：**\n\n给你一个整数 `x` ，如果 `x` 是一个回文整数，返回 `true` ；否则，返回 `false` 。\n\n回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，`121` 是回文，而 `123` 不是。\n<!--more-->\n**示例 1：**\n\n```\n输入：x = 121\n输出：true\n```\n\n**示例 2：**\n\n```\n输入：x = -121\n输出：false\n解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n```\n\n**示例 3：**\n\n```\n输入：x = 10\n输出：false\n解释：从右向左读, 为 01 。因此它不是一个回文数。\n```\n\n**示例 4：**\n\n```\n输入：x = -101\n输出：false\n```\n\n\n\n**解法：**\n\n对于回文数或者说是回文字符串，可以理解成一个字符串正着都和反着读结果是一样的。\n\n例如：`abcba`，正着读结果是：a->b->c->b->a，反着读结果是：a<-b<-c<-b<-a，他们的结果是一样的。\n\n例如：`上海自来水来自海上`也是一个回文字符串。\n\n首先把字符串转换成一个字符数组，然后可以利用头尾依次比较的思想，分别指向头和尾的元素，判断他们是否相等。\n\n```javascript\n/**\n * @param {number} x\n * @return {boolean}\n */\nvar isPalindrome = function(x) {\n    // 特殊情况\n    if (x < 0) return false\n    if (x == 1) return true\n\n    x = x.toString()\n\n    var mid = parseInt(x.length/2) // 不用遍历全部，只需要遍历到中间元素即可，因为后面的已经比较过了\n    for (var i = 0 ; i < mid ; i++) {\n        if (x[i] != x[x.length-1-i]) {// 头尾两个元素比较\n            return false\n        }\n    }\n\n    return true\n};\n```\n\n在了解了回文字符串之后，来看下面一道题，求一个字符串的最长回文子串。\n\n**题目描述**\n\n给你一个字符串 `s`，找到 `s` 中最长的回文子串。\n\n**示例 1：**\n\n```\n输入：s = \"babad\"\n输出：\"bab\"\n解释：\"aba\" 同样是符合题意的答案。\n```\n\n**示例 2：**\n\n```\n输入：s = \"cbbd\"\n输出：\"bb\"\n```\n\n**示例 3：**\n\n```\n输入：s = \"a\"\n输出：\"a\"\n```\n\n**示例 4：**\n\n```\n输入：s = \"ac\"\n输出：\"a\"\n```\n\n**解法：**\n\n首先，对于子串的定义我们需要明白它的涵义是：字符串中一段**连续**的子字符串，例如字符串`abcde`中，其中`abc`是其子串，`abcd`也是，而`ac`或者`bd`就不是，因为他们不连续。\n\n同时，通过上一题的思路，我们可以很容易得到一种暴力的解法，即枚举求出改字符串的所有子串，然后分别判断他们是否是回文串，同时记录长度，取最大长度的结果，我们可以得到如下解法：\n\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function(s) {\n    // 单个字符必然是回文串\n    if (s.length == 1) return s\n    // 判断是否是回文串\n    var check = function(str){\n        var mid = parseInt(str.length/2)\n\n        for (var i = 0 ; i < mid ; i++) {\n            if (str[i] != str[str.length-i-1]) {\n                return false\n            }\n        }\n\n        return true\n\n    }\n    var res = ''\n    //枚举出所有子串\n    for (var i = 0 ; i < s.length ; i++) {\n        var cur = s[i]\n        for (var j = i+1 ; j < s.length ; j++) {\n            cur = cur + '' + s[j]\n            if (check(cur)) {\n\n                if (cur.length > res.length) { // 每次取长度的较大值\n                    res = cur\n                }\n            }\n        }\n    }\n\n    return res == '' ? s[0] : res\n};\n```\n\n上面解法可以通过，但是效率很低，通过观察回文串的特点我们可以知道，对于一个子串而言，如果它是回文串，并且长度大于2，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串`ababa`，如果我们已经知道 `bab` 是回文串，那么`ababa` 一定是回文串，这是因为它的首尾两个字母都是`a`。\n\n创建一个动态规划数组`dp[]`：\n\n* `dp[i][j]`表示字符串`s[i]`到`s[j]`之间的是否为回文串。\n* 并且如果`s[i] == s[j]`，则`dp[i][j]` == `dp[i+1][j-1]`，即如果首位元素相同，那么去掉首位元素后，仍然是回文串。\n* 每次更新完`dp[i][j]`之后，更新并记录最大值。\n\n代码如下：\n\n```javascript\nvar longestPalindrome = function(s) {\n    let n = s.length;\n    let res = '';\n    let dp = Array.from(new Array(n),() => new Array(n).fill(0));\n    //考虑到 主要的递推关系 是由已知子串 i+1..j-1 的情况， 递推到 i..j 的情况， 因此，迭代过程需要反序迭代变量 i ，正序迭代 j\n    for(let i = n-1;i >= 0;i--){\n        for(let j = i;j < n;j++){//(j - i < 2)单个字符肯定是回文串 \n            //dp[i+1][j-1] 且 s[i] == s[j] 则dp[i][j]肯定是回文串\n            if (s[i] == s[j] && (j - i < 2 || dp[i+1][j-1])) {\n                dp[i][j] = true\n            }\n            // 如果dp[i][j]是回文 就记录最大的值(j - i +1)表示长度\n            if(dp[i][j] && j - i +1 > res.length){\n                res = s.substring(i,j+1);\n            }\n        }\n    }\n    return res;\n};\n```\n\n\n\n\n\n","source":"_posts/前端算法--回文串.md","raw":"---\ntitle: 前端算法--回文串\ndate: 2021-05-26 17:26:17\ntags:\n- 算法\n- 回文串\ncategories:\n- 12091\n\n---\n\n**题目描述：**\n\n给你一个整数 `x` ，如果 `x` 是一个回文整数，返回 `true` ；否则，返回 `false` 。\n\n回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，`121` 是回文，而 `123` 不是。\n<!--more-->\n**示例 1：**\n\n```\n输入：x = 121\n输出：true\n```\n\n**示例 2：**\n\n```\n输入：x = -121\n输出：false\n解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n```\n\n**示例 3：**\n\n```\n输入：x = 10\n输出：false\n解释：从右向左读, 为 01 。因此它不是一个回文数。\n```\n\n**示例 4：**\n\n```\n输入：x = -101\n输出：false\n```\n\n\n\n**解法：**\n\n对于回文数或者说是回文字符串，可以理解成一个字符串正着都和反着读结果是一样的。\n\n例如：`abcba`，正着读结果是：a->b->c->b->a，反着读结果是：a<-b<-c<-b<-a，他们的结果是一样的。\n\n例如：`上海自来水来自海上`也是一个回文字符串。\n\n首先把字符串转换成一个字符数组，然后可以利用头尾依次比较的思想，分别指向头和尾的元素，判断他们是否相等。\n\n```javascript\n/**\n * @param {number} x\n * @return {boolean}\n */\nvar isPalindrome = function(x) {\n    // 特殊情况\n    if (x < 0) return false\n    if (x == 1) return true\n\n    x = x.toString()\n\n    var mid = parseInt(x.length/2) // 不用遍历全部，只需要遍历到中间元素即可，因为后面的已经比较过了\n    for (var i = 0 ; i < mid ; i++) {\n        if (x[i] != x[x.length-1-i]) {// 头尾两个元素比较\n            return false\n        }\n    }\n\n    return true\n};\n```\n\n在了解了回文字符串之后，来看下面一道题，求一个字符串的最长回文子串。\n\n**题目描述**\n\n给你一个字符串 `s`，找到 `s` 中最长的回文子串。\n\n**示例 1：**\n\n```\n输入：s = \"babad\"\n输出：\"bab\"\n解释：\"aba\" 同样是符合题意的答案。\n```\n\n**示例 2：**\n\n```\n输入：s = \"cbbd\"\n输出：\"bb\"\n```\n\n**示例 3：**\n\n```\n输入：s = \"a\"\n输出：\"a\"\n```\n\n**示例 4：**\n\n```\n输入：s = \"ac\"\n输出：\"a\"\n```\n\n**解法：**\n\n首先，对于子串的定义我们需要明白它的涵义是：字符串中一段**连续**的子字符串，例如字符串`abcde`中，其中`abc`是其子串，`abcd`也是，而`ac`或者`bd`就不是，因为他们不连续。\n\n同时，通过上一题的思路，我们可以很容易得到一种暴力的解法，即枚举求出改字符串的所有子串，然后分别判断他们是否是回文串，同时记录长度，取最大长度的结果，我们可以得到如下解法：\n\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function(s) {\n    // 单个字符必然是回文串\n    if (s.length == 1) return s\n    // 判断是否是回文串\n    var check = function(str){\n        var mid = parseInt(str.length/2)\n\n        for (var i = 0 ; i < mid ; i++) {\n            if (str[i] != str[str.length-i-1]) {\n                return false\n            }\n        }\n\n        return true\n\n    }\n    var res = ''\n    //枚举出所有子串\n    for (var i = 0 ; i < s.length ; i++) {\n        var cur = s[i]\n        for (var j = i+1 ; j < s.length ; j++) {\n            cur = cur + '' + s[j]\n            if (check(cur)) {\n\n                if (cur.length > res.length) { // 每次取长度的较大值\n                    res = cur\n                }\n            }\n        }\n    }\n\n    return res == '' ? s[0] : res\n};\n```\n\n上面解法可以通过，但是效率很低，通过观察回文串的特点我们可以知道，对于一个子串而言，如果它是回文串，并且长度大于2，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串`ababa`，如果我们已经知道 `bab` 是回文串，那么`ababa` 一定是回文串，这是因为它的首尾两个字母都是`a`。\n\n创建一个动态规划数组`dp[]`：\n\n* `dp[i][j]`表示字符串`s[i]`到`s[j]`之间的是否为回文串。\n* 并且如果`s[i] == s[j]`，则`dp[i][j]` == `dp[i+1][j-1]`，即如果首位元素相同，那么去掉首位元素后，仍然是回文串。\n* 每次更新完`dp[i][j]`之后，更新并记录最大值。\n\n代码如下：\n\n```javascript\nvar longestPalindrome = function(s) {\n    let n = s.length;\n    let res = '';\n    let dp = Array.from(new Array(n),() => new Array(n).fill(0));\n    //考虑到 主要的递推关系 是由已知子串 i+1..j-1 的情况， 递推到 i..j 的情况， 因此，迭代过程需要反序迭代变量 i ，正序迭代 j\n    for(let i = n-1;i >= 0;i--){\n        for(let j = i;j < n;j++){//(j - i < 2)单个字符肯定是回文串 \n            //dp[i+1][j-1] 且 s[i] == s[j] 则dp[i][j]肯定是回文串\n            if (s[i] == s[j] && (j - i < 2 || dp[i+1][j-1])) {\n                dp[i][j] = true\n            }\n            // 如果dp[i][j]是回文 就记录最大的值(j - i +1)表示长度\n            if(dp[i][j] && j - i +1 > res.length){\n                res = s.substring(i,j+1);\n            }\n        }\n    }\n    return res;\n};\n```\n\n\n\n\n\n","slug":"前端算法--回文串","published":1,"updated":"2021-12-10T16:12:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434q0z002o2wvj9rvg8nmz","content":"<p><strong>题目描述：</strong></p>\n<p>给你一个整数 <code>x</code> ，如果 <code>x</code> 是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n<p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，<code>121</code> 是回文，而 <code>123</code> 不是。<br><a id=\"more\"></a><br><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：x = 121</span><br><span class=\"line\">输出：true</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：x = -121</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：x = 10</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：x = -101</span><br><span class=\"line\">输出：false</span><br></pre></td></tr></table></figure>\n<p><strong>解法：</strong></p>\n<p>对于回文数或者说是回文字符串，可以理解成一个字符串正着都和反着读结果是一样的。</p>\n<p>例如：<code>abcba</code>，正着读结果是：a-&gt;b-&gt;c-&gt;b-&gt;a，反着读结果是：a&lt;-b&lt;-c&lt;-b&lt;-a，他们的结果是一样的。</p>\n<p>例如：<code>上海自来水来自海上</code>也是一个回文字符串。</p>\n<p>首先把字符串转换成一个字符数组，然后可以利用头尾依次比较的思想，分别指向头和尾的元素，判断他们是否相等。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number&#125; x</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;boolean&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> isPalindrome = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 特殊情况</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">    x = x.toString()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> mid = <span class=\"built_in\">parseInt</span>(x.length/<span class=\"number\">2</span>) <span class=\"comment\">// 不用遍历全部，只需要遍历到中间元素即可，因为后面的已经比较过了</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i &lt; mid ; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x[i] != x[x.length<span class=\"number\">-1</span>-i]) &#123;<span class=\"comment\">// 头尾两个元素比较</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在了解了回文字符串之后，来看下面一道题，求一个字符串的最长回文子串。</p>\n<p><strong>题目描述</strong></p>\n<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;babad&quot;</span><br><span class=\"line\">输出：&quot;bab&quot;</span><br><span class=\"line\">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;cbbd&quot;</span><br><span class=\"line\">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;a&quot;</span><br><span class=\"line\">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;ac&quot;</span><br><span class=\"line\">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>解法：</strong></p>\n<p>首先，对于子串的定义我们需要明白它的涵义是：字符串中一段<strong>连续</strong>的子字符串，例如字符串<code>abcde</code>中，其中<code>abc</code>是其子串，<code>abcd</code>也是，而<code>ac</code>或者<code>bd</code>就不是，因为他们不连续。</p>\n<p>同时，通过上一题的思路，我们可以很容易得到一种暴力的解法，即枚举求出改字符串的所有子串，然后分别判断他们是否是回文串，同时记录长度，取最大长度的结果，我们可以得到如下解法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;string&#125; s</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;string&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> longestPalindrome = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 单个字符必然是回文串</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s.length == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> s</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否是回文串</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> check = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> mid = <span class=\"built_in\">parseInt</span>(str.length/<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i &lt; mid ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (str[i] != str[str.length-i<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> res = <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"comment\">//枚举出所有子串</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i &lt; s.length ; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> cur = s[i]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = i+<span class=\"number\">1</span> ; j &lt; s.length ; j++) &#123;</span><br><span class=\"line\">            cur = cur + <span class=\"string\">''</span> + s[j]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (check(cur)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cur.length &gt; res.length) &#123; <span class=\"comment\">// 每次取长度的较大值</span></span><br><span class=\"line\">                    res = cur</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res == <span class=\"string\">''</span> ? s[<span class=\"number\">0</span>] : res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上面解法可以通过，但是效率很低，通过观察回文串的特点我们可以知道，对于一个子串而言，如果它是回文串，并且长度大于2，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串<code>ababa</code>，如果我们已经知道 <code>bab</code> 是回文串，那么<code>ababa</code> 一定是回文串，这是因为它的首尾两个字母都是<code>a</code>。</p>\n<p>创建一个动态规划数组<code>dp[]</code>：</p>\n<ul>\n<li><code>dp[i][j]</code>表示字符串<code>s[i]</code>到<code>s[j]</code>之间的是否为回文串。</li>\n<li>并且如果<code>s[i] == s[j]</code>，则<code>dp[i][j]</code> == <code>dp[i+1][j-1]</code>，即如果首位元素相同，那么去掉首位元素后，仍然是回文串。</li>\n<li>每次更新完<code>dp[i][j]</code>之后，更新并记录最大值。</li>\n</ul>\n<p>代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> longestPalindrome = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> n = s.length;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> dp = <span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n),() =&gt; <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n).fill(<span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"comment\">//考虑到 主要的递推关系 是由已知子串 i+1..j-1 的情况， 递推到 i..j 的情况， 因此，迭代过程需要反序迭代变量 i ，正序迭代 j</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = n<span class=\"number\">-1</span>;i &gt;= <span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = i;j &lt; n;j++)&#123;<span class=\"comment\">//(j - i &lt; 2)单个字符肯定是回文串 </span></span><br><span class=\"line\">            <span class=\"comment\">//dp[i+1][j-1] 且 s[i] == s[j] 则dp[i][j]肯定是回文串</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s[i] == s[j] &amp;&amp; (j - i &lt; <span class=\"number\">2</span> || dp[i+<span class=\"number\">1</span>][j<span class=\"number\">-1</span>])) &#123;</span><br><span class=\"line\">                dp[i][j] = <span class=\"literal\">true</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 如果dp[i][j]是回文 就记录最大的值(j - i +1)表示长度</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dp[i][j] &amp;&amp; j - i +<span class=\"number\">1</span> &gt; res.length)&#123;</span><br><span class=\"line\">                res = s.substring(i,j+<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><strong>题目描述：</strong></p>\n<p>给你一个整数 <code>x</code> ，如果 <code>x</code> 是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n<p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，<code>121</code> 是回文，而 <code>123</code> 不是。<br>","more":"<br><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：x = 121</span><br><span class=\"line\">输出：true</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：x = -121</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：x = 10</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：x = -101</span><br><span class=\"line\">输出：false</span><br></pre></td></tr></table></figure>\n<p><strong>解法：</strong></p>\n<p>对于回文数或者说是回文字符串，可以理解成一个字符串正着都和反着读结果是一样的。</p>\n<p>例如：<code>abcba</code>，正着读结果是：a-&gt;b-&gt;c-&gt;b-&gt;a，反着读结果是：a&lt;-b&lt;-c&lt;-b&lt;-a，他们的结果是一样的。</p>\n<p>例如：<code>上海自来水来自海上</code>也是一个回文字符串。</p>\n<p>首先把字符串转换成一个字符数组，然后可以利用头尾依次比较的思想，分别指向头和尾的元素，判断他们是否相等。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number&#125; x</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;boolean&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> isPalindrome = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 特殊情况</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">    x = x.toString()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> mid = <span class=\"built_in\">parseInt</span>(x.length/<span class=\"number\">2</span>) <span class=\"comment\">// 不用遍历全部，只需要遍历到中间元素即可，因为后面的已经比较过了</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i &lt; mid ; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x[i] != x[x.length<span class=\"number\">-1</span>-i]) &#123;<span class=\"comment\">// 头尾两个元素比较</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在了解了回文字符串之后，来看下面一道题，求一个字符串的最长回文子串。</p>\n<p><strong>题目描述</strong></p>\n<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;babad&quot;</span><br><span class=\"line\">输出：&quot;bab&quot;</span><br><span class=\"line\">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;cbbd&quot;</span><br><span class=\"line\">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;a&quot;</span><br><span class=\"line\">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;ac&quot;</span><br><span class=\"line\">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>解法：</strong></p>\n<p>首先，对于子串的定义我们需要明白它的涵义是：字符串中一段<strong>连续</strong>的子字符串，例如字符串<code>abcde</code>中，其中<code>abc</code>是其子串，<code>abcd</code>也是，而<code>ac</code>或者<code>bd</code>就不是，因为他们不连续。</p>\n<p>同时，通过上一题的思路，我们可以很容易得到一种暴力的解法，即枚举求出改字符串的所有子串，然后分别判断他们是否是回文串，同时记录长度，取最大长度的结果，我们可以得到如下解法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;string&#125; s</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;string&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> longestPalindrome = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 单个字符必然是回文串</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s.length == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> s</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否是回文串</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> check = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> mid = <span class=\"built_in\">parseInt</span>(str.length/<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i &lt; mid ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (str[i] != str[str.length-i<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> res = <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"comment\">//枚举出所有子串</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i &lt; s.length ; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> cur = s[i]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = i+<span class=\"number\">1</span> ; j &lt; s.length ; j++) &#123;</span><br><span class=\"line\">            cur = cur + <span class=\"string\">''</span> + s[j]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (check(cur)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cur.length &gt; res.length) &#123; <span class=\"comment\">// 每次取长度的较大值</span></span><br><span class=\"line\">                    res = cur</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res == <span class=\"string\">''</span> ? s[<span class=\"number\">0</span>] : res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上面解法可以通过，但是效率很低，通过观察回文串的特点我们可以知道，对于一个子串而言，如果它是回文串，并且长度大于2，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串<code>ababa</code>，如果我们已经知道 <code>bab</code> 是回文串，那么<code>ababa</code> 一定是回文串，这是因为它的首尾两个字母都是<code>a</code>。</p>\n<p>创建一个动态规划数组<code>dp[]</code>：</p>\n<ul>\n<li><code>dp[i][j]</code>表示字符串<code>s[i]</code>到<code>s[j]</code>之间的是否为回文串。</li>\n<li>并且如果<code>s[i] == s[j]</code>，则<code>dp[i][j]</code> == <code>dp[i+1][j-1]</code>，即如果首位元素相同，那么去掉首位元素后，仍然是回文串。</li>\n<li>每次更新完<code>dp[i][j]</code>之后，更新并记录最大值。</li>\n</ul>\n<p>代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> longestPalindrome = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> n = s.length;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> dp = <span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n),() =&gt; <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n).fill(<span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"comment\">//考虑到 主要的递推关系 是由已知子串 i+1..j-1 的情况， 递推到 i..j 的情况， 因此，迭代过程需要反序迭代变量 i ，正序迭代 j</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = n<span class=\"number\">-1</span>;i &gt;= <span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = i;j &lt; n;j++)&#123;<span class=\"comment\">//(j - i &lt; 2)单个字符肯定是回文串 </span></span><br><span class=\"line\">            <span class=\"comment\">//dp[i+1][j-1] 且 s[i] == s[j] 则dp[i][j]肯定是回文串</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s[i] == s[j] &amp;&amp; (j - i &lt; <span class=\"number\">2</span> || dp[i+<span class=\"number\">1</span>][j<span class=\"number\">-1</span>])) &#123;</span><br><span class=\"line\">                dp[i][j] = <span class=\"literal\">true</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 如果dp[i][j]是回文 就记录最大的值(j - i +1)表示长度</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dp[i][j] &amp;&amp; j - i +<span class=\"number\">1</span> &gt; res.length)&#123;</span><br><span class=\"line\">                res = s.substring(i,j+<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"前端算法--滑动窗口","date":"2021-09-26T09:26:17.000Z","_content":"\n## 滑动窗口概述\n\n滑动窗口（Sliding Window）法，也叫尺取法，可以用来解决一些查找满足一定条件的连续区间的性质（长度等）的问题，在一个特定大小的字符串或数组上进行操作，而不在整个字符串或数组上操作，这样就降低了问题的复杂度，从而也达到降低了循环的嵌套深度。往往类似于“请找到满足xx的最x的区间（子串、子数组）的xx”这类问题都可以使用该方法进行解决。\n<!--more-->\n* **滑动：** 说明这个窗口是移动的，也就是移动是按照一定方向来的。\n* **窗口：** 窗口大小并不是固定的，可以不断扩容直到满足一定的条件；也可以不断缩小，直到找到一个满足条件的最小窗口；当然也可以是固定大小。\n\n## 算法基本思想：\n\n字符串也可以转换成数组，其实本质上滑动窗口都是在数组上进行操作，对数组的操作我们一般会采用循环类方法，而滑动窗口方法则为了提升效率会采用进阶的循环，即两个指针：左指针left，右指针right。\n\n两个指针之间的内容：[left...right]则构成了窗口（window），随着指针的不断移动，窗口的位置和大小都会发生变动，但窗口里面的数据始终是连续的，通过对这些数据的处理，就可以得到需要的结果。\n\n如下图所示，设定滑动窗口（window）大小为 3，当滑动窗口每次划过数组时，计算当前滑动窗口中元素的和，得到结果 res：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbe042a9e3974523ad76a8d2f6280b88~tplv-k3u1fbpfcp-watermark.image?)\n\n结合上面的思路，可以设计一下滑动窗口的通用框架，伪代码如下：\n\n```javascript\nvar list = [...]\n\nvar left = 0; // 左指针\nvar right = 0; // 右指针\n\nvar window = [] 或 {}\n\nwhile(right < list.length) { // 右指针小于边界\n    window.add(list[right]);// 向窗口添加元素\n    right++;// 移动right扩大窗口\n    // 如果符合要求，说明窗口构造完成，移动 left 缩小窗口 \n    while (window 符合要求（length < 3）) {\n\n        // ...针对窗口内容处理\n        sum(window) // 求和res\n\n        window.remove(list[left]); // 将元素移出窗口\n        left++; // 缩小窗口\n    }\n}\n```\n\n框架由两个while循环构成，外层控制窗口扩展，内层控制窗口收缩，下面来举几个例子。\n\n## Leetcode算法原题：\n\n#### 3 无重复字符的最长子串\n\n给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。\n\n**示例 1:**\n\n```\n输入: s = \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n```\n\n**示例 2:**\n\n```\n输入: s = \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n```\n\n**示例 3:**\n\n```\n输入: s = \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n```\n\n**示例 4:**\n\n```\n输入: s = \"\"\n输出: 0\n```\n\n首先，需要明确子串一般是连续的，子序列一般是不连续的，题目中求子串，很容易联想到滑动窗口解法。\n\n根据题目可以知道，窗口的大小是不固定的，所以该题目难点在于我们需要找到一个临界条件来判断合适调整窗口里面的数据，即内层的while循环什么时候执行。\n\n由于题目要求的是无重复字符，对于常见的算法中，很多情况情况下需要利用Map来统计一个字符串中字符是否重复，即key值为单个字符，value为该字符出现的次数，如下：\n\n```javascript\nvar str = 'abcdea'\nvar map = {}\nfor (var i = 0 ; i < str.length ; i++) {\n    var cur = str[i]\n    if (map[cur]) {\n       map[cur] ++\n    } else {\n       map[cur] = 1\n    }\n}\nmap: {\"a\":2,\"b\":1,\"c\":1,\"d\":1,\"e\":1}\n```\n\n所以，当map里面的某个key对应的值大于1时，说明该字符串含有重复字符。利用这个思路，我们使用滑动窗口时，就可以作为window符合要求的条件判断，整体思路如下图（图片来自leetcode）：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e083066f1054bd586740d4d7a68d518~tplv-k3u1fbpfcp-watermark.image?)\n\n其中，i，j两个指针分别对应left和right，通过不断变换窗口来计算每次变换后的连续子串长度。\n\n**解法**：\n\n```javascript\nvar lengthOfLongestSubstring = function(s) {\n    var map = {} // 用来计算每个字符出现的次数\n    var left = 0,right = 0;\n    var len = s.length\n    var res = 0\n    while(right < len) {\n        var r = s[right]\n        right++\n        // 右指针的元素进入窗口\n        if (map[r]) {\n            map[r]++\n        } else {\n            map[r] = 1\n        }\n\n        // 发现窗口中有重复元素\n        while(map[r] > 1) {\n            var l = s[left]\n            // 缩小窗口\n            left++\n            map[l]--\n        }\n        // 此时的窗口中必无重复值\n        // 窗口每次变化 都记录长度 两两比较取最大值\n        res = Math.max(res,right-left)\n    }\n\n    return res\n};\n```\n\n**时间复杂度：** O(N)，其中 N 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。\n\n**空间复杂度：** O(N)，其中 N 是字符串中不重复字符的个数，空间消耗于Map。\n\n#### 239 滑动窗口的最大值\n\n给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。\n\n返回滑动窗口中的最大值。\n\n**示例 1：**\n\n```\n输入：nums = [1,3,-1,-3,5,3,6,7], k = 3\n输出：[3,3,5,5,6,7]\n解释：\n滑动窗口的位置                最大值\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n```\n\n**示例 2：**\n\n```\n输入：nums = [1], k = 1\n输出：[1]\n```\n\n**示例 3：**\n\n```\n输入：nums = [1,-1], k = 1\n输出：[1,-1]\n```\n\n**示例 4：**\n\n```\n输入：nums = [9,11], k = 2\n输出：[11]\n```\n\n**示例 5：**\n\n```javascript\n输入：nums = [4,-2], k = 2\n输出：[4]\n```\n\n在 LeetCode 上，这虽然是一道`hard`难度的题目，但是利用我们上面的滑动窗口框架思路，很容易就可以提供一种解法。\n\n首先，题目中的窗口大小时固定的，所以我们只需要移动窗口，即同步移动`left`和`right`指针，而内层`while`循环的window符合要求条件就很简单了，直接判断窗口长度是否符合即可，核心代码如下：\n\n```javascript\nvar window = []\nwhile (right < nums.length) {\n    var r = nums[right]\n    right++\n    window.push(r)// 右边元素进入窗口\n    while (window.length == k) { // 窗口长度符合k\n       max(window) // 计算窗口中的最大值\n        window.shift()// 左边元素移出窗口\n        left++ // 窗口向右移动\n    }\n}\n```\n\n基本思路：\n\n* 使用滑动窗口遍历数组。\n* 窗口对象为一个数组，每次指针向右移动时，向数组中添加元素。\n* 当窗口大小符合`k`时，计算窗口中的最大值，然后窗口整体向右移动。\n* 当右指针到达边界时，遍历完成。\n\n**解法：**\n\n```javascript\nvar maxSlidingWindow = function(nums, k) {\n  if (k == 1) return nums\n  var right = 0,left = 0\n  var window = []\n  var res = []\n\n  while (right < nums.length) {\n      var r = nums[right]\n      right++\n      window.push(r)\n      while (window.length == k) {\n          res.push(Math.max(...window)) // 利用Math.max求最大值\n          window.shift()\n          left++\n      }\n  }\n\n  return res\n};\n```\n\n但是作为一道`hard`难度的题目，其难度主要在于时间复杂度，上面解法中，我们每次对窗口中的数据求最大值，利用`Math.max()`方法，这其实是非常消耗性能的，底层其实会对窗口进行遍历，并取得到最大值，这样增加了很大一部分循环时间复杂度。\n\n我们可以思考一下，窗口`window`只需要得到最大值，那么我们就可以将窗口设置为一个单调递减的数组队列，每当新进入窗口的元素比之前的还小时，就直接抛弃，这时的最大值还是上一次的最大值，这样就节省了时间，引入单调队列。\n\n单调队列基本思路：\n\n原始队列：`[1 3 -1 -3 5 3]`。\n\n始终要维护队列保证其 **递减** 的特点，所以会有如下的事情发生：\n\n| 操作                                        | 队列状态    |\n| ------------------------------------------- | ----------- |\n| 1入队                                       | [1]         |\n| 3入队，比1大，1删除                         | [3]         |\n| -1入队                                      | [3，-1]     |\n| -3入队                                      | [3，-1，-3] |\n| 5入队，比-3大，删除前面元素，再依次比较删除 | [5]         |\n| 3入队                                       | [5，3]      |\n\n转换成代码如下：\n\n```javascript\n class maxQueue {\n    constructor(){\n        this.items = []\n    }\n    // 进入队列\n    enqueue(ele){\n      // 把前面比新元素小的元素都删掉\n      while(this.items.length && this.items[this.items.length-1] < ele) {\n        this.items.pop()\n      }\n      this.items.push(ele)\n    }\n    // 队首出队\n    dequeue(ele){\n      // 判断是否是需要移出的元素\n      if (this.items.length && this.items[0] == ele) {\n        this.items.shift()\n      }\n    }\n    // 队首就是最大元素\n    front(){\n      return this.items[0]\n    }\n    max(){\n        return this.front()// 队首就是最大元素\n    }\n}\n```\n\n引入优先队列之后，改造我们的整体解法，代码如下：\n\n**解法：**\n\n```javascript\nvar maxSlidingWindow = function(nums, k) {\n    if (k == 1) return nums\n    var right = 0,left = 0\n    var window = new maxQueue()\n    var res = []\n\n    while (right < nums.length) {\n        var r = nums[right]\n        right++\n        window.enqueue(r)\n        while (right-left >= k) {\n            var l = nums[left]\n            res.push(window.max())\n            window.dequeue(l)\n            left++\n        }\n    }\n    return res\n};\n```\n\n**时间复杂度：**O(N logN)，其中N是nums数组的长度。左指针和右指针分别会遍历整个字符串一次。在最坏情况下，数组nums 中的元素单调递增，那么最终优先队列中包含了所有元素，没有元素被移除。由于将一个元素放入优先队列的时间复杂度为 O(log N)，因此总时间复杂度为 O(N logN)\n\n**空间复杂度：**O(N)，其中 N 是优先队列需要使用的空间。\n\n####  76 最小覆盖子串\n\n给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `\"\"` 。\n\n**注意：**\n\n- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。\n- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。\n\n \n\n**示例 1：**\n\n```\n输入：s = \"ADOBECODEBANC\", t = \"ABC\"\n输出：\"BANC\"\n```\n\n**示例 2：**\n\n```\n输入：s = \"a\", t = \"a\"\n输出：\"a\"\n```\n\n**示例 3:**\n\n```\n输入: s = \"a\", t = \"aa\"\n输出: \"\"\n解释: t 中两个字符 'a' 均应包含在 s 的子串中，\n因此没有符合条件的子字符串，返回空字符串。\n```\n\n这是一道`hard`难度的题目，主要难度在于两个字符串，同时需要在第一个字符串中寻找第二个字符串的排列组合，但归根到底还是寻找子串问题，可以对第一个字符串`s`进行滑动窗口算法。\n\n首先，该题目的最终目的是要在`s`中找到含有`t`，但是这个含有不是和`t`相等，而是找到`t`的排列组合即是否含有`t`中的所有元素，由于`t`中可能包含有重复元素，在计算排列组合时，重复元素是不计入统计的，还是利用Map，先统计一下每个字符，代码如下：\n\n```javascript\nvar map = {}\nvar missingType = 0 // 记录不重复的字符个数\n\nfor (var c of t) {\n    if (map[c]) {\n        map[c]++\n    } else {\n        map[c] = 1\n        missingType++\n    }\n}\n```\n\n得到map后，就可以利用map去`s`里面匹配，代码如下：\n\n```javascript\nwhile(right < s.length) {\n    var r = s[right]\n    right++ \n    \n    if (map.hasOwnProperty(r)) { // 每当进入窗口的字符在s中出现时，就将次数-1\n        map[r]--\n    }\n\n    if (map[r] == 0) {// 当某个字符次数为0时，表示当前的这个字符就已经不缺\n        missingType--\n    }\n\n    while(missingType == 0) { // 所有字符都匹配上，这时可以缩小窗口\n\n        if (right - left < res.length) { // 取长度\n            res = s.substring(left,right)\n        }\n        var l = s[left]\n        left++\n        map[l]++ // 每当字符移出窗口时，就将次数+1\n        if (map[l] > 0) { // 如果当前的字符大于0，表示还缺少这个字符\n            missingType++\n        }\n    }\n}\n```\n\n我们在*s* 上滑动窗口，通过移动`right`指针不断扩张窗口。当窗口包含`t`全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口，`missingType`用来增加标志位记录重复字符。整体思路如下图（图片来自leetcode）：\n\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1f20ceb7677416e82dcf673df82197f~tplv-k3u1fbpfcp-watermark.image?\" alt=\"aHR0cHM6Ly9hc3NldHMubGVldGNvZGUtY24uY29tL3NvbHV0aW9uLXN0YXRpYy83Ni83Nl9maWcxLmdpZg.gif\" style=\"zoom:80%;\" />\n\n最后，我们需要处理一些边界条件，例如s和t相等，或者s中完全不包含t的情况，完整解法如下：\n\n**解法：**\n\n```javascript\nvar minWindow = function(s, t) {\n    if (t.length > s.length) return ''\n    if (t == s) return s\n    var flag = false\n    var map = {}\n    var missingType = 0\n    var res = s\n    for (var c of t) {\n        if (!map[c]) {\n            map[c] = 1\n            missingType++\n        } else {\n            map[c]++\n        }\n    }\n    var left = 0,right = 0\n\n    while(right < s.length) {\n        var r = s[right]\n        right++ \n        \n        if (map.hasOwnProperty(r)) { // 每当进入窗口的字符在s中出现时，就将次数-1\n            map[r]--\n        }\n    \n        if (map[r] == 0) {// 当某个字符次数为0时，表示当前的这个字符就已经不缺\n            missingType--\n        }\n    \n        while(missingType == 0) { // 所有字符都匹配上，这时可以缩小窗口\n            flag = true // 在s中找打过t\n            if (right - left < res.length) { // 取长度\n                res = s.substring(left,right)\n            }\n            var l = s[left]\n            left++\n            map[l]++ // 每当字符移出窗口时，就将次数+1\n            if (map[l] > 0) { // 如果当前的字符大于0，表示还缺少这个字符\n                missingType++\n            }\n        }\n    }\n    return !flag ? '' : res\n}\n```\n\n**时间复杂度：** O(N)，其中 N 是字符串`s`的长度。左指针和右指针分别会遍历整个字符串一次。\n\n**空间复杂度：** O(N)，其中 N 是字符串中不重复字符的个数，空间消耗于Map。\n\n\n\n## 总结\n\n滑动窗口类问题是面试当中的 **高频题**，问题本身其实并不复杂，掌握好框架很重要。\n\n\n\n\n\n","source":"_posts/前端算法--滑动窗口.md","raw":"---\ntitle: 前端算法--滑动窗口\ndate: 2021-09-26 17:26:17\ntags:\n- 算法\n- 滑动窗口\ncategories:\n- 12093\n\n---\n\n## 滑动窗口概述\n\n滑动窗口（Sliding Window）法，也叫尺取法，可以用来解决一些查找满足一定条件的连续区间的性质（长度等）的问题，在一个特定大小的字符串或数组上进行操作，而不在整个字符串或数组上操作，这样就降低了问题的复杂度，从而也达到降低了循环的嵌套深度。往往类似于“请找到满足xx的最x的区间（子串、子数组）的xx”这类问题都可以使用该方法进行解决。\n<!--more-->\n* **滑动：** 说明这个窗口是移动的，也就是移动是按照一定方向来的。\n* **窗口：** 窗口大小并不是固定的，可以不断扩容直到满足一定的条件；也可以不断缩小，直到找到一个满足条件的最小窗口；当然也可以是固定大小。\n\n## 算法基本思想：\n\n字符串也可以转换成数组，其实本质上滑动窗口都是在数组上进行操作，对数组的操作我们一般会采用循环类方法，而滑动窗口方法则为了提升效率会采用进阶的循环，即两个指针：左指针left，右指针right。\n\n两个指针之间的内容：[left...right]则构成了窗口（window），随着指针的不断移动，窗口的位置和大小都会发生变动，但窗口里面的数据始终是连续的，通过对这些数据的处理，就可以得到需要的结果。\n\n如下图所示，设定滑动窗口（window）大小为 3，当滑动窗口每次划过数组时，计算当前滑动窗口中元素的和，得到结果 res：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbe042a9e3974523ad76a8d2f6280b88~tplv-k3u1fbpfcp-watermark.image?)\n\n结合上面的思路，可以设计一下滑动窗口的通用框架，伪代码如下：\n\n```javascript\nvar list = [...]\n\nvar left = 0; // 左指针\nvar right = 0; // 右指针\n\nvar window = [] 或 {}\n\nwhile(right < list.length) { // 右指针小于边界\n    window.add(list[right]);// 向窗口添加元素\n    right++;// 移动right扩大窗口\n    // 如果符合要求，说明窗口构造完成，移动 left 缩小窗口 \n    while (window 符合要求（length < 3）) {\n\n        // ...针对窗口内容处理\n        sum(window) // 求和res\n\n        window.remove(list[left]); // 将元素移出窗口\n        left++; // 缩小窗口\n    }\n}\n```\n\n框架由两个while循环构成，外层控制窗口扩展，内层控制窗口收缩，下面来举几个例子。\n\n## Leetcode算法原题：\n\n#### 3 无重复字符的最长子串\n\n给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。\n\n**示例 1:**\n\n```\n输入: s = \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n```\n\n**示例 2:**\n\n```\n输入: s = \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n```\n\n**示例 3:**\n\n```\n输入: s = \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n```\n\n**示例 4:**\n\n```\n输入: s = \"\"\n输出: 0\n```\n\n首先，需要明确子串一般是连续的，子序列一般是不连续的，题目中求子串，很容易联想到滑动窗口解法。\n\n根据题目可以知道，窗口的大小是不固定的，所以该题目难点在于我们需要找到一个临界条件来判断合适调整窗口里面的数据，即内层的while循环什么时候执行。\n\n由于题目要求的是无重复字符，对于常见的算法中，很多情况情况下需要利用Map来统计一个字符串中字符是否重复，即key值为单个字符，value为该字符出现的次数，如下：\n\n```javascript\nvar str = 'abcdea'\nvar map = {}\nfor (var i = 0 ; i < str.length ; i++) {\n    var cur = str[i]\n    if (map[cur]) {\n       map[cur] ++\n    } else {\n       map[cur] = 1\n    }\n}\nmap: {\"a\":2,\"b\":1,\"c\":1,\"d\":1,\"e\":1}\n```\n\n所以，当map里面的某个key对应的值大于1时，说明该字符串含有重复字符。利用这个思路，我们使用滑动窗口时，就可以作为window符合要求的条件判断，整体思路如下图（图片来自leetcode）：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e083066f1054bd586740d4d7a68d518~tplv-k3u1fbpfcp-watermark.image?)\n\n其中，i，j两个指针分别对应left和right，通过不断变换窗口来计算每次变换后的连续子串长度。\n\n**解法**：\n\n```javascript\nvar lengthOfLongestSubstring = function(s) {\n    var map = {} // 用来计算每个字符出现的次数\n    var left = 0,right = 0;\n    var len = s.length\n    var res = 0\n    while(right < len) {\n        var r = s[right]\n        right++\n        // 右指针的元素进入窗口\n        if (map[r]) {\n            map[r]++\n        } else {\n            map[r] = 1\n        }\n\n        // 发现窗口中有重复元素\n        while(map[r] > 1) {\n            var l = s[left]\n            // 缩小窗口\n            left++\n            map[l]--\n        }\n        // 此时的窗口中必无重复值\n        // 窗口每次变化 都记录长度 两两比较取最大值\n        res = Math.max(res,right-left)\n    }\n\n    return res\n};\n```\n\n**时间复杂度：** O(N)，其中 N 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。\n\n**空间复杂度：** O(N)，其中 N 是字符串中不重复字符的个数，空间消耗于Map。\n\n#### 239 滑动窗口的最大值\n\n给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。\n\n返回滑动窗口中的最大值。\n\n**示例 1：**\n\n```\n输入：nums = [1,3,-1,-3,5,3,6,7], k = 3\n输出：[3,3,5,5,6,7]\n解释：\n滑动窗口的位置                最大值\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n```\n\n**示例 2：**\n\n```\n输入：nums = [1], k = 1\n输出：[1]\n```\n\n**示例 3：**\n\n```\n输入：nums = [1,-1], k = 1\n输出：[1,-1]\n```\n\n**示例 4：**\n\n```\n输入：nums = [9,11], k = 2\n输出：[11]\n```\n\n**示例 5：**\n\n```javascript\n输入：nums = [4,-2], k = 2\n输出：[4]\n```\n\n在 LeetCode 上，这虽然是一道`hard`难度的题目，但是利用我们上面的滑动窗口框架思路，很容易就可以提供一种解法。\n\n首先，题目中的窗口大小时固定的，所以我们只需要移动窗口，即同步移动`left`和`right`指针，而内层`while`循环的window符合要求条件就很简单了，直接判断窗口长度是否符合即可，核心代码如下：\n\n```javascript\nvar window = []\nwhile (right < nums.length) {\n    var r = nums[right]\n    right++\n    window.push(r)// 右边元素进入窗口\n    while (window.length == k) { // 窗口长度符合k\n       max(window) // 计算窗口中的最大值\n        window.shift()// 左边元素移出窗口\n        left++ // 窗口向右移动\n    }\n}\n```\n\n基本思路：\n\n* 使用滑动窗口遍历数组。\n* 窗口对象为一个数组，每次指针向右移动时，向数组中添加元素。\n* 当窗口大小符合`k`时，计算窗口中的最大值，然后窗口整体向右移动。\n* 当右指针到达边界时，遍历完成。\n\n**解法：**\n\n```javascript\nvar maxSlidingWindow = function(nums, k) {\n  if (k == 1) return nums\n  var right = 0,left = 0\n  var window = []\n  var res = []\n\n  while (right < nums.length) {\n      var r = nums[right]\n      right++\n      window.push(r)\n      while (window.length == k) {\n          res.push(Math.max(...window)) // 利用Math.max求最大值\n          window.shift()\n          left++\n      }\n  }\n\n  return res\n};\n```\n\n但是作为一道`hard`难度的题目，其难度主要在于时间复杂度，上面解法中，我们每次对窗口中的数据求最大值，利用`Math.max()`方法，这其实是非常消耗性能的，底层其实会对窗口进行遍历，并取得到最大值，这样增加了很大一部分循环时间复杂度。\n\n我们可以思考一下，窗口`window`只需要得到最大值，那么我们就可以将窗口设置为一个单调递减的数组队列，每当新进入窗口的元素比之前的还小时，就直接抛弃，这时的最大值还是上一次的最大值，这样就节省了时间，引入单调队列。\n\n单调队列基本思路：\n\n原始队列：`[1 3 -1 -3 5 3]`。\n\n始终要维护队列保证其 **递减** 的特点，所以会有如下的事情发生：\n\n| 操作                                        | 队列状态    |\n| ------------------------------------------- | ----------- |\n| 1入队                                       | [1]         |\n| 3入队，比1大，1删除                         | [3]         |\n| -1入队                                      | [3，-1]     |\n| -3入队                                      | [3，-1，-3] |\n| 5入队，比-3大，删除前面元素，再依次比较删除 | [5]         |\n| 3入队                                       | [5，3]      |\n\n转换成代码如下：\n\n```javascript\n class maxQueue {\n    constructor(){\n        this.items = []\n    }\n    // 进入队列\n    enqueue(ele){\n      // 把前面比新元素小的元素都删掉\n      while(this.items.length && this.items[this.items.length-1] < ele) {\n        this.items.pop()\n      }\n      this.items.push(ele)\n    }\n    // 队首出队\n    dequeue(ele){\n      // 判断是否是需要移出的元素\n      if (this.items.length && this.items[0] == ele) {\n        this.items.shift()\n      }\n    }\n    // 队首就是最大元素\n    front(){\n      return this.items[0]\n    }\n    max(){\n        return this.front()// 队首就是最大元素\n    }\n}\n```\n\n引入优先队列之后，改造我们的整体解法，代码如下：\n\n**解法：**\n\n```javascript\nvar maxSlidingWindow = function(nums, k) {\n    if (k == 1) return nums\n    var right = 0,left = 0\n    var window = new maxQueue()\n    var res = []\n\n    while (right < nums.length) {\n        var r = nums[right]\n        right++\n        window.enqueue(r)\n        while (right-left >= k) {\n            var l = nums[left]\n            res.push(window.max())\n            window.dequeue(l)\n            left++\n        }\n    }\n    return res\n};\n```\n\n**时间复杂度：**O(N logN)，其中N是nums数组的长度。左指针和右指针分别会遍历整个字符串一次。在最坏情况下，数组nums 中的元素单调递增，那么最终优先队列中包含了所有元素，没有元素被移除。由于将一个元素放入优先队列的时间复杂度为 O(log N)，因此总时间复杂度为 O(N logN)\n\n**空间复杂度：**O(N)，其中 N 是优先队列需要使用的空间。\n\n####  76 最小覆盖子串\n\n给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `\"\"` 。\n\n**注意：**\n\n- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。\n- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。\n\n \n\n**示例 1：**\n\n```\n输入：s = \"ADOBECODEBANC\", t = \"ABC\"\n输出：\"BANC\"\n```\n\n**示例 2：**\n\n```\n输入：s = \"a\", t = \"a\"\n输出：\"a\"\n```\n\n**示例 3:**\n\n```\n输入: s = \"a\", t = \"aa\"\n输出: \"\"\n解释: t 中两个字符 'a' 均应包含在 s 的子串中，\n因此没有符合条件的子字符串，返回空字符串。\n```\n\n这是一道`hard`难度的题目，主要难度在于两个字符串，同时需要在第一个字符串中寻找第二个字符串的排列组合，但归根到底还是寻找子串问题，可以对第一个字符串`s`进行滑动窗口算法。\n\n首先，该题目的最终目的是要在`s`中找到含有`t`，但是这个含有不是和`t`相等，而是找到`t`的排列组合即是否含有`t`中的所有元素，由于`t`中可能包含有重复元素，在计算排列组合时，重复元素是不计入统计的，还是利用Map，先统计一下每个字符，代码如下：\n\n```javascript\nvar map = {}\nvar missingType = 0 // 记录不重复的字符个数\n\nfor (var c of t) {\n    if (map[c]) {\n        map[c]++\n    } else {\n        map[c] = 1\n        missingType++\n    }\n}\n```\n\n得到map后，就可以利用map去`s`里面匹配，代码如下：\n\n```javascript\nwhile(right < s.length) {\n    var r = s[right]\n    right++ \n    \n    if (map.hasOwnProperty(r)) { // 每当进入窗口的字符在s中出现时，就将次数-1\n        map[r]--\n    }\n\n    if (map[r] == 0) {// 当某个字符次数为0时，表示当前的这个字符就已经不缺\n        missingType--\n    }\n\n    while(missingType == 0) { // 所有字符都匹配上，这时可以缩小窗口\n\n        if (right - left < res.length) { // 取长度\n            res = s.substring(left,right)\n        }\n        var l = s[left]\n        left++\n        map[l]++ // 每当字符移出窗口时，就将次数+1\n        if (map[l] > 0) { // 如果当前的字符大于0，表示还缺少这个字符\n            missingType++\n        }\n    }\n}\n```\n\n我们在*s* 上滑动窗口，通过移动`right`指针不断扩张窗口。当窗口包含`t`全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口，`missingType`用来增加标志位记录重复字符。整体思路如下图（图片来自leetcode）：\n\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1f20ceb7677416e82dcf673df82197f~tplv-k3u1fbpfcp-watermark.image?\" alt=\"aHR0cHM6Ly9hc3NldHMubGVldGNvZGUtY24uY29tL3NvbHV0aW9uLXN0YXRpYy83Ni83Nl9maWcxLmdpZg.gif\" style=\"zoom:80%;\" />\n\n最后，我们需要处理一些边界条件，例如s和t相等，或者s中完全不包含t的情况，完整解法如下：\n\n**解法：**\n\n```javascript\nvar minWindow = function(s, t) {\n    if (t.length > s.length) return ''\n    if (t == s) return s\n    var flag = false\n    var map = {}\n    var missingType = 0\n    var res = s\n    for (var c of t) {\n        if (!map[c]) {\n            map[c] = 1\n            missingType++\n        } else {\n            map[c]++\n        }\n    }\n    var left = 0,right = 0\n\n    while(right < s.length) {\n        var r = s[right]\n        right++ \n        \n        if (map.hasOwnProperty(r)) { // 每当进入窗口的字符在s中出现时，就将次数-1\n            map[r]--\n        }\n    \n        if (map[r] == 0) {// 当某个字符次数为0时，表示当前的这个字符就已经不缺\n            missingType--\n        }\n    \n        while(missingType == 0) { // 所有字符都匹配上，这时可以缩小窗口\n            flag = true // 在s中找打过t\n            if (right - left < res.length) { // 取长度\n                res = s.substring(left,right)\n            }\n            var l = s[left]\n            left++\n            map[l]++ // 每当字符移出窗口时，就将次数+1\n            if (map[l] > 0) { // 如果当前的字符大于0，表示还缺少这个字符\n                missingType++\n            }\n        }\n    }\n    return !flag ? '' : res\n}\n```\n\n**时间复杂度：** O(N)，其中 N 是字符串`s`的长度。左指针和右指针分别会遍历整个字符串一次。\n\n**空间复杂度：** O(N)，其中 N 是字符串中不重复字符的个数，空间消耗于Map。\n\n\n\n## 总结\n\n滑动窗口类问题是面试当中的 **高频题**，问题本身其实并不复杂，掌握好框架很重要。\n\n\n\n\n\n","slug":"前端算法--滑动窗口","published":1,"updated":"2021-12-10T16:12:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434q10002q2wvjcwza8vbr","content":"<h2><span id=\"滑动窗口概述\">滑动窗口概述</span></h2><p>滑动窗口（Sliding Window）法，也叫尺取法，可以用来解决一些查找满足一定条件的连续区间的性质（长度等）的问题，在一个特定大小的字符串或数组上进行操作，而不在整个字符串或数组上操作，这样就降低了问题的复杂度，从而也达到降低了循环的嵌套深度。往往类似于“请找到满足xx的最x的区间（子串、子数组）的xx”这类问题都可以使用该方法进行解决。<br><a id=\"more\"></a></p>\n<ul>\n<li><strong>滑动：</strong> 说明这个窗口是移动的，也就是移动是按照一定方向来的。</li>\n<li><strong>窗口：</strong> 窗口大小并不是固定的，可以不断扩容直到满足一定的条件；也可以不断缩小，直到找到一个满足条件的最小窗口；当然也可以是固定大小。</li>\n</ul>\n<h2><span id=\"算法基本思想\">算法基本思想：</span></h2><p>字符串也可以转换成数组，其实本质上滑动窗口都是在数组上进行操作，对数组的操作我们一般会采用循环类方法，而滑动窗口方法则为了提升效率会采用进阶的循环，即两个指针：左指针left，右指针right。</p>\n<p>两个指针之间的内容：[left…right]则构成了窗口（window），随着指针的不断移动，窗口的位置和大小都会发生变动，但窗口里面的数据始终是连续的，通过对这些数据的处理，就可以得到需要的结果。</p>\n<p>如下图所示，设定滑动窗口（window）大小为 3，当滑动窗口每次划过数组时，计算当前滑动窗口中元素的和，得到结果 res：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbe042a9e3974523ad76a8d2f6280b88~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>结合上面的思路，可以设计一下滑动窗口的通用框架，伪代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = [...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> left = <span class=\"number\">0</span>; <span class=\"comment\">// 左指针</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> right = <span class=\"number\">0</span>; <span class=\"comment\">// 右指针</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">window</span> = [] 或 &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(right &lt; list.length) &#123; <span class=\"comment\">// 右指针小于边界</span></span><br><span class=\"line\">    <span class=\"built_in\">window</span>.add(list[right]);<span class=\"comment\">// 向窗口添加元素</span></span><br><span class=\"line\">    right++;<span class=\"comment\">// 移动right扩大窗口</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果符合要求，说明窗口构造完成，移动 left 缩小窗口 </span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">window</span> 符合要求（length &lt; <span class=\"number\">3</span>）) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ...针对窗口内容处理</span></span><br><span class=\"line\">        sum(<span class=\"built_in\">window</span>) <span class=\"comment\">// 求和res</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">window</span>.remove(list[left]); <span class=\"comment\">// 将元素移出窗口</span></span><br><span class=\"line\">        left++; <span class=\"comment\">// 缩小窗口</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>框架由两个while循环构成，外层控制窗口扩展，内层控制窗口收缩，下面来举几个例子。</p>\n<h2><span id=\"leetcode算法原题\">Leetcode算法原题：</span></h2><h4><span id=\"3-无重复字符的最长子串\">3 无重复字符的最长子串</span></h4><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;abcabcbb&quot;</span><br><span class=\"line\">输出: 3 </span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;bbbbb&quot;</span><br><span class=\"line\">输出: 1</span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;pwwkew&quot;</span><br><span class=\"line\">输出: 3</span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class=\"line\">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 4:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;&quot;</span><br><span class=\"line\">输出: 0</span><br></pre></td></tr></table></figure>\n<p>首先，需要明确子串一般是连续的，子序列一般是不连续的，题目中求子串，很容易联想到滑动窗口解法。</p>\n<p>根据题目可以知道，窗口的大小是不固定的，所以该题目难点在于我们需要找到一个临界条件来判断合适调整窗口里面的数据，即内层的while循环什么时候执行。</p>\n<p>由于题目要求的是无重复字符，对于常见的算法中，很多情况情况下需要利用Map来统计一个字符串中字符是否重复，即key值为单个字符，value为该字符出现的次数，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'abcdea'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> map = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i &lt; str.length ; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cur = str[i]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map[cur]) &#123;</span><br><span class=\"line\">       map[cur] ++</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       map[cur] = <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">map: &#123;<span class=\"string\">\"a\"</span>:<span class=\"number\">2</span>,<span class=\"string\">\"b\"</span>:<span class=\"number\">1</span>,<span class=\"string\">\"c\"</span>:<span class=\"number\">1</span>,<span class=\"string\">\"d\"</span>:<span class=\"number\">1</span>,<span class=\"string\">\"e\"</span>:<span class=\"number\">1</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>所以，当map里面的某个key对应的值大于1时，说明该字符串含有重复字符。利用这个思路，我们使用滑动窗口时，就可以作为window符合要求的条件判断，整体思路如下图（图片来自leetcode）：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e083066f1054bd586740d4d7a68d518~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>其中，i，j两个指针分别对应left和right，通过不断变换窗口来计算每次变换后的连续子串长度。</p>\n<p><strong>解法</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> lengthOfLongestSubstring = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> map = &#123;&#125; <span class=\"comment\">// 用来计算每个字符出现的次数</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> left = <span class=\"number\">0</span>,right = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = s.length</span><br><span class=\"line\">    <span class=\"keyword\">var</span> res = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(right &lt; len) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> r = s[right]</span><br><span class=\"line\">        right++</span><br><span class=\"line\">        <span class=\"comment\">// 右指针的元素进入窗口</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map[r]) &#123;</span><br><span class=\"line\">            map[r]++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            map[r] = <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 发现窗口中有重复元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(map[r] &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> l = s[left]</span><br><span class=\"line\">            <span class=\"comment\">// 缩小窗口</span></span><br><span class=\"line\">            left++</span><br><span class=\"line\">            map[l]--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 此时的窗口中必无重复值</span></span><br><span class=\"line\">        <span class=\"comment\">// 窗口每次变化 都记录长度 两两比较取最大值</span></span><br><span class=\"line\">        res = <span class=\"built_in\">Math</span>.max(res,right-left)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>时间复杂度：</strong> O(N)，其中 N 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。</p>\n<p><strong>空间复杂度：</strong> O(N)，其中 N 是字符串中不重复字符的个数，空间消耗于Map。</p>\n<h4><span id=\"239-滑动窗口的最大值\">239 滑动窗口的最大值</span></h4><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p>\n<p>返回滑动窗口中的最大值。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class=\"line\">输出：[3,3,5,5,6,7]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">滑动窗口的位置                最大值</span><br><span class=\"line\">---------------               -----</span><br><span class=\"line\">[1  3  -1] -3  5  3  6  7       3</span><br><span class=\"line\"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class=\"line\"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class=\"line\"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class=\"line\"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class=\"line\"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1], k = 1</span><br><span class=\"line\">输出：[1]</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,-1], k = 1</span><br><span class=\"line\">输出：[1,-1]</span><br></pre></td></tr></table></figure>\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [9,11], k = 2</span><br><span class=\"line\">输出：[11]</span><br></pre></td></tr></table></figure>\n<p><strong>示例 5：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [<span class=\"number\">4</span>,<span class=\"number\">-2</span>], k = <span class=\"number\">2</span></span><br><span class=\"line\">输出：[<span class=\"number\">4</span>]</span><br></pre></td></tr></table></figure>\n<p>在 LeetCode 上，这虽然是一道<code>hard</code>难度的题目，但是利用我们上面的滑动窗口框架思路，很容易就可以提供一种解法。</p>\n<p>首先，题目中的窗口大小时固定的，所以我们只需要移动窗口，即同步移动<code>left</code>和<code>right</code>指针，而内层<code>while</code>循环的window符合要求条件就很简单了，直接判断窗口长度是否符合即可，核心代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">window</span> = []</span><br><span class=\"line\"><span class=\"keyword\">while</span> (right &lt; nums.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> r = nums[right]</span><br><span class=\"line\">    right++</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.push(r)<span class=\"comment\">// 右边元素进入窗口</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">window</span>.length == k) &#123; <span class=\"comment\">// 窗口长度符合k</span></span><br><span class=\"line\">       max(<span class=\"built_in\">window</span>) <span class=\"comment\">// 计算窗口中的最大值</span></span><br><span class=\"line\">        <span class=\"built_in\">window</span>.shift()<span class=\"comment\">// 左边元素移出窗口</span></span><br><span class=\"line\">        left++ <span class=\"comment\">// 窗口向右移动</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>基本思路：</p>\n<ul>\n<li>使用滑动窗口遍历数组。</li>\n<li>窗口对象为一个数组，每次指针向右移动时，向数组中添加元素。</li>\n<li>当窗口大小符合<code>k</code>时，计算窗口中的最大值，然后窗口整体向右移动。</li>\n<li>当右指针到达边界时，遍历完成。</li>\n</ul>\n<p><strong>解法：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> maxSlidingWindow = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nums, k</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (k == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> nums</span><br><span class=\"line\">  <span class=\"keyword\">var</span> right = <span class=\"number\">0</span>,left = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> <span class=\"built_in\">window</span> = []</span><br><span class=\"line\">  <span class=\"keyword\">var</span> res = []</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (right &lt; nums.length) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> r = nums[right]</span><br><span class=\"line\">      right++</span><br><span class=\"line\">      <span class=\"built_in\">window</span>.push(r)</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (<span class=\"built_in\">window</span>.length == k) &#123;</span><br><span class=\"line\">          res.push(<span class=\"built_in\">Math</span>.max(...window)) <span class=\"comment\">// 利用Math.max求最大值</span></span><br><span class=\"line\">          <span class=\"built_in\">window</span>.shift()</span><br><span class=\"line\">          left++</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>但是作为一道<code>hard</code>难度的题目，其难度主要在于时间复杂度，上面解法中，我们每次对窗口中的数据求最大值，利用<code>Math.max()</code>方法，这其实是非常消耗性能的，底层其实会对窗口进行遍历，并取得到最大值，这样增加了很大一部分循环时间复杂度。</p>\n<p>我们可以思考一下，窗口<code>window</code>只需要得到最大值，那么我们就可以将窗口设置为一个单调递减的数组队列，每当新进入窗口的元素比之前的还小时，就直接抛弃，这时的最大值还是上一次的最大值，这样就节省了时间，引入单调队列。</p>\n<p>单调队列基本思路：</p>\n<p>原始队列：<code>[1 3 -1 -3 5 3]</code>。</p>\n<p>始终要维护队列保证其 <strong>递减</strong> 的特点，所以会有如下的事情发生：</p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>队列状态</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1入队</td>\n<td>[1]</td>\n</tr>\n<tr>\n<td>3入队，比1大，1删除</td>\n<td>[3]</td>\n</tr>\n<tr>\n<td>-1入队</td>\n<td>[3，-1]</td>\n</tr>\n<tr>\n<td>-3入队</td>\n<td>[3，-1，-3]</td>\n</tr>\n<tr>\n<td>5入队，比-3大，删除前面元素，再依次比较删除</td>\n<td>[5]</td>\n</tr>\n<tr>\n<td>3入队</td>\n<td>[5，3]</td>\n</tr>\n</tbody>\n</table>\n<p>转换成代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">maxQueue</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.items = []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 进入队列</span></span><br><span class=\"line\">    enqueue(ele)&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 把前面比新元素小的元素都删掉</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span>(<span class=\"keyword\">this</span>.items.length &amp;&amp; <span class=\"keyword\">this</span>.items[<span class=\"keyword\">this</span>.items.length<span class=\"number\">-1</span>] &lt; ele) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.items.pop()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.items.push(ele)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 队首出队</span></span><br><span class=\"line\">    dequeue(ele)&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 判断是否是需要移出的元素</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.items.length &amp;&amp; <span class=\"keyword\">this</span>.items[<span class=\"number\">0</span>] == ele) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.items.shift()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 队首就是最大元素</span></span><br><span class=\"line\">    front()&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.items[<span class=\"number\">0</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    max()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.front()<span class=\"comment\">// 队首就是最大元素</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>引入优先队列之后，改造我们的整体解法，代码如下：</p>\n<p><strong>解法：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> maxSlidingWindow = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nums, k</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> nums</span><br><span class=\"line\">    <span class=\"keyword\">var</span> right = <span class=\"number\">0</span>,left = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">window</span> = <span class=\"keyword\">new</span> maxQueue()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> res = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (right &lt; nums.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> r = nums[right]</span><br><span class=\"line\">        right++</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.enqueue(r)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (right-left &gt;= k) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> l = nums[left]</span><br><span class=\"line\">            res.push(<span class=\"built_in\">window</span>.max())</span><br><span class=\"line\">            <span class=\"built_in\">window</span>.dequeue(l)</span><br><span class=\"line\">            left++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>时间复杂度：</strong>O(N logN)，其中N是nums数组的长度。左指针和右指针分别会遍历整个字符串一次。在最坏情况下，数组nums 中的元素单调递增，那么最终优先队列中包含了所有元素，没有元素被移除。由于将一个元素放入优先队列的时间复杂度为 O(log N)，因此总时间复杂度为 O(N logN)</p>\n<p><strong>空间复杂度：</strong>O(N)，其中 N 是优先队列需要使用的空间。</p>\n<h4><span id=\"76-最小覆盖子串\">76 最小覆盖子串</span></h4><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li>\n<li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class=\"line\">输出：&quot;BANC&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;a&quot;, t = &quot;a&quot;</span><br><span class=\"line\">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;a&quot;, t = &quot;aa&quot;</span><br><span class=\"line\">输出: &quot;&quot;</span><br><span class=\"line\">解释: t 中两个字符 &apos;a&apos; 均应包含在 s 的子串中，</span><br><span class=\"line\">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure>\n<p>这是一道<code>hard</code>难度的题目，主要难度在于两个字符串，同时需要在第一个字符串中寻找第二个字符串的排列组合，但归根到底还是寻找子串问题，可以对第一个字符串<code>s</code>进行滑动窗口算法。</p>\n<p>首先，该题目的最终目的是要在<code>s</code>中找到含有<code>t</code>，但是这个含有不是和<code>t</code>相等，而是找到<code>t</code>的排列组合即是否含有<code>t</code>中的所有元素，由于<code>t</code>中可能包含有重复元素，在计算排列组合时，重复元素是不计入统计的，还是利用Map，先统计一下每个字符，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> map = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> missingType = <span class=\"number\">0</span> <span class=\"comment\">// 记录不重复的字符个数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> c <span class=\"keyword\">of</span> t) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map[c]) &#123;</span><br><span class=\"line\">        map[c]++</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        map[c] = <span class=\"number\">1</span></span><br><span class=\"line\">        missingType++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>得到map后，就可以利用map去<code>s</code>里面匹配，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(right &lt; s.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> r = s[right]</span><br><span class=\"line\">    right++ </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map.hasOwnProperty(r)) &#123; <span class=\"comment\">// 每当进入窗口的字符在s中出现时，就将次数-1</span></span><br><span class=\"line\">        map[r]--</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map[r] == <span class=\"number\">0</span>) &#123;<span class=\"comment\">// 当某个字符次数为0时，表示当前的这个字符就已经不缺</span></span><br><span class=\"line\">        missingType--</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(missingType == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 所有字符都匹配上，这时可以缩小窗口</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right - left &lt; res.length) &#123; <span class=\"comment\">// 取长度</span></span><br><span class=\"line\">            res = s.substring(left,right)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> l = s[left]</span><br><span class=\"line\">        left++</span><br><span class=\"line\">        map[l]++ <span class=\"comment\">// 每当字符移出窗口时，就将次数+1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map[l] &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 如果当前的字符大于0，表示还缺少这个字符</span></span><br><span class=\"line\">            missingType++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们在<em>s</em> 上滑动窗口，通过移动<code>right</code>指针不断扩张窗口。当窗口包含<code>t</code>全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口，<code>missingType</code>用来增加标志位记录重复字符。整体思路如下图（图片来自leetcode）：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1f20ceb7677416e82dcf673df82197f~tplv-k3u1fbpfcp-watermark.image?\" alt=\"aHR0cHM6Ly9hc3NldHMubGVldGNvZGUtY24uY29tL3NvbHV0aW9uLXN0YXRpYy83Ni83Nl9maWcxLmdpZg.gif\" style=\"zoom:80%;\"></p>\n<p>最后，我们需要处理一些边界条件，例如s和t相等，或者s中完全不包含t的情况，完整解法如下：</p>\n<p><strong>解法：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> minWindow = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s, t</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t.length &gt; s.length) <span class=\"keyword\">return</span> <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t == s) <span class=\"keyword\">return</span> s</span><br><span class=\"line\">    <span class=\"keyword\">var</span> flag = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> map = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> missingType = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> res = s</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> c <span class=\"keyword\">of</span> t) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!map[c]) &#123;</span><br><span class=\"line\">            map[c] = <span class=\"number\">1</span></span><br><span class=\"line\">            missingType++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            map[c]++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> left = <span class=\"number\">0</span>,right = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(right &lt; s.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> r = s[right]</span><br><span class=\"line\">        right++ </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map.hasOwnProperty(r)) &#123; <span class=\"comment\">// 每当进入窗口的字符在s中出现时，就将次数-1</span></span><br><span class=\"line\">            map[r]--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map[r] == <span class=\"number\">0</span>) &#123;<span class=\"comment\">// 当某个字符次数为0时，表示当前的这个字符就已经不缺</span></span><br><span class=\"line\">            missingType--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(missingType == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 所有字符都匹配上，这时可以缩小窗口</span></span><br><span class=\"line\">            flag = <span class=\"literal\">true</span> <span class=\"comment\">// 在s中找打过t</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (right - left &lt; res.length) &#123; <span class=\"comment\">// 取长度</span></span><br><span class=\"line\">                res = s.substring(left,right)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> l = s[left]</span><br><span class=\"line\">            left++</span><br><span class=\"line\">            map[l]++ <span class=\"comment\">// 每当字符移出窗口时，就将次数+1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map[l] &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 如果当前的字符大于0，表示还缺少这个字符</span></span><br><span class=\"line\">                missingType++</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !flag ? <span class=\"string\">''</span> : res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>时间复杂度：</strong> O(N)，其中 N 是字符串<code>s</code>的长度。左指针和右指针分别会遍历整个字符串一次。</p>\n<p><strong>空间复杂度：</strong> O(N)，其中 N 是字符串中不重复字符的个数，空间消耗于Map。</p>\n<h2><span id=\"总结\">总结</span></h2><p>滑动窗口类问题是面试当中的 <strong>高频题</strong>，问题本身其实并不复杂，掌握好框架很重要。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"滑动窗口概述\"><a href=\"#滑动窗口概述\" class=\"headerlink\" title=\"滑动窗口概述\"></a>滑动窗口概述</h2><p>滑动窗口（Sliding Window）法，也叫尺取法，可以用来解决一些查找满足一定条件的连续区间的性质（长度等）的问题，在一个特定大小的字符串或数组上进行操作，而不在整个字符串或数组上操作，这样就降低了问题的复杂度，从而也达到降低了循环的嵌套深度。往往类似于“请找到满足xx的最x的区间（子串、子数组）的xx”这类问题都可以使用该方法进行解决。<br>","more":"</p>\n<ul>\n<li><strong>滑动：</strong> 说明这个窗口是移动的，也就是移动是按照一定方向来的。</li>\n<li><strong>窗口：</strong> 窗口大小并不是固定的，可以不断扩容直到满足一定的条件；也可以不断缩小，直到找到一个满足条件的最小窗口；当然也可以是固定大小。</li>\n</ul>\n<h2 id=\"算法基本思想：\"><a href=\"#算法基本思想：\" class=\"headerlink\" title=\"算法基本思想：\"></a>算法基本思想：</h2><p>字符串也可以转换成数组，其实本质上滑动窗口都是在数组上进行操作，对数组的操作我们一般会采用循环类方法，而滑动窗口方法则为了提升效率会采用进阶的循环，即两个指针：左指针left，右指针right。</p>\n<p>两个指针之间的内容：[left…right]则构成了窗口（window），随着指针的不断移动，窗口的位置和大小都会发生变动，但窗口里面的数据始终是连续的，通过对这些数据的处理，就可以得到需要的结果。</p>\n<p>如下图所示，设定滑动窗口（window）大小为 3，当滑动窗口每次划过数组时，计算当前滑动窗口中元素的和，得到结果 res：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbe042a9e3974523ad76a8d2f6280b88~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>结合上面的思路，可以设计一下滑动窗口的通用框架，伪代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = [...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> left = <span class=\"number\">0</span>; <span class=\"comment\">// 左指针</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> right = <span class=\"number\">0</span>; <span class=\"comment\">// 右指针</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">window</span> = [] 或 &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(right &lt; list.length) &#123; <span class=\"comment\">// 右指针小于边界</span></span><br><span class=\"line\">    <span class=\"built_in\">window</span>.add(list[right]);<span class=\"comment\">// 向窗口添加元素</span></span><br><span class=\"line\">    right++;<span class=\"comment\">// 移动right扩大窗口</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果符合要求，说明窗口构造完成，移动 left 缩小窗口 </span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">window</span> 符合要求（length &lt; <span class=\"number\">3</span>）) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ...针对窗口内容处理</span></span><br><span class=\"line\">        sum(<span class=\"built_in\">window</span>) <span class=\"comment\">// 求和res</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">window</span>.remove(list[left]); <span class=\"comment\">// 将元素移出窗口</span></span><br><span class=\"line\">        left++; <span class=\"comment\">// 缩小窗口</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>框架由两个while循环构成，外层控制窗口扩展，内层控制窗口收缩，下面来举几个例子。</p>\n<h2 id=\"Leetcode算法原题：\"><a href=\"#Leetcode算法原题：\" class=\"headerlink\" title=\"Leetcode算法原题：\"></a>Leetcode算法原题：</h2><h4 id=\"3-无重复字符的最长子串\"><a href=\"#3-无重复字符的最长子串\" class=\"headerlink\" title=\"3 无重复字符的最长子串\"></a>3 无重复字符的最长子串</h4><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;abcabcbb&quot;</span><br><span class=\"line\">输出: 3 </span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;bbbbb&quot;</span><br><span class=\"line\">输出: 1</span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;pwwkew&quot;</span><br><span class=\"line\">输出: 3</span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class=\"line\">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 4:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;&quot;</span><br><span class=\"line\">输出: 0</span><br></pre></td></tr></table></figure>\n<p>首先，需要明确子串一般是连续的，子序列一般是不连续的，题目中求子串，很容易联想到滑动窗口解法。</p>\n<p>根据题目可以知道，窗口的大小是不固定的，所以该题目难点在于我们需要找到一个临界条件来判断合适调整窗口里面的数据，即内层的while循环什么时候执行。</p>\n<p>由于题目要求的是无重复字符，对于常见的算法中，很多情况情况下需要利用Map来统计一个字符串中字符是否重复，即key值为单个字符，value为该字符出现的次数，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'abcdea'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> map = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i &lt; str.length ; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cur = str[i]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map[cur]) &#123;</span><br><span class=\"line\">       map[cur] ++</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       map[cur] = <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">map: &#123;<span class=\"string\">\"a\"</span>:<span class=\"number\">2</span>,<span class=\"string\">\"b\"</span>:<span class=\"number\">1</span>,<span class=\"string\">\"c\"</span>:<span class=\"number\">1</span>,<span class=\"string\">\"d\"</span>:<span class=\"number\">1</span>,<span class=\"string\">\"e\"</span>:<span class=\"number\">1</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>所以，当map里面的某个key对应的值大于1时，说明该字符串含有重复字符。利用这个思路，我们使用滑动窗口时，就可以作为window符合要求的条件判断，整体思路如下图（图片来自leetcode）：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e083066f1054bd586740d4d7a68d518~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>其中，i，j两个指针分别对应left和right，通过不断变换窗口来计算每次变换后的连续子串长度。</p>\n<p><strong>解法</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> lengthOfLongestSubstring = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> map = &#123;&#125; <span class=\"comment\">// 用来计算每个字符出现的次数</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> left = <span class=\"number\">0</span>,right = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = s.length</span><br><span class=\"line\">    <span class=\"keyword\">var</span> res = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(right &lt; len) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> r = s[right]</span><br><span class=\"line\">        right++</span><br><span class=\"line\">        <span class=\"comment\">// 右指针的元素进入窗口</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map[r]) &#123;</span><br><span class=\"line\">            map[r]++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            map[r] = <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 发现窗口中有重复元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(map[r] &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> l = s[left]</span><br><span class=\"line\">            <span class=\"comment\">// 缩小窗口</span></span><br><span class=\"line\">            left++</span><br><span class=\"line\">            map[l]--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 此时的窗口中必无重复值</span></span><br><span class=\"line\">        <span class=\"comment\">// 窗口每次变化 都记录长度 两两比较取最大值</span></span><br><span class=\"line\">        res = <span class=\"built_in\">Math</span>.max(res,right-left)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>时间复杂度：</strong> O(N)，其中 N 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。</p>\n<p><strong>空间复杂度：</strong> O(N)，其中 N 是字符串中不重复字符的个数，空间消耗于Map。</p>\n<h4 id=\"239-滑动窗口的最大值\"><a href=\"#239-滑动窗口的最大值\" class=\"headerlink\" title=\"239 滑动窗口的最大值\"></a>239 滑动窗口的最大值</h4><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p>\n<p>返回滑动窗口中的最大值。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class=\"line\">输出：[3,3,5,5,6,7]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">滑动窗口的位置                最大值</span><br><span class=\"line\">---------------               -----</span><br><span class=\"line\">[1  3  -1] -3  5  3  6  7       3</span><br><span class=\"line\"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class=\"line\"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class=\"line\"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class=\"line\"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class=\"line\"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1], k = 1</span><br><span class=\"line\">输出：[1]</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,-1], k = 1</span><br><span class=\"line\">输出：[1,-1]</span><br></pre></td></tr></table></figure>\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [9,11], k = 2</span><br><span class=\"line\">输出：[11]</span><br></pre></td></tr></table></figure>\n<p><strong>示例 5：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [<span class=\"number\">4</span>,<span class=\"number\">-2</span>], k = <span class=\"number\">2</span></span><br><span class=\"line\">输出：[<span class=\"number\">4</span>]</span><br></pre></td></tr></table></figure>\n<p>在 LeetCode 上，这虽然是一道<code>hard</code>难度的题目，但是利用我们上面的滑动窗口框架思路，很容易就可以提供一种解法。</p>\n<p>首先，题目中的窗口大小时固定的，所以我们只需要移动窗口，即同步移动<code>left</code>和<code>right</code>指针，而内层<code>while</code>循环的window符合要求条件就很简单了，直接判断窗口长度是否符合即可，核心代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">window</span> = []</span><br><span class=\"line\"><span class=\"keyword\">while</span> (right &lt; nums.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> r = nums[right]</span><br><span class=\"line\">    right++</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.push(r)<span class=\"comment\">// 右边元素进入窗口</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">window</span>.length == k) &#123; <span class=\"comment\">// 窗口长度符合k</span></span><br><span class=\"line\">       max(<span class=\"built_in\">window</span>) <span class=\"comment\">// 计算窗口中的最大值</span></span><br><span class=\"line\">        <span class=\"built_in\">window</span>.shift()<span class=\"comment\">// 左边元素移出窗口</span></span><br><span class=\"line\">        left++ <span class=\"comment\">// 窗口向右移动</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>基本思路：</p>\n<ul>\n<li>使用滑动窗口遍历数组。</li>\n<li>窗口对象为一个数组，每次指针向右移动时，向数组中添加元素。</li>\n<li>当窗口大小符合<code>k</code>时，计算窗口中的最大值，然后窗口整体向右移动。</li>\n<li>当右指针到达边界时，遍历完成。</li>\n</ul>\n<p><strong>解法：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> maxSlidingWindow = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nums, k</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (k == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> nums</span><br><span class=\"line\">  <span class=\"keyword\">var</span> right = <span class=\"number\">0</span>,left = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> <span class=\"built_in\">window</span> = []</span><br><span class=\"line\">  <span class=\"keyword\">var</span> res = []</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (right &lt; nums.length) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> r = nums[right]</span><br><span class=\"line\">      right++</span><br><span class=\"line\">      <span class=\"built_in\">window</span>.push(r)</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (<span class=\"built_in\">window</span>.length == k) &#123;</span><br><span class=\"line\">          res.push(<span class=\"built_in\">Math</span>.max(...window)) <span class=\"comment\">// 利用Math.max求最大值</span></span><br><span class=\"line\">          <span class=\"built_in\">window</span>.shift()</span><br><span class=\"line\">          left++</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>但是作为一道<code>hard</code>难度的题目，其难度主要在于时间复杂度，上面解法中，我们每次对窗口中的数据求最大值，利用<code>Math.max()</code>方法，这其实是非常消耗性能的，底层其实会对窗口进行遍历，并取得到最大值，这样增加了很大一部分循环时间复杂度。</p>\n<p>我们可以思考一下，窗口<code>window</code>只需要得到最大值，那么我们就可以将窗口设置为一个单调递减的数组队列，每当新进入窗口的元素比之前的还小时，就直接抛弃，这时的最大值还是上一次的最大值，这样就节省了时间，引入单调队列。</p>\n<p>单调队列基本思路：</p>\n<p>原始队列：<code>[1 3 -1 -3 5 3]</code>。</p>\n<p>始终要维护队列保证其 <strong>递减</strong> 的特点，所以会有如下的事情发生：</p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>队列状态</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1入队</td>\n<td>[1]</td>\n</tr>\n<tr>\n<td>3入队，比1大，1删除</td>\n<td>[3]</td>\n</tr>\n<tr>\n<td>-1入队</td>\n<td>[3，-1]</td>\n</tr>\n<tr>\n<td>-3入队</td>\n<td>[3，-1，-3]</td>\n</tr>\n<tr>\n<td>5入队，比-3大，删除前面元素，再依次比较删除</td>\n<td>[5]</td>\n</tr>\n<tr>\n<td>3入队</td>\n<td>[5，3]</td>\n</tr>\n</tbody>\n</table>\n<p>转换成代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">maxQueue</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.items = []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 进入队列</span></span><br><span class=\"line\">    enqueue(ele)&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 把前面比新元素小的元素都删掉</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span>(<span class=\"keyword\">this</span>.items.length &amp;&amp; <span class=\"keyword\">this</span>.items[<span class=\"keyword\">this</span>.items.length<span class=\"number\">-1</span>] &lt; ele) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.items.pop()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.items.push(ele)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 队首出队</span></span><br><span class=\"line\">    dequeue(ele)&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 判断是否是需要移出的元素</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.items.length &amp;&amp; <span class=\"keyword\">this</span>.items[<span class=\"number\">0</span>] == ele) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.items.shift()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 队首就是最大元素</span></span><br><span class=\"line\">    front()&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.items[<span class=\"number\">0</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    max()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.front()<span class=\"comment\">// 队首就是最大元素</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>引入优先队列之后，改造我们的整体解法，代码如下：</p>\n<p><strong>解法：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> maxSlidingWindow = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nums, k</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> nums</span><br><span class=\"line\">    <span class=\"keyword\">var</span> right = <span class=\"number\">0</span>,left = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">window</span> = <span class=\"keyword\">new</span> maxQueue()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> res = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (right &lt; nums.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> r = nums[right]</span><br><span class=\"line\">        right++</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.enqueue(r)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (right-left &gt;= k) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> l = nums[left]</span><br><span class=\"line\">            res.push(<span class=\"built_in\">window</span>.max())</span><br><span class=\"line\">            <span class=\"built_in\">window</span>.dequeue(l)</span><br><span class=\"line\">            left++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>时间复杂度：</strong>O(N logN)，其中N是nums数组的长度。左指针和右指针分别会遍历整个字符串一次。在最坏情况下，数组nums 中的元素单调递增，那么最终优先队列中包含了所有元素，没有元素被移除。由于将一个元素放入优先队列的时间复杂度为 O(log N)，因此总时间复杂度为 O(N logN)</p>\n<p><strong>空间复杂度：</strong>O(N)，其中 N 是优先队列需要使用的空间。</p>\n<h4 id=\"76-最小覆盖子串\"><a href=\"#76-最小覆盖子串\" class=\"headerlink\" title=\"76 最小覆盖子串\"></a>76 最小覆盖子串</h4><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li>\n<li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class=\"line\">输出：&quot;BANC&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;a&quot;, t = &quot;a&quot;</span><br><span class=\"line\">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;a&quot;, t = &quot;aa&quot;</span><br><span class=\"line\">输出: &quot;&quot;</span><br><span class=\"line\">解释: t 中两个字符 &apos;a&apos; 均应包含在 s 的子串中，</span><br><span class=\"line\">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure>\n<p>这是一道<code>hard</code>难度的题目，主要难度在于两个字符串，同时需要在第一个字符串中寻找第二个字符串的排列组合，但归根到底还是寻找子串问题，可以对第一个字符串<code>s</code>进行滑动窗口算法。</p>\n<p>首先，该题目的最终目的是要在<code>s</code>中找到含有<code>t</code>，但是这个含有不是和<code>t</code>相等，而是找到<code>t</code>的排列组合即是否含有<code>t</code>中的所有元素，由于<code>t</code>中可能包含有重复元素，在计算排列组合时，重复元素是不计入统计的，还是利用Map，先统计一下每个字符，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> map = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> missingType = <span class=\"number\">0</span> <span class=\"comment\">// 记录不重复的字符个数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> c <span class=\"keyword\">of</span> t) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map[c]) &#123;</span><br><span class=\"line\">        map[c]++</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        map[c] = <span class=\"number\">1</span></span><br><span class=\"line\">        missingType++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>得到map后，就可以利用map去<code>s</code>里面匹配，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(right &lt; s.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> r = s[right]</span><br><span class=\"line\">    right++ </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map.hasOwnProperty(r)) &#123; <span class=\"comment\">// 每当进入窗口的字符在s中出现时，就将次数-1</span></span><br><span class=\"line\">        map[r]--</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map[r] == <span class=\"number\">0</span>) &#123;<span class=\"comment\">// 当某个字符次数为0时，表示当前的这个字符就已经不缺</span></span><br><span class=\"line\">        missingType--</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(missingType == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 所有字符都匹配上，这时可以缩小窗口</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right - left &lt; res.length) &#123; <span class=\"comment\">// 取长度</span></span><br><span class=\"line\">            res = s.substring(left,right)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> l = s[left]</span><br><span class=\"line\">        left++</span><br><span class=\"line\">        map[l]++ <span class=\"comment\">// 每当字符移出窗口时，就将次数+1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map[l] &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 如果当前的字符大于0，表示还缺少这个字符</span></span><br><span class=\"line\">            missingType++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们在<em>s</em> 上滑动窗口，通过移动<code>right</code>指针不断扩张窗口。当窗口包含<code>t</code>全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口，<code>missingType</code>用来增加标志位记录重复字符。整体思路如下图（图片来自leetcode）：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1f20ceb7677416e82dcf673df82197f~tplv-k3u1fbpfcp-watermark.image?\" alt=\"aHR0cHM6Ly9hc3NldHMubGVldGNvZGUtY24uY29tL3NvbHV0aW9uLXN0YXRpYy83Ni83Nl9maWcxLmdpZg.gif\" style=\"zoom:80%;\"></p>\n<p>最后，我们需要处理一些边界条件，例如s和t相等，或者s中完全不包含t的情况，完整解法如下：</p>\n<p><strong>解法：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> minWindow = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s, t</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t.length &gt; s.length) <span class=\"keyword\">return</span> <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t == s) <span class=\"keyword\">return</span> s</span><br><span class=\"line\">    <span class=\"keyword\">var</span> flag = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> map = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> missingType = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> res = s</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> c <span class=\"keyword\">of</span> t) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!map[c]) &#123;</span><br><span class=\"line\">            map[c] = <span class=\"number\">1</span></span><br><span class=\"line\">            missingType++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            map[c]++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> left = <span class=\"number\">0</span>,right = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(right &lt; s.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> r = s[right]</span><br><span class=\"line\">        right++ </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map.hasOwnProperty(r)) &#123; <span class=\"comment\">// 每当进入窗口的字符在s中出现时，就将次数-1</span></span><br><span class=\"line\">            map[r]--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map[r] == <span class=\"number\">0</span>) &#123;<span class=\"comment\">// 当某个字符次数为0时，表示当前的这个字符就已经不缺</span></span><br><span class=\"line\">            missingType--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(missingType == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 所有字符都匹配上，这时可以缩小窗口</span></span><br><span class=\"line\">            flag = <span class=\"literal\">true</span> <span class=\"comment\">// 在s中找打过t</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (right - left &lt; res.length) &#123; <span class=\"comment\">// 取长度</span></span><br><span class=\"line\">                res = s.substring(left,right)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> l = s[left]</span><br><span class=\"line\">            left++</span><br><span class=\"line\">            map[l]++ <span class=\"comment\">// 每当字符移出窗口时，就将次数+1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map[l] &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 如果当前的字符大于0，表示还缺少这个字符</span></span><br><span class=\"line\">                missingType++</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !flag ? <span class=\"string\">''</span> : res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>时间复杂度：</strong> O(N)，其中 N 是字符串<code>s</code>的长度。左指针和右指针分别会遍历整个字符串一次。</p>\n<p><strong>空间复杂度：</strong> O(N)，其中 N 是字符串中不重复字符的个数，空间消耗于Map。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>滑动窗口类问题是面试当中的 <strong>高频题</strong>，问题本身其实并不复杂，掌握好框架很重要。</p>"},{"title":"前端算法--背包问题","date":"2021-08-26T09:26:17.000Z","_content":"\n## 背包问题\n\n背包问题是一类经典的算法问题，属于动态规划解法范畴，其核心是在一个范围内择出最优解。\n\n一般描述为：给定一组物品和一个背包，每种物品都有自己的重量和价格，在背包限定的总重量内，我们如何选择，才能使得物品的总价格最高。\n<!--more-->\n### 非完全背包\n\n如下面的背包基础问题：\n\n**描述**\n\n有若干个物品和一个大小为 `m` 的背包. 给定数组 `A` 表示每个物品的大小和数组 `V` 表示每个物品的价值。\n\n问最多能装入背包的总价值是多大?\n\n样例\n\n**样例 1：**\n\n输入：\n\n```\nm = 10\nA = [2, 3, 5, 7]\nV = [1, 5, 2, 4]\n```\n\n输出：\n\n```\n9\n```\n\n解释：\n\n装入 A[1] 和 A[3] 可以得到最大价值, V[1] + V[3] = 9\n\n**样例 2：**\n\n输入：\n\n```\nm = 10\nA = [2, 3, 8]\nV = [2, 5, 8]\n```\n\n输出：\n\n```\n10\n```\n\n解释：\n\n装入 A[0] 和 A[2] 可以得到最大价值, V[0] + V[2] = 10\n\n**解法**\n\n我们有*n*种物品，物品*j*的重量为*wj*，价格为*pj*。\n\n我们假定所有物品的重量和价格都是非负的。背包所能承受的最大重量为*W*。\n\n针对每个物品x，我们可以选择0个或者1个（用或者不用），转换成具体公式：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ec32f8358eb4d818026c118d6d07c4d~tplv-k3u1fbpfcp-watermark.image?)\n\n在总重量不超过*W*的前提下，我们希望总价格最高。对于*Y* ≤ *W*，我们将在总重量不超过*Y*的前提下，总价格所能达到的最高值定义为*A*(*Y*)。*A*(*W*)即为问题的答案。\n\n显然，*A*(*Y*)满足：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a73d746d304c40db91c6aa8bb2a36bd4~tplv-k3u1fbpfcp-watermark.image?)\n\n其中，*pj*为第*j*种物品的价格。\n\n* 对于第一种情况，如果总重量为0，总价值也为0。\n* 对于第二种情况，总重量为*Y*时背包的最高价值可能有两种情况，第一种是该重量无法被完全填满，这对应于表达式*A*(*Y - 1*)。第二种是刚好填满，这对应于一个包含一系列刚好填满的可能性的集合，其中的可能性是指当最后放进包中的物品恰好是重量为*wj*的物品时背包填满并达到最高价值。而这时的背包价值等于重量为*wj*物品的价值*pj*和当没有放入该物品时背包的最高价值之和。故归纳为表达式*pj* + *A*(*Y* - *wj*)。最后把所有上述情况中背包价值的最大值求出就得到了*A*(*Y*)的值。\n\n所以这里就存在了递推关系，依次计算*A*(0), *A*(1), ..., *A*(*W*)，并把每一步骤的结果存入表中供后续步骤使用，完成这些步骤后*A*(*W*)即为最终结果，符合了动态规划思路，我们把这个思路转换为代码：\n\n```javascript\nvar backPack = function(m, A, V) {\n  var dp = new Array(m + 1).fill(0) // 动态规划数组，初始化值为0，即没有任何物品，价值为0\n  // 外层循环物品\n  for (var i = 0; i < A.length; i++) {\n    // 内层循环背包，倒序避免重复\n    for (var j = m; j >= 0; j--) {\n      if (j - A[i] >= 0) {\n        // dp[j]表示公式里面的A(Y),V[i]表示pj,A[i]表示wj\n        dp[j] = Math.max(dp[j], dp[j - A[i]] + V[i])\n      }\n    }\n  }\n  return dp[m] // 达到背包容量时，即最大价值\n}\n```\n\n这样，就得到了答案，这个问题中，每个物品只能被使用一次，即不能重复使用，对于可以重复使用的物品，我们称之为完全背包问题。\n\n### 完全背包\n\n**描述**\n\n给定若干种物品, 每种物品都有无限个. 第 `i` 个物品的体积为 `A[i]`, 价值为 `V[i]`.\n\n再给定一个容量为 `m` 的背包. 问可以装入背包的最大价值是多少?\n\n**样例**\n\n**样例 1:**\n\n```\n输入: A = [2, 3, 5, 7], V = [1, 5, 2, 4], m = 10\n输出: 15\n解释: 装入三个物品 1 (A[1] = 3, V[1] = 5), 总价值 15.\n```\n\n**样例 2:**\n\n```\n输入: A = [1, 2, 3], V = [1, 2, 3], m = 5\n输出: 5\n解释: 策略不唯一. 比如, 装入五个物品 0 (A[0] = 1, V[0] = 1).\n```\n\n**解法**\n\n我们直接给出代码：\n\n```javascript\nvar backPack = function(m, A, V) {\n  var dp = new Array(m + 1).fill(0) // 动态规划数组，初始化值为0，即没有任何物品，价值为0\n  // 外层循环背包\n  for (var i = 0; i <= m; i++) {\n    // 内层循环物品\n    for (var j = 0; j < A.length; j++) {\n      if (i - A[j] >= 0) {\n        dp[i] = Math.max(dp[i], dp[i - A[j]] + V[j])\n      }\n    }\n  }\n  return dp[m] // 达到背包容量时，即最大价值\n}\n```\n\n和上面非完全背包区别是，由于物品可以无限次使用，我们把物品循环放在了内部，外层循环背包。\n\n## 背包问题模板\n\n\n\n### 万能模板\n\n上面的解法，采用了数学公式的思路，推断出动态规划的递推公式，这显然很复杂，但是看最终的代码实现，我们发现这类背包问题一般是如下步骤：\n\n* 首先定义一个DP数组，保存每一步递推的值。\n* 两层循环，外层物品或内层背包。\n* 判断临界条件，应用递推公式计算。\n* 通过DP数组，得出最终结果。\n\n结合上面的步骤，以及完全背包和非完全背包的区别，我们可以得到解决背包问题或者类似背包问题的通用模板万能公式，如下：\n\n```\ntarget：背包\nnums：物品\nvar dp = new Array(target + 1).fill(0);\ndp[0] = 1;// 根据实际情况是否设置初始值\nfor(var i = 1; i <= target; i++){\n  for(var j = 0; j < nums.length; j++){\n    ...公式\n  }\n}\n```\n\n* 非完全背包：每个物品只能用一次（内层循环倒序）。\n* 完全背包：每个物品可以重复使用（内层循环正序）。\n\n* 非完全背包：\n  * 外层for循环遍历物品，内层for遍历背包。\n* 完全背包：\n  * 如果求组合数（不考虑结果元素的顺序）就是外层for循环遍历物品，内层for遍历背包。\n  * 如果求排列数（考虑顺序）就是外层for遍历背包，内层for循环遍历物品。\n\n### 真题套用\n\n结合leetcode上的原题，我们可以把背包问题大致分为以下几类：\n\n* 1、组合问题：\n\n  [494.目标和](https://leetcode-cn.com/problems/target-sum/)\n\n  [518.零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)\n\n  组合问题公式：`dp[i] += dp[i-num]`\n\n* 2、排列问题\n\n  [377.组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv)\n\n  排列问题公式：`dp[i] += dp[i-num]`\n\n* 3、True、False问题：\n\n  [139.单词拆分（组合）](https://leetcode-cn.com/problems/word-break)\n\n  [416.分割等和子集（组合）](https://leetcode-cn.com/problems/partition-equal-subset-sum)\n\n  True、False问题公式：`dp[i] = dp[i] or dp[i-num]`\n\n* 4、最大最小问题：\n\n  [474.一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)\n\n  [322.零钱兑换（组合）](https://leetcode-cn.com/problems/coin-change)\n\n  [279.完全平方数](https://leetcode-cn.com/problems/perfect-squares)\n\n  最大最小问题公式：`dp[i] = min(dp[i], dp[i-num]+1)或者dp[i] = max(dp[i], dp[i-num]+1)`\n\n下面，结合几个典型真题例子，来看看如何套用公式。\n\n**322.零钱兑换：**\n\n给定不同面额的硬币 `coins` 和一个总金额 `amount`。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 `-1`。\n\n你可以认为每种硬币的数量是无限的。\n\n**示例 1：**\n\n```\n输入：coins = [1, 2, 5], amount = 11\n输出：3 \n解释：11 = 5 + 5 + 1\n```\n\n**示例 2：**\n\n```\n输入：coins = [2], amount = 3\n输出：-1\n```\n\n**示例 3：**\n\n```\n输入：coins = [1], amount = 0\n输出：0\n```\n\n**示例 4：**\n\n```\n输入：coins = [1], amount = 1\n输出：1\n```\n\n**示例 5：**\n\n```\n输入：coins = [1], amount = 2\n输出：2\n```\n\n**解法**\n\n金额可以抽象为背包，硬币可以抽象为物品，这就转换成了一个背包问题，题目中描述硬币数量无限使用，那么就是一个完全背包问题，那么就可以套用模板：\n\n* 只求数量，不考虑顺序，符合组合数，外层for物品，内层for背包。\n* 最小值问题，使用最小值公式。\n* 完全背包问题，内层循环正序。\n\n得到代码如下所示：\n\n```javascript\nvar coinChange = function(coins, amount) {\n  var dp = new Array(amount + 1).fill(Number.MAX_SAFE_INTEGER) dp[0] = 0\n  for (var i = 0; i < coins.length; i++) {\n    for (var j = 0; j <= amount; j++) {\n      if (j >= coins[i]) {\n        dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1) // 最小值问题公式\n      }\n    }\n  }\n  return dp[amount] == Number.MAX_SAFE_INTEGER ? -1 : dp[amount]\n};\n```\n\n**518.零钱兑换II：**\n\n给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。\n\n请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。\n\n假设每一种面额的硬币有无限个。 \n\n**示例 1：**\n\n```\n输入：amount = 5, coins = [1, 2, 5]\n输出：4\n解释：有四种方式可以凑成总金额：\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\n```\n\n**示例 2：**\n\n```\n输入：amount = 3, coins = [2]\n输出：0\n解释：只用面额 2 的硬币不能凑成总金额 3 。\n```\n\n**示例 3：**\n\n```\n输入：amount = 10, coins = [10] \n输出：1\n```\n\n**解法**\n\n金额可以抽象为背包，硬币可以抽象为物品，这就转换成了一个背包问题，题目中描述硬币数量无限使用，那么就是一个完全背包问题，那么就可以套用模板：\n\n* 只求数量，不考虑顺序，符合组合数，外层for物品，内层for背包。\n* 组合问题，使用组合公式。\n* 完全背包问题，内层循环正序。\n\n得到代码如下所示：\n\n```javascript\nvar change = function(amount, coins) {\n  var dp = new Array(amount + 1).fill(0)\n  // 总数为0时，只有一种方案兑换 就是所有硬币都不选择\n  dp[0] = 1\n  for (var i = 0; i < coins.length; i++) {\n    for (var j = 0; j <= amount; j++) {\n      if (j - coins[i] >= 0) {\n        dp[j] = dp[j] + dp[j - coins[i]] // 组合问题公式\n      }\n    }\n  }\n  return dp[amount]\n};\n```\n\n**139.单词拆分：**\n\n给定一个**非空**字符串 *s* 和一个包含**非空**单词的列表 *wordDict*，判定 *s* 是否可以被空格拆分为一个或多个在字典中出现的单词。\n\n**说明：**\n\n- 拆分时可以重复使用字典中的单词。\n- 你可以假设字典中没有重复的单词。\n\n**示例 1：**\n\n```\n输入: s = \"leetcode\", wordDict = [\"leet\", \"code\"]\n输出: true\n解释: 返回 true 因为 \"leetcode\" 可以被拆分成 \"leet code\"。\n```\n\n**示例 2：**\n\n```\n输入: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\n输出: true\n解释: 返回 true 因为 \"applepenapple\" 可以被拆分成 \"apple pen apple\"。\n     注意你可以重复使用字典中的单词。\n```\n\n**示例 3：**\n\n```\n输入: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\n输出: false\n```\n\n**解法**\n\n字符串`s`可以抽象为背包，单词列表`wordDict`可以抽象为物品，这就转换成了一个背包问题，题目中描述可以使用重复的单词，那么就是一个完全背包问题，那么就可以套用模板：\n\n* 单词顺序影响结果，符合排列数，外层for背包，内层for物品。\n* True，False问题，使用True，False公式。\n* 完全背包问题，内层循环正序。\n\n得到代码如下所示：\n\n```javascript\nvar wordBreak = function(s, wordDict) {\n  var dp = new Array(s.length + 1).fill(false)\n  // dp[i] 表示以 i 结尾的字符串是否可以被 wordDict 中组合而成\n  dp[0] = true // 空字符可以不从wordDict中选择，也能组成\n  for (var i = 1; i <= s.length; i++) {\n    for (var j = 0; j < wordDict.length; j++) {\n      var s1 = wordDict[j] // s1表示当前的字符串\n      // temp表示字符串s中截取s1长度的临时串\n      var temp = s.substr(i - s1.length, s1.length)\n      // 临时串和当前s1相等时，可匹配\n      if (temp == s1) {\n        dp[i] = dp[i] || dp[i - s1.length]\n      }\n    }\n  }\n  return dp[s.length]\n}\n```\n\n其他相关的公式，也都可以套用，这里就不在赘述。掌握了背包问题公式，大部分的问题都可以迎刃而解了！\n\n\n\n\n\n\n\n","source":"_posts/前端算法--背包问题.md","raw":"---\ntitle: 前端算法--背包问题\ndate: 2021-08-26 17:26:17\ntags:\n- 算法\n- 背包问题\ncategories:\n- 12095\n\n---\n\n## 背包问题\n\n背包问题是一类经典的算法问题，属于动态规划解法范畴，其核心是在一个范围内择出最优解。\n\n一般描述为：给定一组物品和一个背包，每种物品都有自己的重量和价格，在背包限定的总重量内，我们如何选择，才能使得物品的总价格最高。\n<!--more-->\n### 非完全背包\n\n如下面的背包基础问题：\n\n**描述**\n\n有若干个物品和一个大小为 `m` 的背包. 给定数组 `A` 表示每个物品的大小和数组 `V` 表示每个物品的价值。\n\n问最多能装入背包的总价值是多大?\n\n样例\n\n**样例 1：**\n\n输入：\n\n```\nm = 10\nA = [2, 3, 5, 7]\nV = [1, 5, 2, 4]\n```\n\n输出：\n\n```\n9\n```\n\n解释：\n\n装入 A[1] 和 A[3] 可以得到最大价值, V[1] + V[3] = 9\n\n**样例 2：**\n\n输入：\n\n```\nm = 10\nA = [2, 3, 8]\nV = [2, 5, 8]\n```\n\n输出：\n\n```\n10\n```\n\n解释：\n\n装入 A[0] 和 A[2] 可以得到最大价值, V[0] + V[2] = 10\n\n**解法**\n\n我们有*n*种物品，物品*j*的重量为*wj*，价格为*pj*。\n\n我们假定所有物品的重量和价格都是非负的。背包所能承受的最大重量为*W*。\n\n针对每个物品x，我们可以选择0个或者1个（用或者不用），转换成具体公式：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ec32f8358eb4d818026c118d6d07c4d~tplv-k3u1fbpfcp-watermark.image?)\n\n在总重量不超过*W*的前提下，我们希望总价格最高。对于*Y* ≤ *W*，我们将在总重量不超过*Y*的前提下，总价格所能达到的最高值定义为*A*(*Y*)。*A*(*W*)即为问题的答案。\n\n显然，*A*(*Y*)满足：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a73d746d304c40db91c6aa8bb2a36bd4~tplv-k3u1fbpfcp-watermark.image?)\n\n其中，*pj*为第*j*种物品的价格。\n\n* 对于第一种情况，如果总重量为0，总价值也为0。\n* 对于第二种情况，总重量为*Y*时背包的最高价值可能有两种情况，第一种是该重量无法被完全填满，这对应于表达式*A*(*Y - 1*)。第二种是刚好填满，这对应于一个包含一系列刚好填满的可能性的集合，其中的可能性是指当最后放进包中的物品恰好是重量为*wj*的物品时背包填满并达到最高价值。而这时的背包价值等于重量为*wj*物品的价值*pj*和当没有放入该物品时背包的最高价值之和。故归纳为表达式*pj* + *A*(*Y* - *wj*)。最后把所有上述情况中背包价值的最大值求出就得到了*A*(*Y*)的值。\n\n所以这里就存在了递推关系，依次计算*A*(0), *A*(1), ..., *A*(*W*)，并把每一步骤的结果存入表中供后续步骤使用，完成这些步骤后*A*(*W*)即为最终结果，符合了动态规划思路，我们把这个思路转换为代码：\n\n```javascript\nvar backPack = function(m, A, V) {\n  var dp = new Array(m + 1).fill(0) // 动态规划数组，初始化值为0，即没有任何物品，价值为0\n  // 外层循环物品\n  for (var i = 0; i < A.length; i++) {\n    // 内层循环背包，倒序避免重复\n    for (var j = m; j >= 0; j--) {\n      if (j - A[i] >= 0) {\n        // dp[j]表示公式里面的A(Y),V[i]表示pj,A[i]表示wj\n        dp[j] = Math.max(dp[j], dp[j - A[i]] + V[i])\n      }\n    }\n  }\n  return dp[m] // 达到背包容量时，即最大价值\n}\n```\n\n这样，就得到了答案，这个问题中，每个物品只能被使用一次，即不能重复使用，对于可以重复使用的物品，我们称之为完全背包问题。\n\n### 完全背包\n\n**描述**\n\n给定若干种物品, 每种物品都有无限个. 第 `i` 个物品的体积为 `A[i]`, 价值为 `V[i]`.\n\n再给定一个容量为 `m` 的背包. 问可以装入背包的最大价值是多少?\n\n**样例**\n\n**样例 1:**\n\n```\n输入: A = [2, 3, 5, 7], V = [1, 5, 2, 4], m = 10\n输出: 15\n解释: 装入三个物品 1 (A[1] = 3, V[1] = 5), 总价值 15.\n```\n\n**样例 2:**\n\n```\n输入: A = [1, 2, 3], V = [1, 2, 3], m = 5\n输出: 5\n解释: 策略不唯一. 比如, 装入五个物品 0 (A[0] = 1, V[0] = 1).\n```\n\n**解法**\n\n我们直接给出代码：\n\n```javascript\nvar backPack = function(m, A, V) {\n  var dp = new Array(m + 1).fill(0) // 动态规划数组，初始化值为0，即没有任何物品，价值为0\n  // 外层循环背包\n  for (var i = 0; i <= m; i++) {\n    // 内层循环物品\n    for (var j = 0; j < A.length; j++) {\n      if (i - A[j] >= 0) {\n        dp[i] = Math.max(dp[i], dp[i - A[j]] + V[j])\n      }\n    }\n  }\n  return dp[m] // 达到背包容量时，即最大价值\n}\n```\n\n和上面非完全背包区别是，由于物品可以无限次使用，我们把物品循环放在了内部，外层循环背包。\n\n## 背包问题模板\n\n\n\n### 万能模板\n\n上面的解法，采用了数学公式的思路，推断出动态规划的递推公式，这显然很复杂，但是看最终的代码实现，我们发现这类背包问题一般是如下步骤：\n\n* 首先定义一个DP数组，保存每一步递推的值。\n* 两层循环，外层物品或内层背包。\n* 判断临界条件，应用递推公式计算。\n* 通过DP数组，得出最终结果。\n\n结合上面的步骤，以及完全背包和非完全背包的区别，我们可以得到解决背包问题或者类似背包问题的通用模板万能公式，如下：\n\n```\ntarget：背包\nnums：物品\nvar dp = new Array(target + 1).fill(0);\ndp[0] = 1;// 根据实际情况是否设置初始值\nfor(var i = 1; i <= target; i++){\n  for(var j = 0; j < nums.length; j++){\n    ...公式\n  }\n}\n```\n\n* 非完全背包：每个物品只能用一次（内层循环倒序）。\n* 完全背包：每个物品可以重复使用（内层循环正序）。\n\n* 非完全背包：\n  * 外层for循环遍历物品，内层for遍历背包。\n* 完全背包：\n  * 如果求组合数（不考虑结果元素的顺序）就是外层for循环遍历物品，内层for遍历背包。\n  * 如果求排列数（考虑顺序）就是外层for遍历背包，内层for循环遍历物品。\n\n### 真题套用\n\n结合leetcode上的原题，我们可以把背包问题大致分为以下几类：\n\n* 1、组合问题：\n\n  [494.目标和](https://leetcode-cn.com/problems/target-sum/)\n\n  [518.零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)\n\n  组合问题公式：`dp[i] += dp[i-num]`\n\n* 2、排列问题\n\n  [377.组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv)\n\n  排列问题公式：`dp[i] += dp[i-num]`\n\n* 3、True、False问题：\n\n  [139.单词拆分（组合）](https://leetcode-cn.com/problems/word-break)\n\n  [416.分割等和子集（组合）](https://leetcode-cn.com/problems/partition-equal-subset-sum)\n\n  True、False问题公式：`dp[i] = dp[i] or dp[i-num]`\n\n* 4、最大最小问题：\n\n  [474.一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)\n\n  [322.零钱兑换（组合）](https://leetcode-cn.com/problems/coin-change)\n\n  [279.完全平方数](https://leetcode-cn.com/problems/perfect-squares)\n\n  最大最小问题公式：`dp[i] = min(dp[i], dp[i-num]+1)或者dp[i] = max(dp[i], dp[i-num]+1)`\n\n下面，结合几个典型真题例子，来看看如何套用公式。\n\n**322.零钱兑换：**\n\n给定不同面额的硬币 `coins` 和一个总金额 `amount`。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 `-1`。\n\n你可以认为每种硬币的数量是无限的。\n\n**示例 1：**\n\n```\n输入：coins = [1, 2, 5], amount = 11\n输出：3 \n解释：11 = 5 + 5 + 1\n```\n\n**示例 2：**\n\n```\n输入：coins = [2], amount = 3\n输出：-1\n```\n\n**示例 3：**\n\n```\n输入：coins = [1], amount = 0\n输出：0\n```\n\n**示例 4：**\n\n```\n输入：coins = [1], amount = 1\n输出：1\n```\n\n**示例 5：**\n\n```\n输入：coins = [1], amount = 2\n输出：2\n```\n\n**解法**\n\n金额可以抽象为背包，硬币可以抽象为物品，这就转换成了一个背包问题，题目中描述硬币数量无限使用，那么就是一个完全背包问题，那么就可以套用模板：\n\n* 只求数量，不考虑顺序，符合组合数，外层for物品，内层for背包。\n* 最小值问题，使用最小值公式。\n* 完全背包问题，内层循环正序。\n\n得到代码如下所示：\n\n```javascript\nvar coinChange = function(coins, amount) {\n  var dp = new Array(amount + 1).fill(Number.MAX_SAFE_INTEGER) dp[0] = 0\n  for (var i = 0; i < coins.length; i++) {\n    for (var j = 0; j <= amount; j++) {\n      if (j >= coins[i]) {\n        dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1) // 最小值问题公式\n      }\n    }\n  }\n  return dp[amount] == Number.MAX_SAFE_INTEGER ? -1 : dp[amount]\n};\n```\n\n**518.零钱兑换II：**\n\n给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。\n\n请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。\n\n假设每一种面额的硬币有无限个。 \n\n**示例 1：**\n\n```\n输入：amount = 5, coins = [1, 2, 5]\n输出：4\n解释：有四种方式可以凑成总金额：\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\n```\n\n**示例 2：**\n\n```\n输入：amount = 3, coins = [2]\n输出：0\n解释：只用面额 2 的硬币不能凑成总金额 3 。\n```\n\n**示例 3：**\n\n```\n输入：amount = 10, coins = [10] \n输出：1\n```\n\n**解法**\n\n金额可以抽象为背包，硬币可以抽象为物品，这就转换成了一个背包问题，题目中描述硬币数量无限使用，那么就是一个完全背包问题，那么就可以套用模板：\n\n* 只求数量，不考虑顺序，符合组合数，外层for物品，内层for背包。\n* 组合问题，使用组合公式。\n* 完全背包问题，内层循环正序。\n\n得到代码如下所示：\n\n```javascript\nvar change = function(amount, coins) {\n  var dp = new Array(amount + 1).fill(0)\n  // 总数为0时，只有一种方案兑换 就是所有硬币都不选择\n  dp[0] = 1\n  for (var i = 0; i < coins.length; i++) {\n    for (var j = 0; j <= amount; j++) {\n      if (j - coins[i] >= 0) {\n        dp[j] = dp[j] + dp[j - coins[i]] // 组合问题公式\n      }\n    }\n  }\n  return dp[amount]\n};\n```\n\n**139.单词拆分：**\n\n给定一个**非空**字符串 *s* 和一个包含**非空**单词的列表 *wordDict*，判定 *s* 是否可以被空格拆分为一个或多个在字典中出现的单词。\n\n**说明：**\n\n- 拆分时可以重复使用字典中的单词。\n- 你可以假设字典中没有重复的单词。\n\n**示例 1：**\n\n```\n输入: s = \"leetcode\", wordDict = [\"leet\", \"code\"]\n输出: true\n解释: 返回 true 因为 \"leetcode\" 可以被拆分成 \"leet code\"。\n```\n\n**示例 2：**\n\n```\n输入: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\n输出: true\n解释: 返回 true 因为 \"applepenapple\" 可以被拆分成 \"apple pen apple\"。\n     注意你可以重复使用字典中的单词。\n```\n\n**示例 3：**\n\n```\n输入: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\n输出: false\n```\n\n**解法**\n\n字符串`s`可以抽象为背包，单词列表`wordDict`可以抽象为物品，这就转换成了一个背包问题，题目中描述可以使用重复的单词，那么就是一个完全背包问题，那么就可以套用模板：\n\n* 单词顺序影响结果，符合排列数，外层for背包，内层for物品。\n* True，False问题，使用True，False公式。\n* 完全背包问题，内层循环正序。\n\n得到代码如下所示：\n\n```javascript\nvar wordBreak = function(s, wordDict) {\n  var dp = new Array(s.length + 1).fill(false)\n  // dp[i] 表示以 i 结尾的字符串是否可以被 wordDict 中组合而成\n  dp[0] = true // 空字符可以不从wordDict中选择，也能组成\n  for (var i = 1; i <= s.length; i++) {\n    for (var j = 0; j < wordDict.length; j++) {\n      var s1 = wordDict[j] // s1表示当前的字符串\n      // temp表示字符串s中截取s1长度的临时串\n      var temp = s.substr(i - s1.length, s1.length)\n      // 临时串和当前s1相等时，可匹配\n      if (temp == s1) {\n        dp[i] = dp[i] || dp[i - s1.length]\n      }\n    }\n  }\n  return dp[s.length]\n}\n```\n\n其他相关的公式，也都可以套用，这里就不在赘述。掌握了背包问题公式，大部分的问题都可以迎刃而解了！\n\n\n\n\n\n\n\n","slug":"前端算法--背包问题","published":1,"updated":"2021-12-10T16:12:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434q11002u2wvjo86cuif1","content":"<h2><span id=\"背包问题\">背包问题</span></h2><p>背包问题是一类经典的算法问题，属于动态规划解法范畴，其核心是在一个范围内择出最优解。</p>\n<p>一般描述为：给定一组物品和一个背包，每种物品都有自己的重量和价格，在背包限定的总重量内，我们如何选择，才能使得物品的总价格最高。<br><a id=\"more\"></a></p>\n<h3><span id=\"非完全背包\">非完全背包</span></h3><p>如下面的背包基础问题：</p>\n<p><strong>描述</strong></p>\n<p>有若干个物品和一个大小为 <code>m</code> 的背包. 给定数组 <code>A</code> 表示每个物品的大小和数组 <code>V</code> 表示每个物品的价值。</p>\n<p>问最多能装入背包的总价值是多大?</p>\n<p>样例</p>\n<p><strong>样例 1：</strong></p>\n<p>输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m = 10</span><br><span class=\"line\">A = [2, 3, 5, 7]</span><br><span class=\"line\">V = [1, 5, 2, 4]</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">9</span><br></pre></td></tr></table></figure>\n<p>解释：</p>\n<p>装入 A[1] 和 A[3] 可以得到最大价值, V[1] + V[3] = 9</p>\n<p><strong>样例 2：</strong></p>\n<p>输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m = 10</span><br><span class=\"line\">A = [2, 3, 8]</span><br><span class=\"line\">V = [2, 5, 8]</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n<p>解释：</p>\n<p>装入 A[0] 和 A[2] 可以得到最大价值, V[0] + V[2] = 10</p>\n<p><strong>解法</strong></p>\n<p>我们有<em>n</em>种物品，物品<em>j</em>的重量为<em>wj</em>，价格为<em>pj</em>。</p>\n<p>我们假定所有物品的重量和价格都是非负的。背包所能承受的最大重量为<em>W</em>。</p>\n<p>针对每个物品x，我们可以选择0个或者1个（用或者不用），转换成具体公式：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ec32f8358eb4d818026c118d6d07c4d~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>在总重量不超过<em>W</em>的前提下，我们希望总价格最高。对于<em>Y</em> ≤ <em>W</em>，我们将在总重量不超过<em>Y</em>的前提下，总价格所能达到的最高值定义为<em>A</em>(<em>Y</em>)。<em>A</em>(<em>W</em>)即为问题的答案。</p>\n<p>显然，<em>A</em>(<em>Y</em>)满足：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a73d746d304c40db91c6aa8bb2a36bd4~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>其中，<em>pj</em>为第<em>j</em>种物品的价格。</p>\n<ul>\n<li>对于第一种情况，如果总重量为0，总价值也为0。</li>\n<li>对于第二种情况，总重量为<em>Y</em>时背包的最高价值可能有两种情况，第一种是该重量无法被完全填满，这对应于表达式<em>A</em>(<em>Y - 1</em>)。第二种是刚好填满，这对应于一个包含一系列刚好填满的可能性的集合，其中的可能性是指当最后放进包中的物品恰好是重量为<em>wj</em>的物品时背包填满并达到最高价值。而这时的背包价值等于重量为<em>wj</em>物品的价值<em>pj</em>和当没有放入该物品时背包的最高价值之和。故归纳为表达式<em>pj</em> + <em>A</em>(<em>Y</em> - <em>wj</em>)。最后把所有上述情况中背包价值的最大值求出就得到了<em>A</em>(<em>Y</em>)的值。</li>\n</ul>\n<p>所以这里就存在了递推关系，依次计算<em>A</em>(0), <em>A</em>(1), …, <em>A</em>(<em>W</em>)，并把每一步骤的结果存入表中供后续步骤使用，完成这些步骤后<em>A</em>(<em>W</em>)即为最终结果，符合了动态规划思路，我们把这个思路转换为代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> backPack = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m, A, V</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> dp = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(m + <span class=\"number\">1</span>).fill(<span class=\"number\">0</span>) <span class=\"comment\">// 动态规划数组，初始化值为0，即没有任何物品，价值为0</span></span><br><span class=\"line\">  <span class=\"comment\">// 外层循环物品</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; A.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 内层循环背包，倒序避免重复</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = m; j &gt;= <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (j - A[i] &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// dp[j]表示公式里面的A(Y),V[i]表示pj,A[i]表示wj</span></span><br><span class=\"line\">        dp[j] = <span class=\"built_in\">Math</span>.max(dp[j], dp[j - A[i]] + V[i])</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dp[m] <span class=\"comment\">// 达到背包容量时，即最大价值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，就得到了答案，这个问题中，每个物品只能被使用一次，即不能重复使用，对于可以重复使用的物品，我们称之为完全背包问题。</p>\n<h3><span id=\"完全背包\">完全背包</span></h3><p><strong>描述</strong></p>\n<p>给定若干种物品, 每种物品都有无限个. 第 <code>i</code> 个物品的体积为 <code>A[i]</code>, 价值为 <code>V[i]</code>.</p>\n<p>再给定一个容量为 <code>m</code> 的背包. 问可以装入背包的最大价值是多少?</p>\n<p><strong>样例</strong></p>\n<p><strong>样例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: A = [2, 3, 5, 7], V = [1, 5, 2, 4], m = 10</span><br><span class=\"line\">输出: 15</span><br><span class=\"line\">解释: 装入三个物品 1 (A[1] = 3, V[1] = 5), 总价值 15.</span><br></pre></td></tr></table></figure>\n<p><strong>样例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: A = [1, 2, 3], V = [1, 2, 3], m = 5</span><br><span class=\"line\">输出: 5</span><br><span class=\"line\">解释: 策略不唯一. 比如, 装入五个物品 0 (A[0] = 1, V[0] = 1).</span><br></pre></td></tr></table></figure>\n<p><strong>解法</strong></p>\n<p>我们直接给出代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> backPack = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m, A, V</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> dp = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(m + <span class=\"number\">1</span>).fill(<span class=\"number\">0</span>) <span class=\"comment\">// 动态规划数组，初始化值为0，即没有任何物品，价值为0</span></span><br><span class=\"line\">  <span class=\"comment\">// 外层循环背包</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 内层循环物品</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; A.length; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i - A[j] &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        dp[i] = <span class=\"built_in\">Math</span>.max(dp[i], dp[i - A[j]] + V[j])</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dp[m] <span class=\"comment\">// 达到背包容量时，即最大价值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和上面非完全背包区别是，由于物品可以无限次使用，我们把物品循环放在了内部，外层循环背包。</p>\n<h2><span id=\"背包问题模板\">背包问题模板</span></h2><h3><span id=\"万能模板\">万能模板</span></h3><p>上面的解法，采用了数学公式的思路，推断出动态规划的递推公式，这显然很复杂，但是看最终的代码实现，我们发现这类背包问题一般是如下步骤：</p>\n<ul>\n<li>首先定义一个DP数组，保存每一步递推的值。</li>\n<li>两层循环，外层物品或内层背包。</li>\n<li>判断临界条件，应用递推公式计算。</li>\n<li>通过DP数组，得出最终结果。</li>\n</ul>\n<p>结合上面的步骤，以及完全背包和非完全背包的区别，我们可以得到解决背包问题或者类似背包问题的通用模板万能公式，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target：背包</span><br><span class=\"line\">nums：物品</span><br><span class=\"line\">var dp = new Array(target + 1).fill(0);</span><br><span class=\"line\">dp[0] = 1;// 根据实际情况是否设置初始值</span><br><span class=\"line\">for(var i = 1; i &lt;= target; i++)&#123;</span><br><span class=\"line\">  for(var j = 0; j &lt; nums.length; j++)&#123;</span><br><span class=\"line\">    ...公式</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>非完全背包：每个物品只能用一次（内层循环倒序）。</li>\n<li><p>完全背包：每个物品可以重复使用（内层循环正序）。</p>\n</li>\n<li><p>非完全背包：</p>\n<ul>\n<li>外层for循环遍历物品，内层for遍历背包。</li>\n</ul>\n</li>\n<li>完全背包：<ul>\n<li>如果求组合数（不考虑结果元素的顺序）就是外层for循环遍历物品，内层for遍历背包。</li>\n<li>如果求排列数（考虑顺序）就是外层for遍历背包，内层for循环遍历物品。</li>\n</ul>\n</li>\n</ul>\n<h3><span id=\"真题套用\">真题套用</span></h3><p>结合leetcode上的原题，我们可以把背包问题大致分为以下几类：</p>\n<ul>\n<li><p>1、组合问题：</p>\n<p><a href=\"https://leetcode-cn.com/problems/target-sum/\" target=\"_blank\" rel=\"noopener\">494.目标和</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/coin-change-2/\" target=\"_blank\" rel=\"noopener\">518.零钱兑换 II</a></p>\n<p>组合问题公式：<code>dp[i] += dp[i-num]</code></p>\n</li>\n<li><p>2、排列问题</p>\n<p><a href=\"https://leetcode-cn.com/problems/combination-sum-iv\" target=\"_blank\" rel=\"noopener\">377.组合总和 Ⅳ</a></p>\n<p>排列问题公式：<code>dp[i] += dp[i-num]</code></p>\n</li>\n<li><p>3、True、False问题：</p>\n<p><a href=\"https://leetcode-cn.com/problems/word-break\" target=\"_blank\" rel=\"noopener\">139.单词拆分（组合）</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/partition-equal-subset-sum\" target=\"_blank\" rel=\"noopener\">416.分割等和子集（组合）</a></p>\n<p>True、False问题公式：<code>dp[i] = dp[i] or dp[i-num]</code></p>\n</li>\n<li><p>4、最大最小问题：</p>\n<p><a href=\"https://leetcode-cn.com/problems/ones-and-zeroes/\" target=\"_blank\" rel=\"noopener\">474.一和零</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/coin-change\" target=\"_blank\" rel=\"noopener\">322.零钱兑换（组合）</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/perfect-squares\" target=\"_blank\" rel=\"noopener\">279.完全平方数</a></p>\n<p>最大最小问题公式：<code>dp[i] = min(dp[i], dp[i-num]+1)或者dp[i] = max(dp[i], dp[i-num]+1)</code></p>\n</li>\n</ul>\n<p>下面，结合几个典型真题例子，来看看如何套用公式。</p>\n<p><strong>322.零钱兑换：</strong></p>\n<p>给定不同面额的硬币 <code>coins</code> 和一个总金额 <code>amount</code>。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。</p>\n<p>你可以认为每种硬币的数量是无限的。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：coins = [1, 2, 5], amount = 11</span><br><span class=\"line\">输出：3 </span><br><span class=\"line\">解释：11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：coins = [2], amount = 3</span><br><span class=\"line\">输出：-1</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：coins = [1], amount = 0</span><br><span class=\"line\">输出：0</span><br></pre></td></tr></table></figure>\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：coins = [1], amount = 1</span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure>\n<p><strong>示例 5：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：coins = [1], amount = 2</span><br><span class=\"line\">输出：2</span><br></pre></td></tr></table></figure>\n<p><strong>解法</strong></p>\n<p>金额可以抽象为背包，硬币可以抽象为物品，这就转换成了一个背包问题，题目中描述硬币数量无限使用，那么就是一个完全背包问题，那么就可以套用模板：</p>\n<ul>\n<li>只求数量，不考虑顺序，符合组合数，外层for物品，内层for背包。</li>\n<li>最小值问题，使用最小值公式。</li>\n<li>完全背包问题，内层循环正序。</li>\n</ul>\n<p>得到代码如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> coinChange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">coins, amount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> dp = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(amount + <span class=\"number\">1</span>).fill(<span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER) dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt;= amount; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (j &gt;= coins[i]) &#123;</span><br><span class=\"line\">        dp[j] = <span class=\"built_in\">Math</span>.min(dp[j], dp[j - coins[i]] + <span class=\"number\">1</span>) <span class=\"comment\">// 最小值问题公式</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dp[amount] == <span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER ? <span class=\"number\">-1</span> : dp[amount]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>518.零钱兑换II：</strong></p>\n<p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p>\n<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p>\n<p>假设每一种面额的硬币有无限个。 </p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：amount = 5, coins = [1, 2, 5]</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：有四种方式可以凑成总金额：</span><br><span class=\"line\">5=5</span><br><span class=\"line\">5=2+2+1</span><br><span class=\"line\">5=2+1+1+1</span><br><span class=\"line\">5=1+1+1+1+1</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：amount = 3, coins = [2]</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：只用面额 2 的硬币不能凑成总金额 3 。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：amount = 10, coins = [10] </span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure>\n<p><strong>解法</strong></p>\n<p>金额可以抽象为背包，硬币可以抽象为物品，这就转换成了一个背包问题，题目中描述硬币数量无限使用，那么就是一个完全背包问题，那么就可以套用模板：</p>\n<ul>\n<li>只求数量，不考虑顺序，符合组合数，外层for物品，内层for背包。</li>\n<li>组合问题，使用组合公式。</li>\n<li>完全背包问题，内层循环正序。</li>\n</ul>\n<p>得到代码如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> change = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">amount, coins</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> dp = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(amount + <span class=\"number\">1</span>).fill(<span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 总数为0时，只有一种方案兑换 就是所有硬币都不选择</span></span><br><span class=\"line\">  dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt;= amount; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (j - coins[i] &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        dp[j] = dp[j] + dp[j - coins[i]] <span class=\"comment\">// 组合问题公式</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dp[amount]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>139.单词拆分：</strong></p>\n<p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词的列表 <em>wordDict</em>，判定 <em>s</em> 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>\n<p><strong>说明：</strong></p>\n<ul>\n<li>拆分时可以重复使用字典中的单词。</li>\n<li>你可以假设字典中没有重复的单词。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class=\"line\">输出: true</span><br><span class=\"line\">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class=\"line\">输出: true</span><br><span class=\"line\">解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。</span><br><span class=\"line\">     注意你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class=\"line\">输出: false</span><br></pre></td></tr></table></figure>\n<p><strong>解法</strong></p>\n<p>字符串<code>s</code>可以抽象为背包，单词列表<code>wordDict</code>可以抽象为物品，这就转换成了一个背包问题，题目中描述可以使用重复的单词，那么就是一个完全背包问题，那么就可以套用模板：</p>\n<ul>\n<li>单词顺序影响结果，符合排列数，外层for背包，内层for物品。</li>\n<li>True，False问题，使用True，False公式。</li>\n<li>完全背包问题，内层循环正序。</li>\n</ul>\n<p>得到代码如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> wordBreak = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s, wordDict</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> dp = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(s.length + <span class=\"number\">1</span>).fill(<span class=\"literal\">false</span>)</span><br><span class=\"line\">  <span class=\"comment\">// dp[i] 表示以 i 结尾的字符串是否可以被 wordDict 中组合而成</span></span><br><span class=\"line\">  dp[<span class=\"number\">0</span>] = <span class=\"literal\">true</span> <span class=\"comment\">// 空字符可以不从wordDict中选择，也能组成</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= s.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; wordDict.length; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> s1 = wordDict[j] <span class=\"comment\">// s1表示当前的字符串</span></span><br><span class=\"line\">      <span class=\"comment\">// temp表示字符串s中截取s1长度的临时串</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> temp = s.substr(i - s1.length, s1.length)</span><br><span class=\"line\">      <span class=\"comment\">// 临时串和当前s1相等时，可匹配</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (temp == s1) &#123;</span><br><span class=\"line\">        dp[i] = dp[i] || dp[i - s1.length]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dp[s.length]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其他相关的公式，也都可以套用，这里就不在赘述。掌握了背包问题公式，大部分的问题都可以迎刃而解了！</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"背包问题\"><a href=\"#背包问题\" class=\"headerlink\" title=\"背包问题\"></a>背包问题</h2><p>背包问题是一类经典的算法问题，属于动态规划解法范畴，其核心是在一个范围内择出最优解。</p>\n<p>一般描述为：给定一组物品和一个背包，每种物品都有自己的重量和价格，在背包限定的总重量内，我们如何选择，才能使得物品的总价格最高。<br>","more":"</p>\n<h3 id=\"非完全背包\"><a href=\"#非完全背包\" class=\"headerlink\" title=\"非完全背包\"></a>非完全背包</h3><p>如下面的背包基础问题：</p>\n<p><strong>描述</strong></p>\n<p>有若干个物品和一个大小为 <code>m</code> 的背包. 给定数组 <code>A</code> 表示每个物品的大小和数组 <code>V</code> 表示每个物品的价值。</p>\n<p>问最多能装入背包的总价值是多大?</p>\n<p>样例</p>\n<p><strong>样例 1：</strong></p>\n<p>输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m = 10</span><br><span class=\"line\">A = [2, 3, 5, 7]</span><br><span class=\"line\">V = [1, 5, 2, 4]</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">9</span><br></pre></td></tr></table></figure>\n<p>解释：</p>\n<p>装入 A[1] 和 A[3] 可以得到最大价值, V[1] + V[3] = 9</p>\n<p><strong>样例 2：</strong></p>\n<p>输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m = 10</span><br><span class=\"line\">A = [2, 3, 8]</span><br><span class=\"line\">V = [2, 5, 8]</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n<p>解释：</p>\n<p>装入 A[0] 和 A[2] 可以得到最大价值, V[0] + V[2] = 10</p>\n<p><strong>解法</strong></p>\n<p>我们有<em>n</em>种物品，物品<em>j</em>的重量为<em>wj</em>，价格为<em>pj</em>。</p>\n<p>我们假定所有物品的重量和价格都是非负的。背包所能承受的最大重量为<em>W</em>。</p>\n<p>针对每个物品x，我们可以选择0个或者1个（用或者不用），转换成具体公式：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ec32f8358eb4d818026c118d6d07c4d~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>在总重量不超过<em>W</em>的前提下，我们希望总价格最高。对于<em>Y</em> ≤ <em>W</em>，我们将在总重量不超过<em>Y</em>的前提下，总价格所能达到的最高值定义为<em>A</em>(<em>Y</em>)。<em>A</em>(<em>W</em>)即为问题的答案。</p>\n<p>显然，<em>A</em>(<em>Y</em>)满足：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a73d746d304c40db91c6aa8bb2a36bd4~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>其中，<em>pj</em>为第<em>j</em>种物品的价格。</p>\n<ul>\n<li>对于第一种情况，如果总重量为0，总价值也为0。</li>\n<li>对于第二种情况，总重量为<em>Y</em>时背包的最高价值可能有两种情况，第一种是该重量无法被完全填满，这对应于表达式<em>A</em>(<em>Y - 1</em>)。第二种是刚好填满，这对应于一个包含一系列刚好填满的可能性的集合，其中的可能性是指当最后放进包中的物品恰好是重量为<em>wj</em>的物品时背包填满并达到最高价值。而这时的背包价值等于重量为<em>wj</em>物品的价值<em>pj</em>和当没有放入该物品时背包的最高价值之和。故归纳为表达式<em>pj</em> + <em>A</em>(<em>Y</em> - <em>wj</em>)。最后把所有上述情况中背包价值的最大值求出就得到了<em>A</em>(<em>Y</em>)的值。</li>\n</ul>\n<p>所以这里就存在了递推关系，依次计算<em>A</em>(0), <em>A</em>(1), …, <em>A</em>(<em>W</em>)，并把每一步骤的结果存入表中供后续步骤使用，完成这些步骤后<em>A</em>(<em>W</em>)即为最终结果，符合了动态规划思路，我们把这个思路转换为代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> backPack = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m, A, V</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> dp = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(m + <span class=\"number\">1</span>).fill(<span class=\"number\">0</span>) <span class=\"comment\">// 动态规划数组，初始化值为0，即没有任何物品，价值为0</span></span><br><span class=\"line\">  <span class=\"comment\">// 外层循环物品</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; A.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 内层循环背包，倒序避免重复</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = m; j &gt;= <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (j - A[i] &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// dp[j]表示公式里面的A(Y),V[i]表示pj,A[i]表示wj</span></span><br><span class=\"line\">        dp[j] = <span class=\"built_in\">Math</span>.max(dp[j], dp[j - A[i]] + V[i])</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dp[m] <span class=\"comment\">// 达到背包容量时，即最大价值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，就得到了答案，这个问题中，每个物品只能被使用一次，即不能重复使用，对于可以重复使用的物品，我们称之为完全背包问题。</p>\n<h3 id=\"完全背包\"><a href=\"#完全背包\" class=\"headerlink\" title=\"完全背包\"></a>完全背包</h3><p><strong>描述</strong></p>\n<p>给定若干种物品, 每种物品都有无限个. 第 <code>i</code> 个物品的体积为 <code>A[i]</code>, 价值为 <code>V[i]</code>.</p>\n<p>再给定一个容量为 <code>m</code> 的背包. 问可以装入背包的最大价值是多少?</p>\n<p><strong>样例</strong></p>\n<p><strong>样例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: A = [2, 3, 5, 7], V = [1, 5, 2, 4], m = 10</span><br><span class=\"line\">输出: 15</span><br><span class=\"line\">解释: 装入三个物品 1 (A[1] = 3, V[1] = 5), 总价值 15.</span><br></pre></td></tr></table></figure>\n<p><strong>样例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: A = [1, 2, 3], V = [1, 2, 3], m = 5</span><br><span class=\"line\">输出: 5</span><br><span class=\"line\">解释: 策略不唯一. 比如, 装入五个物品 0 (A[0] = 1, V[0] = 1).</span><br></pre></td></tr></table></figure>\n<p><strong>解法</strong></p>\n<p>我们直接给出代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> backPack = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m, A, V</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> dp = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(m + <span class=\"number\">1</span>).fill(<span class=\"number\">0</span>) <span class=\"comment\">// 动态规划数组，初始化值为0，即没有任何物品，价值为0</span></span><br><span class=\"line\">  <span class=\"comment\">// 外层循环背包</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 内层循环物品</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; A.length; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i - A[j] &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        dp[i] = <span class=\"built_in\">Math</span>.max(dp[i], dp[i - A[j]] + V[j])</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dp[m] <span class=\"comment\">// 达到背包容量时，即最大价值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和上面非完全背包区别是，由于物品可以无限次使用，我们把物品循环放在了内部，外层循环背包。</p>\n<h2 id=\"背包问题模板\"><a href=\"#背包问题模板\" class=\"headerlink\" title=\"背包问题模板\"></a>背包问题模板</h2><h3 id=\"万能模板\"><a href=\"#万能模板\" class=\"headerlink\" title=\"万能模板\"></a>万能模板</h3><p>上面的解法，采用了数学公式的思路，推断出动态规划的递推公式，这显然很复杂，但是看最终的代码实现，我们发现这类背包问题一般是如下步骤：</p>\n<ul>\n<li>首先定义一个DP数组，保存每一步递推的值。</li>\n<li>两层循环，外层物品或内层背包。</li>\n<li>判断临界条件，应用递推公式计算。</li>\n<li>通过DP数组，得出最终结果。</li>\n</ul>\n<p>结合上面的步骤，以及完全背包和非完全背包的区别，我们可以得到解决背包问题或者类似背包问题的通用模板万能公式，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target：背包</span><br><span class=\"line\">nums：物品</span><br><span class=\"line\">var dp = new Array(target + 1).fill(0);</span><br><span class=\"line\">dp[0] = 1;// 根据实际情况是否设置初始值</span><br><span class=\"line\">for(var i = 1; i &lt;= target; i++)&#123;</span><br><span class=\"line\">  for(var j = 0; j &lt; nums.length; j++)&#123;</span><br><span class=\"line\">    ...公式</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>非完全背包：每个物品只能用一次（内层循环倒序）。</li>\n<li><p>完全背包：每个物品可以重复使用（内层循环正序）。</p>\n</li>\n<li><p>非完全背包：</p>\n<ul>\n<li>外层for循环遍历物品，内层for遍历背包。</li>\n</ul>\n</li>\n<li>完全背包：<ul>\n<li>如果求组合数（不考虑结果元素的顺序）就是外层for循环遍历物品，内层for遍历背包。</li>\n<li>如果求排列数（考虑顺序）就是外层for遍历背包，内层for循环遍历物品。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"真题套用\"><a href=\"#真题套用\" class=\"headerlink\" title=\"真题套用\"></a>真题套用</h3><p>结合leetcode上的原题，我们可以把背包问题大致分为以下几类：</p>\n<ul>\n<li><p>1、组合问题：</p>\n<p><a href=\"https://leetcode-cn.com/problems/target-sum/\" target=\"_blank\" rel=\"noopener\">494.目标和</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/coin-change-2/\" target=\"_blank\" rel=\"noopener\">518.零钱兑换 II</a></p>\n<p>组合问题公式：<code>dp[i] += dp[i-num]</code></p>\n</li>\n<li><p>2、排列问题</p>\n<p><a href=\"https://leetcode-cn.com/problems/combination-sum-iv\" target=\"_blank\" rel=\"noopener\">377.组合总和 Ⅳ</a></p>\n<p>排列问题公式：<code>dp[i] += dp[i-num]</code></p>\n</li>\n<li><p>3、True、False问题：</p>\n<p><a href=\"https://leetcode-cn.com/problems/word-break\" target=\"_blank\" rel=\"noopener\">139.单词拆分（组合）</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/partition-equal-subset-sum\" target=\"_blank\" rel=\"noopener\">416.分割等和子集（组合）</a></p>\n<p>True、False问题公式：<code>dp[i] = dp[i] or dp[i-num]</code></p>\n</li>\n<li><p>4、最大最小问题：</p>\n<p><a href=\"https://leetcode-cn.com/problems/ones-and-zeroes/\" target=\"_blank\" rel=\"noopener\">474.一和零</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/coin-change\" target=\"_blank\" rel=\"noopener\">322.零钱兑换（组合）</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/perfect-squares\" target=\"_blank\" rel=\"noopener\">279.完全平方数</a></p>\n<p>最大最小问题公式：<code>dp[i] = min(dp[i], dp[i-num]+1)或者dp[i] = max(dp[i], dp[i-num]+1)</code></p>\n</li>\n</ul>\n<p>下面，结合几个典型真题例子，来看看如何套用公式。</p>\n<p><strong>322.零钱兑换：</strong></p>\n<p>给定不同面额的硬币 <code>coins</code> 和一个总金额 <code>amount</code>。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。</p>\n<p>你可以认为每种硬币的数量是无限的。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：coins = [1, 2, 5], amount = 11</span><br><span class=\"line\">输出：3 </span><br><span class=\"line\">解释：11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：coins = [2], amount = 3</span><br><span class=\"line\">输出：-1</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：coins = [1], amount = 0</span><br><span class=\"line\">输出：0</span><br></pre></td></tr></table></figure>\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：coins = [1], amount = 1</span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure>\n<p><strong>示例 5：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：coins = [1], amount = 2</span><br><span class=\"line\">输出：2</span><br></pre></td></tr></table></figure>\n<p><strong>解法</strong></p>\n<p>金额可以抽象为背包，硬币可以抽象为物品，这就转换成了一个背包问题，题目中描述硬币数量无限使用，那么就是一个完全背包问题，那么就可以套用模板：</p>\n<ul>\n<li>只求数量，不考虑顺序，符合组合数，外层for物品，内层for背包。</li>\n<li>最小值问题，使用最小值公式。</li>\n<li>完全背包问题，内层循环正序。</li>\n</ul>\n<p>得到代码如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> coinChange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">coins, amount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> dp = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(amount + <span class=\"number\">1</span>).fill(<span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER) dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt;= amount; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (j &gt;= coins[i]) &#123;</span><br><span class=\"line\">        dp[j] = <span class=\"built_in\">Math</span>.min(dp[j], dp[j - coins[i]] + <span class=\"number\">1</span>) <span class=\"comment\">// 最小值问题公式</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dp[amount] == <span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER ? <span class=\"number\">-1</span> : dp[amount]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>518.零钱兑换II：</strong></p>\n<p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p>\n<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p>\n<p>假设每一种面额的硬币有无限个。 </p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：amount = 5, coins = [1, 2, 5]</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：有四种方式可以凑成总金额：</span><br><span class=\"line\">5=5</span><br><span class=\"line\">5=2+2+1</span><br><span class=\"line\">5=2+1+1+1</span><br><span class=\"line\">5=1+1+1+1+1</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：amount = 3, coins = [2]</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：只用面额 2 的硬币不能凑成总金额 3 。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：amount = 10, coins = [10] </span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure>\n<p><strong>解法</strong></p>\n<p>金额可以抽象为背包，硬币可以抽象为物品，这就转换成了一个背包问题，题目中描述硬币数量无限使用，那么就是一个完全背包问题，那么就可以套用模板：</p>\n<ul>\n<li>只求数量，不考虑顺序，符合组合数，外层for物品，内层for背包。</li>\n<li>组合问题，使用组合公式。</li>\n<li>完全背包问题，内层循环正序。</li>\n</ul>\n<p>得到代码如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> change = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">amount, coins</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> dp = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(amount + <span class=\"number\">1</span>).fill(<span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 总数为0时，只有一种方案兑换 就是所有硬币都不选择</span></span><br><span class=\"line\">  dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt;= amount; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (j - coins[i] &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        dp[j] = dp[j] + dp[j - coins[i]] <span class=\"comment\">// 组合问题公式</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dp[amount]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>139.单词拆分：</strong></p>\n<p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词的列表 <em>wordDict</em>，判定 <em>s</em> 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>\n<p><strong>说明：</strong></p>\n<ul>\n<li>拆分时可以重复使用字典中的单词。</li>\n<li>你可以假设字典中没有重复的单词。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class=\"line\">输出: true</span><br><span class=\"line\">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class=\"line\">输出: true</span><br><span class=\"line\">解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。</span><br><span class=\"line\">     注意你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class=\"line\">输出: false</span><br></pre></td></tr></table></figure>\n<p><strong>解法</strong></p>\n<p>字符串<code>s</code>可以抽象为背包，单词列表<code>wordDict</code>可以抽象为物品，这就转换成了一个背包问题，题目中描述可以使用重复的单词，那么就是一个完全背包问题，那么就可以套用模板：</p>\n<ul>\n<li>单词顺序影响结果，符合排列数，外层for背包，内层for物品。</li>\n<li>True，False问题，使用True，False公式。</li>\n<li>完全背包问题，内层循环正序。</li>\n</ul>\n<p>得到代码如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> wordBreak = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s, wordDict</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> dp = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(s.length + <span class=\"number\">1</span>).fill(<span class=\"literal\">false</span>)</span><br><span class=\"line\">  <span class=\"comment\">// dp[i] 表示以 i 结尾的字符串是否可以被 wordDict 中组合而成</span></span><br><span class=\"line\">  dp[<span class=\"number\">0</span>] = <span class=\"literal\">true</span> <span class=\"comment\">// 空字符可以不从wordDict中选择，也能组成</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= s.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; wordDict.length; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> s1 = wordDict[j] <span class=\"comment\">// s1表示当前的字符串</span></span><br><span class=\"line\">      <span class=\"comment\">// temp表示字符串s中截取s1长度的临时串</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> temp = s.substr(i - s1.length, s1.length)</span><br><span class=\"line\">      <span class=\"comment\">// 临时串和当前s1相等时，可匹配</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (temp == s1) &#123;</span><br><span class=\"line\">        dp[i] = dp[i] || dp[i - s1.length]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dp[s.length]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其他相关的公式，也都可以套用，这里就不在赘述。掌握了背包问题公式，大部分的问题都可以迎刃而解了！</p>"},{"title":"前端算法--迷宫问题","date":"2021-07-26T09:26:17.000Z","_content":"\n## 迷宫问题\n\n我们常常会遇到各种迷宫问题，即从起点走到终点，会有哪些路径：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b13f4a474daf459cb1d43bbd5683b851~tplv-k3u1fbpfcp-watermark.image)\n<!--more-->\n或者是求起点到终点最短路径：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e822b6cc3b24d1bbf04b7aefca48b49~tplv-k3u1fbpfcp-watermark.image)\n\n对于这类迷宫问题，我们使用程序化的思想，可以简单的抽象成一个M*N的二维数组矩阵，如下：\n\n```javascript\nvar matrix = \n    [[0, 1, 0, 0, 0, 0]\n    [0, 1, 0, 1, 0, 0]\n    [0, 0, 0, 0, 0, 1]\n    [1, 1, 0, 0, 0, 0]\n    [1, 1, 0, 0, 0, 0]\n    [1, 1, 0, 0, 0, 0]]\n```\n\n上面二维数组中，取左上角为起点，右下角为终点，每个点有上下左右一共4个方向可以走，0表示通路可以通过，1表示障碍物不能通过，求从起点到终点共有多少种走法。\n\n如下所示其中一种走法，我们用“#”代表走过的路径：\n\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdad46710f17453da929b292e3124fc0~tplv-k3u1fbpfcp-watermark.image)\n\n我们可以很容易的找到1种走法，当然这只是对于矩阵比较小的情况下，如果矩阵足够大，那么就需要转换成程序语言来解答了。\n\n## 深度优先搜索\n\n深度优先搜索也叫深度优先遍历是一种常见的搜索方法，它的特点就是一条路走到深，不撞南墙不回头。深度优先遍历迷宫，流程如下：\n\n1. 访问起点s。\n2. 依次从s的未被访问的邻接点出发，在某一方向上进行搜索，直至该方向搜索完毕，并且和s有路径相通的点都被访问。\n3. 若此时还有未被访问的节点，则从一个未被访问的节点出发，重新进行深度搜索，直到所有节点均被访问为止。\n4. 循环上述操作，直到访问到终点e为止。\n\n在进行搜索的同时，我们需要增加一些判断条件来规避一些非法的路径状态，\n\n1. 当前节点是通路。\n2. 当前节点没有超过迷宫范围。\n3. 当前节点在同一路径中不应被访问第二次。\n\n最后，在搜索的同时需要记录访问过的路径，根据上面的思路，转换成JavaScript代码，我们采用递归来实现：\n\n```javascript\nvar mazeSearch = function(){\n    var matrix = \n        [[0,1,0,0,0,0],\n         [0,0,0,1,0,0],\n         [0,0,1,0,0,1],\n         [1,1,0,0,0,0],\n         [1,1,0,0,0,0],\n         [1,1,0,0,0,0]]\n    \n    var m = matrix.length\n    var n = matrix[0].length\n    // 此数组用来记录当前节点是否被访问过\n    var visited = new Array(m).fill('').map((d)=>new Array(n).fill(false)) \n\n    var dirs = [[0,1],[0,-1],[1,0],[-1,0]] // 当前节点可走的4个方向，分别对应右，左，上，下\n\n\n    var dfs = function(x,y,path){\n        // 到达终点\n        if (x == m-1 && y == n-1) {\n            console.log(path) // 打印当前路径\n            return \n        }\n\n        for (var dir of dirs) {\n\n            var nx = x + dir[0]\n            var ny = y + dir[1]\n            // 分别判断当前节点是否是有效节点\n            if (nx < m && // 迷宫边界\n                nx >=0 && \n                ny < n && \n                ny >=0 && \n                matrix[nx][ny] == 0 && // 是否通路0：通路1：障碍\n                visited[nx][ny] == false) {// 是否已访问过\n                // 当访问该节点时，标记已访问\n                visited[nx][ny] = true\n                // 进入递归，每次递归都表示一个完整路径\n                // 需要传入当前节点和已经访问过的路径\n                dfs(nx,ny,path+'-'+nx+','+ny)\n                // 每次路径完成时，针对该节点需要回溯原始状态\n                visited[nx][ny] = false;\n                \n            }\n        }\n    }\n\n    // 进入起点\n    dfs(0,0,'0,0')\n    visited[0][0] = true\n}\n```\n\n上述代码会打印出从起点到终点的所有路径，最终右212种走法，我们可以随机画出其中几个解法的路径，如下图：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ec638b1240645678f3ed996da86eac3~tplv-k3u1fbpfcp-watermark.image)\n\n每种路径上面的数字代表当前路径的长度即所经过的节点数，可以看到不同的路径有不同的长度，那么，我们是否能在这212种走法里面找到最短的那一种呢，这就涉及到最优解，我们只需改造部分代码：\n\n```javascript\nvar mazeSearch = function(){\n    ...\n\n    var res = {\n        path:null,\n        len:Number.MAX_SAFE_INTEGER\n    }\n    var dfs = function(x,y,path){\n        // 到达终点\n        if (x == m-1 && y == n-1) {\n            // 得到当前路径长度\n            var currentLen = path.split('-').length\n            // 如果当前路径小于结果路径，则取结果路径\n            if (res.len > currentLen) {\n                res = {\n                    path:path,\n                    len:currentLen\n                }\n            }\n\n            return \n        }\n        ...\n\n    }\n\n    ...\n\n    console.log(res)\n\n}\n```\n\n打印出最优解，长度为12：\n\n```json\n{\n    len: 13,\n    path: \"0,0-1,0-1,1-1,2-0,2-0,3-0,4-1,4-2,4-3,4-3,5-4,5-5,5\"\n}\n```\n\n通过深度优先搜索得到最优解，其核心思想是得到所有解，然后从所有解里面找到最优解，那么我们能否采取一种效率更高的办法直接得到最优解呢？\n\n## 广度优先搜索\n\n广度优先搜索也叫宽度优先遍历是一种常见的搜索方法，它的特点沿一个点向四周方向向外扩展，也就是呈一种发散状向外边扩散，依次下去，直到搜索到所有的顶点。该思想就是二叉树的层序遍历的演变，一层一层的进行遍历。\n\n广度优先搜索通常用来求最优解，即得到结果的同时，这个结果就是最短的路径，在广度遍历时，会对节点周围相关联且未遍历的点先进行遍历，然后重复此步骤直至所有节点都被遍历。由于与一个节点相关联的节点有多个且不能同时进行遍历，所以我们需要用到队列这个数据结构模拟这种“同时”的遍历，流程和思想如下：\n\n1. 访问起点s。\n2. 将起点作为当前节点，遍历该点的四个方向，并压入队列，并标记为已访问过的。\n3. 依次从队列中，移出队首为当前方向上的节点，记录路径。\n4. 循环上述2，3步骤操作，直到访问到终点e为止。\n\n同样，在进行搜索的同时，我们需要增加一些判断条件来规避一些非法的路径状态，\n\n1. 当前节点是通路。\n2. 当前节点没有超过迷宫范围。\n3. 当前节点在同一路径中不应被访问第二次。\n\n根据上面的思路，转换成JavaScript代码：\n\n```javascript\nvar mazeSearch = function(){\n    var matrix = \n        [[0,1,0,0,0,0],\n         [0,0,0,1,0,0],\n         [0,0,1,0,0,1],\n         [1,1,0,0,0,0],\n         [1,1,0,0,0,0],\n         [1,1,0,0,0,0]]\n\n    var m = matrix.length\n    var n = matrix[0].length\n    // 此数组用来记录当前节点是否被访问过\n    var visited = new Array(m).fill('').map((d)=>new Array(n).fill(false))\n    var arr = [] // 队列\n    var dirs = [[0,1],[0,-1],[1,0],[-1,0]]// 当前节点可走的4个方向，分别对应右，左，上，下\n\n    // 起点入队\n    arr.push({\n        x:0,\n        y:0,\n        path: '0,0'\n    })\n    visited[0][0] = true\n\n    while(arr.length) {\n        var current = arr.shift() // 当前方向上节点出队\n\n        if (current.x == m-1 && current.y == n-1) {\n            console.log(current.path)// 打印当前路径\n            break;\n        }\n        for (var dir of dirs) {\n            var nx = current.x + dir[0]\n            var ny = current.y + dir[1]\n\n            // 分别判断当前节点是否是有效节点\n            if (nx < m && // 迷宫边界\n                nx >=0 && \n                ny < n && \n                ny >=0 && \n                matrix[nx][ny] == 0 && // 是否通路0：通路1：障碍\n                visited[nx][ny] == false) {// 是否已访问过\n\n                // 根据当前路径记录走过的路径\n                var _path = current.path + '-'+nx+','+ny+''\n                // 节点入队\n                arr.push({\n                    x:nx,\n                    y:ny,\n                    path:_path\n                })\n                // 标记已访问过\n                visited[nx][ny] = true\n            }\n        }\n    }\n}\n```\n\n至此，我们分别使用广度优先搜素和深度优先搜索完成的迷宫问题，当然，这只是最简单的迷宫问题，类似还有很多变种。\n\n## 迷宫问题变种\n\n* 方向增加\n\n例如：每个点有8个方向可以移动，我们可以通过修改方向数组的方式：\n\n```\nvar dirs = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[-1,-1],[1,-1],[-1,1]]\n// 分别对应右，左，上，下，右上，左下，右下，左上\n```\n\n* 小球滚动题目：\n\n在迷宫中有一个球，里面有空的空间和墙壁。球可以通过滚`上`，`下`，`左`或`右`移动，但它不会停止滚动直到撞到墙上。当球停止时，它可以选择下一个方向，求小球从起点到终点的最短路径。\n\n这个题目中的最大不同就是小球在遇到障碍物时不会停止，而是可以向四个方向移动，直到遇到墙面才会停止，所以我们针对上面的思路，梳理出两个改动点：\n\n1. 把是否遇到墙壁，即迷宫边界单独判断。\n2. 将`if`改为`while`即循环判断是否是有效路径。\n\n代码如下：\n\n```javascript\n  shortestDistance(maze,start,destination) {\n\n    var m = maze.length\n    var n = maze[0].length\n    var res = Number.MAX_SAFE_INTEGER\n    var visited = new Array(m).fill('').map(d=>new Array(n).fill(false))\n    var dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n    // 抽离出墙面迷宫边界\n    var notWall = function(x,y){\n        return x >= 0 && x < m && y >= 0 && y < n;\n    }\n    var dfs = function(x,y,step){\n        \n\n        if(x == destination[0] && y == destination[1]) {\n            res = Math.min(res,step)\n            return \n        }\n        for(var dir of dirs) {\n            var nx = x, ny = y;\n            var _step = step\n            // 这里改为循环判断\n            while(notWall(nx + dir[0], ny + dir[1]) && maze[nx+dir[0]][ny+dir[1]] != 1) {\n                nx += dir[0];\n                ny += dir[1];\n                _step = _step+1\n            }\n\n            if(!visited[nx][ny]) {\n                visited[nx][ny] = true\n                dfs(nx,ny,_step)\n                visited[nx][ny] = false\n                \n            }\n            \n        }\n\n    }\n\n    dfs(start[0],start[1],0)\n\n    return res == Number.MAX_SAFE_INTEGER ? -1 : res\n  }\n```\n\n* 其他题目\n\n例如在迷宫中增加随机传送门，LeetCode 200.岛屿数量，LeetCode  695.岛屿最大面积 等等的题目，都是属于迷宫问题的变种，其核心思想都是采用深度优先和广度优先搜索来解决。\n\n\n\n\n\n\n\n","source":"_posts/前端算法--迷宫问题.md","raw":"---\ntitle: 前端算法--迷宫问题\ndate: 2021-07-26 17:26:17\ntags:\n- 算法\n- 迷宫问题\ncategories:\n- 12097\n\n---\n\n## 迷宫问题\n\n我们常常会遇到各种迷宫问题，即从起点走到终点，会有哪些路径：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b13f4a474daf459cb1d43bbd5683b851~tplv-k3u1fbpfcp-watermark.image)\n<!--more-->\n或者是求起点到终点最短路径：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e822b6cc3b24d1bbf04b7aefca48b49~tplv-k3u1fbpfcp-watermark.image)\n\n对于这类迷宫问题，我们使用程序化的思想，可以简单的抽象成一个M*N的二维数组矩阵，如下：\n\n```javascript\nvar matrix = \n    [[0, 1, 0, 0, 0, 0]\n    [0, 1, 0, 1, 0, 0]\n    [0, 0, 0, 0, 0, 1]\n    [1, 1, 0, 0, 0, 0]\n    [1, 1, 0, 0, 0, 0]\n    [1, 1, 0, 0, 0, 0]]\n```\n\n上面二维数组中，取左上角为起点，右下角为终点，每个点有上下左右一共4个方向可以走，0表示通路可以通过，1表示障碍物不能通过，求从起点到终点共有多少种走法。\n\n如下所示其中一种走法，我们用“#”代表走过的路径：\n\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdad46710f17453da929b292e3124fc0~tplv-k3u1fbpfcp-watermark.image)\n\n我们可以很容易的找到1种走法，当然这只是对于矩阵比较小的情况下，如果矩阵足够大，那么就需要转换成程序语言来解答了。\n\n## 深度优先搜索\n\n深度优先搜索也叫深度优先遍历是一种常见的搜索方法，它的特点就是一条路走到深，不撞南墙不回头。深度优先遍历迷宫，流程如下：\n\n1. 访问起点s。\n2. 依次从s的未被访问的邻接点出发，在某一方向上进行搜索，直至该方向搜索完毕，并且和s有路径相通的点都被访问。\n3. 若此时还有未被访问的节点，则从一个未被访问的节点出发，重新进行深度搜索，直到所有节点均被访问为止。\n4. 循环上述操作，直到访问到终点e为止。\n\n在进行搜索的同时，我们需要增加一些判断条件来规避一些非法的路径状态，\n\n1. 当前节点是通路。\n2. 当前节点没有超过迷宫范围。\n3. 当前节点在同一路径中不应被访问第二次。\n\n最后，在搜索的同时需要记录访问过的路径，根据上面的思路，转换成JavaScript代码，我们采用递归来实现：\n\n```javascript\nvar mazeSearch = function(){\n    var matrix = \n        [[0,1,0,0,0,0],\n         [0,0,0,1,0,0],\n         [0,0,1,0,0,1],\n         [1,1,0,0,0,0],\n         [1,1,0,0,0,0],\n         [1,1,0,0,0,0]]\n    \n    var m = matrix.length\n    var n = matrix[0].length\n    // 此数组用来记录当前节点是否被访问过\n    var visited = new Array(m).fill('').map((d)=>new Array(n).fill(false)) \n\n    var dirs = [[0,1],[0,-1],[1,0],[-1,0]] // 当前节点可走的4个方向，分别对应右，左，上，下\n\n\n    var dfs = function(x,y,path){\n        // 到达终点\n        if (x == m-1 && y == n-1) {\n            console.log(path) // 打印当前路径\n            return \n        }\n\n        for (var dir of dirs) {\n\n            var nx = x + dir[0]\n            var ny = y + dir[1]\n            // 分别判断当前节点是否是有效节点\n            if (nx < m && // 迷宫边界\n                nx >=0 && \n                ny < n && \n                ny >=0 && \n                matrix[nx][ny] == 0 && // 是否通路0：通路1：障碍\n                visited[nx][ny] == false) {// 是否已访问过\n                // 当访问该节点时，标记已访问\n                visited[nx][ny] = true\n                // 进入递归，每次递归都表示一个完整路径\n                // 需要传入当前节点和已经访问过的路径\n                dfs(nx,ny,path+'-'+nx+','+ny)\n                // 每次路径完成时，针对该节点需要回溯原始状态\n                visited[nx][ny] = false;\n                \n            }\n        }\n    }\n\n    // 进入起点\n    dfs(0,0,'0,0')\n    visited[0][0] = true\n}\n```\n\n上述代码会打印出从起点到终点的所有路径，最终右212种走法，我们可以随机画出其中几个解法的路径，如下图：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ec638b1240645678f3ed996da86eac3~tplv-k3u1fbpfcp-watermark.image)\n\n每种路径上面的数字代表当前路径的长度即所经过的节点数，可以看到不同的路径有不同的长度，那么，我们是否能在这212种走法里面找到最短的那一种呢，这就涉及到最优解，我们只需改造部分代码：\n\n```javascript\nvar mazeSearch = function(){\n    ...\n\n    var res = {\n        path:null,\n        len:Number.MAX_SAFE_INTEGER\n    }\n    var dfs = function(x,y,path){\n        // 到达终点\n        if (x == m-1 && y == n-1) {\n            // 得到当前路径长度\n            var currentLen = path.split('-').length\n            // 如果当前路径小于结果路径，则取结果路径\n            if (res.len > currentLen) {\n                res = {\n                    path:path,\n                    len:currentLen\n                }\n            }\n\n            return \n        }\n        ...\n\n    }\n\n    ...\n\n    console.log(res)\n\n}\n```\n\n打印出最优解，长度为12：\n\n```json\n{\n    len: 13,\n    path: \"0,0-1,0-1,1-1,2-0,2-0,3-0,4-1,4-2,4-3,4-3,5-4,5-5,5\"\n}\n```\n\n通过深度优先搜索得到最优解，其核心思想是得到所有解，然后从所有解里面找到最优解，那么我们能否采取一种效率更高的办法直接得到最优解呢？\n\n## 广度优先搜索\n\n广度优先搜索也叫宽度优先遍历是一种常见的搜索方法，它的特点沿一个点向四周方向向外扩展，也就是呈一种发散状向外边扩散，依次下去，直到搜索到所有的顶点。该思想就是二叉树的层序遍历的演变，一层一层的进行遍历。\n\n广度优先搜索通常用来求最优解，即得到结果的同时，这个结果就是最短的路径，在广度遍历时，会对节点周围相关联且未遍历的点先进行遍历，然后重复此步骤直至所有节点都被遍历。由于与一个节点相关联的节点有多个且不能同时进行遍历，所以我们需要用到队列这个数据结构模拟这种“同时”的遍历，流程和思想如下：\n\n1. 访问起点s。\n2. 将起点作为当前节点，遍历该点的四个方向，并压入队列，并标记为已访问过的。\n3. 依次从队列中，移出队首为当前方向上的节点，记录路径。\n4. 循环上述2，3步骤操作，直到访问到终点e为止。\n\n同样，在进行搜索的同时，我们需要增加一些判断条件来规避一些非法的路径状态，\n\n1. 当前节点是通路。\n2. 当前节点没有超过迷宫范围。\n3. 当前节点在同一路径中不应被访问第二次。\n\n根据上面的思路，转换成JavaScript代码：\n\n```javascript\nvar mazeSearch = function(){\n    var matrix = \n        [[0,1,0,0,0,0],\n         [0,0,0,1,0,0],\n         [0,0,1,0,0,1],\n         [1,1,0,0,0,0],\n         [1,1,0,0,0,0],\n         [1,1,0,0,0,0]]\n\n    var m = matrix.length\n    var n = matrix[0].length\n    // 此数组用来记录当前节点是否被访问过\n    var visited = new Array(m).fill('').map((d)=>new Array(n).fill(false))\n    var arr = [] // 队列\n    var dirs = [[0,1],[0,-1],[1,0],[-1,0]]// 当前节点可走的4个方向，分别对应右，左，上，下\n\n    // 起点入队\n    arr.push({\n        x:0,\n        y:0,\n        path: '0,0'\n    })\n    visited[0][0] = true\n\n    while(arr.length) {\n        var current = arr.shift() // 当前方向上节点出队\n\n        if (current.x == m-1 && current.y == n-1) {\n            console.log(current.path)// 打印当前路径\n            break;\n        }\n        for (var dir of dirs) {\n            var nx = current.x + dir[0]\n            var ny = current.y + dir[1]\n\n            // 分别判断当前节点是否是有效节点\n            if (nx < m && // 迷宫边界\n                nx >=0 && \n                ny < n && \n                ny >=0 && \n                matrix[nx][ny] == 0 && // 是否通路0：通路1：障碍\n                visited[nx][ny] == false) {// 是否已访问过\n\n                // 根据当前路径记录走过的路径\n                var _path = current.path + '-'+nx+','+ny+''\n                // 节点入队\n                arr.push({\n                    x:nx,\n                    y:ny,\n                    path:_path\n                })\n                // 标记已访问过\n                visited[nx][ny] = true\n            }\n        }\n    }\n}\n```\n\n至此，我们分别使用广度优先搜素和深度优先搜索完成的迷宫问题，当然，这只是最简单的迷宫问题，类似还有很多变种。\n\n## 迷宫问题变种\n\n* 方向增加\n\n例如：每个点有8个方向可以移动，我们可以通过修改方向数组的方式：\n\n```\nvar dirs = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[-1,-1],[1,-1],[-1,1]]\n// 分别对应右，左，上，下，右上，左下，右下，左上\n```\n\n* 小球滚动题目：\n\n在迷宫中有一个球，里面有空的空间和墙壁。球可以通过滚`上`，`下`，`左`或`右`移动，但它不会停止滚动直到撞到墙上。当球停止时，它可以选择下一个方向，求小球从起点到终点的最短路径。\n\n这个题目中的最大不同就是小球在遇到障碍物时不会停止，而是可以向四个方向移动，直到遇到墙面才会停止，所以我们针对上面的思路，梳理出两个改动点：\n\n1. 把是否遇到墙壁，即迷宫边界单独判断。\n2. 将`if`改为`while`即循环判断是否是有效路径。\n\n代码如下：\n\n```javascript\n  shortestDistance(maze,start,destination) {\n\n    var m = maze.length\n    var n = maze[0].length\n    var res = Number.MAX_SAFE_INTEGER\n    var visited = new Array(m).fill('').map(d=>new Array(n).fill(false))\n    var dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n    // 抽离出墙面迷宫边界\n    var notWall = function(x,y){\n        return x >= 0 && x < m && y >= 0 && y < n;\n    }\n    var dfs = function(x,y,step){\n        \n\n        if(x == destination[0] && y == destination[1]) {\n            res = Math.min(res,step)\n            return \n        }\n        for(var dir of dirs) {\n            var nx = x, ny = y;\n            var _step = step\n            // 这里改为循环判断\n            while(notWall(nx + dir[0], ny + dir[1]) && maze[nx+dir[0]][ny+dir[1]] != 1) {\n                nx += dir[0];\n                ny += dir[1];\n                _step = _step+1\n            }\n\n            if(!visited[nx][ny]) {\n                visited[nx][ny] = true\n                dfs(nx,ny,_step)\n                visited[nx][ny] = false\n                \n            }\n            \n        }\n\n    }\n\n    dfs(start[0],start[1],0)\n\n    return res == Number.MAX_SAFE_INTEGER ? -1 : res\n  }\n```\n\n* 其他题目\n\n例如在迷宫中增加随机传送门，LeetCode 200.岛屿数量，LeetCode  695.岛屿最大面积 等等的题目，都是属于迷宫问题的变种，其核心思想都是采用深度优先和广度优先搜索来解决。\n\n\n\n\n\n\n\n","slug":"前端算法--迷宫问题","published":1,"updated":"2021-12-10T16:12:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434q13002w2wvjv8au5890","content":"<h2><span id=\"迷宫问题\">迷宫问题</span></h2><p>我们常常会遇到各种迷宫问题，即从起点走到终点，会有哪些路径：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b13f4a474daf459cb1d43bbd5683b851~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"><br><a id=\"more\"></a><br>或者是求起点到终点最短路径：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e822b6cc3b24d1bbf04b7aefca48b49~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>对于这类迷宫问题，我们使用程序化的思想，可以简单的抽象成一个M*N的二维数组矩阵，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> matrix = </span><br><span class=\"line\">    [[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">    [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">    [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">    [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">    [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">    [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]]</span><br></pre></td></tr></table></figure>\n<p>上面二维数组中，取左上角为起点，右下角为终点，每个点有上下左右一共4个方向可以走，0表示通路可以通过，1表示障碍物不能通过，求从起点到终点共有多少种走法。</p>\n<p>如下所示其中一种走法，我们用“#”代表走过的路径：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdad46710f17453da929b292e3124fc0~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>我们可以很容易的找到1种走法，当然这只是对于矩阵比较小的情况下，如果矩阵足够大，那么就需要转换成程序语言来解答了。</p>\n<h2><span id=\"深度优先搜索\">深度优先搜索</span></h2><p>深度优先搜索也叫深度优先遍历是一种常见的搜索方法，它的特点就是一条路走到深，不撞南墙不回头。深度优先遍历迷宫，流程如下：</p>\n<ol>\n<li>访问起点s。</li>\n<li>依次从s的未被访问的邻接点出发，在某一方向上进行搜索，直至该方向搜索完毕，并且和s有路径相通的点都被访问。</li>\n<li>若此时还有未被访问的节点，则从一个未被访问的节点出发，重新进行深度搜索，直到所有节点均被访问为止。</li>\n<li>循环上述操作，直到访问到终点e为止。</li>\n</ol>\n<p>在进行搜索的同时，我们需要增加一些判断条件来规避一些非法的路径状态，</p>\n<ol>\n<li>当前节点是通路。</li>\n<li>当前节点没有超过迷宫范围。</li>\n<li>当前节点在同一路径中不应被访问第二次。</li>\n</ol>\n<p>最后，在搜索的同时需要记录访问过的路径，根据上面的思路，转换成JavaScript代码，我们采用递归来实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mazeSearch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> matrix = </span><br><span class=\"line\">        [[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>],</span><br><span class=\"line\">         [<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>],</span><br><span class=\"line\">         [<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>],</span><br><span class=\"line\">         [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>],</span><br><span class=\"line\">         [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>],</span><br><span class=\"line\">         [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>]]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> m = matrix.length</span><br><span class=\"line\">    <span class=\"keyword\">var</span> n = matrix[<span class=\"number\">0</span>].length</span><br><span class=\"line\">    <span class=\"comment\">// 此数组用来记录当前节点是否被访问过</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> visited = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(m).fill(<span class=\"string\">''</span>).map(<span class=\"function\">(<span class=\"params\">d</span>)=&gt;</span><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n).fill(<span class=\"literal\">false</span>)) </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> dirs = [[<span class=\"number\">0</span>,<span class=\"number\">1</span>],[<span class=\"number\">0</span>,<span class=\"number\">-1</span>],[<span class=\"number\">1</span>,<span class=\"number\">0</span>],[<span class=\"number\">-1</span>,<span class=\"number\">0</span>]] <span class=\"comment\">// 当前节点可走的4个方向，分别对应右，左，上，下</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> dfs = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y,path</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 到达终点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x == m<span class=\"number\">-1</span> &amp;&amp; y == n<span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(path) <span class=\"comment\">// 打印当前路径</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> dir <span class=\"keyword\">of</span> dirs) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">var</span> nx = x + dir[<span class=\"number\">0</span>]</span><br><span class=\"line\">            <span class=\"keyword\">var</span> ny = y + dir[<span class=\"number\">1</span>]</span><br><span class=\"line\">            <span class=\"comment\">// 分别判断当前节点是否是有效节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nx &lt; m &amp;&amp; <span class=\"comment\">// 迷宫边界</span></span><br><span class=\"line\">                nx &gt;=<span class=\"number\">0</span> &amp;&amp; </span><br><span class=\"line\">                ny &lt; n &amp;&amp; </span><br><span class=\"line\">                ny &gt;=<span class=\"number\">0</span> &amp;&amp; </span><br><span class=\"line\">                matrix[nx][ny] == <span class=\"number\">0</span> &amp;&amp; <span class=\"comment\">// 是否通路0：通路1：障碍</span></span><br><span class=\"line\">                visited[nx][ny] == <span class=\"literal\">false</span>) &#123;<span class=\"comment\">// 是否已访问过</span></span><br><span class=\"line\">                <span class=\"comment\">// 当访问该节点时，标记已访问</span></span><br><span class=\"line\">                visited[nx][ny] = <span class=\"literal\">true</span></span><br><span class=\"line\">                <span class=\"comment\">// 进入递归，每次递归都表示一个完整路径</span></span><br><span class=\"line\">                <span class=\"comment\">// 需要传入当前节点和已经访问过的路径</span></span><br><span class=\"line\">                dfs(nx,ny,path+<span class=\"string\">'-'</span>+nx+<span class=\"string\">','</span>+ny)</span><br><span class=\"line\">                <span class=\"comment\">// 每次路径完成时，针对该节点需要回溯原始状态</span></span><br><span class=\"line\">                visited[nx][ny] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 进入起点</span></span><br><span class=\"line\">    dfs(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"string\">'0,0'</span>)</span><br><span class=\"line\">    visited[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码会打印出从起点到终点的所有路径，最终右212种走法，我们可以随机画出其中几个解法的路径，如下图：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ec638b1240645678f3ed996da86eac3~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>每种路径上面的数字代表当前路径的长度即所经过的节点数，可以看到不同的路径有不同的长度，那么，我们是否能在这212种走法里面找到最短的那一种呢，这就涉及到最优解，我们只需改造部分代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mazeSearch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> res = &#123;</span><br><span class=\"line\">        path:<span class=\"literal\">null</span>,</span><br><span class=\"line\">        len:<span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dfs = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y,path</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 到达终点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x == m<span class=\"number\">-1</span> &amp;&amp; y == n<span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 得到当前路径长度</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> currentLen = path.split(<span class=\"string\">'-'</span>).length</span><br><span class=\"line\">            <span class=\"comment\">// 如果当前路径小于结果路径，则取结果路径</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (res.len &gt; currentLen) &#123;</span><br><span class=\"line\">                res = &#123;</span><br><span class=\"line\">                    path:path,</span><br><span class=\"line\">                    len:currentLen</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>打印出最优解，长度为12：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    len: 13,</span><br><span class=\"line\">    path: \"0,0-1,0-1,1-1,2-0,2-0,3-0,4-1,4-2,4-3,4-3,5-4,5-5,5\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过深度优先搜索得到最优解，其核心思想是得到所有解，然后从所有解里面找到最优解，那么我们能否采取一种效率更高的办法直接得到最优解呢？</p>\n<h2><span id=\"广度优先搜索\">广度优先搜索</span></h2><p>广度优先搜索也叫宽度优先遍历是一种常见的搜索方法，它的特点沿一个点向四周方向向外扩展，也就是呈一种发散状向外边扩散，依次下去，直到搜索到所有的顶点。该思想就是二叉树的层序遍历的演变，一层一层的进行遍历。</p>\n<p>广度优先搜索通常用来求最优解，即得到结果的同时，这个结果就是最短的路径，在广度遍历时，会对节点周围相关联且未遍历的点先进行遍历，然后重复此步骤直至所有节点都被遍历。由于与一个节点相关联的节点有多个且不能同时进行遍历，所以我们需要用到队列这个数据结构模拟这种“同时”的遍历，流程和思想如下：</p>\n<ol>\n<li>访问起点s。</li>\n<li>将起点作为当前节点，遍历该点的四个方向，并压入队列，并标记为已访问过的。</li>\n<li>依次从队列中，移出队首为当前方向上的节点，记录路径。</li>\n<li>循环上述2，3步骤操作，直到访问到终点e为止。</li>\n</ol>\n<p>同样，在进行搜索的同时，我们需要增加一些判断条件来规避一些非法的路径状态，</p>\n<ol>\n<li>当前节点是通路。</li>\n<li>当前节点没有超过迷宫范围。</li>\n<li>当前节点在同一路径中不应被访问第二次。</li>\n</ol>\n<p>根据上面的思路，转换成JavaScript代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mazeSearch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> matrix = </span><br><span class=\"line\">        [[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>],</span><br><span class=\"line\">         [<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>],</span><br><span class=\"line\">         [<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>],</span><br><span class=\"line\">         [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>],</span><br><span class=\"line\">         [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>],</span><br><span class=\"line\">         [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>]]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> m = matrix.length</span><br><span class=\"line\">    <span class=\"keyword\">var</span> n = matrix[<span class=\"number\">0</span>].length</span><br><span class=\"line\">    <span class=\"comment\">// 此数组用来记录当前节点是否被访问过</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> visited = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(m).fill(<span class=\"string\">''</span>).map(<span class=\"function\">(<span class=\"params\">d</span>)=&gt;</span><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n).fill(<span class=\"literal\">false</span>))</span><br><span class=\"line\">    <span class=\"keyword\">var</span> arr = [] <span class=\"comment\">// 队列</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> dirs = [[<span class=\"number\">0</span>,<span class=\"number\">1</span>],[<span class=\"number\">0</span>,<span class=\"number\">-1</span>],[<span class=\"number\">1</span>,<span class=\"number\">0</span>],[<span class=\"number\">-1</span>,<span class=\"number\">0</span>]]<span class=\"comment\">// 当前节点可走的4个方向，分别对应右，左，上，下</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 起点入队</span></span><br><span class=\"line\">    arr.push(&#123;</span><br><span class=\"line\">        x:<span class=\"number\">0</span>,</span><br><span class=\"line\">        y:<span class=\"number\">0</span>,</span><br><span class=\"line\">        path: <span class=\"string\">'0,0'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    visited[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(arr.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> current = arr.shift() <span class=\"comment\">// 当前方向上节点出队</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (current.x == m<span class=\"number\">-1</span> &amp;&amp; current.y == n<span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(current.path)<span class=\"comment\">// 打印当前路径</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> dir <span class=\"keyword\">of</span> dirs) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> nx = current.x + dir[<span class=\"number\">0</span>]</span><br><span class=\"line\">            <span class=\"keyword\">var</span> ny = current.y + dir[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 分别判断当前节点是否是有效节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nx &lt; m &amp;&amp; <span class=\"comment\">// 迷宫边界</span></span><br><span class=\"line\">                nx &gt;=<span class=\"number\">0</span> &amp;&amp; </span><br><span class=\"line\">                ny &lt; n &amp;&amp; </span><br><span class=\"line\">                ny &gt;=<span class=\"number\">0</span> &amp;&amp; </span><br><span class=\"line\">                matrix[nx][ny] == <span class=\"number\">0</span> &amp;&amp; <span class=\"comment\">// 是否通路0：通路1：障碍</span></span><br><span class=\"line\">                visited[nx][ny] == <span class=\"literal\">false</span>) &#123;<span class=\"comment\">// 是否已访问过</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 根据当前路径记录走过的路径</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> _path = current.path + <span class=\"string\">'-'</span>+nx+<span class=\"string\">','</span>+ny+<span class=\"string\">''</span></span><br><span class=\"line\">                <span class=\"comment\">// 节点入队</span></span><br><span class=\"line\">                arr.push(&#123;</span><br><span class=\"line\">                    x:nx,</span><br><span class=\"line\">                    y:ny,</span><br><span class=\"line\">                    path:_path</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                <span class=\"comment\">// 标记已访问过</span></span><br><span class=\"line\">                visited[nx][ny] = <span class=\"literal\">true</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此，我们分别使用广度优先搜素和深度优先搜索完成的迷宫问题，当然，这只是最简单的迷宫问题，类似还有很多变种。</p>\n<h2><span id=\"迷宫问题变种\">迷宫问题变种</span></h2><ul>\n<li>方向增加</li>\n</ul>\n<p>例如：每个点有8个方向可以移动，我们可以通过修改方向数组的方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var dirs = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[-1,-1],[1,-1],[-1,1]]</span><br><span class=\"line\">// 分别对应右，左，上，下，右上，左下，右下，左上</span><br></pre></td></tr></table></figure>\n<ul>\n<li>小球滚动题目：</li>\n</ul>\n<p>在迷宫中有一个球，里面有空的空间和墙壁。球可以通过滚<code>上</code>，<code>下</code>，<code>左</code>或<code>右</code>移动，但它不会停止滚动直到撞到墙上。当球停止时，它可以选择下一个方向，求小球从起点到终点的最短路径。</p>\n<p>这个题目中的最大不同就是小球在遇到障碍物时不会停止，而是可以向四个方向移动，直到遇到墙面才会停止，所以我们针对上面的思路，梳理出两个改动点：</p>\n<ol>\n<li>把是否遇到墙壁，即迷宫边界单独判断。</li>\n<li>将<code>if</code>改为<code>while</code>即循环判断是否是有效路径。</li>\n</ol>\n<p>代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shortestDistance(maze,start,destination) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> m = maze.length</span><br><span class=\"line\">  <span class=\"keyword\">var</span> n = maze[<span class=\"number\">0</span>].length</span><br><span class=\"line\">  <span class=\"keyword\">var</span> res = <span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER</span><br><span class=\"line\">  <span class=\"keyword\">var</span> visited = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(m).fill(<span class=\"string\">''</span>).map(<span class=\"function\"><span class=\"params\">d</span>=&gt;</span><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n).fill(<span class=\"literal\">false</span>))</span><br><span class=\"line\">  <span class=\"keyword\">var</span> dirs = [[<span class=\"number\">-1</span>, <span class=\"number\">0</span>], [<span class=\"number\">1</span>, <span class=\"number\">0</span>], [<span class=\"number\">0</span>, <span class=\"number\">-1</span>], [<span class=\"number\">0</span>, <span class=\"number\">1</span>]];</span><br><span class=\"line\">  <span class=\"comment\">// 抽离出墙面迷宫边界</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> notWall = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> x &gt;= <span class=\"number\">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class=\"number\">0</span> &amp;&amp; y &lt; n;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> dfs = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y,step</span>)</span>&#123;</span><br><span class=\"line\">      </span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(x == destination[<span class=\"number\">0</span>] &amp;&amp; y == destination[<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">          res = <span class=\"built_in\">Math</span>.min(res,step)</span><br><span class=\"line\">          <span class=\"keyword\">return</span> </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> dir <span class=\"keyword\">of</span> dirs) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> nx = x, ny = y;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> _step = step</span><br><span class=\"line\">          <span class=\"comment\">// 这里改为循环判断</span></span><br><span class=\"line\">          <span class=\"keyword\">while</span>(notWall(nx + dir[<span class=\"number\">0</span>], ny + dir[<span class=\"number\">1</span>]) &amp;&amp; maze[nx+dir[<span class=\"number\">0</span>]][ny+dir[<span class=\"number\">1</span>]] != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">              nx += dir[<span class=\"number\">0</span>];</span><br><span class=\"line\">              ny += dir[<span class=\"number\">1</span>];</span><br><span class=\"line\">              _step = _step+<span class=\"number\">1</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span>(!visited[nx][ny]) &#123;</span><br><span class=\"line\">              visited[nx][ny] = <span class=\"literal\">true</span></span><br><span class=\"line\">              dfs(nx,ny,_step)</span><br><span class=\"line\">              visited[nx][ny] = <span class=\"literal\">false</span></span><br><span class=\"line\">              </span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  dfs(start[<span class=\"number\">0</span>],start[<span class=\"number\">1</span>],<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res == <span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER ? <span class=\"number\">-1</span> : res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>其他题目</li>\n</ul>\n<p>例如在迷宫中增加随机传送门，LeetCode 200.岛屿数量，LeetCode  695.岛屿最大面积 等等的题目，都是属于迷宫问题的变种，其核心思想都是采用深度优先和广度优先搜索来解决。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"迷宫问题\"><a href=\"#迷宫问题\" class=\"headerlink\" title=\"迷宫问题\"></a>迷宫问题</h2><p>我们常常会遇到各种迷宫问题，即从起点走到终点，会有哪些路径：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b13f4a474daf459cb1d43bbd5683b851~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"><br>","more":"<br>或者是求起点到终点最短路径：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e822b6cc3b24d1bbf04b7aefca48b49~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>对于这类迷宫问题，我们使用程序化的思想，可以简单的抽象成一个M*N的二维数组矩阵，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> matrix = </span><br><span class=\"line\">    [[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">    [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">    [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">    [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">    [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">    [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]]</span><br></pre></td></tr></table></figure>\n<p>上面二维数组中，取左上角为起点，右下角为终点，每个点有上下左右一共4个方向可以走，0表示通路可以通过，1表示障碍物不能通过，求从起点到终点共有多少种走法。</p>\n<p>如下所示其中一种走法，我们用“#”代表走过的路径：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdad46710f17453da929b292e3124fc0~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>我们可以很容易的找到1种走法，当然这只是对于矩阵比较小的情况下，如果矩阵足够大，那么就需要转换成程序语言来解答了。</p>\n<h2 id=\"深度优先搜索\"><a href=\"#深度优先搜索\" class=\"headerlink\" title=\"深度优先搜索\"></a>深度优先搜索</h2><p>深度优先搜索也叫深度优先遍历是一种常见的搜索方法，它的特点就是一条路走到深，不撞南墙不回头。深度优先遍历迷宫，流程如下：</p>\n<ol>\n<li>访问起点s。</li>\n<li>依次从s的未被访问的邻接点出发，在某一方向上进行搜索，直至该方向搜索完毕，并且和s有路径相通的点都被访问。</li>\n<li>若此时还有未被访问的节点，则从一个未被访问的节点出发，重新进行深度搜索，直到所有节点均被访问为止。</li>\n<li>循环上述操作，直到访问到终点e为止。</li>\n</ol>\n<p>在进行搜索的同时，我们需要增加一些判断条件来规避一些非法的路径状态，</p>\n<ol>\n<li>当前节点是通路。</li>\n<li>当前节点没有超过迷宫范围。</li>\n<li>当前节点在同一路径中不应被访问第二次。</li>\n</ol>\n<p>最后，在搜索的同时需要记录访问过的路径，根据上面的思路，转换成JavaScript代码，我们采用递归来实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mazeSearch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> matrix = </span><br><span class=\"line\">        [[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>],</span><br><span class=\"line\">         [<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>],</span><br><span class=\"line\">         [<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>],</span><br><span class=\"line\">         [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>],</span><br><span class=\"line\">         [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>],</span><br><span class=\"line\">         [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>]]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> m = matrix.length</span><br><span class=\"line\">    <span class=\"keyword\">var</span> n = matrix[<span class=\"number\">0</span>].length</span><br><span class=\"line\">    <span class=\"comment\">// 此数组用来记录当前节点是否被访问过</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> visited = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(m).fill(<span class=\"string\">''</span>).map(<span class=\"function\">(<span class=\"params\">d</span>)=&gt;</span><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n).fill(<span class=\"literal\">false</span>)) </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> dirs = [[<span class=\"number\">0</span>,<span class=\"number\">1</span>],[<span class=\"number\">0</span>,<span class=\"number\">-1</span>],[<span class=\"number\">1</span>,<span class=\"number\">0</span>],[<span class=\"number\">-1</span>,<span class=\"number\">0</span>]] <span class=\"comment\">// 当前节点可走的4个方向，分别对应右，左，上，下</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> dfs = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y,path</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 到达终点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x == m<span class=\"number\">-1</span> &amp;&amp; y == n<span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(path) <span class=\"comment\">// 打印当前路径</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> dir <span class=\"keyword\">of</span> dirs) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">var</span> nx = x + dir[<span class=\"number\">0</span>]</span><br><span class=\"line\">            <span class=\"keyword\">var</span> ny = y + dir[<span class=\"number\">1</span>]</span><br><span class=\"line\">            <span class=\"comment\">// 分别判断当前节点是否是有效节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nx &lt; m &amp;&amp; <span class=\"comment\">// 迷宫边界</span></span><br><span class=\"line\">                nx &gt;=<span class=\"number\">0</span> &amp;&amp; </span><br><span class=\"line\">                ny &lt; n &amp;&amp; </span><br><span class=\"line\">                ny &gt;=<span class=\"number\">0</span> &amp;&amp; </span><br><span class=\"line\">                matrix[nx][ny] == <span class=\"number\">0</span> &amp;&amp; <span class=\"comment\">// 是否通路0：通路1：障碍</span></span><br><span class=\"line\">                visited[nx][ny] == <span class=\"literal\">false</span>) &#123;<span class=\"comment\">// 是否已访问过</span></span><br><span class=\"line\">                <span class=\"comment\">// 当访问该节点时，标记已访问</span></span><br><span class=\"line\">                visited[nx][ny] = <span class=\"literal\">true</span></span><br><span class=\"line\">                <span class=\"comment\">// 进入递归，每次递归都表示一个完整路径</span></span><br><span class=\"line\">                <span class=\"comment\">// 需要传入当前节点和已经访问过的路径</span></span><br><span class=\"line\">                dfs(nx,ny,path+<span class=\"string\">'-'</span>+nx+<span class=\"string\">','</span>+ny)</span><br><span class=\"line\">                <span class=\"comment\">// 每次路径完成时，针对该节点需要回溯原始状态</span></span><br><span class=\"line\">                visited[nx][ny] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 进入起点</span></span><br><span class=\"line\">    dfs(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"string\">'0,0'</span>)</span><br><span class=\"line\">    visited[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码会打印出从起点到终点的所有路径，最终右212种走法，我们可以随机画出其中几个解法的路径，如下图：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ec638b1240645678f3ed996da86eac3~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>每种路径上面的数字代表当前路径的长度即所经过的节点数，可以看到不同的路径有不同的长度，那么，我们是否能在这212种走法里面找到最短的那一种呢，这就涉及到最优解，我们只需改造部分代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mazeSearch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> res = &#123;</span><br><span class=\"line\">        path:<span class=\"literal\">null</span>,</span><br><span class=\"line\">        len:<span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dfs = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y,path</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 到达终点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x == m<span class=\"number\">-1</span> &amp;&amp; y == n<span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 得到当前路径长度</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> currentLen = path.split(<span class=\"string\">'-'</span>).length</span><br><span class=\"line\">            <span class=\"comment\">// 如果当前路径小于结果路径，则取结果路径</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (res.len &gt; currentLen) &#123;</span><br><span class=\"line\">                res = &#123;</span><br><span class=\"line\">                    path:path,</span><br><span class=\"line\">                    len:currentLen</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>打印出最优解，长度为12：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    len: 13,</span><br><span class=\"line\">    path: \"0,0-1,0-1,1-1,2-0,2-0,3-0,4-1,4-2,4-3,4-3,5-4,5-5,5\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过深度优先搜索得到最优解，其核心思想是得到所有解，然后从所有解里面找到最优解，那么我们能否采取一种效率更高的办法直接得到最优解呢？</p>\n<h2 id=\"广度优先搜索\"><a href=\"#广度优先搜索\" class=\"headerlink\" title=\"广度优先搜索\"></a>广度优先搜索</h2><p>广度优先搜索也叫宽度优先遍历是一种常见的搜索方法，它的特点沿一个点向四周方向向外扩展，也就是呈一种发散状向外边扩散，依次下去，直到搜索到所有的顶点。该思想就是二叉树的层序遍历的演变，一层一层的进行遍历。</p>\n<p>广度优先搜索通常用来求最优解，即得到结果的同时，这个结果就是最短的路径，在广度遍历时，会对节点周围相关联且未遍历的点先进行遍历，然后重复此步骤直至所有节点都被遍历。由于与一个节点相关联的节点有多个且不能同时进行遍历，所以我们需要用到队列这个数据结构模拟这种“同时”的遍历，流程和思想如下：</p>\n<ol>\n<li>访问起点s。</li>\n<li>将起点作为当前节点，遍历该点的四个方向，并压入队列，并标记为已访问过的。</li>\n<li>依次从队列中，移出队首为当前方向上的节点，记录路径。</li>\n<li>循环上述2，3步骤操作，直到访问到终点e为止。</li>\n</ol>\n<p>同样，在进行搜索的同时，我们需要增加一些判断条件来规避一些非法的路径状态，</p>\n<ol>\n<li>当前节点是通路。</li>\n<li>当前节点没有超过迷宫范围。</li>\n<li>当前节点在同一路径中不应被访问第二次。</li>\n</ol>\n<p>根据上面的思路，转换成JavaScript代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mazeSearch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> matrix = </span><br><span class=\"line\">        [[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>],</span><br><span class=\"line\">         [<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>],</span><br><span class=\"line\">         [<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>],</span><br><span class=\"line\">         [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>],</span><br><span class=\"line\">         [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>],</span><br><span class=\"line\">         [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>]]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> m = matrix.length</span><br><span class=\"line\">    <span class=\"keyword\">var</span> n = matrix[<span class=\"number\">0</span>].length</span><br><span class=\"line\">    <span class=\"comment\">// 此数组用来记录当前节点是否被访问过</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> visited = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(m).fill(<span class=\"string\">''</span>).map(<span class=\"function\">(<span class=\"params\">d</span>)=&gt;</span><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n).fill(<span class=\"literal\">false</span>))</span><br><span class=\"line\">    <span class=\"keyword\">var</span> arr = [] <span class=\"comment\">// 队列</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> dirs = [[<span class=\"number\">0</span>,<span class=\"number\">1</span>],[<span class=\"number\">0</span>,<span class=\"number\">-1</span>],[<span class=\"number\">1</span>,<span class=\"number\">0</span>],[<span class=\"number\">-1</span>,<span class=\"number\">0</span>]]<span class=\"comment\">// 当前节点可走的4个方向，分别对应右，左，上，下</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 起点入队</span></span><br><span class=\"line\">    arr.push(&#123;</span><br><span class=\"line\">        x:<span class=\"number\">0</span>,</span><br><span class=\"line\">        y:<span class=\"number\">0</span>,</span><br><span class=\"line\">        path: <span class=\"string\">'0,0'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    visited[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(arr.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> current = arr.shift() <span class=\"comment\">// 当前方向上节点出队</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (current.x == m<span class=\"number\">-1</span> &amp;&amp; current.y == n<span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(current.path)<span class=\"comment\">// 打印当前路径</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> dir <span class=\"keyword\">of</span> dirs) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> nx = current.x + dir[<span class=\"number\">0</span>]</span><br><span class=\"line\">            <span class=\"keyword\">var</span> ny = current.y + dir[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 分别判断当前节点是否是有效节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nx &lt; m &amp;&amp; <span class=\"comment\">// 迷宫边界</span></span><br><span class=\"line\">                nx &gt;=<span class=\"number\">0</span> &amp;&amp; </span><br><span class=\"line\">                ny &lt; n &amp;&amp; </span><br><span class=\"line\">                ny &gt;=<span class=\"number\">0</span> &amp;&amp; </span><br><span class=\"line\">                matrix[nx][ny] == <span class=\"number\">0</span> &amp;&amp; <span class=\"comment\">// 是否通路0：通路1：障碍</span></span><br><span class=\"line\">                visited[nx][ny] == <span class=\"literal\">false</span>) &#123;<span class=\"comment\">// 是否已访问过</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 根据当前路径记录走过的路径</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> _path = current.path + <span class=\"string\">'-'</span>+nx+<span class=\"string\">','</span>+ny+<span class=\"string\">''</span></span><br><span class=\"line\">                <span class=\"comment\">// 节点入队</span></span><br><span class=\"line\">                arr.push(&#123;</span><br><span class=\"line\">                    x:nx,</span><br><span class=\"line\">                    y:ny,</span><br><span class=\"line\">                    path:_path</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                <span class=\"comment\">// 标记已访问过</span></span><br><span class=\"line\">                visited[nx][ny] = <span class=\"literal\">true</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此，我们分别使用广度优先搜素和深度优先搜索完成的迷宫问题，当然，这只是最简单的迷宫问题，类似还有很多变种。</p>\n<h2 id=\"迷宫问题变种\"><a href=\"#迷宫问题变种\" class=\"headerlink\" title=\"迷宫问题变种\"></a>迷宫问题变种</h2><ul>\n<li>方向增加</li>\n</ul>\n<p>例如：每个点有8个方向可以移动，我们可以通过修改方向数组的方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var dirs = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[-1,-1],[1,-1],[-1,1]]</span><br><span class=\"line\">// 分别对应右，左，上，下，右上，左下，右下，左上</span><br></pre></td></tr></table></figure>\n<ul>\n<li>小球滚动题目：</li>\n</ul>\n<p>在迷宫中有一个球，里面有空的空间和墙壁。球可以通过滚<code>上</code>，<code>下</code>，<code>左</code>或<code>右</code>移动，但它不会停止滚动直到撞到墙上。当球停止时，它可以选择下一个方向，求小球从起点到终点的最短路径。</p>\n<p>这个题目中的最大不同就是小球在遇到障碍物时不会停止，而是可以向四个方向移动，直到遇到墙面才会停止，所以我们针对上面的思路，梳理出两个改动点：</p>\n<ol>\n<li>把是否遇到墙壁，即迷宫边界单独判断。</li>\n<li>将<code>if</code>改为<code>while</code>即循环判断是否是有效路径。</li>\n</ol>\n<p>代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shortestDistance(maze,start,destination) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> m = maze.length</span><br><span class=\"line\">  <span class=\"keyword\">var</span> n = maze[<span class=\"number\">0</span>].length</span><br><span class=\"line\">  <span class=\"keyword\">var</span> res = <span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER</span><br><span class=\"line\">  <span class=\"keyword\">var</span> visited = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(m).fill(<span class=\"string\">''</span>).map(<span class=\"function\"><span class=\"params\">d</span>=&gt;</span><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n).fill(<span class=\"literal\">false</span>))</span><br><span class=\"line\">  <span class=\"keyword\">var</span> dirs = [[<span class=\"number\">-1</span>, <span class=\"number\">0</span>], [<span class=\"number\">1</span>, <span class=\"number\">0</span>], [<span class=\"number\">0</span>, <span class=\"number\">-1</span>], [<span class=\"number\">0</span>, <span class=\"number\">1</span>]];</span><br><span class=\"line\">  <span class=\"comment\">// 抽离出墙面迷宫边界</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> notWall = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> x &gt;= <span class=\"number\">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class=\"number\">0</span> &amp;&amp; y &lt; n;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> dfs = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y,step</span>)</span>&#123;</span><br><span class=\"line\">      </span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(x == destination[<span class=\"number\">0</span>] &amp;&amp; y == destination[<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">          res = <span class=\"built_in\">Math</span>.min(res,step)</span><br><span class=\"line\">          <span class=\"keyword\">return</span> </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> dir <span class=\"keyword\">of</span> dirs) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> nx = x, ny = y;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> _step = step</span><br><span class=\"line\">          <span class=\"comment\">// 这里改为循环判断</span></span><br><span class=\"line\">          <span class=\"keyword\">while</span>(notWall(nx + dir[<span class=\"number\">0</span>], ny + dir[<span class=\"number\">1</span>]) &amp;&amp; maze[nx+dir[<span class=\"number\">0</span>]][ny+dir[<span class=\"number\">1</span>]] != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">              nx += dir[<span class=\"number\">0</span>];</span><br><span class=\"line\">              ny += dir[<span class=\"number\">1</span>];</span><br><span class=\"line\">              _step = _step+<span class=\"number\">1</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span>(!visited[nx][ny]) &#123;</span><br><span class=\"line\">              visited[nx][ny] = <span class=\"literal\">true</span></span><br><span class=\"line\">              dfs(nx,ny,_step)</span><br><span class=\"line\">              visited[nx][ny] = <span class=\"literal\">false</span></span><br><span class=\"line\">              </span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  dfs(start[<span class=\"number\">0</span>],start[<span class=\"number\">1</span>],<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res == <span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER ? <span class=\"number\">-1</span> : res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>其他题目</li>\n</ul>\n<p>例如在迷宫中增加随机传送门，LeetCode 200.岛屿数量，LeetCode  695.岛屿最大面积 等等的题目，都是属于迷宫问题的变种，其核心思想都是采用深度优先和广度优先搜索来解决。</p>"},{"title":"博客内容转移至慕课网手记,掘金,知乎专栏告知","date":"2020-03-02T09:26:17.000Z","sticky":2,"_content":"\n### 原因\n\n介于博客的入口流量过于单一，并且越来越多的博主将文章发表在第三方的技术平台中，不仅省去了日常运维等工作，而且能够借助平台的流量涨粉。毕竟除非将个人博客运营的非常好，否则，将文章发表到第三方的技术平台已成为趋势。\n\n### 入口地址\n\n* 慕课网手记：[@吕小鸣](https://www.imooc.com/u/139514/articles)\n\n* 掘金：[@吕小鸣](https://juejin.im/user/591ea3c32f301e006becc1bc)\n\n* 知乎专栏：[@吕小鸣Developer](https://zhuanlan.zhihu.com/c_1145300130113662976)\n\n* GitHub：[@lvming6816077](https://github.com/lvming6816077)\n\n\n### 其它\n\n对于想要折腾的同学来说，从零搭建一个博客系统也是能学到不少东西的，当然如果各位遇到任何前端相关的技术问题，也欢迎和我沟通和留言，感谢各位的支持，多点关注哦。","source":"_posts/博客内容转移至慕课网手记,掘金,知乎专栏告知.md","raw":"---\ntitle: 博客内容转移至慕课网手记,掘金,知乎专栏告知\ndate: 2020-02-31 17:26:17\ntags:\n- 专栏\ncategories:\n- 1111\n\nsticky: 2\n---\n\n### 原因\n\n介于博客的入口流量过于单一，并且越来越多的博主将文章发表在第三方的技术平台中，不仅省去了日常运维等工作，而且能够借助平台的流量涨粉。毕竟除非将个人博客运营的非常好，否则，将文章发表到第三方的技术平台已成为趋势。\n\n### 入口地址\n\n* 慕课网手记：[@吕小鸣](https://www.imooc.com/u/139514/articles)\n\n* 掘金：[@吕小鸣](https://juejin.im/user/591ea3c32f301e006becc1bc)\n\n* 知乎专栏：[@吕小鸣Developer](https://zhuanlan.zhihu.com/c_1145300130113662976)\n\n* GitHub：[@lvming6816077](https://github.com/lvming6816077)\n\n\n### 其它\n\n对于想要折腾的同学来说，从零搭建一个博客系统也是能学到不少东西的，当然如果各位遇到任何前端相关的技术问题，也欢迎和我沟通和留言，感谢各位的支持，多点关注哦。","slug":"博客内容转移至慕课网手记,掘金,知乎专栏告知","published":1,"updated":"2021-12-13T02:35:38.660Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434q14002z2wvjjjw2nqhz","content":"<h3><span id=\"原因\">原因</span></h3><p>介于博客的入口流量过于单一，并且越来越多的博主将文章发表在第三方的技术平台中，不仅省去了日常运维等工作，而且能够借助平台的流量涨粉。毕竟除非将个人博客运营的非常好，否则，将文章发表到第三方的技术平台已成为趋势。</p>\n<h3><span id=\"入口地址\">入口地址</span></h3><ul>\n<li><p>慕课网手记：<a href=\"https://www.imooc.com/u/139514/articles\" target=\"_blank\" rel=\"noopener\">@吕小鸣</a></p>\n</li>\n<li><p>掘金：<a href=\"https://juejin.im/user/591ea3c32f301e006becc1bc\" target=\"_blank\" rel=\"noopener\">@吕小鸣</a></p>\n</li>\n<li><p>知乎专栏：<a href=\"https://zhuanlan.zhihu.com/c_1145300130113662976\" target=\"_blank\" rel=\"noopener\">@吕小鸣Developer</a></p>\n</li>\n<li><p>GitHub：<a href=\"https://github.com/lvming6816077\" target=\"_blank\" rel=\"noopener\">@lvming6816077</a></p>\n</li>\n</ul>\n<h3><span id=\"其它\">其它</span></h3><p>对于想要折腾的同学来说，从零搭建一个博客系统也是能学到不少东西的，当然如果各位遇到任何前端相关的技术问题，也欢迎和我沟通和留言，感谢各位的支持，多点关注哦。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>介于博客的入口流量过于单一，并且越来越多的博主将文章发表在第三方的技术平台中，不仅省去了日常运维等工作，而且能够借助平台的流量涨粉。毕竟除非将个人博客运营的非常好，否则，将文章发表到第三方的技术平台已成为趋势。</p>\n<h3 id=\"入口地址\"><a href=\"#入口地址\" class=\"headerlink\" title=\"入口地址\"></a>入口地址</h3><ul>\n<li><p>慕课网手记：<a href=\"https://www.imooc.com/u/139514/articles\" target=\"_blank\" rel=\"noopener\">@吕小鸣</a></p>\n</li>\n<li><p>掘金：<a href=\"https://juejin.im/user/591ea3c32f301e006becc1bc\" target=\"_blank\" rel=\"noopener\">@吕小鸣</a></p>\n</li>\n<li><p>知乎专栏：<a href=\"https://zhuanlan.zhihu.com/c_1145300130113662976\" target=\"_blank\" rel=\"noopener\">@吕小鸣Developer</a></p>\n</li>\n<li><p>GitHub：<a href=\"https://github.com/lvming6816077\" target=\"_blank\" rel=\"noopener\">@lvming6816077</a></p>\n</li>\n</ul>\n<h3 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h3><p>对于想要折腾的同学来说，从零搭建一个博客系统也是能学到不少东西的，当然如果各位遇到任何前端相关的技术问题，也欢迎和我沟通和留言，感谢各位的支持，多点关注哦。</p>\n"},{"title":"号外！本博客已经全面升级HTTPS啦","date":"2016-11-02T12:57:57.000Z","photos":["https://qiniu.nihaoshijie.com.cn/httpslogo2.png"],"_content":"<h3><a href=\"https://www.nihaoshijie.com.cn\">吕小鸣的前端博客</a></h3><h3>目前已经全站从HTTP升级成HTTPS啦，漂亮的小绿锁终于看到了！</h3>\n<!--more-->\n<p>在此总结了升级过程中的心路历程供大家参考！</p><h4><span style=\"text-decoration: underline; color: #0000ff;\">1.证书申请</span></h4><h4><span style=\"text-decoration: underline; color: #0000ff;\">2.服务器修改配置</span></h4><h4><span style=\"text-decoration: underline; color: #0000ff;\">3.CDN资源和链接地址 https修改</span></h4><h4><span style=\"text-decoration: underline; color: #0000ff;\">4.全站https改造</span></h4>","source":"_posts/号外！本博客已经全面升级HTTPS啦.md","raw":"---\ntitle: 号外！本博客已经全面升级HTTPS啦\ndate: 2016-11-02 20:57:57\ntags:\n- https\ncategories:\n- 646\nphotos: https://qiniu.nihaoshijie.com.cn/httpslogo2.png\n---\n<h3><a href=\"https://www.nihaoshijie.com.cn\">吕小鸣的前端博客</a></h3><h3>目前已经全站从HTTP升级成HTTPS啦，漂亮的小绿锁终于看到了！</h3>\n<!--more-->\n<p>在此总结了升级过程中的心路历程供大家参考！</p><h4><span style=\"text-decoration: underline; color: #0000ff;\">1.证书申请</span></h4><h4><span style=\"text-decoration: underline; color: #0000ff;\">2.服务器修改配置</span></h4><h4><span style=\"text-decoration: underline; color: #0000ff;\">3.CDN资源和链接地址 https修改</span></h4><h4><span style=\"text-decoration: underline; color: #0000ff;\">4.全站https改造</span></h4>","slug":"号外！本博客已经全面升级HTTPS啦","published":1,"updated":"2019-04-02T16:49:40.000Z","comments":1,"layout":"post","link":"","_id":"ckx434q1500302wvjejg73dv3","content":"<p></p><h3><span id=\"吕小鸣的前端博客\"></span></h3><h3><span id=\"目前已经全站从http升级成https啦漂亮的小绿锁终于看到了\">目前已经全站从HTTP升级成HTTPS啦，漂亮的小绿锁终于看到了！</span></h3><br><a id=\"more\"></a><p></p>\n<p></p><p>在此总结了升级过程中的心路历程供大家参考！</p><h4><span id=\"1证书申请\"><span style=\"text-decoration: underline; color: #0000ff;\">1.证书申请</span></span></h4><h4><span id=\"2服务器修改配置\"><span style=\"text-decoration: underline; color: #0000ff;\">2.服务器修改配置</span></span></h4><h4><span id=\"3cdn资源和链接地址-https修改\"><span style=\"text-decoration: underline; color: #0000ff;\">3.CDN资源和链接地址 https修改</span></span></h4><h4><span id=\"4全站https改造\"><span style=\"text-decoration: underline; color: #0000ff;\">4.全站https改造</span></span></h4><p></p>\n","site":{"data":{}},"excerpt":"<p></p><h3><a href=\"https://www.nihaoshijie.com.cn\">吕小鸣的前端博客</a></h3><h3>目前已经全站从HTTP升级成HTTPS啦，漂亮的小绿锁终于看到了！</h3><br>","more":"<p></p>\n<p></p><p>在此总结了升级过程中的心路历程供大家参考！</p><h4><span style=\"text-decoration: underline; color: #0000ff;\">1.证书申请</span></h4><h4><span style=\"text-decoration: underline; color: #0000ff;\">2.服务器修改配置</span></h4><h4><span style=\"text-decoration: underline; color: #0000ff;\">3.CDN资源和链接地址 https修改</span></h4><h4><span style=\"text-decoration: underline; color: #0000ff;\">4.全站https改造</span></h4><p></p>"},{"title":"吕小鸣博客搬家记Hexo","date":"2017-05-01T10:30:23.000Z","_content":">又名hexo折腾记。\n用了3年的博客，是时候对自己的博客好好整理了一下，从wordpress迁移到了hexo+github了，忽然感觉hexo大法好啊！\n\n#### 1.为啥要迁移博客?\n<!--more-->\n* 从2014年开始写博客之后，都是运行在wordpress上的，当时刚接触php，对wordpress热情很高，也尝试过自己写wordpress主题，但是无奈不会设计，最终还是放弃了。\n* 之前利用wordpress博客时部署在香港的vps上的，200块一年（没钱买阿里云或者腾讯云），所以速度很慢，首屏的时间很长，体验不好。\n* wordpress本事也显得较为笨重，也不是说wordpress不好，但用久了总想尝试一些新的东西。\n* 在加上身为一个前端工程师无法长期忍受菊花时间所以就萌生了迁移博客的想法，遂开始实践。\n\n#### 2.迁移策略\n* 想放弃wordpress之前也找了一些其他的替代最后筛选下来剩下[jekyll](http://jekyll.com.cn/),[hexo](https://hexo.io/)这两个选择。\n\t* jekyll和hexo都是基于静态的博客服务，就是说不需要后台数据库跟wordpress有很大区别，完全纯前端实现。md文件实现。\n\t* jekyll基于ruby，hexo基于nodejs。\n\t* hexo本地调试较jekyll方便很多，直接本地起一个node服务，前端学习成本低。\n\t* hexo主题比较多。\n* 所以最终选择的hexo。\n* 借助GitPage和hexo这两个黄金搭配，最终确认了迁移策略。\n\n#### 3.如何迁移\n* 关于hexo＋GitPage快速生成博客的教程，网上已经有大把大把的了，所以我这里就不具体说了，说一下遇到的一些问题。\n\t1. 迁移博客最大的难点在于如何保证迁移前后的文章链接固定，由于之前的wordpress采用的是index.php+archives+文章id的方式来构建的，所以在利用静态文件时要想办法构造出这个链接，好在hexo提供了[Front-matter](https://hexo.io/docs/front-matter.html)的方式,巧妙的利用了category来配置id实现了这个链接。\n\t```javascript\n\tpermalink: index.php/archives/:category/\n\t```\n\t```\n\ttitle: 吕小鸣博客搬家记\n\tdate: 2017-05-01 18:30:23\n\tcategories:\n\t- 700\n\t```\n* hexo官方提供了wordpress文章迁移到hexo生成md文件的[插件](https://hexo.io/docs/migration.html#WordPress),但是对于我之前的博客基本上时用不了的，毕竟之前的博客文章代码太乱，就算生成好了也要一个一个改，所以便做了一个艰难的决定，自己手工来改。\n* 看了一下我的所有博客，整整50篇，遂挑选了一些有必要改的来手工改，毕竟从2014年时写的文章有些也比较小白，不迁移也行。\n* 按照官方文档上的步骤将hexo的文章建立了起来，同时将静态文件上传到Github的GitPage上托管，方便很多，在也不用下个ftp工具在服务器上改wordpress代码了。\n\n#### 4.辅助插件的选择\n* 之前用的多说第三方评论插件在5月底就要到期了，说实话多说插件用了很久，感觉还是很不错的，无奈即将无法使用，还是有些遗憾的了。\n* hexo默认集成了[Disqus](http://www.disqus.com/)社交评论插件，但是Disqus毕竟时国外的，很多登录账户还是需要twtter或者faceboox才能登录，而且速度比较慢，在国内用的还是少，所以没有使用这个插件。\n* 大概找了 [有言](http://www.uyan.cc/)，[搜狐畅聊](http://changyan.kuaizhan.com/)，[网易云跟帖](https://gentie.163.com/info.html) 三种评论插件之后，最终选择了 网易云跟帖,怎么说呢，比较合我的胃口。\n```javascript\nvar cloudTieConfig = {\n  url: document.location.href.replace('https','').replace('http',''),\n  sourceId: \"\",\n  productKey: \"eb0b276c0f00410db0322e1a9a9b8bbc\",\n  target: \"cloud-tie-wrapper\"\n};\nvar yunManualLoad = true;\nTie.loader(\"aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s\", true);\n```\n这里有一个技巧，为了防止以后博客评论可以随着文章链接迁移，特地将https和http的唯一标识去掉了。\n\n#### 5.自定义域名使用https\n* 在使用了GitPage之后域名默认时username.github.io想要修改成自己的域名并不难，在你域名的dns解析面板上修改解析规则到github的ip即可，同时在source上调价CNAME文件，具体细节网上有很多教程。\n* 但是难点在于将自己的自定义域名增加https的支持，在什么都不改的情况下访问https的网页会报一个\n![](https://qiniu.nihaoshijie.com.cn/blogA262222C-9392-4F08-BF75-A8E937E58DC8.png)错误，意思就是github的证书不能应用在你自定义的域名上。\n* 在网上找了解决办法采用[Cloudflare](https://www.cloudflare.com/)代理的方式来实现https访问，原理就是\n![](https://qiniu.nihaoshijie.com.cn/blog/513492664b24d.jpg)\n* 简单来说就是Cloudflare注册成功之后Cloudflare会提供给你2个dns服务器地址，修改你的域名的dns解析的服务器成这两个地址，Cloudflare在平台上免费部署了ssl，所以以后的域名解析都在cloudflare上托管了。\n* 这个折腾起来还是很复杂的，再加上家里网速访问Cloudflare太慢，至今还没有完全部署成https，以后在继续研究。\n\n**总之，博客迁移完成之后还是很有成就感的，后续会继续优化一个博客主题，让博客变得更炫目一些！**\n***\n* 本博客使用的主题是在 [Landscape-plus](https://github.com/xiangming/landscape-plus)的基础上修改的。\n* 本博客使用的插件 \n\t* [网易云跟帖](https://gentie.163.com/info.html)。\n\t* [busuanzi计数](http://busuanzi.ibruce.info/)。\n\t* [LearnCloud数据存储](https://leancloud.cn/)。\n\t* [七牛云图床](https://portal.qiniu.com/bucket/tenny/resource)。","source":"_posts/吕小鸣博客搬家记.md","raw":"---\ntitle: 吕小鸣博客搬家记Hexo\ndate: 2017-05-01 18:30:23\ncategories:\n- 700\ntags:\n- 博客搬家\n- hexo\n- wordpress\n---\n>又名hexo折腾记。\n用了3年的博客，是时候对自己的博客好好整理了一下，从wordpress迁移到了hexo+github了，忽然感觉hexo大法好啊！\n\n#### 1.为啥要迁移博客?\n<!--more-->\n* 从2014年开始写博客之后，都是运行在wordpress上的，当时刚接触php，对wordpress热情很高，也尝试过自己写wordpress主题，但是无奈不会设计，最终还是放弃了。\n* 之前利用wordpress博客时部署在香港的vps上的，200块一年（没钱买阿里云或者腾讯云），所以速度很慢，首屏的时间很长，体验不好。\n* wordpress本事也显得较为笨重，也不是说wordpress不好，但用久了总想尝试一些新的东西。\n* 在加上身为一个前端工程师无法长期忍受菊花时间所以就萌生了迁移博客的想法，遂开始实践。\n\n#### 2.迁移策略\n* 想放弃wordpress之前也找了一些其他的替代最后筛选下来剩下[jekyll](http://jekyll.com.cn/),[hexo](https://hexo.io/)这两个选择。\n\t* jekyll和hexo都是基于静态的博客服务，就是说不需要后台数据库跟wordpress有很大区别，完全纯前端实现。md文件实现。\n\t* jekyll基于ruby，hexo基于nodejs。\n\t* hexo本地调试较jekyll方便很多，直接本地起一个node服务，前端学习成本低。\n\t* hexo主题比较多。\n* 所以最终选择的hexo。\n* 借助GitPage和hexo这两个黄金搭配，最终确认了迁移策略。\n\n#### 3.如何迁移\n* 关于hexo＋GitPage快速生成博客的教程，网上已经有大把大把的了，所以我这里就不具体说了，说一下遇到的一些问题。\n\t1. 迁移博客最大的难点在于如何保证迁移前后的文章链接固定，由于之前的wordpress采用的是index.php+archives+文章id的方式来构建的，所以在利用静态文件时要想办法构造出这个链接，好在hexo提供了[Front-matter](https://hexo.io/docs/front-matter.html)的方式,巧妙的利用了category来配置id实现了这个链接。\n\t```javascript\n\tpermalink: index.php/archives/:category/\n\t```\n\t```\n\ttitle: 吕小鸣博客搬家记\n\tdate: 2017-05-01 18:30:23\n\tcategories:\n\t- 700\n\t```\n* hexo官方提供了wordpress文章迁移到hexo生成md文件的[插件](https://hexo.io/docs/migration.html#WordPress),但是对于我之前的博客基本上时用不了的，毕竟之前的博客文章代码太乱，就算生成好了也要一个一个改，所以便做了一个艰难的决定，自己手工来改。\n* 看了一下我的所有博客，整整50篇，遂挑选了一些有必要改的来手工改，毕竟从2014年时写的文章有些也比较小白，不迁移也行。\n* 按照官方文档上的步骤将hexo的文章建立了起来，同时将静态文件上传到Github的GitPage上托管，方便很多，在也不用下个ftp工具在服务器上改wordpress代码了。\n\n#### 4.辅助插件的选择\n* 之前用的多说第三方评论插件在5月底就要到期了，说实话多说插件用了很久，感觉还是很不错的，无奈即将无法使用，还是有些遗憾的了。\n* hexo默认集成了[Disqus](http://www.disqus.com/)社交评论插件，但是Disqus毕竟时国外的，很多登录账户还是需要twtter或者faceboox才能登录，而且速度比较慢，在国内用的还是少，所以没有使用这个插件。\n* 大概找了 [有言](http://www.uyan.cc/)，[搜狐畅聊](http://changyan.kuaizhan.com/)，[网易云跟帖](https://gentie.163.com/info.html) 三种评论插件之后，最终选择了 网易云跟帖,怎么说呢，比较合我的胃口。\n```javascript\nvar cloudTieConfig = {\n  url: document.location.href.replace('https','').replace('http',''),\n  sourceId: \"\",\n  productKey: \"eb0b276c0f00410db0322e1a9a9b8bbc\",\n  target: \"cloud-tie-wrapper\"\n};\nvar yunManualLoad = true;\nTie.loader(\"aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s\", true);\n```\n这里有一个技巧，为了防止以后博客评论可以随着文章链接迁移，特地将https和http的唯一标识去掉了。\n\n#### 5.自定义域名使用https\n* 在使用了GitPage之后域名默认时username.github.io想要修改成自己的域名并不难，在你域名的dns解析面板上修改解析规则到github的ip即可，同时在source上调价CNAME文件，具体细节网上有很多教程。\n* 但是难点在于将自己的自定义域名增加https的支持，在什么都不改的情况下访问https的网页会报一个\n![](https://qiniu.nihaoshijie.com.cn/blogA262222C-9392-4F08-BF75-A8E937E58DC8.png)错误，意思就是github的证书不能应用在你自定义的域名上。\n* 在网上找了解决办法采用[Cloudflare](https://www.cloudflare.com/)代理的方式来实现https访问，原理就是\n![](https://qiniu.nihaoshijie.com.cn/blog/513492664b24d.jpg)\n* 简单来说就是Cloudflare注册成功之后Cloudflare会提供给你2个dns服务器地址，修改你的域名的dns解析的服务器成这两个地址，Cloudflare在平台上免费部署了ssl，所以以后的域名解析都在cloudflare上托管了。\n* 这个折腾起来还是很复杂的，再加上家里网速访问Cloudflare太慢，至今还没有完全部署成https，以后在继续研究。\n\n**总之，博客迁移完成之后还是很有成就感的，后续会继续优化一个博客主题，让博客变得更炫目一些！**\n***\n* 本博客使用的主题是在 [Landscape-plus](https://github.com/xiangming/landscape-plus)的基础上修改的。\n* 本博客使用的插件 \n\t* [网易云跟帖](https://gentie.163.com/info.html)。\n\t* [busuanzi计数](http://busuanzi.ibruce.info/)。\n\t* [LearnCloud数据存储](https://leancloud.cn/)。\n\t* [七牛云图床](https://portal.qiniu.com/bucket/tenny/resource)。","slug":"吕小鸣博客搬家记","published":1,"updated":"2019-04-02T16:49:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434q1700342wvj7d6prm6y","content":"<blockquote>\n<p>又名hexo折腾记。<br>用了3年的博客，是时候对自己的博客好好整理了一下，从wordpress迁移到了hexo+github了，忽然感觉hexo大法好啊！</p>\n</blockquote>\n<h4><span id=\"1为啥要迁移博客\">1.为啥要迁移博客?</span></h4><a id=\"more\"></a>\n<ul>\n<li>从2014年开始写博客之后，都是运行在wordpress上的，当时刚接触php，对wordpress热情很高，也尝试过自己写wordpress主题，但是无奈不会设计，最终还是放弃了。</li>\n<li>之前利用wordpress博客时部署在香港的vps上的，200块一年（没钱买阿里云或者腾讯云），所以速度很慢，首屏的时间很长，体验不好。</li>\n<li>wordpress本事也显得较为笨重，也不是说wordpress不好，但用久了总想尝试一些新的东西。</li>\n<li>在加上身为一个前端工程师无法长期忍受菊花时间所以就萌生了迁移博客的想法，遂开始实践。</li>\n</ul>\n<h4><span id=\"2迁移策略\">2.迁移策略</span></h4><ul>\n<li>想放弃wordpress之前也找了一些其他的替代最后筛选下来剩下<a href=\"http://jekyll.com.cn/\" target=\"_blank\" rel=\"noopener\">jekyll</a>,<a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">hexo</a>这两个选择。<ul>\n<li>jekyll和hexo都是基于静态的博客服务，就是说不需要后台数据库跟wordpress有很大区别，完全纯前端实现。md文件实现。</li>\n<li>jekyll基于ruby，hexo基于nodejs。</li>\n<li>hexo本地调试较jekyll方便很多，直接本地起一个node服务，前端学习成本低。</li>\n<li>hexo主题比较多。</li>\n</ul>\n</li>\n<li>所以最终选择的hexo。</li>\n<li>借助GitPage和hexo这两个黄金搭配，最终确认了迁移策略。</li>\n</ul>\n<h4><span id=\"3如何迁移\">3.如何迁移</span></h4><ul>\n<li><p>关于hexo＋GitPage快速生成博客的教程，网上已经有大把大把的了，所以我这里就不具体说了，说一下遇到的一些问题。</p>\n<ol>\n<li><p>迁移博客最大的难点在于如何保证迁移前后的文章链接固定，由于之前的wordpress采用的是index.php+archives+文章id的方式来构建的，所以在利用静态文件时要想办法构造出这个链接，好在hexo提供了<a href=\"https://hexo.io/docs/front-matter.html\" target=\"_blank\" rel=\"noopener\">Front-matter</a>的方式,巧妙的利用了category来配置id实现了这个链接。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">permalink: index.php/archives/:category/</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: 吕小鸣博客搬家记</span><br><span class=\"line\">date: 2017-05-01 18:30:23</span><br><span class=\"line\">categories:</span><br><span class=\"line\">- 700</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>hexo官方提供了wordpress文章迁移到hexo生成md文件的<a href=\"https://hexo.io/docs/migration.html#WordPress\" target=\"_blank\" rel=\"noopener\">插件</a>,但是对于我之前的博客基本上时用不了的，毕竟之前的博客文章代码太乱，就算生成好了也要一个一个改，所以便做了一个艰难的决定，自己手工来改。</p>\n</li>\n<li>看了一下我的所有博客，整整50篇，遂挑选了一些有必要改的来手工改，毕竟从2014年时写的文章有些也比较小白，不迁移也行。</li>\n<li>按照官方文档上的步骤将hexo的文章建立了起来，同时将静态文件上传到Github的GitPage上托管，方便很多，在也不用下个ftp工具在服务器上改wordpress代码了。</li>\n</ul>\n<h4><span id=\"4辅助插件的选择\">4.辅助插件的选择</span></h4><ul>\n<li>之前用的多说第三方评论插件在5月底就要到期了，说实话多说插件用了很久，感觉还是很不错的，无奈即将无法使用，还是有些遗憾的了。</li>\n<li>hexo默认集成了<a href=\"http://www.disqus.com/\" target=\"_blank\" rel=\"noopener\">Disqus</a>社交评论插件，但是Disqus毕竟时国外的，很多登录账户还是需要twtter或者faceboox才能登录，而且速度比较慢，在国内用的还是少，所以没有使用这个插件。</li>\n<li>大概找了 <a href=\"http://www.uyan.cc/\" target=\"_blank\" rel=\"noopener\">有言</a>，<a href=\"http://changyan.kuaizhan.com/\" target=\"_blank\" rel=\"noopener\">搜狐畅聊</a>，<a href=\"https://gentie.163.com/info.html\" target=\"_blank\" rel=\"noopener\">网易云跟帖</a> 三种评论插件之后，最终选择了 网易云跟帖,怎么说呢，比较合我的胃口。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cloudTieConfig = &#123;</span><br><span class=\"line\">  url: <span class=\"built_in\">document</span>.location.href.replace(<span class=\"string\">'https'</span>,<span class=\"string\">''</span>).replace(<span class=\"string\">'http'</span>,<span class=\"string\">''</span>),</span><br><span class=\"line\">  sourceId: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">  productKey: <span class=\"string\">\"eb0b276c0f00410db0322e1a9a9b8bbc\"</span>,</span><br><span class=\"line\">  target: <span class=\"string\">\"cloud-tie-wrapper\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> yunManualLoad = <span class=\"literal\">true</span>;</span><br><span class=\"line\">Tie.loader(<span class=\"string\">\"aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s\"</span>, <span class=\"literal\">true</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里有一个技巧，为了防止以后博客评论可以随着文章链接迁移，特地将https和http的唯一标识去掉了。</p>\n<h4><span id=\"5自定义域名使用https\">5.自定义域名使用https</span></h4><ul>\n<li>在使用了GitPage之后域名默认时username.github.io想要修改成自己的域名并不难，在你域名的dns解析面板上修改解析规则到github的ip即可，同时在source上调价CNAME文件，具体细节网上有很多教程。</li>\n<li>但是难点在于将自己的自定义域名增加https的支持，在什么都不改的情况下访问https的网页会报一个<br><img src=\"https://qiniu.nihaoshijie.com.cn/blogA262222C-9392-4F08-BF75-A8E937E58DC8.png\" alt>错误，意思就是github的证书不能应用在你自定义的域名上。</li>\n<li>在网上找了解决办法采用<a href=\"https://www.cloudflare.com/\" target=\"_blank\" rel=\"noopener\">Cloudflare</a>代理的方式来实现https访问，原理就是<br><img src=\"https://qiniu.nihaoshijie.com.cn/blog/513492664b24d.jpg\" alt></li>\n<li>简单来说就是Cloudflare注册成功之后Cloudflare会提供给你2个dns服务器地址，修改你的域名的dns解析的服务器成这两个地址，Cloudflare在平台上免费部署了ssl，所以以后的域名解析都在cloudflare上托管了。</li>\n<li>这个折腾起来还是很复杂的，再加上家里网速访问Cloudflare太慢，至今还没有完全部署成https，以后在继续研究。</li>\n</ul>\n<p><strong>总之，博客迁移完成之后还是很有成就感的，后续会继续优化一个博客主题，让博客变得更炫目一些！</strong></p>\n<hr>\n<ul>\n<li>本博客使用的主题是在 <a href=\"https://github.com/xiangming/landscape-plus\" target=\"_blank\" rel=\"noopener\">Landscape-plus</a>的基础上修改的。</li>\n<li>本博客使用的插件 <ul>\n<li><a href=\"https://gentie.163.com/info.html\" target=\"_blank\" rel=\"noopener\">网易云跟帖</a>。</li>\n<li><a href=\"http://busuanzi.ibruce.info/\" target=\"_blank\" rel=\"noopener\">busuanzi计数</a>。</li>\n<li><a href=\"https://leancloud.cn/\" target=\"_blank\" rel=\"noopener\">LearnCloud数据存储</a>。</li>\n<li><a href=\"https://portal.qiniu.com/bucket/tenny/resource\" target=\"_blank\" rel=\"noopener\">七牛云图床</a>。</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>又名hexo折腾记。<br>用了3年的博客，是时候对自己的博客好好整理了一下，从wordpress迁移到了hexo+github了，忽然感觉hexo大法好啊！</p>\n</blockquote>\n<h4 id=\"1-为啥要迁移博客\"><a href=\"#1-为啥要迁移博客\" class=\"headerlink\" title=\"1.为啥要迁移博客?\"></a>1.为啥要迁移博客?</h4>","more":"<ul>\n<li>从2014年开始写博客之后，都是运行在wordpress上的，当时刚接触php，对wordpress热情很高，也尝试过自己写wordpress主题，但是无奈不会设计，最终还是放弃了。</li>\n<li>之前利用wordpress博客时部署在香港的vps上的，200块一年（没钱买阿里云或者腾讯云），所以速度很慢，首屏的时间很长，体验不好。</li>\n<li>wordpress本事也显得较为笨重，也不是说wordpress不好，但用久了总想尝试一些新的东西。</li>\n<li>在加上身为一个前端工程师无法长期忍受菊花时间所以就萌生了迁移博客的想法，遂开始实践。</li>\n</ul>\n<h4 id=\"2-迁移策略\"><a href=\"#2-迁移策略\" class=\"headerlink\" title=\"2.迁移策略\"></a>2.迁移策略</h4><ul>\n<li>想放弃wordpress之前也找了一些其他的替代最后筛选下来剩下<a href=\"http://jekyll.com.cn/\" target=\"_blank\" rel=\"noopener\">jekyll</a>,<a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">hexo</a>这两个选择。<ul>\n<li>jekyll和hexo都是基于静态的博客服务，就是说不需要后台数据库跟wordpress有很大区别，完全纯前端实现。md文件实现。</li>\n<li>jekyll基于ruby，hexo基于nodejs。</li>\n<li>hexo本地调试较jekyll方便很多，直接本地起一个node服务，前端学习成本低。</li>\n<li>hexo主题比较多。</li>\n</ul>\n</li>\n<li>所以最终选择的hexo。</li>\n<li>借助GitPage和hexo这两个黄金搭配，最终确认了迁移策略。</li>\n</ul>\n<h4 id=\"3-如何迁移\"><a href=\"#3-如何迁移\" class=\"headerlink\" title=\"3.如何迁移\"></a>3.如何迁移</h4><ul>\n<li><p>关于hexo＋GitPage快速生成博客的教程，网上已经有大把大把的了，所以我这里就不具体说了，说一下遇到的一些问题。</p>\n<ol>\n<li><p>迁移博客最大的难点在于如何保证迁移前后的文章链接固定，由于之前的wordpress采用的是index.php+archives+文章id的方式来构建的，所以在利用静态文件时要想办法构造出这个链接，好在hexo提供了<a href=\"https://hexo.io/docs/front-matter.html\" target=\"_blank\" rel=\"noopener\">Front-matter</a>的方式,巧妙的利用了category来配置id实现了这个链接。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">permalink: index.php/archives/:category/</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: 吕小鸣博客搬家记</span><br><span class=\"line\">date: 2017-05-01 18:30:23</span><br><span class=\"line\">categories:</span><br><span class=\"line\">- 700</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>hexo官方提供了wordpress文章迁移到hexo生成md文件的<a href=\"https://hexo.io/docs/migration.html#WordPress\" target=\"_blank\" rel=\"noopener\">插件</a>,但是对于我之前的博客基本上时用不了的，毕竟之前的博客文章代码太乱，就算生成好了也要一个一个改，所以便做了一个艰难的决定，自己手工来改。</p>\n</li>\n<li>看了一下我的所有博客，整整50篇，遂挑选了一些有必要改的来手工改，毕竟从2014年时写的文章有些也比较小白，不迁移也行。</li>\n<li>按照官方文档上的步骤将hexo的文章建立了起来，同时将静态文件上传到Github的GitPage上托管，方便很多，在也不用下个ftp工具在服务器上改wordpress代码了。</li>\n</ul>\n<h4 id=\"4-辅助插件的选择\"><a href=\"#4-辅助插件的选择\" class=\"headerlink\" title=\"4.辅助插件的选择\"></a>4.辅助插件的选择</h4><ul>\n<li>之前用的多说第三方评论插件在5月底就要到期了，说实话多说插件用了很久，感觉还是很不错的，无奈即将无法使用，还是有些遗憾的了。</li>\n<li>hexo默认集成了<a href=\"http://www.disqus.com/\" target=\"_blank\" rel=\"noopener\">Disqus</a>社交评论插件，但是Disqus毕竟时国外的，很多登录账户还是需要twtter或者faceboox才能登录，而且速度比较慢，在国内用的还是少，所以没有使用这个插件。</li>\n<li>大概找了 <a href=\"http://www.uyan.cc/\" target=\"_blank\" rel=\"noopener\">有言</a>，<a href=\"http://changyan.kuaizhan.com/\" target=\"_blank\" rel=\"noopener\">搜狐畅聊</a>，<a href=\"https://gentie.163.com/info.html\" target=\"_blank\" rel=\"noopener\">网易云跟帖</a> 三种评论插件之后，最终选择了 网易云跟帖,怎么说呢，比较合我的胃口。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cloudTieConfig = &#123;</span><br><span class=\"line\">  url: <span class=\"built_in\">document</span>.location.href.replace(<span class=\"string\">'https'</span>,<span class=\"string\">''</span>).replace(<span class=\"string\">'http'</span>,<span class=\"string\">''</span>),</span><br><span class=\"line\">  sourceId: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">  productKey: <span class=\"string\">\"eb0b276c0f00410db0322e1a9a9b8bbc\"</span>,</span><br><span class=\"line\">  target: <span class=\"string\">\"cloud-tie-wrapper\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> yunManualLoad = <span class=\"literal\">true</span>;</span><br><span class=\"line\">Tie.loader(<span class=\"string\">\"aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s\"</span>, <span class=\"literal\">true</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里有一个技巧，为了防止以后博客评论可以随着文章链接迁移，特地将https和http的唯一标识去掉了。</p>\n<h4 id=\"5-自定义域名使用https\"><a href=\"#5-自定义域名使用https\" class=\"headerlink\" title=\"5.自定义域名使用https\"></a>5.自定义域名使用https</h4><ul>\n<li>在使用了GitPage之后域名默认时username.github.io想要修改成自己的域名并不难，在你域名的dns解析面板上修改解析规则到github的ip即可，同时在source上调价CNAME文件，具体细节网上有很多教程。</li>\n<li>但是难点在于将自己的自定义域名增加https的支持，在什么都不改的情况下访问https的网页会报一个<br><img src=\"https://qiniu.nihaoshijie.com.cn/blogA262222C-9392-4F08-BF75-A8E937E58DC8.png\" alt=\"\">错误，意思就是github的证书不能应用在你自定义的域名上。</li>\n<li>在网上找了解决办法采用<a href=\"https://www.cloudflare.com/\" target=\"_blank\" rel=\"noopener\">Cloudflare</a>代理的方式来实现https访问，原理就是<br><img src=\"https://qiniu.nihaoshijie.com.cn/blog/513492664b24d.jpg\" alt=\"\"></li>\n<li>简单来说就是Cloudflare注册成功之后Cloudflare会提供给你2个dns服务器地址，修改你的域名的dns解析的服务器成这两个地址，Cloudflare在平台上免费部署了ssl，所以以后的域名解析都在cloudflare上托管了。</li>\n<li>这个折腾起来还是很复杂的，再加上家里网速访问Cloudflare太慢，至今还没有完全部署成https，以后在继续研究。</li>\n</ul>\n<p><strong>总之，博客迁移完成之后还是很有成就感的，后续会继续优化一个博客主题，让博客变得更炫目一些！</strong></p>\n<hr>\n<ul>\n<li>本博客使用的主题是在 <a href=\"https://github.com/xiangming/landscape-plus\" target=\"_blank\" rel=\"noopener\">Landscape-plus</a>的基础上修改的。</li>\n<li>本博客使用的插件 <ul>\n<li><a href=\"https://gentie.163.com/info.html\" target=\"_blank\" rel=\"noopener\">网易云跟帖</a>。</li>\n<li><a href=\"http://busuanzi.ibruce.info/\" target=\"_blank\" rel=\"noopener\">busuanzi计数</a>。</li>\n<li><a href=\"https://leancloud.cn/\" target=\"_blank\" rel=\"noopener\">LearnCloud数据存储</a>。</li>\n<li><a href=\"https://portal.qiniu.com/bucket/tenny/resource\" target=\"_blank\" rel=\"noopener\">七牛云图床</a>。</li>\n</ul>\n</li>\n</ul>"},{"title":"微前端-最容易看懂的微前端知识","date":"2020-05-11T09:26:17.000Z","photos":["https://pic4.zhimg.com/v2-8a39b1952a90c6e975215080fa310e8e_b.jpg"],"sticky":1,"_content":"\n\n本文将以理论介绍的方式来对微前端这个概念做一个整体扫盲，涉及到的大多数理论知识并不会太过于对展开，如果读者对一些细节比较感兴趣，可以留言或者搜索相关的概念。\n\n## 什么是微前端？\n微前端（Micro-Frontends）是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。各个前端应用还可以独立运行、独立开发、独立部署。**微前端不是单纯的前端框架或者工具，而是一套架构体系**，这个概念最早在2016年底被提出，可以参考在Google上搜索Micro-Frontends, 排名靠前的https://micro-frontends.org的博客文章，提出了早期的微前端模型。\n<!--more-->\n\n## 为什么会有微前端\n任何新技术的产生都是为了解决现有场景和需求下的技术痛点，微前端也不例外：\n1. **拆分和细化**：当下前端领域，单页面应用（SPA）是非常流行的项目形态之一，而随着时间的推移以及应用功能的丰富，单页应用变得不再单一而是越来越庞大也越来越难以维护，往往是改一处而动全身，由此带来的发版成本也越来越高。微前端的意义就是将这些庞大应用进行拆分，并随之解耦，每个部分可以单独进行维护和部署，提升效率。\n2. **整合历史系统**：在不少的业务中，或多或少会存在一些历史项目，这些项目大多以采用老框架类似（Backbone.js，Angular.js 1）的B端管理系统为主，介于日常运营，这些系统需要结合到新框架中来使用还不能抛弃，对此我们也没有理由浪费时间和精力重写旧的逻辑。而微前端可以将这些系统进行整合，在基本不修改来逻辑的同时来同时兼容新老两套系统并行运行。\n \n\n## 实现微前端有哪些方案\n\n单纯根据对概念的理解，很容易想到实现微前端的重要思想就是将应用进行拆解和整合，通常是一个父应用加上一些子应用，那么使用类似Nginx配置不同应用的转发，或是采用iframe来将多个应用整合到一起等等这些其实都属于微前端的实现方案，他们之间的对比如下图：\n\n| 方案 | 描述 | 优点 |缺点|\n|------|------------|------------|----|\n| Nginx路由转发  | 通过Nginx配置反向代理来实现不同路径映射到不同应用，例如www.abc.com/app1对应app1，www.abc.com/app2对应app2，这种方案本身并不属于前端层面的改造，更多的是运维的配置。          | 简单，快速，易配置         |在切换应用时会触发浏览器刷新，影响体验|\n| iframe嵌套  | 父应用单独是一个页面，每个子应用嵌套一个iframe，父子通信可采用postMessage或者contentWindow方式        | 实现简单，子应用之间自带沙箱，天然隔离，互不影响        |iframe的样式显示、兼容性等都具有局限性；太过简单而显得low|\n| Web Components   | 每个子应用需要采用纯Web Components技术编写组件，是一套全新的开发模式       |每个子应用拥有独立的script和css，也可单独部署       |对于历史系统改造成本高，子应用通信较为复杂易踩坑|\n| 组合式应用路由分发   | 每个子应用独立构建和部署，运行时由父应用来进行路由管理，应用加载，启动，卸载，以及通信机制    |纯前端改造，体验良好，可无感知切换，子应用相互隔离       |需要设计和开发，由于父子应用处于同一页面运行，需要解决子应用的样式冲突，变量对象污染，通信机制等技术点|\n\n上述方案中，每种都有自己的优劣，最原始的Nginx配置反向代理是从接入层的角度来将系统进行分离，但是需要运维配置，而iframe嵌套是最简单和最快速的方案，但是iframe的弊端也是无法避免的，而Web Components的方案则需要大量的改造成本，最后的组合式应用路由分发方案改造成本中等并且能满足大部分需求，也不影响各前端应用的体验，是当下各个业务普遍采用的一种方案，本文后面的内容也是主要基于这种方案进行阐述。\n\n## 微前端由哪些模块组成\n基于上文，当下微前端主要采用的是组合式应用路由方案，该方案的核心是“主从”思想，即包括一个基座（MainApp）应用和若干个微（MicroApp）应用，基座应用大多数是一个前端SPA项目，主要负责应用注册，路由映射，消息下发等，而微应用是独立前端项目，这些项目不限于采用React，Vue，Angular或者JQuery开发，每个微应用注册到基座应用中，由基座进行管理，但是如果脱离基座也是可以单独访问，基本的流程如下图所示：\n\n![](https://user-gold-cdn.xitu.io/2020/5/15/1721766ee9a543cf?w=752&h=609&f=png&s=108725)\n当整个微前端框架运行之后，给用户的体验就是类似下图所示：\n\n![](https://user-gold-cdn.xitu.io/2020/5/15/172176876d3a64fa?w=1280&h=470&f=jpeg&s=31300)\n简单描述下就是基座应用中有一些菜单项，点击每个菜单项可以展示对应的微应用，这些应用的切换是纯前端无感知的，所以，基于目前的方案来说，一个微前端的基座框架需要解决以下问题：\n1. 路由切换的分发问题。\n2. 主微应用的隔离问题。\n3. 通信问题。\n\n下面针对这些问题来一一阐述。\n\n## 微前端的路由分发\n作为微前端的基座应用，是整个应用的入口，负责承载当前微应用的展示和对其他路由微应用的转发，对于当前微应用的展示，一般是由以下几步构成：\n\n1. 作为一个SPA的基座应用，本身是一套纯前端项目，要想展示微应用的页面除了采用iframe之外，要能先拉取到微应用的页面内容， 这就需要**远程拉取机制**。\n2. 远程拉取机制通常会采用fetch API来首先获取到微应用的HTML内容，然后通过解析将微应用的JavaScript和CSS进行抽离，采用eval方法来运行JavaScript，并将CSS和HTML内容append到基座应用中留给微应用的展示区域，当微应用切换走时，同步卸载这些内容，这就构成的当前应用的展示流程。\n3. 当然这个流程里会涉及到CSS样式的污染以及JavaScript对全局对象的污染，这个涉及到隔离问题会在后面讨论，而目前针对远程拉取机制这套流程，已有现成的库来实现，可以参考[import-html-entry](https://www.npmjs.com/package/import-html-entry)和[system.js](https://www.npmjs.com/package/system.js)。\n\n对于路由分发而言，以采用vue-router开发的基座SPA应用来举例，主要是下面这个流程：\n1. 当浏览器的路径变化后，vue-router会监听hashchange或者popstate事件，从而获取到路由切换的时机。\n2. 最先接收到这个变化的是基座的router，通过查询注册信息可以获取到转发到那个微应用，经过一些逻辑处理后，采用修改hash方法或者pushState方法来路由信息推送给微应用的路由，微应用可以是手动监听hashchange或者popstate事件接收，或者采用React-router，vue-router接管路由，后面的逻辑就由微应用自己控制。\n\n\n## 微前端的应用隔离\n应用隔离问题主要分为主应用和微应用，微应用和微应用之间的JavaScript执行环境隔离，CSS样式隔离，我们先来说下CSS的隔离。\n\n**CSS隔离**：当主应用和微应用同屏渲染时，就可能会有一些样式会相互污染，如果要彻底隔离CSS污染，可以采用CSS Module 或者命名空间的方式，给每个微应用模块以特定前缀，即可保证不会互相干扰，可以采用webpack的postcss插件，在打包时添加特定的前缀。\n\n而对于微应用与微应用之间的CSS隔离就非常简单，在每次应用加载时，将该应用所有的link和style 内容进行标记。在应用卸载后，同步卸载页面上对应的link和style即可。\n\n**JavaScript隔离**：每当微应用的JavaScript被加载并运行时，它的核心实际上是对全局对象Window的修改以及一些全局事件的改变，例如jQuery这个js运行后，会在Window上挂载一个`window.$`对象，对于其他库React，Vue也不例外。为此，需要在加载和卸载每个微应用的同时，尽可能消除这种冲突和影响，最普遍的做法是采用沙箱机制（SandBox）。\n\n沙箱机制的核心是让局部的JavaScript运行时，对外部对象的访问和修改处在可控的范围内，即无论内部怎么运行，都不会影响外部的对象。通常在Node.js端可以采用vm模块，而对于浏览器，则需要结合with关键字和window.Proxy对象来实现浏览器端的沙箱。\n\n## 微前端的消息通信\n应用间通信有很多种方式，当然，要让多个分离的微应用之间要做到通信，本质上仍离不开中间媒介或者说全局对象。所以对于消息订阅（pub/sub）模式的通信机制是非常适用的，在基座应用中会定义事件中心Event，每个微应用分别来注册事件，当被触发事件时再有事件中心统一分发，这就构成了基本的通信机制，流程如下图：\n\n![](https://user-gold-cdn.xitu.io/2020/5/17/1722065f24632ddb?w=488&h=413&f=png&s=27067)\n当然，如果基座和微应用采用的是React或者是Vue，是可以结合Redux和Vuex来一起使用，实现应用之间的通信。\n\n## 微前端有哪些框架\n基于上述对微前端整体概念和理论的阐述，目前业界已经有不少框架来帮助开发者轻松的集成微前端架构，例如下面这些：\n* [Mooa](https://www.npmjs.com/package/mooa)：基于Angular的微前端服务框架\n* [Single-Spa](https://www.npmjs.com/package/single-spa)：最早的微前端框架，兼容多种前端技术栈。\n* [Qiankun](https://www.npmjs.com/package/qiankun)：基于Single-Spa，阿里系开源微前端框架。\n* [Icestark](https://www.npmjs.com/package/icestark)：阿里飞冰微前端框架，兼容多种前端技术栈。\n* [Ara Framework](https://www.npmjs.com/package/https://ara-framework.github.io/website/docs/quick-start)：由服务端渲染延伸出的微前端框架。\n\n上面这些框架，笔者这里就不在过多延伸，各位读者感兴趣的话可以来亲自试试。\n\n## 是否要用微前端\n微前端帮助开发者解决了实际的问题，但是对于每个业务来说，是否适合使用微前端，以及是否正确的使用微前端，还是需要遵循以下一些原则：\n\n1. 微前端最佳的使用场景是一些B端的管理系统，既能兼容集成历史系统，也可以将新的系统集成进来，并且不影响原先的交互体验。\n2. 整体的微前端不仅仅是只将系统集成进来，而是整个微前端体系的完善，这其中就包括：\n\n    1)：基座应用和微应用的自动部署能力。\n    \n    2)：微应用的配置管理能力。\n    \n    3)：本地开发调试能力。\n    \n    4)：线上监控和统计能力等等。\n    \n    只有将整个能力体系搭建完善，才能说是整个微前端体系流程的完善。\n    \n3. 当发现使用微前端反而使效率变低，简单的变更复杂那就说明微前端并不适用。\n\n","source":"_posts/微前端-最容易看懂的微前端知识.md","raw":"---\ntitle: 微前端-最容易看懂的微前端知识\ndate: 2020-05-11 17:26:17\ntags:\n- 微前端\n\ncategories:\n- 1100\nphotos: https://pic4.zhimg.com/v2-8a39b1952a90c6e975215080fa310e8e_b.jpg\n\nsticky: 1\n---\n\n\n本文将以理论介绍的方式来对微前端这个概念做一个整体扫盲，涉及到的大多数理论知识并不会太过于对展开，如果读者对一些细节比较感兴趣，可以留言或者搜索相关的概念。\n\n## 什么是微前端？\n微前端（Micro-Frontends）是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。各个前端应用还可以独立运行、独立开发、独立部署。**微前端不是单纯的前端框架或者工具，而是一套架构体系**，这个概念最早在2016年底被提出，可以参考在Google上搜索Micro-Frontends, 排名靠前的https://micro-frontends.org的博客文章，提出了早期的微前端模型。\n<!--more-->\n\n## 为什么会有微前端\n任何新技术的产生都是为了解决现有场景和需求下的技术痛点，微前端也不例外：\n1. **拆分和细化**：当下前端领域，单页面应用（SPA）是非常流行的项目形态之一，而随着时间的推移以及应用功能的丰富，单页应用变得不再单一而是越来越庞大也越来越难以维护，往往是改一处而动全身，由此带来的发版成本也越来越高。微前端的意义就是将这些庞大应用进行拆分，并随之解耦，每个部分可以单独进行维护和部署，提升效率。\n2. **整合历史系统**：在不少的业务中，或多或少会存在一些历史项目，这些项目大多以采用老框架类似（Backbone.js，Angular.js 1）的B端管理系统为主，介于日常运营，这些系统需要结合到新框架中来使用还不能抛弃，对此我们也没有理由浪费时间和精力重写旧的逻辑。而微前端可以将这些系统进行整合，在基本不修改来逻辑的同时来同时兼容新老两套系统并行运行。\n \n\n## 实现微前端有哪些方案\n\n单纯根据对概念的理解，很容易想到实现微前端的重要思想就是将应用进行拆解和整合，通常是一个父应用加上一些子应用，那么使用类似Nginx配置不同应用的转发，或是采用iframe来将多个应用整合到一起等等这些其实都属于微前端的实现方案，他们之间的对比如下图：\n\n| 方案 | 描述 | 优点 |缺点|\n|------|------------|------------|----|\n| Nginx路由转发  | 通过Nginx配置反向代理来实现不同路径映射到不同应用，例如www.abc.com/app1对应app1，www.abc.com/app2对应app2，这种方案本身并不属于前端层面的改造，更多的是运维的配置。          | 简单，快速，易配置         |在切换应用时会触发浏览器刷新，影响体验|\n| iframe嵌套  | 父应用单独是一个页面，每个子应用嵌套一个iframe，父子通信可采用postMessage或者contentWindow方式        | 实现简单，子应用之间自带沙箱，天然隔离，互不影响        |iframe的样式显示、兼容性等都具有局限性；太过简单而显得low|\n| Web Components   | 每个子应用需要采用纯Web Components技术编写组件，是一套全新的开发模式       |每个子应用拥有独立的script和css，也可单独部署       |对于历史系统改造成本高，子应用通信较为复杂易踩坑|\n| 组合式应用路由分发   | 每个子应用独立构建和部署，运行时由父应用来进行路由管理，应用加载，启动，卸载，以及通信机制    |纯前端改造，体验良好，可无感知切换，子应用相互隔离       |需要设计和开发，由于父子应用处于同一页面运行，需要解决子应用的样式冲突，变量对象污染，通信机制等技术点|\n\n上述方案中，每种都有自己的优劣，最原始的Nginx配置反向代理是从接入层的角度来将系统进行分离，但是需要运维配置，而iframe嵌套是最简单和最快速的方案，但是iframe的弊端也是无法避免的，而Web Components的方案则需要大量的改造成本，最后的组合式应用路由分发方案改造成本中等并且能满足大部分需求，也不影响各前端应用的体验，是当下各个业务普遍采用的一种方案，本文后面的内容也是主要基于这种方案进行阐述。\n\n## 微前端由哪些模块组成\n基于上文，当下微前端主要采用的是组合式应用路由方案，该方案的核心是“主从”思想，即包括一个基座（MainApp）应用和若干个微（MicroApp）应用，基座应用大多数是一个前端SPA项目，主要负责应用注册，路由映射，消息下发等，而微应用是独立前端项目，这些项目不限于采用React，Vue，Angular或者JQuery开发，每个微应用注册到基座应用中，由基座进行管理，但是如果脱离基座也是可以单独访问，基本的流程如下图所示：\n\n![](https://user-gold-cdn.xitu.io/2020/5/15/1721766ee9a543cf?w=752&h=609&f=png&s=108725)\n当整个微前端框架运行之后，给用户的体验就是类似下图所示：\n\n![](https://user-gold-cdn.xitu.io/2020/5/15/172176876d3a64fa?w=1280&h=470&f=jpeg&s=31300)\n简单描述下就是基座应用中有一些菜单项，点击每个菜单项可以展示对应的微应用，这些应用的切换是纯前端无感知的，所以，基于目前的方案来说，一个微前端的基座框架需要解决以下问题：\n1. 路由切换的分发问题。\n2. 主微应用的隔离问题。\n3. 通信问题。\n\n下面针对这些问题来一一阐述。\n\n## 微前端的路由分发\n作为微前端的基座应用，是整个应用的入口，负责承载当前微应用的展示和对其他路由微应用的转发，对于当前微应用的展示，一般是由以下几步构成：\n\n1. 作为一个SPA的基座应用，本身是一套纯前端项目，要想展示微应用的页面除了采用iframe之外，要能先拉取到微应用的页面内容， 这就需要**远程拉取机制**。\n2. 远程拉取机制通常会采用fetch API来首先获取到微应用的HTML内容，然后通过解析将微应用的JavaScript和CSS进行抽离，采用eval方法来运行JavaScript，并将CSS和HTML内容append到基座应用中留给微应用的展示区域，当微应用切换走时，同步卸载这些内容，这就构成的当前应用的展示流程。\n3. 当然这个流程里会涉及到CSS样式的污染以及JavaScript对全局对象的污染，这个涉及到隔离问题会在后面讨论，而目前针对远程拉取机制这套流程，已有现成的库来实现，可以参考[import-html-entry](https://www.npmjs.com/package/import-html-entry)和[system.js](https://www.npmjs.com/package/system.js)。\n\n对于路由分发而言，以采用vue-router开发的基座SPA应用来举例，主要是下面这个流程：\n1. 当浏览器的路径变化后，vue-router会监听hashchange或者popstate事件，从而获取到路由切换的时机。\n2. 最先接收到这个变化的是基座的router，通过查询注册信息可以获取到转发到那个微应用，经过一些逻辑处理后，采用修改hash方法或者pushState方法来路由信息推送给微应用的路由，微应用可以是手动监听hashchange或者popstate事件接收，或者采用React-router，vue-router接管路由，后面的逻辑就由微应用自己控制。\n\n\n## 微前端的应用隔离\n应用隔离问题主要分为主应用和微应用，微应用和微应用之间的JavaScript执行环境隔离，CSS样式隔离，我们先来说下CSS的隔离。\n\n**CSS隔离**：当主应用和微应用同屏渲染时，就可能会有一些样式会相互污染，如果要彻底隔离CSS污染，可以采用CSS Module 或者命名空间的方式，给每个微应用模块以特定前缀，即可保证不会互相干扰，可以采用webpack的postcss插件，在打包时添加特定的前缀。\n\n而对于微应用与微应用之间的CSS隔离就非常简单，在每次应用加载时，将该应用所有的link和style 内容进行标记。在应用卸载后，同步卸载页面上对应的link和style即可。\n\n**JavaScript隔离**：每当微应用的JavaScript被加载并运行时，它的核心实际上是对全局对象Window的修改以及一些全局事件的改变，例如jQuery这个js运行后，会在Window上挂载一个`window.$`对象，对于其他库React，Vue也不例外。为此，需要在加载和卸载每个微应用的同时，尽可能消除这种冲突和影响，最普遍的做法是采用沙箱机制（SandBox）。\n\n沙箱机制的核心是让局部的JavaScript运行时，对外部对象的访问和修改处在可控的范围内，即无论内部怎么运行，都不会影响外部的对象。通常在Node.js端可以采用vm模块，而对于浏览器，则需要结合with关键字和window.Proxy对象来实现浏览器端的沙箱。\n\n## 微前端的消息通信\n应用间通信有很多种方式，当然，要让多个分离的微应用之间要做到通信，本质上仍离不开中间媒介或者说全局对象。所以对于消息订阅（pub/sub）模式的通信机制是非常适用的，在基座应用中会定义事件中心Event，每个微应用分别来注册事件，当被触发事件时再有事件中心统一分发，这就构成了基本的通信机制，流程如下图：\n\n![](https://user-gold-cdn.xitu.io/2020/5/17/1722065f24632ddb?w=488&h=413&f=png&s=27067)\n当然，如果基座和微应用采用的是React或者是Vue，是可以结合Redux和Vuex来一起使用，实现应用之间的通信。\n\n## 微前端有哪些框架\n基于上述对微前端整体概念和理论的阐述，目前业界已经有不少框架来帮助开发者轻松的集成微前端架构，例如下面这些：\n* [Mooa](https://www.npmjs.com/package/mooa)：基于Angular的微前端服务框架\n* [Single-Spa](https://www.npmjs.com/package/single-spa)：最早的微前端框架，兼容多种前端技术栈。\n* [Qiankun](https://www.npmjs.com/package/qiankun)：基于Single-Spa，阿里系开源微前端框架。\n* [Icestark](https://www.npmjs.com/package/icestark)：阿里飞冰微前端框架，兼容多种前端技术栈。\n* [Ara Framework](https://www.npmjs.com/package/https://ara-framework.github.io/website/docs/quick-start)：由服务端渲染延伸出的微前端框架。\n\n上面这些框架，笔者这里就不在过多延伸，各位读者感兴趣的话可以来亲自试试。\n\n## 是否要用微前端\n微前端帮助开发者解决了实际的问题，但是对于每个业务来说，是否适合使用微前端，以及是否正确的使用微前端，还是需要遵循以下一些原则：\n\n1. 微前端最佳的使用场景是一些B端的管理系统，既能兼容集成历史系统，也可以将新的系统集成进来，并且不影响原先的交互体验。\n2. 整体的微前端不仅仅是只将系统集成进来，而是整个微前端体系的完善，这其中就包括：\n\n    1)：基座应用和微应用的自动部署能力。\n    \n    2)：微应用的配置管理能力。\n    \n    3)：本地开发调试能力。\n    \n    4)：线上监控和统计能力等等。\n    \n    只有将整个能力体系搭建完善，才能说是整个微前端体系流程的完善。\n    \n3. 当发现使用微前端反而使效率变低，简单的变更复杂那就说明微前端并不适用。\n\n","slug":"微前端-最容易看懂的微前端知识","published":1,"updated":"2021-12-13T02:35:30.198Z","comments":1,"layout":"post","link":"","_id":"ckx434q1800372wvj0h9uginj","content":"<p>本文将以理论介绍的方式来对微前端这个概念做一个整体扫盲，涉及到的大多数理论知识并不会太过于对展开，如果读者对一些细节比较感兴趣，可以留言或者搜索相关的概念。</p>\n<h2><span id=\"什么是微前端\">什么是微前端？</span></h2><p>微前端（Micro-Frontends）是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。各个前端应用还可以独立运行、独立开发、独立部署。<strong>微前端不是单纯的前端框架或者工具，而是一套架构体系</strong>，这个概念最早在2016年底被提出，可以参考在Google上搜索Micro-Frontends, 排名靠前的<a href=\"https://micro-frontends.org的博客文章，提出了早期的微前端模型。\" target=\"_blank\" rel=\"noopener\">https://micro-frontends.org的博客文章，提出了早期的微前端模型。</a><br><a id=\"more\"></a></p>\n<h2><span id=\"为什么会有微前端\">为什么会有微前端</span></h2><p>任何新技术的产生都是为了解决现有场景和需求下的技术痛点，微前端也不例外：</p>\n<ol>\n<li><strong>拆分和细化</strong>：当下前端领域，单页面应用（SPA）是非常流行的项目形态之一，而随着时间的推移以及应用功能的丰富，单页应用变得不再单一而是越来越庞大也越来越难以维护，往往是改一处而动全身，由此带来的发版成本也越来越高。微前端的意义就是将这些庞大应用进行拆分，并随之解耦，每个部分可以单独进行维护和部署，提升效率。</li>\n<li><strong>整合历史系统</strong>：在不少的业务中，或多或少会存在一些历史项目，这些项目大多以采用老框架类似（Backbone.js，Angular.js 1）的B端管理系统为主，介于日常运营，这些系统需要结合到新框架中来使用还不能抛弃，对此我们也没有理由浪费时间和精力重写旧的逻辑。而微前端可以将这些系统进行整合，在基本不修改来逻辑的同时来同时兼容新老两套系统并行运行。</li>\n</ol>\n<h2><span id=\"实现微前端有哪些方案\">实现微前端有哪些方案</span></h2><p>单纯根据对概念的理解，很容易想到实现微前端的重要思想就是将应用进行拆解和整合，通常是一个父应用加上一些子应用，那么使用类似Nginx配置不同应用的转发，或是采用iframe来将多个应用整合到一起等等这些其实都属于微前端的实现方案，他们之间的对比如下图：</p>\n<table>\n<thead>\n<tr>\n<th>方案</th>\n<th>描述</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Nginx路由转发</td>\n<td>通过Nginx配置反向代理来实现不同路径映射到不同应用，例如www.abc.com/app1对应app1，www.abc.com/app2对应app2，这种方案本身并不属于前端层面的改造，更多的是运维的配置。</td>\n<td>简单，快速，易配置</td>\n<td>在切换应用时会触发浏览器刷新，影响体验</td>\n</tr>\n<tr>\n<td>iframe嵌套</td>\n<td>父应用单独是一个页面，每个子应用嵌套一个iframe，父子通信可采用postMessage或者contentWindow方式</td>\n<td>实现简单，子应用之间自带沙箱，天然隔离，互不影响</td>\n<td>iframe的样式显示、兼容性等都具有局限性；太过简单而显得low</td>\n</tr>\n<tr>\n<td>Web Components</td>\n<td>每个子应用需要采用纯Web Components技术编写组件，是一套全新的开发模式</td>\n<td>每个子应用拥有独立的script和css，也可单独部署</td>\n<td>对于历史系统改造成本高，子应用通信较为复杂易踩坑</td>\n</tr>\n<tr>\n<td>组合式应用路由分发</td>\n<td>每个子应用独立构建和部署，运行时由父应用来进行路由管理，应用加载，启动，卸载，以及通信机制</td>\n<td>纯前端改造，体验良好，可无感知切换，子应用相互隔离</td>\n<td>需要设计和开发，由于父子应用处于同一页面运行，需要解决子应用的样式冲突，变量对象污染，通信机制等技术点</td>\n</tr>\n</tbody>\n</table>\n<p>上述方案中，每种都有自己的优劣，最原始的Nginx配置反向代理是从接入层的角度来将系统进行分离，但是需要运维配置，而iframe嵌套是最简单和最快速的方案，但是iframe的弊端也是无法避免的，而Web Components的方案则需要大量的改造成本，最后的组合式应用路由分发方案改造成本中等并且能满足大部分需求，也不影响各前端应用的体验，是当下各个业务普遍采用的一种方案，本文后面的内容也是主要基于这种方案进行阐述。</p>\n<h2><span id=\"微前端由哪些模块组成\">微前端由哪些模块组成</span></h2><p>基于上文，当下微前端主要采用的是组合式应用路由方案，该方案的核心是“主从”思想，即包括一个基座（MainApp）应用和若干个微（MicroApp）应用，基座应用大多数是一个前端SPA项目，主要负责应用注册，路由映射，消息下发等，而微应用是独立前端项目，这些项目不限于采用React，Vue，Angular或者JQuery开发，每个微应用注册到基座应用中，由基座进行管理，但是如果脱离基座也是可以单独访问，基本的流程如下图所示：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/5/15/1721766ee9a543cf?w=752&amp;h=609&amp;f=png&amp;s=108725\" alt><br>当整个微前端框架运行之后，给用户的体验就是类似下图所示：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/5/15/172176876d3a64fa?w=1280&amp;h=470&amp;f=jpeg&amp;s=31300\" alt><br>简单描述下就是基座应用中有一些菜单项，点击每个菜单项可以展示对应的微应用，这些应用的切换是纯前端无感知的，所以，基于目前的方案来说，一个微前端的基座框架需要解决以下问题：</p>\n<ol>\n<li>路由切换的分发问题。</li>\n<li>主微应用的隔离问题。</li>\n<li>通信问题。</li>\n</ol>\n<p>下面针对这些问题来一一阐述。</p>\n<h2><span id=\"微前端的路由分发\">微前端的路由分发</span></h2><p>作为微前端的基座应用，是整个应用的入口，负责承载当前微应用的展示和对其他路由微应用的转发，对于当前微应用的展示，一般是由以下几步构成：</p>\n<ol>\n<li>作为一个SPA的基座应用，本身是一套纯前端项目，要想展示微应用的页面除了采用iframe之外，要能先拉取到微应用的页面内容， 这就需要<strong>远程拉取机制</strong>。</li>\n<li>远程拉取机制通常会采用fetch API来首先获取到微应用的HTML内容，然后通过解析将微应用的JavaScript和CSS进行抽离，采用eval方法来运行JavaScript，并将CSS和HTML内容append到基座应用中留给微应用的展示区域，当微应用切换走时，同步卸载这些内容，这就构成的当前应用的展示流程。</li>\n<li>当然这个流程里会涉及到CSS样式的污染以及JavaScript对全局对象的污染，这个涉及到隔离问题会在后面讨论，而目前针对远程拉取机制这套流程，已有现成的库来实现，可以参考<a href=\"https://www.npmjs.com/package/import-html-entry\" target=\"_blank\" rel=\"noopener\">import-html-entry</a>和<a href=\"https://www.npmjs.com/package/system.js\" target=\"_blank\" rel=\"noopener\">system.js</a>。</li>\n</ol>\n<p>对于路由分发而言，以采用vue-router开发的基座SPA应用来举例，主要是下面这个流程：</p>\n<ol>\n<li>当浏览器的路径变化后，vue-router会监听hashchange或者popstate事件，从而获取到路由切换的时机。</li>\n<li>最先接收到这个变化的是基座的router，通过查询注册信息可以获取到转发到那个微应用，经过一些逻辑处理后，采用修改hash方法或者pushState方法来路由信息推送给微应用的路由，微应用可以是手动监听hashchange或者popstate事件接收，或者采用React-router，vue-router接管路由，后面的逻辑就由微应用自己控制。</li>\n</ol>\n<h2><span id=\"微前端的应用隔离\">微前端的应用隔离</span></h2><p>应用隔离问题主要分为主应用和微应用，微应用和微应用之间的JavaScript执行环境隔离，CSS样式隔离，我们先来说下CSS的隔离。</p>\n<p><strong>CSS隔离</strong>：当主应用和微应用同屏渲染时，就可能会有一些样式会相互污染，如果要彻底隔离CSS污染，可以采用CSS Module 或者命名空间的方式，给每个微应用模块以特定前缀，即可保证不会互相干扰，可以采用webpack的postcss插件，在打包时添加特定的前缀。</p>\n<p>而对于微应用与微应用之间的CSS隔离就非常简单，在每次应用加载时，将该应用所有的link和style 内容进行标记。在应用卸载后，同步卸载页面上对应的link和style即可。</p>\n<p><strong>JavaScript隔离</strong>：每当微应用的JavaScript被加载并运行时，它的核心实际上是对全局对象Window的修改以及一些全局事件的改变，例如jQuery这个js运行后，会在Window上挂载一个<code>window.$</code>对象，对于其他库React，Vue也不例外。为此，需要在加载和卸载每个微应用的同时，尽可能消除这种冲突和影响，最普遍的做法是采用沙箱机制（SandBox）。</p>\n<p>沙箱机制的核心是让局部的JavaScript运行时，对外部对象的访问和修改处在可控的范围内，即无论内部怎么运行，都不会影响外部的对象。通常在Node.js端可以采用vm模块，而对于浏览器，则需要结合with关键字和window.Proxy对象来实现浏览器端的沙箱。</p>\n<h2><span id=\"微前端的消息通信\">微前端的消息通信</span></h2><p>应用间通信有很多种方式，当然，要让多个分离的微应用之间要做到通信，本质上仍离不开中间媒介或者说全局对象。所以对于消息订阅（pub/sub）模式的通信机制是非常适用的，在基座应用中会定义事件中心Event，每个微应用分别来注册事件，当被触发事件时再有事件中心统一分发，这就构成了基本的通信机制，流程如下图：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/5/17/1722065f24632ddb?w=488&amp;h=413&amp;f=png&amp;s=27067\" alt><br>当然，如果基座和微应用采用的是React或者是Vue，是可以结合Redux和Vuex来一起使用，实现应用之间的通信。</p>\n<h2><span id=\"微前端有哪些框架\">微前端有哪些框架</span></h2><p>基于上述对微前端整体概念和理论的阐述，目前业界已经有不少框架来帮助开发者轻松的集成微前端架构，例如下面这些：</p>\n<ul>\n<li><a href=\"https://www.npmjs.com/package/mooa\" target=\"_blank\" rel=\"noopener\">Mooa</a>：基于Angular的微前端服务框架</li>\n<li><a href=\"https://www.npmjs.com/package/single-spa\" target=\"_blank\" rel=\"noopener\">Single-Spa</a>：最早的微前端框架，兼容多种前端技术栈。</li>\n<li><a href=\"https://www.npmjs.com/package/qiankun\" target=\"_blank\" rel=\"noopener\">Qiankun</a>：基于Single-Spa，阿里系开源微前端框架。</li>\n<li><a href=\"https://www.npmjs.com/package/icestark\" target=\"_blank\" rel=\"noopener\">Icestark</a>：阿里飞冰微前端框架，兼容多种前端技术栈。</li>\n<li><a href=\"https://www.npmjs.com/package/https://ara-framework.github.io/website/docs/quick-start\" target=\"_blank\" rel=\"noopener\">Ara Framework</a>：由服务端渲染延伸出的微前端框架。</li>\n</ul>\n<p>上面这些框架，笔者这里就不在过多延伸，各位读者感兴趣的话可以来亲自试试。</p>\n<h2><span id=\"是否要用微前端\">是否要用微前端</span></h2><p>微前端帮助开发者解决了实际的问题，但是对于每个业务来说，是否适合使用微前端，以及是否正确的使用微前端，还是需要遵循以下一些原则：</p>\n<ol>\n<li>微前端最佳的使用场景是一些B端的管理系统，既能兼容集成历史系统，也可以将新的系统集成进来，并且不影响原先的交互体验。</li>\n<li><p>整体的微前端不仅仅是只将系统集成进来，而是整个微前端体系的完善，这其中就包括：</p>\n<p> 1)：基座应用和微应用的自动部署能力。</p>\n<p> 2)：微应用的配置管理能力。</p>\n<p> 3)：本地开发调试能力。</p>\n<p> 4)：线上监控和统计能力等等。</p>\n<p> 只有将整个能力体系搭建完善，才能说是整个微前端体系流程的完善。</p>\n</li>\n<li><p>当发现使用微前端反而使效率变低，简单的变更复杂那就说明微前端并不适用。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>本文将以理论介绍的方式来对微前端这个概念做一个整体扫盲，涉及到的大多数理论知识并不会太过于对展开，如果读者对一些细节比较感兴趣，可以留言或者搜索相关的概念。</p>\n<h2 id=\"什么是微前端？\"><a href=\"#什么是微前端？\" class=\"headerlink\" title=\"什么是微前端？\"></a>什么是微前端？</h2><p>微前端（Micro-Frontends）是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。各个前端应用还可以独立运行、独立开发、独立部署。<strong>微前端不是单纯的前端框架或者工具，而是一套架构体系</strong>，这个概念最早在2016年底被提出，可以参考在Google上搜索Micro-Frontends, 排名靠前的<a href=\"https://micro-frontends.org的博客文章，提出了早期的微前端模型。\" target=\"_blank\" rel=\"noopener\">https://micro-frontends.org的博客文章，提出了早期的微前端模型。</a><br>","more":"</p>\n<h2 id=\"为什么会有微前端\"><a href=\"#为什么会有微前端\" class=\"headerlink\" title=\"为什么会有微前端\"></a>为什么会有微前端</h2><p>任何新技术的产生都是为了解决现有场景和需求下的技术痛点，微前端也不例外：</p>\n<ol>\n<li><strong>拆分和细化</strong>：当下前端领域，单页面应用（SPA）是非常流行的项目形态之一，而随着时间的推移以及应用功能的丰富，单页应用变得不再单一而是越来越庞大也越来越难以维护，往往是改一处而动全身，由此带来的发版成本也越来越高。微前端的意义就是将这些庞大应用进行拆分，并随之解耦，每个部分可以单独进行维护和部署，提升效率。</li>\n<li><strong>整合历史系统</strong>：在不少的业务中，或多或少会存在一些历史项目，这些项目大多以采用老框架类似（Backbone.js，Angular.js 1）的B端管理系统为主，介于日常运营，这些系统需要结合到新框架中来使用还不能抛弃，对此我们也没有理由浪费时间和精力重写旧的逻辑。而微前端可以将这些系统进行整合，在基本不修改来逻辑的同时来同时兼容新老两套系统并行运行。</li>\n</ol>\n<h2 id=\"实现微前端有哪些方案\"><a href=\"#实现微前端有哪些方案\" class=\"headerlink\" title=\"实现微前端有哪些方案\"></a>实现微前端有哪些方案</h2><p>单纯根据对概念的理解，很容易想到实现微前端的重要思想就是将应用进行拆解和整合，通常是一个父应用加上一些子应用，那么使用类似Nginx配置不同应用的转发，或是采用iframe来将多个应用整合到一起等等这些其实都属于微前端的实现方案，他们之间的对比如下图：</p>\n<table>\n<thead>\n<tr>\n<th>方案</th>\n<th>描述</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Nginx路由转发</td>\n<td>通过Nginx配置反向代理来实现不同路径映射到不同应用，例如www.abc.com/app1对应app1，www.abc.com/app2对应app2，这种方案本身并不属于前端层面的改造，更多的是运维的配置。</td>\n<td>简单，快速，易配置</td>\n<td>在切换应用时会触发浏览器刷新，影响体验</td>\n</tr>\n<tr>\n<td>iframe嵌套</td>\n<td>父应用单独是一个页面，每个子应用嵌套一个iframe，父子通信可采用postMessage或者contentWindow方式</td>\n<td>实现简单，子应用之间自带沙箱，天然隔离，互不影响</td>\n<td>iframe的样式显示、兼容性等都具有局限性；太过简单而显得low</td>\n</tr>\n<tr>\n<td>Web Components</td>\n<td>每个子应用需要采用纯Web Components技术编写组件，是一套全新的开发模式</td>\n<td>每个子应用拥有独立的script和css，也可单独部署</td>\n<td>对于历史系统改造成本高，子应用通信较为复杂易踩坑</td>\n</tr>\n<tr>\n<td>组合式应用路由分发</td>\n<td>每个子应用独立构建和部署，运行时由父应用来进行路由管理，应用加载，启动，卸载，以及通信机制</td>\n<td>纯前端改造，体验良好，可无感知切换，子应用相互隔离</td>\n<td>需要设计和开发，由于父子应用处于同一页面运行，需要解决子应用的样式冲突，变量对象污染，通信机制等技术点</td>\n</tr>\n</tbody>\n</table>\n<p>上述方案中，每种都有自己的优劣，最原始的Nginx配置反向代理是从接入层的角度来将系统进行分离，但是需要运维配置，而iframe嵌套是最简单和最快速的方案，但是iframe的弊端也是无法避免的，而Web Components的方案则需要大量的改造成本，最后的组合式应用路由分发方案改造成本中等并且能满足大部分需求，也不影响各前端应用的体验，是当下各个业务普遍采用的一种方案，本文后面的内容也是主要基于这种方案进行阐述。</p>\n<h2 id=\"微前端由哪些模块组成\"><a href=\"#微前端由哪些模块组成\" class=\"headerlink\" title=\"微前端由哪些模块组成\"></a>微前端由哪些模块组成</h2><p>基于上文，当下微前端主要采用的是组合式应用路由方案，该方案的核心是“主从”思想，即包括一个基座（MainApp）应用和若干个微（MicroApp）应用，基座应用大多数是一个前端SPA项目，主要负责应用注册，路由映射，消息下发等，而微应用是独立前端项目，这些项目不限于采用React，Vue，Angular或者JQuery开发，每个微应用注册到基座应用中，由基座进行管理，但是如果脱离基座也是可以单独访问，基本的流程如下图所示：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/5/15/1721766ee9a543cf?w=752&amp;h=609&amp;f=png&amp;s=108725\" alt=\"\"><br>当整个微前端框架运行之后，给用户的体验就是类似下图所示：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/5/15/172176876d3a64fa?w=1280&amp;h=470&amp;f=jpeg&amp;s=31300\" alt=\"\"><br>简单描述下就是基座应用中有一些菜单项，点击每个菜单项可以展示对应的微应用，这些应用的切换是纯前端无感知的，所以，基于目前的方案来说，一个微前端的基座框架需要解决以下问题：</p>\n<ol>\n<li>路由切换的分发问题。</li>\n<li>主微应用的隔离问题。</li>\n<li>通信问题。</li>\n</ol>\n<p>下面针对这些问题来一一阐述。</p>\n<h2 id=\"微前端的路由分发\"><a href=\"#微前端的路由分发\" class=\"headerlink\" title=\"微前端的路由分发\"></a>微前端的路由分发</h2><p>作为微前端的基座应用，是整个应用的入口，负责承载当前微应用的展示和对其他路由微应用的转发，对于当前微应用的展示，一般是由以下几步构成：</p>\n<ol>\n<li>作为一个SPA的基座应用，本身是一套纯前端项目，要想展示微应用的页面除了采用iframe之外，要能先拉取到微应用的页面内容， 这就需要<strong>远程拉取机制</strong>。</li>\n<li>远程拉取机制通常会采用fetch API来首先获取到微应用的HTML内容，然后通过解析将微应用的JavaScript和CSS进行抽离，采用eval方法来运行JavaScript，并将CSS和HTML内容append到基座应用中留给微应用的展示区域，当微应用切换走时，同步卸载这些内容，这就构成的当前应用的展示流程。</li>\n<li>当然这个流程里会涉及到CSS样式的污染以及JavaScript对全局对象的污染，这个涉及到隔离问题会在后面讨论，而目前针对远程拉取机制这套流程，已有现成的库来实现，可以参考<a href=\"https://www.npmjs.com/package/import-html-entry\" target=\"_blank\" rel=\"noopener\">import-html-entry</a>和<a href=\"https://www.npmjs.com/package/system.js\" target=\"_blank\" rel=\"noopener\">system.js</a>。</li>\n</ol>\n<p>对于路由分发而言，以采用vue-router开发的基座SPA应用来举例，主要是下面这个流程：</p>\n<ol>\n<li>当浏览器的路径变化后，vue-router会监听hashchange或者popstate事件，从而获取到路由切换的时机。</li>\n<li>最先接收到这个变化的是基座的router，通过查询注册信息可以获取到转发到那个微应用，经过一些逻辑处理后，采用修改hash方法或者pushState方法来路由信息推送给微应用的路由，微应用可以是手动监听hashchange或者popstate事件接收，或者采用React-router，vue-router接管路由，后面的逻辑就由微应用自己控制。</li>\n</ol>\n<h2 id=\"微前端的应用隔离\"><a href=\"#微前端的应用隔离\" class=\"headerlink\" title=\"微前端的应用隔离\"></a>微前端的应用隔离</h2><p>应用隔离问题主要分为主应用和微应用，微应用和微应用之间的JavaScript执行环境隔离，CSS样式隔离，我们先来说下CSS的隔离。</p>\n<p><strong>CSS隔离</strong>：当主应用和微应用同屏渲染时，就可能会有一些样式会相互污染，如果要彻底隔离CSS污染，可以采用CSS Module 或者命名空间的方式，给每个微应用模块以特定前缀，即可保证不会互相干扰，可以采用webpack的postcss插件，在打包时添加特定的前缀。</p>\n<p>而对于微应用与微应用之间的CSS隔离就非常简单，在每次应用加载时，将该应用所有的link和style 内容进行标记。在应用卸载后，同步卸载页面上对应的link和style即可。</p>\n<p><strong>JavaScript隔离</strong>：每当微应用的JavaScript被加载并运行时，它的核心实际上是对全局对象Window的修改以及一些全局事件的改变，例如jQuery这个js运行后，会在Window上挂载一个<code>window.$</code>对象，对于其他库React，Vue也不例外。为此，需要在加载和卸载每个微应用的同时，尽可能消除这种冲突和影响，最普遍的做法是采用沙箱机制（SandBox）。</p>\n<p>沙箱机制的核心是让局部的JavaScript运行时，对外部对象的访问和修改处在可控的范围内，即无论内部怎么运行，都不会影响外部的对象。通常在Node.js端可以采用vm模块，而对于浏览器，则需要结合with关键字和window.Proxy对象来实现浏览器端的沙箱。</p>\n<h2 id=\"微前端的消息通信\"><a href=\"#微前端的消息通信\" class=\"headerlink\" title=\"微前端的消息通信\"></a>微前端的消息通信</h2><p>应用间通信有很多种方式，当然，要让多个分离的微应用之间要做到通信，本质上仍离不开中间媒介或者说全局对象。所以对于消息订阅（pub/sub）模式的通信机制是非常适用的，在基座应用中会定义事件中心Event，每个微应用分别来注册事件，当被触发事件时再有事件中心统一分发，这就构成了基本的通信机制，流程如下图：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/5/17/1722065f24632ddb?w=488&amp;h=413&amp;f=png&amp;s=27067\" alt=\"\"><br>当然，如果基座和微应用采用的是React或者是Vue，是可以结合Redux和Vuex来一起使用，实现应用之间的通信。</p>\n<h2 id=\"微前端有哪些框架\"><a href=\"#微前端有哪些框架\" class=\"headerlink\" title=\"微前端有哪些框架\"></a>微前端有哪些框架</h2><p>基于上述对微前端整体概念和理论的阐述，目前业界已经有不少框架来帮助开发者轻松的集成微前端架构，例如下面这些：</p>\n<ul>\n<li><a href=\"https://www.npmjs.com/package/mooa\" target=\"_blank\" rel=\"noopener\">Mooa</a>：基于Angular的微前端服务框架</li>\n<li><a href=\"https://www.npmjs.com/package/single-spa\" target=\"_blank\" rel=\"noopener\">Single-Spa</a>：最早的微前端框架，兼容多种前端技术栈。</li>\n<li><a href=\"https://www.npmjs.com/package/qiankun\" target=\"_blank\" rel=\"noopener\">Qiankun</a>：基于Single-Spa，阿里系开源微前端框架。</li>\n<li><a href=\"https://www.npmjs.com/package/icestark\" target=\"_blank\" rel=\"noopener\">Icestark</a>：阿里飞冰微前端框架，兼容多种前端技术栈。</li>\n<li><a href=\"https://www.npmjs.com/package/https://ara-framework.github.io/website/docs/quick-start\" target=\"_blank\" rel=\"noopener\">Ara Framework</a>：由服务端渲染延伸出的微前端框架。</li>\n</ul>\n<p>上面这些框架，笔者这里就不在过多延伸，各位读者感兴趣的话可以来亲自试试。</p>\n<h2 id=\"是否要用微前端\"><a href=\"#是否要用微前端\" class=\"headerlink\" title=\"是否要用微前端\"></a>是否要用微前端</h2><p>微前端帮助开发者解决了实际的问题，但是对于每个业务来说，是否适合使用微前端，以及是否正确的使用微前端，还是需要遵循以下一些原则：</p>\n<ol>\n<li>微前端最佳的使用场景是一些B端的管理系统，既能兼容集成历史系统，也可以将新的系统集成进来，并且不影响原先的交互体验。</li>\n<li><p>整体的微前端不仅仅是只将系统集成进来，而是整个微前端体系的完善，这其中就包括：</p>\n<p> 1)：基座应用和微应用的自动部署能力。</p>\n<p> 2)：微应用的配置管理能力。</p>\n<p> 3)：本地开发调试能力。</p>\n<p> 4)：线上监控和统计能力等等。</p>\n<p> 只有将整个能力体系搭建完善，才能说是整个微前端体系流程的完善。</p>\n</li>\n<li><p>当发现使用微前端反而使效率变低，简单的变更复杂那就说明微前端并不适用。</p>\n</li>\n</ol>"},{"title":"数据结构温习 排序算法","date":"2014-06-12T11:35:23.000Z","_content":"<p style=\"color: #362e2b;\">js 排序算法</p>\n<p style=\"color: #362e2b;\">冒泡排序：</p>\n<!--more-->\n```javascript\nvar array = [{\"name\" : \"aa\",index : 100},{\"name\" : \"aa\",index : 200},{\"name\" : \"aa\",index : 300}];  \nvar len = array.length;  \nfor (var i = 0 ; i &lt; len - 1 ; i++) { //-1 是为了j+1不会发生数组越界，且不会和自己比较  \n    for (var  j = 0 ; j &lt; len - i - 1;j++) {  \n        if (array[j] &lt; array[j+1]) {  \n            var temp = a[j];  \n            a[j] = a[j+1];  \n            a[j+1] = temp;//交换位置  \n        }  \n    }  \n}\n```\n<span style=\"color: #362e2b;\">快速排序：</span>\n\n&nbsp;\n```javascript\nvar arr = [{\"name\" : \"aa\",index : 200},{\"name\" : \"aa\",index : 100},{\"name\" : \"aa\",index : 300}];  \nfunction qSort(arr,i,j){  \n  if(i&gt;=j) return;  \n  var tempi=i,tempj=j;  \n  var key=arr[i];  \n    while(i&lt;j){  \n    while(i&lt;j&amp;&amp;arr[j].index&gt;key.index) j--;//从右向左找第1个小于key的数  \n    if(i&lt;j) arr[i++]=arr[j];  \n    while(i&lt;j&amp;&amp;arr[i].index&lt;key.index) i++;//从左向右找第1个大于key的数  \n    if(i&lt;j) arr[j--]=arr[i];  \n    }  \n    arr[i]=key;  \n    qSort(arr,tempi,i-1);  \n    qSort(arr,i+1,tempj);  \n}  \nqSort(arr,0,2)\n```\n&nbsp;\n\n<span style=\"color: #362e2b;\">选择排序:</span>\n```javascript\nvar min,len = arr.length;  \nfor (var i = 0 ; i &lt; len - 1 ; i++) {  \n    min = i;  \n    for (var j = i + 1 ; j &lt; len ; j++) {  \n        if (arr[j].index &lt; arr[min].index) {  \n            min = j;          \n        }  \n    }  \n    var temp = arr[min];  \n    arr[min] = arr[i];  \n    arr[i] = temp;  \n}\n```\n","source":"_posts/数据结构温习-排序算法.md","raw":"---\ntitle: 数据结构温习 排序算法\ndate: 2014-06-12 19:35:23\ntags:\n- 数据结构\ncategories:\n- 126\n---\n<p style=\"color: #362e2b;\">js 排序算法</p>\n<p style=\"color: #362e2b;\">冒泡排序：</p>\n<!--more-->\n```javascript\nvar array = [{\"name\" : \"aa\",index : 100},{\"name\" : \"aa\",index : 200},{\"name\" : \"aa\",index : 300}];  \nvar len = array.length;  \nfor (var i = 0 ; i &lt; len - 1 ; i++) { //-1 是为了j+1不会发生数组越界，且不会和自己比较  \n    for (var  j = 0 ; j &lt; len - i - 1;j++) {  \n        if (array[j] &lt; array[j+1]) {  \n            var temp = a[j];  \n            a[j] = a[j+1];  \n            a[j+1] = temp;//交换位置  \n        }  \n    }  \n}\n```\n<span style=\"color: #362e2b;\">快速排序：</span>\n\n&nbsp;\n```javascript\nvar arr = [{\"name\" : \"aa\",index : 200},{\"name\" : \"aa\",index : 100},{\"name\" : \"aa\",index : 300}];  \nfunction qSort(arr,i,j){  \n  if(i&gt;=j) return;  \n  var tempi=i,tempj=j;  \n  var key=arr[i];  \n    while(i&lt;j){  \n    while(i&lt;j&amp;&amp;arr[j].index&gt;key.index) j--;//从右向左找第1个小于key的数  \n    if(i&lt;j) arr[i++]=arr[j];  \n    while(i&lt;j&amp;&amp;arr[i].index&lt;key.index) i++;//从左向右找第1个大于key的数  \n    if(i&lt;j) arr[j--]=arr[i];  \n    }  \n    arr[i]=key;  \n    qSort(arr,tempi,i-1);  \n    qSort(arr,i+1,tempj);  \n}  \nqSort(arr,0,2)\n```\n&nbsp;\n\n<span style=\"color: #362e2b;\">选择排序:</span>\n```javascript\nvar min,len = arr.length;  \nfor (var i = 0 ; i &lt; len - 1 ; i++) {  \n    min = i;  \n    for (var j = i + 1 ; j &lt; len ; j++) {  \n        if (arr[j].index &lt; arr[min].index) {  \n            min = j;          \n        }  \n    }  \n    var temp = arr[min];  \n    arr[min] = arr[i];  \n    arr[i] = temp;  \n}\n```\n","slug":"数据结构温习-排序算法","published":1,"updated":"2017-04-30T11:40:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434q1b003a2wvj8eo2nm2c","content":"<p></p><p style=\"color: #362e2b;\">js 排序算法</p><p></p>\n<p></p><p style=\"color: #362e2b;\">冒泡排序：</p><br><a id=\"more\"></a><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array = [&#123;<span class=\"string\">\"name\"</span> : <span class=\"string\">\"aa\"</span>,<span class=\"attr\">index</span> : <span class=\"number\">100</span>&#125;,&#123;<span class=\"string\">\"name\"</span> : <span class=\"string\">\"aa\"</span>,<span class=\"attr\">index</span> : <span class=\"number\">200</span>&#125;,&#123;<span class=\"string\">\"name\"</span> : <span class=\"string\">\"aa\"</span>,<span class=\"attr\">index</span> : <span class=\"number\">300</span>&#125;];  </span><br><span class=\"line\"><span class=\"keyword\">var</span> len = array.length;  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i &amp;lt; len - <span class=\"number\">1</span> ; i++) &#123; <span class=\"comment\">//-1 是为了j+1不会发生数组越界，且不会和自己比较  </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span>  j = <span class=\"number\">0</span> ; j &amp;lt; len - i - <span class=\"number\">1</span>;j++) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array[j] &amp;lt; array[j+<span class=\"number\">1</span>]) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">var</span> temp = a[j];  </span><br><span class=\"line\">            a[j] = a[j+<span class=\"number\">1</span>];  </span><br><span class=\"line\">            a[j+<span class=\"number\">1</span>] = temp;<span class=\"comment\">//交换位置  </span></span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p>\n<p><span style=\"color: #362e2b;\">快速排序：</span></p>\n<p>&nbsp;<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [&#123;<span class=\"string\">\"name\"</span> : <span class=\"string\">\"aa\"</span>,<span class=\"attr\">index</span> : <span class=\"number\">200</span>&#125;,&#123;<span class=\"string\">\"name\"</span> : <span class=\"string\">\"aa\"</span>,<span class=\"attr\">index</span> : <span class=\"number\">100</span>&#125;,&#123;<span class=\"string\">\"name\"</span> : <span class=\"string\">\"aa\"</span>,<span class=\"attr\">index</span> : <span class=\"number\">300</span>&#125;];  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">qSort</span>(<span class=\"params\">arr,i,j</span>)</span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">if</span>(i&amp;gt;=j) <span class=\"keyword\">return</span>;  </span><br><span class=\"line\">  <span class=\"keyword\">var</span> tempi=i,tempj=j;  </span><br><span class=\"line\">  <span class=\"keyword\">var</span> key=arr[i];  </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&amp;lt;j)&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&amp;lt;j&amp;amp;&amp;amp;arr[j].index&amp;gt;key.index) j--;<span class=\"comment\">//从右向左找第1个小于key的数  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i&amp;lt;j) arr[i++]=arr[j];  </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&amp;lt;j&amp;amp;&amp;amp;arr[i].index&amp;lt;key.index) i++;<span class=\"comment\">//从左向右找第1个大于key的数  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i&amp;lt;j) arr[j--]=arr[i];  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    arr[i]=key;  </span><br><span class=\"line\">    qSort(arr,tempi,i<span class=\"number\">-1</span>);  </span><br><span class=\"line\">    qSort(arr,i+<span class=\"number\">1</span>,tempj);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">qSort(arr,<span class=\"number\">0</span>,<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;</p>\n<p><span style=\"color: #362e2b;\">选择排序:</span><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> min,len = arr.length;  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i &amp;lt; len - <span class=\"number\">1</span> ; i++) &#123;  </span><br><span class=\"line\">    min = i;  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = i + <span class=\"number\">1</span> ; j &amp;lt; len ; j++) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[j].index &amp;lt; arr[min].index) &#123;  </span><br><span class=\"line\">            min = j;          </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">var</span> temp = arr[min];  </span><br><span class=\"line\">    arr[min] = arr[i];  </span><br><span class=\"line\">    arr[i] = temp;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p></p><p style=\"color: #362e2b;\">js 排序算法</p><p></p>\n<p></p><p style=\"color: #362e2b;\">冒泡排序：</p><br>","more":"<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array = [&#123;<span class=\"string\">\"name\"</span> : <span class=\"string\">\"aa\"</span>,<span class=\"attr\">index</span> : <span class=\"number\">100</span>&#125;,&#123;<span class=\"string\">\"name\"</span> : <span class=\"string\">\"aa\"</span>,<span class=\"attr\">index</span> : <span class=\"number\">200</span>&#125;,&#123;<span class=\"string\">\"name\"</span> : <span class=\"string\">\"aa\"</span>,<span class=\"attr\">index</span> : <span class=\"number\">300</span>&#125;];  </span><br><span class=\"line\"><span class=\"keyword\">var</span> len = array.length;  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i &amp;lt; len - <span class=\"number\">1</span> ; i++) &#123; <span class=\"comment\">//-1 是为了j+1不会发生数组越界，且不会和自己比较  </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span>  j = <span class=\"number\">0</span> ; j &amp;lt; len - i - <span class=\"number\">1</span>;j++) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array[j] &amp;lt; array[j+<span class=\"number\">1</span>]) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">var</span> temp = a[j];  </span><br><span class=\"line\">            a[j] = a[j+<span class=\"number\">1</span>];  </span><br><span class=\"line\">            a[j+<span class=\"number\">1</span>] = temp;<span class=\"comment\">//交换位置  </span></span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p>\n<p><span style=\"color: #362e2b;\">快速排序：</span></p>\n<p>&nbsp;<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [&#123;<span class=\"string\">\"name\"</span> : <span class=\"string\">\"aa\"</span>,<span class=\"attr\">index</span> : <span class=\"number\">200</span>&#125;,&#123;<span class=\"string\">\"name\"</span> : <span class=\"string\">\"aa\"</span>,<span class=\"attr\">index</span> : <span class=\"number\">100</span>&#125;,&#123;<span class=\"string\">\"name\"</span> : <span class=\"string\">\"aa\"</span>,<span class=\"attr\">index</span> : <span class=\"number\">300</span>&#125;];  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">qSort</span>(<span class=\"params\">arr,i,j</span>)</span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">if</span>(i&amp;gt;=j) <span class=\"keyword\">return</span>;  </span><br><span class=\"line\">  <span class=\"keyword\">var</span> tempi=i,tempj=j;  </span><br><span class=\"line\">  <span class=\"keyword\">var</span> key=arr[i];  </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&amp;lt;j)&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&amp;lt;j&amp;amp;&amp;amp;arr[j].index&amp;gt;key.index) j--;<span class=\"comment\">//从右向左找第1个小于key的数  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i&amp;lt;j) arr[i++]=arr[j];  </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&amp;lt;j&amp;amp;&amp;amp;arr[i].index&amp;lt;key.index) i++;<span class=\"comment\">//从左向右找第1个大于key的数  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i&amp;lt;j) arr[j--]=arr[i];  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    arr[i]=key;  </span><br><span class=\"line\">    qSort(arr,tempi,i<span class=\"number\">-1</span>);  </span><br><span class=\"line\">    qSort(arr,i+<span class=\"number\">1</span>,tempj);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">qSort(arr,<span class=\"number\">0</span>,<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;</p>\n<p><span style=\"color: #362e2b;\">选择排序:</span><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> min,len = arr.length;  </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i &amp;lt; len - <span class=\"number\">1</span> ; i++) &#123;  </span><br><span class=\"line\">    min = i;  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = i + <span class=\"number\">1</span> ; j &amp;lt; len ; j++) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[j].index &amp;lt; arr[min].index) &#123;  </span><br><span class=\"line\">            min = j;          </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">var</span> temp = arr[min];  </span><br><span class=\"line\">    arr[min] = arr[i];  </span><br><span class=\"line\">    arr[i] = temp;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"百度分享HTTPS折腾记","date":"2017-06-26T14:48:20.000Z","_content":">百度分享很坑！！\n\n### 发现问题\n\n今天打开博客忽然发现百度分享用不了了，点击分享按钮没有任何作用，于是打开控制台查看：\n![](https://qiniu.nihaoshijie.com.cn/blog/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-26%2021.56.04.png)\n##### 这是什么鬼！\n<!--more-->\n忽然想起来，之前我也是为了解决百度分享不支持https时，参考网上的做法将百度分享的js文件，也就是那个static文件夹拷贝到本地使用。\n[参考这篇教程](https://www.hrwhisper.me/baidu-share-not-support-https-solution/)\n\n\n### 解决问题\n\n但是怎么今天突然不行了呢，我敢肯定当时改完时没问题的，于是尝试找到出错的地方，进行修复：\n1. 这些文件都是被压缩的，想要直接修改还需要将文件反压缩一下。\n2. 找到出错文件share.js，出错原因大概是语法错误，因为不知道逻辑，所以将出错的代码行删掉了。\n3. 原本天真的以为万事大吉，谁知刷新之后🈶又出现两个新的错误。\n\n![](https://qiniu.nihaoshijie.com.cn/blog/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-26%2021.56.42.png)\n\n##### 这又是什么鬼？\n\n难道百度源码都是没有测试过的么？？\n\n1. 找到出问题的文件tangram.js,代码又是被压缩的，找到出问题代码fix之。\n2. 找到出问题的文件view_base.js,代码又是被压缩的，找到出问题代码fix之。\n3. 刷新一看，尼玛怎么又冒出新的错误？\n![](https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-27%2011.55.17.png)\n\n##### 心累。。\n于是又开始想别的办法，发誓不在修改百度分享的源码了。。\n\n### 完美解决\n\n经过一系列的查找的求助，终于找到了完美的结局办法：\n1. 百度分享的js源码其实也有部署在百度的另外一个支持https的cdn上即：[](https://ss1.baidu.com/9rA4cT8aBw9FktbgoI7O1ygwehsv/static/api/js/share.js).\n2. 利用这个cdn的url同样可以得到其他js源码文件的地址：\nhttps://ss1.baidu.com/9rA4cT8aBw9FktbgoI7O1ygwehsv/static/api/js/base/tangram.js\nhttps://ss1.baidu.com/9rA4cT8aBw9FktbgoI7O1ygwehsv/static/api/js/base/class.js\n3. 将原本的bdimg.share.baidu.com修改为ss1.baidu.com/9rA4cT8aBw9FktbgoI7O1ygwehsv，同时将http换成https即可。\n4. 但这并没有结束如果只改了share.js 这个js里面引入其他js同样会是http的，所以还需要将share.js inline到script标签里面，同时修改\n```javascript\njscfg:{domain:{staticUrl:\"https://ss1.baidu.com/9rA4cT8aBw9FktbgoI7O1ygwehsv/\"}}}\n```\n将用于模块化加载的js的地址也替换成新的。\n\n\n#### 大功告成！","source":"_posts/百度分享HTTPS折腾记.md","raw":"---\ntitle: 百度分享HTTPS折腾记\ndate: 2017-06-26 22:48:20\ntags:\n- hexo\n- bdshare\ncategories:\n- 701\n---\n>百度分享很坑！！\n\n### 发现问题\n\n今天打开博客忽然发现百度分享用不了了，点击分享按钮没有任何作用，于是打开控制台查看：\n![](https://qiniu.nihaoshijie.com.cn/blog/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-26%2021.56.04.png)\n##### 这是什么鬼！\n<!--more-->\n忽然想起来，之前我也是为了解决百度分享不支持https时，参考网上的做法将百度分享的js文件，也就是那个static文件夹拷贝到本地使用。\n[参考这篇教程](https://www.hrwhisper.me/baidu-share-not-support-https-solution/)\n\n\n### 解决问题\n\n但是怎么今天突然不行了呢，我敢肯定当时改完时没问题的，于是尝试找到出错的地方，进行修复：\n1. 这些文件都是被压缩的，想要直接修改还需要将文件反压缩一下。\n2. 找到出错文件share.js，出错原因大概是语法错误，因为不知道逻辑，所以将出错的代码行删掉了。\n3. 原本天真的以为万事大吉，谁知刷新之后🈶又出现两个新的错误。\n\n![](https://qiniu.nihaoshijie.com.cn/blog/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-26%2021.56.42.png)\n\n##### 这又是什么鬼？\n\n难道百度源码都是没有测试过的么？？\n\n1. 找到出问题的文件tangram.js,代码又是被压缩的，找到出问题代码fix之。\n2. 找到出问题的文件view_base.js,代码又是被压缩的，找到出问题代码fix之。\n3. 刷新一看，尼玛怎么又冒出新的错误？\n![](https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-27%2011.55.17.png)\n\n##### 心累。。\n于是又开始想别的办法，发誓不在修改百度分享的源码了。。\n\n### 完美解决\n\n经过一系列的查找的求助，终于找到了完美的结局办法：\n1. 百度分享的js源码其实也有部署在百度的另外一个支持https的cdn上即：[](https://ss1.baidu.com/9rA4cT8aBw9FktbgoI7O1ygwehsv/static/api/js/share.js).\n2. 利用这个cdn的url同样可以得到其他js源码文件的地址：\nhttps://ss1.baidu.com/9rA4cT8aBw9FktbgoI7O1ygwehsv/static/api/js/base/tangram.js\nhttps://ss1.baidu.com/9rA4cT8aBw9FktbgoI7O1ygwehsv/static/api/js/base/class.js\n3. 将原本的bdimg.share.baidu.com修改为ss1.baidu.com/9rA4cT8aBw9FktbgoI7O1ygwehsv，同时将http换成https即可。\n4. 但这并没有结束如果只改了share.js 这个js里面引入其他js同样会是http的，所以还需要将share.js inline到script标签里面，同时修改\n```javascript\njscfg:{domain:{staticUrl:\"https://ss1.baidu.com/9rA4cT8aBw9FktbgoI7O1ygwehsv/\"}}}\n```\n将用于模块化加载的js的地址也替换成新的。\n\n\n#### 大功告成！","slug":"百度分享HTTPS折腾记","published":1,"updated":"2019-04-02T16:49:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434q1d003d2wvju43p6xwh","content":"<blockquote>\n<p>百度分享很坑！！</p>\n</blockquote>\n<h3><span id=\"发现问题\">发现问题</span></h3><p>今天打开博客忽然发现百度分享用不了了，点击分享按钮没有任何作用，于是打开控制台查看：<br><img src=\"https://qiniu.nihaoshijie.com.cn/blog/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-26%2021.56.04.png\" alt></p>\n<h5><span id=\"这是什么鬼\">这是什么鬼！</span></h5><a id=\"more\"></a>\n<p>忽然想起来，之前我也是为了解决百度分享不支持https时，参考网上的做法将百度分享的js文件，也就是那个static文件夹拷贝到本地使用。<br><a href=\"https://www.hrwhisper.me/baidu-share-not-support-https-solution/\" target=\"_blank\" rel=\"noopener\">参考这篇教程</a></p>\n<h3><span id=\"解决问题\">解决问题</span></h3><p>但是怎么今天突然不行了呢，我敢肯定当时改完时没问题的，于是尝试找到出错的地方，进行修复：</p>\n<ol>\n<li>这些文件都是被压缩的，想要直接修改还需要将文件反压缩一下。</li>\n<li>找到出错文件share.js，出错原因大概是语法错误，因为不知道逻辑，所以将出错的代码行删掉了。</li>\n<li>原本天真的以为万事大吉，谁知刷新之后🈶又出现两个新的错误。</li>\n</ol>\n<p><img src=\"https://qiniu.nihaoshijie.com.cn/blog/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-26%2021.56.42.png\" alt></p>\n<h5><span id=\"这又是什么鬼\">这又是什么鬼？</span></h5><p>难道百度源码都是没有测试过的么？？</p>\n<ol>\n<li>找到出问题的文件tangram.js,代码又是被压缩的，找到出问题代码fix之。</li>\n<li>找到出问题的文件view_base.js,代码又是被压缩的，找到出问题代码fix之。</li>\n<li>刷新一看，尼玛怎么又冒出新的错误？<br><img src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-27%2011.55.17.png\" alt></li>\n</ol>\n<h5><span id=\"心累\">心累。。</span></h5><p>于是又开始想别的办法，发誓不在修改百度分享的源码了。。</p>\n<h3><span id=\"完美解决\">完美解决</span></h3><p>经过一系列的查找的求助，终于找到了完美的结局办法：</p>\n<ol>\n<li>百度分享的js源码其实也有部署在百度的另外一个支持https的cdn上即：<a href=\"https://ss1.baidu.com/9rA4cT8aBw9FktbgoI7O1ygwehsv/static/api/js/share.js\" target=\"_blank\" rel=\"noopener\"></a>.</li>\n<li>利用这个cdn的url同样可以得到其他js源码文件的地址：<br><a href=\"https://ss1.baidu.com/9rA4cT8aBw9FktbgoI7O1ygwehsv/static/api/js/base/tangram.js\" target=\"_blank\" rel=\"noopener\">https://ss1.baidu.com/9rA4cT8aBw9FktbgoI7O1ygwehsv/static/api/js/base/tangram.js</a><br><a href=\"https://ss1.baidu.com/9rA4cT8aBw9FktbgoI7O1ygwehsv/static/api/js/base/class.js\" target=\"_blank\" rel=\"noopener\">https://ss1.baidu.com/9rA4cT8aBw9FktbgoI7O1ygwehsv/static/api/js/base/class.js</a></li>\n<li>将原本的bdimg.share.baidu.com修改为ss1.baidu.com/9rA4cT8aBw9FktbgoI7O1ygwehsv，同时将http换成https即可。</li>\n<li>但这并没有结束如果只改了share.js 这个js里面引入其他js同样会是http的，所以还需要将share.js inline到script标签里面，同时修改<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jscfg:&#123;<span class=\"attr\">domain</span>:&#123;<span class=\"attr\">staticUrl</span>:<span class=\"string\">\"https://ss1.baidu.com/9rA4cT8aBw9FktbgoI7O1ygwehsv/\"</span>&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>将用于模块化加载的js的地址也替换成新的。</p>\n<h4><span id=\"大功告成\">大功告成！</span></h4>","site":{"data":{}},"excerpt":"<blockquote>\n<p>百度分享很坑！！</p>\n</blockquote>\n<h3 id=\"发现问题\"><a href=\"#发现问题\" class=\"headerlink\" title=\"发现问题\"></a>发现问题</h3><p>今天打开博客忽然发现百度分享用不了了，点击分享按钮没有任何作用，于是打开控制台查看：<br><img src=\"https://qiniu.nihaoshijie.com.cn/blog/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-26%2021.56.04.png\" alt=\"\"></p>\n<h5 id=\"这是什么鬼！\"><a href=\"#这是什么鬼！\" class=\"headerlink\" title=\"这是什么鬼！\"></a>这是什么鬼！</h5>","more":"<p>忽然想起来，之前我也是为了解决百度分享不支持https时，参考网上的做法将百度分享的js文件，也就是那个static文件夹拷贝到本地使用。<br><a href=\"https://www.hrwhisper.me/baidu-share-not-support-https-solution/\" target=\"_blank\" rel=\"noopener\">参考这篇教程</a></p>\n<h3 id=\"解决问题\"><a href=\"#解决问题\" class=\"headerlink\" title=\"解决问题\"></a>解决问题</h3><p>但是怎么今天突然不行了呢，我敢肯定当时改完时没问题的，于是尝试找到出错的地方，进行修复：</p>\n<ol>\n<li>这些文件都是被压缩的，想要直接修改还需要将文件反压缩一下。</li>\n<li>找到出错文件share.js，出错原因大概是语法错误，因为不知道逻辑，所以将出错的代码行删掉了。</li>\n<li>原本天真的以为万事大吉，谁知刷新之后🈶又出现两个新的错误。</li>\n</ol>\n<p><img src=\"https://qiniu.nihaoshijie.com.cn/blog/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-26%2021.56.42.png\" alt=\"\"></p>\n<h5 id=\"这又是什么鬼？\"><a href=\"#这又是什么鬼？\" class=\"headerlink\" title=\"这又是什么鬼？\"></a>这又是什么鬼？</h5><p>难道百度源码都是没有测试过的么？？</p>\n<ol>\n<li>找到出问题的文件tangram.js,代码又是被压缩的，找到出问题代码fix之。</li>\n<li>找到出问题的文件view_base.js,代码又是被压缩的，找到出问题代码fix之。</li>\n<li>刷新一看，尼玛怎么又冒出新的错误？<br><img src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-27%2011.55.17.png\" alt=\"\"></li>\n</ol>\n<h5 id=\"心累。。\"><a href=\"#心累。。\" class=\"headerlink\" title=\"心累。。\"></a>心累。。</h5><p>于是又开始想别的办法，发誓不在修改百度分享的源码了。。</p>\n<h3 id=\"完美解决\"><a href=\"#完美解决\" class=\"headerlink\" title=\"完美解决\"></a>完美解决</h3><p>经过一系列的查找的求助，终于找到了完美的结局办法：</p>\n<ol>\n<li>百度分享的js源码其实也有部署在百度的另外一个支持https的cdn上即：<a href=\"https://ss1.baidu.com/9rA4cT8aBw9FktbgoI7O1ygwehsv/static/api/js/share.js\" target=\"_blank\" rel=\"noopener\"></a>.</li>\n<li>利用这个cdn的url同样可以得到其他js源码文件的地址：<br><a href=\"https://ss1.baidu.com/9rA4cT8aBw9FktbgoI7O1ygwehsv/static/api/js/base/tangram.js\" target=\"_blank\" rel=\"noopener\">https://ss1.baidu.com/9rA4cT8aBw9FktbgoI7O1ygwehsv/static/api/js/base/tangram.js</a><br><a href=\"https://ss1.baidu.com/9rA4cT8aBw9FktbgoI7O1ygwehsv/static/api/js/base/class.js\" target=\"_blank\" rel=\"noopener\">https://ss1.baidu.com/9rA4cT8aBw9FktbgoI7O1ygwehsv/static/api/js/base/class.js</a></li>\n<li>将原本的bdimg.share.baidu.com修改为ss1.baidu.com/9rA4cT8aBw9FktbgoI7O1ygwehsv，同时将http换成https即可。</li>\n<li>但这并没有结束如果只改了share.js 这个js里面引入其他js同样会是http的，所以还需要将share.js inline到script标签里面，同时修改<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jscfg:&#123;<span class=\"attr\">domain</span>:&#123;<span class=\"attr\">staticUrl</span>:<span class=\"string\">\"https://ss1.baidu.com/9rA4cT8aBw9FktbgoI7O1ygwehsv/\"</span>&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>将用于模块化加载的js的地址也替换成新的。</p>\n<h4 id=\"大功告成！\"><a href=\"#大功告成！\" class=\"headerlink\" title=\"大功告成！\"></a>大功告成！</h4>"},{"title":"最新React全家桶实战使用配置指南","date":"2018-10-18T12:23:10.000Z","photos":["https://qiniu.nihaoshijie.com.cn/images/reactquanjiatong.png"],"_content":"\n### 写在前面\n\n这篇文档 是我结合以往的项目经验 加上自己本身对react webpack redux理解写下的总结文档，总共耗时一周总结下来的，希望能对读者能够有收获。\n\n# 目录\n\n1. [版本说明](#版本说明)\n2. [目录结构](#目录结构)\n3. [初始化项目](#初始化项目)\n4. [webpack](#webpack)\n5. [react](#react)\n6. [配置loader(sass,jsx)](#配置loader(sass,jsx))\n7. [引入babel](#引入babel)\n8. [使用HtmlWebpackPlugin](#使用HtmlWebpackPlugin)\n9. [redux](#redux)\n10. [使用webpack-dev-server](#使用webpack-dev-server)\n11. [多入口页面配置](#多入口页面配置)\n12. [如何理解`entry point(bundle)`,`chunk`,`module`](#entry)\n13. [多入口页面html配置](#多入口页面html配置)\n14. [模块热替换（Hot Module Replacement）](#hmr)\n15. [使用ESLint](#使用ESLint)\n16. [使用react-router](#使用react-router)\n16. [使用redux-thunk](#使用redux-thunk)\n17. [使用axios和async/await](#使用axios和async/await)\n18. [Code Splitting](#CodeSplitting)\n19. [使用CommonsChunkPlugin](#使用CommonsChunkPlugin)\n\n<!--more-->\n\n\n# 版本说明<div id=\"banben\"></div>\n由于构建相关例如webpack，babel等更新的较快，所以本教程以下面各种模块的版本号为主，切勿轻易修改或更新版本。\n```javascript\n\"dependencies\": {\n    \"babel-core\": \"^6.26.3\",\n    \"babel-eslint\": \"^8.2.3\",\n    \"babel-loader\": \"^7.1.4\",\n    \"babel-plugin-transform-async-to-generator\": \"^6.24.1\",\n    \"babel-plugin-transform-runtime\": \"^6.23.0\",\n    \"babel-preset-es2015\": \"^6.24.1\",\n    \"babel-preset-react\": \"^6.24.1\",\n    \"babel-preset-stage-0\": \"^6.24.1\",\n    \"babel-preset-stage-3\": \"^6.24.1\",\n    \"css-loader\": \"^0.28.11\",\n    \"eslint\": \"^4.19.1\",\n    \"eslint-loader\": \"^2.0.0\",\n    \"eslint-plugin-react\": \"^7.9.1\",\n    \"file-loader\": \"^1.1.11\",\n    \"history\": \"^4.7.2\",\n    \"html-webpack-plugin\": \"^3.2.0\",\n    \"react\": \"^16.4.0\",\n    \"react-dom\": \"^16.4.0\",\n    \"react-hot-loader\": \"^4.0.0\",\n    \"react-redux\": \"^5.0.7\",\n    \"react-router-dom\": \"^4.3.1\",\n    \"react-router-redux\": \"^5.0.0-alpha.9\",\n    \"redux\": \"^4.0.0\",\n    \"sass-loader\": \"^7.0.3\",\n    \"style-loader\": \"^0.21.0\",\n    \"url-loader\": \"^1.0.1\",\n    \"webpack\": \"^4.12.0\",\n    \"webpack-cli\": \"^3.0.3\",\n    \"webpack-dev-server\": \"^3.1.1\"\n}\n```\n# 目录结构<div id=\"mulu\"></div>\n开发和发布版本的配置文件是分开的，多入口页面的目录结构。\n```\nreact-family/\n    |\n    |──dist/                                    * 发布版本构建输出路径\n    |\n    |──dev/                                     * 调试版本构建输出路径\n    |\n    |──src/                                     * 工具函数\n    |     |\n    |     |—— component/                        * 各页面公用组件\n    |     |\n    |     |—— page/                             * 页面代码\n    |     |      |—— index/                     * 页面代码\n    |     |      |        |—— Main/             * 组件代码\n    |     |      |        |       |—— Main.jsx  * 组件jsx\n    |     |      |        |       |—— Main.scss * 组件css\n    |     |      |\n    |     |      |—— detail/                    * 页面代码\n    |     |\n    |     |—— static/                           * 静态文件js，css\n    |\n    |\n    |──webpack.config.build.js                  * 发布版本使用的webpack配置文件\n    |──webpack.config.dev.js                    * 调试版本使用的webpack配置文件\n    |──.eslint                                  * eslint配置文件\n    |__.babelrc                                 * babel配置文件\n```\n\n# 初始化项目<div id=\"initcode\"></div>\n1. 创建文件夹\n\n```bash\nmkdir react-family-bucket\n```\n2. 初始化npm\n```bash\ncd react-family-bucket\nnpm init\n```\n如果有特殊需要，可以填入自己的配置，一路回车下来，会生成一个`package.json`，里面是你项目的基本信息，后面的npm依赖安装也会配置在这里。\n# webpack<div id=\"webpack\"></div>\n1. 安装[webpack](https://webpack.js.org/)\n```bash\nnpm install webpack --save\nor\nnpm install webpack --g\n```\n`--save`是将当前webpack安装到react-family-bucket下的`/node_modules`。<br>\n`--g`是将当前webpack安装到全局下面，可以在node的安装目录下找到全局的`/node_modules`。\n\n2. 配置webopack配置文件\n\n```bash\ntouch webpack.config.dev.js\n```\n新建一个app.js\n```bash\ntouch app.js\n```\n写入基本的webpack配置，可以[参考这里](https://webpack.js.org/)：\n\n```javascript\nconst path = require('path');\nconst srcRoot = './src';\nmodule.exports = {\n\n    // 输入配置\n    entry: [\n      './app.js'\n    ],,\n\n    // 输出配置\n    output: {\n        path: path.resolve(__dirname, './dev'),\n\n        filename: 'bundle.min.js'\n    },\n\n};\n```\n3, 执行webpack命令\n如果是全局安装：\n```bash\nwebpack --config webpack.config.dev.js\n```\n如果是当前目录安装：\n```bash\n./node_modules/.bin/webpack --config webpack.config.dev.js\n```\n在package.json中添加执行命令：\n```json\n  \"scripts\": {\n    \"dev\": \"./node_modules/.bin/webpack --config webpack.config.dev.js\",\n  },\n```\n执行`npm run dev`命令之后，会发现需要安装`webpack-cli`，（webpack4之后需要安装这个）\n```bash\nnpm install webpack-cli --save\n```\n\n去除`WARNING in configuration`警告,在webpack.config.dev.js增加一个配置即可：\n\n```javascript\n...\nmode: 'development'\n...\n```\n成功之后会在dev下面生成bundle.min.js代表正常。<br>\n如果想要动态监听文件变化需要在命令后面添加  `--watch`\n# react<div id=\"react\"></div>\n1. 安装[react](https://reactjs.org/)\n\n```bash\nnpm install react react-dom --save\n```\n2. 创建page目录和index页面文件：\n\n```bash\nmkdir src\nmkdir page\ncd page\n```\n创建index\n```bash\nmkdir index\ncd index & touch index.js & touch index.html\n```\nindex.js\n\n```javascript\nimport ReactDom from 'react-dom';\nimport Main from './Main/Main.jsx';\n\nReactDom.render(<Main />, document.getElementById('root'));\n```\nindex.html\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title>index</title>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\">\n\n</head>\n<body>\n<div id=\"root\"></div>\n</body>\n</html>\n```\n3. 创建Main组件\n\n```javascript\n\nimport React from 'react';\n\nclass Main extends React.Component {\n\n    constructor(props) {\n        super(props);\n\n    }\n\n    render() {\n\n        return (<div>Main</div>);\n    }\n}\n\nexport default Main;\n```\n* `export` 和 `export default`区别：\n\nexport可以有多个\n\n```javascript\nxx.js:\nexport const test1 = 'a'\nexport function test2() {}\n\nyy.js:\nimport { test1, test2 } from 'xx.js';\n```\nexport default只能有1个\n\n```javascript\nxx.js:\nlet test1 = 'a';\nexport default test1;\n\nyy.js:\nimport test1 from 'xx.js';\n```\n* `export` 和 `module.exports`\n\n```javascript\nlet exports = module.exports;\n```\n4. 修改webpack配置入口文件\n\n```javascript\nentry: [\n    path.resolve(srcRoot,'./page/index/index.js')\n],\n```\n# 配置loader<div id=\"loader\"></div>\n\n1. 处理样式文件需要这些loader:\n* [css-loader](https://github.com/webpack-contrib/css-loader)\n* [sass-loader](https://github.com/webpack-contrib/sass-loader)\n* [style-loader](https://github.com/webpack-contrib/style-loader)\n\n```bash\nnpm install css-loader sass-loader style-loader file-loader --save\n```\n配置：\n\n```javascript\n    module: {\n        // 加载器配置\n        rules: [\n            { test: /\\.css$/, use: ['style-loader', 'css-loader'], include: path.resolve(srcRoot)},\n            { test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'], include: path.resolve(srcRoot)}\n        ]\n    },\n```\n2. [url-loader](https://github.com/webpack-contrib/url-loader)处理处理静态文件\n\n```bash\nnpm install url-loader --save\n```\n配置：\n```\n    module: {\n        // 加载器配置\n        rules: [\n            { test: /\\.(png|jpg|jpeg)$/, use: 'url-loader?limit=8192&name=images/[name].[hash].[ext]', include: path.resolve(srcRoot)}\n        ]\n    },\n```\n`limit:`表示超过多少就使用base64来代替，单位是byte<br>\n`name:`可以设置图片的路径，名称和是否使用hash 具体[参考这里](https://github.com/webpack-contrib/url-loader)\n\n# 引入babel<div id=\"babel\"></div>\n\n[bebel](https://babeljs.io/)是用来解析es6语法或者是es7语法分解析器，让开发者能够使用新的es语法，同时支持jsx，vue等多种框架。\n1. 安装babel\n* [babel-core](https://www.npmjs.com/package/babel-core)\n* [babel-loader](https://www.npmjs.com/package/babel-loader)\n\n```bash\nnpm install babel-core babel-loader --save\n```\n配置：\n```\n    module: {\n        // 加载器配置\n        rules: [\n            { test: /\\.(js|jsx)$/, use: [{loader:'babel-loader'}] ,include: path.resolve(srcRoot)},\n        ]\n    },\n```\nbabel配置文件：`.babelrc`\n\n```bash\ntouch .babelrc\n```\n配置：\n\n```javascript\n{\n    \"presets\": [\n        \"es2015\",\n        \"react\",\n        \"stage-0\"\n    ],\n    \"plugins\": []\n}\n```\nbabel支持自定义的预设(presets)或插件(plugins),只有配置了这两个才能让babel生效，单独的安装babel是无意义的<br>\n<br>\n`presets`：代表babel支持那种语法(就是你用那种语法写)，优先级是从下往上,`state-0|1|2|..`代表有很多没有列入标准的语法回已state-x表示,[参考这里](https://babeljs.io/docs/en/babel-preset-stage-0.html)<br>\n`plugins`:代表babel解析的时候使用哪些插件，作用和presets类似，优先级是从上往下。\n依次安装：\n* [babel-preset-es2015](https://www.npmjs.com/package/babel-preset-es2015)\n* [babel-preset-react](https://www.npmjs.com/package/babel-preset-react)\n* [babel-preset-stage-0](https://www.npmjs.com/package/babel-preset-stage-0)\n\n```bash\nnpm install babel-preset-es2015 babel-preset-react babel-preset-stage-0 --save\n```\n\n2. [babel-polyfill](https://babeljs.io/docs/en/babel-polyfill.html)是什么？<br>\n我们之前使用的babel，babel-loader 默认只转换新的 JavaScript 语法，而不转换新的 API。例如，Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转译。如果想使用这些新的对象和方法，必须使用 babel-polyfill，为当前环境提供一个垫片。\n\n```bash\nnpm install --save babel-polyfill\n```\n使用：\n\n```javascript\nimport \"babel-polyfill\";\n```\n3. [transform-runtime](https://babeljs.io/docs/en/babel-plugin-transform-runtime)有什么区别？<br>\n当使用`babel-polyfill`时有一些问题：<br>\n* 默认会引入所有babel支持的新语法，这样就会导致你的文件代码非常庞大。\n* 通过向全局对象和内置对象的prototype上添加方法来达成目的,造成全局变量污染。\n\n这时就需要`transform-runtime`来帮我们有选择性的引入\n\n```bash\nnpm install --save babel-plugin-transform-runtime\n```\n配置文件：\n\n```javascript\n{\n  \"plugins\": [\n    [\"transform-runtime\", {\n      \"helpers\": false,\n      \"polyfill\": false,\n      \"regenerator\": true,\n      \"moduleName\": \"babel-runtime\"\n    }]\n  ]\n}\n```\n# 使用HtmlWebpackPlugin<div id=\"HtmlWebpackPlugin\"></div>\n记得我们之前新建的index.html么 我们执行构建命令之后并没有将index.html打包到dev目录下 我们需要[HtmlWebpackPlugin](https://github.com/jantimon/html-webpack-plugin)来将我们output的js和html结合起来\n\n```bash\nnpm install html-webpack-plugin --save\n```\n配置：\n\n```javascript\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n...\nplugins: [\n    new HtmlWebpackPlugin({\n        filename: path.resolve(devPath, 'index.html'),\n        template: path.resolve(srcRoot, './page/index/index.html'),\n    })\n]\n```\n`filename`:可以设置html输出的路径和文件名<br>\n`template`:可以设置已哪个html文件为模版\n更多参数配置可以[参考这里](https://github.com/jantimon/html-webpack-plugin)\n\n# redux<div id=\"redux\"></div>\n\n关于[redux](http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html)的使用可以参考阮一峰老师的入门[教程](http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html)\n\n1. 安装redux\n* [redux](https://www.npmjs.com/package/redux)\n* [react-redux](https://www.npmjs.com/package/react-redux)\n\n```bash\nnpm install redux react-redux --save\n```\n\n2. 新建`reducers`，`actions`目录和文件\n```\n|—— index/                          \n|—— Main/                   * 组件代码\n|       |—— Main.jsx        * 组件jsx\n|       |—— Main.scss       * 组件css\n|\n|—— actions/ \n|       |—— actionTypes.js  * action常量\n|       |—— todoAction.js   * action\n|\n|—— reducers/ \n|       |—— todoReducer.js  * reducer\n|\n|—— store.js\n|\n|—— index.js\n\n```\n\n3. 修改代码，引入redux,这里以一个redux todo为demo例子：<br>\n\n`index.js`\n\n```javascript\nimport ReactDom from 'react-dom';\nimport React from 'react';\nimport Main from './Main/Main.jsx';\nimport store from './store.js';\nimport { Provider } from 'react-redux';\n\nReactDom.render(\n    <Provider store={store}>\n        <Main />\n    </Provider>\n, document.getElementById('root'));\n```\n`store.js`\n\n```javascript\nimport { createStore } from 'redux';\nimport todoReducer from './reducers/todoReducer.js';\n\nconst store = createStore(todoReducer);\n\nexport default store;\n```\n`tabReducer.js`\n\n```javascript\nimport { ADD_TODO } from '../actions/actionTypes.js';\n\nconst initialState = {\n      todoList: []\n};\n\nconst addTodo = (state, action) => {\n\n  return { ...state, todoList: state.todoList.concat(action.obj) }\n}\n\nconst todoReducer = (state = initialState, action) => {\n  switch(action.type) {\n    case ADD_TODO: return addTodo(state, action);\n    default: return state;\n  }\n};\nexport default todoReducer;\n\n```\n`Main.jsx`\n\n```javascript\nimport React from 'react';\nimport { connect } from 'react-redux';\nimport { addTodo } from '../actions/todoAction.js';\n\nclass Main extends React.Component {\n\n    onClick(){\n        let text = this.refs.input;\n\n        this.props.dispatch(addTodo({\n            text: text.value\n        }))\n    }\n    render() {\n        return (\n            <div>\n                <input ref=\"input\" type=\"text\"></input>\n                <button onClick={()=>this.onClick()}>提交</button>\n                <ul>\n                {this.props.todoList.map((item, index)=>{\n                    return <li key={index}>{item.text}</li>\n                })}\n                </ul>\n            </div>\n        );\n    }\n}\n\nexport default connect(\n    state => ({\n        todoList: state.todoList\n    })\n)(Main);\n```\n`todoAction.js`\n\n```javascript\nimport { ADD_TODO } from './actionTypes.js';\n\nexport const addTodo = (obj) => {\n  return {\n    type: ADD_TODO,\n    obj: obj\n  };\n};\n```\n\n# 使用webpack-dev-server<div id=\"webpack-dev-server\"></div>\n[webpack-dev-server](https://github.com/jantimon/webpack-dev-server)是一个小型的`Node.js Express`服务器,它使用webpack-dev-middleware来服务于webpack的包。\n1. 安装\n\n```bash\nnpm install webpack-dev-server --save\n```\n修改在package.json中添加的执行命令：\n```json\n  \"scripts\": {\n    \"dev\": \"./node_modules/.bin/webpack-dev-server --config webpack.config.dev.js\",\n  },\n```\n2. 配置webpack配置文件：\n\n```json\ndevServer: {\n    \"contentBase\": devPath,\n    \"compress\": true,\n},\n```\n`contentBase` 表示server文件的根目录\n`compress` 表示开启gzip\n更多的配置文档[参考这里](https://webpack.docschina.org/configuration/dev-server/)\n\n* `webpack-dev-server`默认情况下会将output的内容放在内存中，是看不到物理的文件的，如果想要看到物理的dev下面的文件可以安装[write-file-webpack-plugin](https://www.npmjs.com/package/webpack-dev-server)这个插件。\n\n* `webpack-dev-server`默认会开启livereload功能\n\n3. `devtool`功能：<br>\n具体来说添加了`devtool: 'inline-source-map'`之后，利用source-map你在chrome控制台看到的source源码都是真正的源码，未压缩，未编译前的代码，没有添加，你看到的代码是真实的压缩过，编译过的代码，更多devtool的配置可以[参考这里](https://webpack.docschina.org/configuration/devtool/)\n\n# 多入口文件配置<div id=\"rukou\"></div>\n在之前的配置中，都是基于单入口页面配置的，entry和output只有一个文件，但是实际项目很多情况下是多页面的，在配置多页面时，有2中方法可以选择：\n\n1. 在entry入口配置时，传入对象而不是单独数组,output时利用`[name]`关键字来区分输出文件例如：\n\n```javascript\nentry: {\n    index: [path.resolve(srcRoot,'./page/index/index1.js'),path.resolve(srcRoot,'./page/index/index2.js')],\n    detail: path.resolve(srcRoot,'./page/detail/detail.js'),\n    home: path.resolve(srcRoot,'./page/home/home.js'),\n},\noutput: {\n    path: path.resolve(__dirname, './dev'),\n\n    filename: '[name].min.js'\n},\n```\n2. 通过node动态遍历需要entry point的目录，来动态生成entry：\n\n```javascript\nconst pageDir = path.resolve(srcRoot, 'page');\nfunction getEntry() {\n    let entryMap = {};\n\n    fs.readdirSync(pageDir).forEach((pathname)=>{\n        let fullPathName = path.resolve(pageDir, pathname);\n        let stat = fs.statSync(fullPathName);\n        let fileName = path.resolve(fullPathName, 'index.js');\n\n        if (stat.isDirectory() && fs.existsSync(fileName)) {\n            entryMap[pathname] = fileName;\n        }\n\n    });\n\n    return entryMap;\n}\n{\n    ...\n    entry: getEntry()\n    ...\n}\n```\n\n本demo采用的是第二中写法，能够更加灵活。\n\n# 如何理解`entry point(bundle)`,`chunk`,`module`<div id=\"entry\"></div>\n\n在webpack中，如何理解`entry point(bundle)`,`chunk`,`module`?\n![](https://qiniu.nihaoshijie.com.cn/image/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-15%20%E4%B8%8B%E5%8D%889.06.45.png)\n\n根据图上的表述，我这里简单说一下便于理解的结论：<br>\n* 配置中每个文件例如index1.js,index2.js,detail.js,home.js都属于`entry point`.\n* entry这个配置中，每个key值,index,detail,home都相当于`chunk`。\n* 我们在代码中的require或者import的都属于`module`，这点很好理解。\n* `chunk`的分类比较特别，有`entry chunk`,`initial chunk`,`normal chunk`,参考[这个文章](https://github.com/webpack/webpack.js.org/issues/970)\n* 正常情况下，一个`chunk`对应一个output,在使用了`CommonsChunkPlugin`或者`require.ensure`之后，`chunk`就变成了`initial chunk`,`normal chunk`，这时，一个`chunk`对应多个output。<br>\n理解这些概念对于后续使用webpack插件有很大的帮助。\n\n# 多入口页面html配置<div id=\"html\"></div>\n\n之前我们配置`HtmlWebpackPlugin`时，同样采用的是但页面的配置，这里我们将进行多页面改造,`entryMap`是上一步得到的entry：\n\n```javascript\nfunction htmlAarray(entryMap) {\n    let htmlAarray = [];\n\n    Object.keys(entryMap).forEach(function(key){\n        let fullPathName = path.resolve(pageDir, key);\n        let fileName = path.resolve(fullPathName, key + '.html')\n        if (fs.existsSync(fileName)) {\n            htmlAarray.push(new HtmlWebpackPlugin({\n                chunks: key, // 注意这里的key就是chunk\n                filename: key + '.html',\n                template: fileName,\n                inlineSource:  '.(js|css)'\n            }))\n        }\n    });\n\n    return htmlAarray;\n\n}\n```\n修改plugin配置：\n\n```javascript\nplugins: [\n     ...\n].concat(htmlMap)\n```\n# 模块热替换（Hot Module Replacement）<div id=\"hmr\"></div>\n\n[模块热替换](https://webpack.docschina.org/guides/hot-module-replacement)(Hot Module Replacement 或 HMR)是 webpack 提供的最有用的功能之一。它允许在运行时更新各种模块，而无需进行完全刷新,很高大上有木有！\n\n下面说一下配置方法，它需要结合`devServer`使用：\n\n```javascript\ndevServer: {\n    hot: true // 开启HMR\n},\n```\n开启plugin：\n\n```javascript\nconst webpack = require('webpack');\nplugins: [\n    new webpack.NamedModulesPlugin(),\n    new webpack.HotModuleReplacementPlugin(),\n].concat(htmlMap)\n```\n\n结合React一起使用：<br>\n\n1. 安装[react-hot-loader](https://github.com/jantimon/react-hot-loader),\n\n```bash\nnpm install react-hot-loader --save\n```\n并新建一个Container.jsx:<br>\n\n```javascript\nimport React from 'react';\nimport Main from './Main.jsx';\nimport { hot } from 'react-hot-loader'\n\nclass Container extends React.Component {\n\n    render() {\n        return <Main />\n    }\n        \n}\nexport default hot(module)(Container);\n```\n\n结合redux：如果项目没有使用redux，可以无需配置后面2步<br>\n2. 修改store.js新增下面代码，为了让reducer也能实时热替换\n\n```javascript\nif (module.hot) {\n    module.hot.accept('./reducers/todoReducer.js', () => {\n      const nextRootReducer = require('./reducers/todoReducer.js').default;\n      store.replaceReducer(nextRootReducer);\n    });\n}\n```\n3. 修改index.js\n\n```javascript\nimport ReactDom from 'react-dom';\nimport React from 'react';\nimport Container from './Main/Container.jsx';\nimport store from './store.js';\n\nimport { Provider } from 'react-redux';\n\nReactDom.render(\n    <Provider store={store}>\n        <Container />\n    </Provider>\n, document.getElementById('root'));\n```\n\n当控制台看到`[WDS] Hot Module Replacement enabled.`代表开启成功\n\n# 使用ESLint<div id=\"eslint\"></div>\n[ESLint](https://eslint.org/) 是众多 Javascript Linter 中的其中一种，其他比较常见的还有 [JSLint](https://www.jslint.com/) 跟 [JSHint](http://jshint.com/)，之所以用 ESLint 是因为他可以自由选择要使用哪些规则，也有很多现成的 plugin 可以使用，另外他对 ES6 还有 JSX 的支持程度跟其他 linter 相比之下也是最高的。\n\n1. 安装ESLint\n\n```bash\nnpm install eslint eslint-loader babel-eslint --save\n```\n其中`eslint-loader`是将webpack和eslint结合起来在webpack的配置文件中新增一个eslint-loader种，修改如下\n\n```javascript\n{ test: /\\.(js|jsx)$/, use: [{loader:'babel-loader'},{loader:'eslint-loader'}] ,include: path.resolve(srcRoot)},\n```\n\n2. 新建`.eslintrc`配置文件,将parser配置成`babel-eslint`\n\n```json\n{\n    \"extends\": [\"eslint:recommended\"],\n    \n    \"parser\": \"babel-eslint\",\n\n    \"globals\": {\n    },\n    \"rules\": {\n    }\n}\n```\n\n3. 安装[eslint-plugin-react](https://github.com/jantimon/eslint-plugin-react):\n\n```bash\nnpm install eslint-plugin-react --save\n```\n* 说明一下，正常情况下每个eslint规则都是需要在`rule`下面配置，如果什么都不配置，其实本身eslint是不生效的。\n* eslint本身有很多默认的规则模版，可以通过`extends`来配置，默认可以使用`eslint:recommended`。\n* 在使用react开发时可以安装`eslint-plugin-react`来告知使用react专用的规则来lint。\n3. 修改`.eslintrc`配置文件,增加rules，更多rules配置可以[参考这里](https://eslint.org/docs/rules/)\n\n```javascript\n{\n    \"extends\": [\"eslint:recommended\",\"plugin:react/recommended\"],\n    \n    \"parser\": \"babel-eslint\",\n\n    \"globals\": {\n        \"window\": true,\n        \"document\": true,\n        \"module\": true,\n        \"require\": true\n    },\n    \"rules\": {\n        \"react/prop-types\" : \"off\",\n        \"no-console\" : \"off\"\n    }\n}\n```\n\n# 使用react-router<div id=\"react-router\"></div>\nreact-router强大指出在于方便代码管理，结合redux使用更加强大，同时支持web，native更多[参考这里](https://reacttraining.com/react-router/)\n1. 安装[react-router-dom](https://github.com/jantimon/react-router-dom)\n\n```bash\nnpm install react-router-dom --save\n```\n2. 如果项目中用了redux，可以安装[react-router-redux](https://github.com/ReactTraining/react-router/tree/master/packages/react-router-redux)\n\n```bash\nnpm install react-router-redux@next history --save\n```\n\n3. 修改代码：<br>\n`index.js`:\n\n```javascript\nimport ReactDom from 'react-dom';\nimport React from 'react';\nimport Container from './Main/Container.jsx';\nimport { store, history } from './store.js';\n\nimport { Provider } from 'react-redux';\n\nimport createHistory from 'history/createHashHistory';\nimport { ConnectedRouter } from 'react-router-redux';\n\nconst history = createHistory();\n\nReactDom.render(\n    <Provider store={store}>\n        <ConnectedRouter history={history}>\n            <Container />\n        </ConnectedRouter>\n    </Provider>\n, document.getElementById('root'));\n```\n\n结合`history`,react-router一共有3中不同的router：\n* [BrowserRouter](https://reacttraining.com/react-router/web/api/BrowserRouter)通过`history/createBrowserHistory`引入:当切换时，url会动态更新，底层使用的时html5的[pushState](https://blog.csdn.net/tianyitianyi1/article/details/7426606)。\n* [HashRouter](https://reacttraining.com/react-router/web/api/HashRouter)通过`history/createHashHistory`引入:当切换时，动态修改hash，利用hashchange事件。\n* [MemoryRouter](https://reacttraining.com/react-router/web/api/MemoryRouter)通过`history/createMemoryHistory`引入:将路径，路由相关数据存入内存中，不涉及url相关更新，兼容性好。\n\n更多配置可以[参考这里](https://reacttraining.com/react-router/)\n\n4. 如果想要在代码逻辑中获取当前的route路径需要引入`router-reducer`:<br>\n新建`main.js`:\n\n```javascript\nimport { combineReducers } from 'redux';\nimport { routerReducer } from \"react-router-redux\";\nimport todoReducer from './todoReducer.js';\n\nconst reducers = combineReducers({\n  todoReducer,\n  router: routerReducer\n});\nexport default reducers;\n```\n\n修改`store.js`:\n\n```javascript\nimport { createStore } from 'redux';\nimport mainReducer from './reducers/main.js';\n\nconst store = createStore(mainReducer);\n\nexport default store;\n```\n然后就可以在`this.props.router`里面获取单相关的路径信息\n4. 如果需要自己通过action来触发router的跳转，需要引入`routerMiddleware`:\n\n```javascript\nimport { createStore,applyMiddleware } from 'redux';\nimport { routerMiddleware } from \"react-router-redux\";\nconst middleware = routerMiddleware(history);\nconst store = createStore(mainReducer,applyMiddleware(middleware));\n```\n\n5. 使用`Route`和`Link`和`withRouter`:<br>\n先说说都是干嘛的：<br>\n* [Route](https://reacttraining.com/react-router/web/api/Route):component里面的内容即是tab的主要内容，这个从react-router4开始生效：\n\n```javascript\n<Route exact path=\"/\" component={Div1}></Route>\n<Route path=\"/2\" component={Div2}></Route>\n```\n* [Link](https://reacttraining.com/react-router/web/api/Link):通常也可以用[NavLink](https://reacttraining.com/react-router/web/api/NavLink)，相当于tab按钮，控制router的切换,`activeClass`表示当前tab处于激活态时应用上的class。\n* [withRouter](https://reacttraining.com/react-router/web/api/withRouter):如果你用了redux，那么你一定要引入它。\n\n```javascript\nexport default withRouter(connect(\n    state => ({\n        todoList: state.todoReducer.todoList\n    })\n)(Main));\n```\n\n*如果你在使用hash时遇到`Warning: Hash history cannot PUSH the same path; a new entry will not be added to the history stack`错误，可以将push改为replace即*\n\n```javascript\n<NavLink\n    replace={true}\n    to=\"/2\"\n    activeClassName=\"selected\"\n    >切换到2号</NavLink>\n```\n6. 设置初始化路由：\n* `BrowserRouter`和`HashRouter`:\n\n```javascript\nconst history = createHistory();\nhistory.push('2');\n```\n* `MemoryRouter`:\n\n```javascript\nconst history = createMemoryHistory({\n    initialEntries: ['/2']\n});\n```\n\n# 使用redux-thunk<div id=\"redux-thunk\"></div>\n\n[redux-thunk](https://www.npmjs.com/package/redux-thunk) 是一个比较流行的 redux 异步 action 中间件，比如 action 中有 setTimeout 或者通过 fetch通用远程 API 这些场景，那么久应该使用 redux-thunk 了。redux-thunk 帮助你统一了异步和同步 action 的调用方式，把异步过程放在 action 级别解决，对 component 没有影响。\n\n1. 安装`redux-thunk`:\n```bash\nnpm install redux-thunk --save\n```\n2. 修改`store.js`:\n\n```javascript\n\nimport { createStore,applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport mainReducer from './reducers/main';\n...\nconst store = createStore(mainReducer, applyMiddleware(thunk));\n...\nexport default store;\n```\n3. 在`action.js`使用redux-thunk：\n\n```javascript\nexport const getData = (obj) => (dispatch, getState) => {\n  setTimeout(()=>{\n    dispatch({\n        type: GET_DATA,\n        obj: obj\n    });\n  },1000);\n};\n```\n\n# 使用axios和async/await<div id=\"axios\"></div>\n\n[axios](https://github.com/axios/axios) 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端：\n\n* 从浏览器中创建 XMLHttpRequest\n* 从 node.js 发出 http 请求\n* 支持 Promise API\n* 自动转换JSON数据\n\n1. 安装axios:\n\n```bash\nnpm install axios --save\n```\n\n2. 在action中使用axios：\n\n```javascript\nimport axios from 'axios';\nexport const getData = (obj) => (dispatch, getState) => {\n    axios.get('/json/comments.json').then((resp)=>{\n        dispatch({\n            type: GET_DATA,\n            obj: resp\n        });\n    });\n};\n```\n[async/await](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function)：<br>\n\nJavascript的回调地狱，相信很多人都知道，尤其是在node端，近些年比较流行的是[Promise](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)的解决方案，但是随着 Node 7 的发布，编程终级解决方案的 async/await应声而出。\n\n```javascript\nfunction resolveAfter2Seconds() {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve('resolved');\n    }, 2000);\n  });\n}\n\nasync function asyncCall() {\n  var result = await resolveAfter2Seconds();\n}\n\nasyncCall();\n```\nasync/await的用途是简化使用 promises 异步调用的操作，并对一组 Promises执行某些操作。await前提是方法返回的是一个Promise对象，正如Promises类似于结构化回调，async/await类似于组合生成器和 promises。<br>\n\n1. `async/await`需要安装[babel-plugin-transform-async-to-generator](https://www.npmjs.com/package/babel-plugin-transform-async-to-generator)。\n\n```bash\nnpm install babel-plugin-transform-async-to-generator --save\n```\n\n2. 在`.babelrc`中增加配置：\n\n```javascript\n    \"plugins\": [\n        \"transform-async-to-generator\"\n    ]\n```\n\n这样做仅仅是将async转换generator，如果你当前的浏览器不支持generator，你将会收到一个`Uncaught ReferenceError: regeneratorRuntime is not defined`的错误，你需要：<br>\n3. 安装[babel-plugin-transform-runtime](https://www.npmjs.com/package/babel-plugin-transform-runtime):\n\n```bash\nnpm install babel-plugin-transform-async-to-generator --save\n```\n\n4. 修改`.babelrc`中的配置(可以去掉之前配置的transform-async-to-generator)：\n\n```javascript\n    \"plugins\": [\n        \"transform-runtime\"\n    ]\n```\n5. 如果不想引入所有的polyfill(参考上面对babel的解释),可以增加配置：\n\n```javascript\n    \"plugins\": [\n        \"transform-runtime\",\n            {\n                \"polyfill\": false,\n\n                \"regenerator\": true,\n            }\n    ]\n```\n6. 结合axios使用：\n\n```javascript\nimport axios from 'axios';\nexport const getData = (obj) => async (dispatch, getState) => {\n    let resp = axios.get('/json/comments.json');\n    dispatch({\n        type: GET_DATA,\n        obj: resp\n    });\n};\n```\n\n# Code Splitting<div id=\"CodeSplitting\"></div>\n1. 对于webpack1，2之前，你可以使用`require.ensure`来控制一个组件的懒加载：<br>\n\n```javascript\nrequire.ensure([], _require => {\n    let Component = _require('./Component.jsx');\n},'lazyname')\n```\n2. 在webpack4中，官方已经不再推荐使用`require.ensure`来使用懒加载功能*Dynamic Imports*，取而代之的是ES6的`import()`方法：\n\n```javascript\nimport(\n  /* webpackChunkName: \"my-chunk-name\" */\n  /* webpackMode: \"lazy\" */\n  'module'\n);\n```\n不小小看注释里的代码，webpack在打包时会动态识别这里的代码来做相关的配置，例如chunk name等等。\n3. [Prefetching/Preloading modules](https://webpack.js.org/guides/code-splitting/#prefetching-preloading-modules):<br>\n\nwebpack 4.6.0+支持了Prefetching/Preloading的写法:\n\n```javascript\n//...\nimport(/* webpackPreload: true */ 'ChartingLibrary');\n```\n4. 结合React-Router使用:<br>\n\n[react-loadable](https://www.npmjs.com/package/react-loadable)对上述的功能做了封装，丰富了一些功能，结合`React-Router`起来使用更加方便。\n\n```bash\nnpm install react-loadable --save\n```\n在react-router里使用：\n\n```javascript\nfunction Loading() {\n  return <div>Loading...</div>;\n}\n\nlet Div2 = Loadable({\n  loader: () => import('./Div2'), \n  loading: Loading,\n});\n\n<Route path=\"/2\" component={Div2}></Route>\n```\n\n\n# 使用CommonsChunkPlugin\n\n`CommonsChunkPlugin` 插件，是一个可选的用于建立一个独立文件(又称作 chunk)的功能，这个文件包括多个入口 chunk 的公共模块。通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存起来到缓存中供后续使用。<br>\n\n1. 在webpack4之前的用法：\n\n```javascript\nnew webpack.optimize.CommonsChunkPlugin({\n    name: 'common',\n    chunks: ['page1','page2'],\n    minChunks: 3\n})\n```\n* `name`: string: 提出出的名称\n* `chunks`: string[]: webpack会从传入的chunk里面提取公共代码,默认从所有entry里提取\n* `minChunks`: number|infinity|function(module,count)->boolean: 如果传入数字或infinity(默认值为3)，就是告诉webpack，只有当模块重复的次数大于等于该数字时，这个模块才会被提取出来。当传入为函数时，所有符合条件的chunk中的模块都会被传入该函数做计算，返回true的模块会被提取到目标chunk。\n更多的参数配置，可以[参考这里](https://webpack.js.org/plugins/commons-chunk-plugin/#src/components/Sidebar/Sidebar.jsx)\n\n2. 在webpack4之后的用法：\n\n\n```javascript\n\nmodule.exports = {\n  //...\n  optimization: {\n    splitChunks: {\n      chunks: 'async',\n      minSize: 30000,\n      minChunks: 1,\n      maxAsyncRequests: 5,\n      maxInitialRequests: 3,\n      automaticNameDelimiter: '~',\n      name: true,\n      cacheGroups: {\n        vendors: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          priority: -10\n        },\n        default: {\n          minChunks: 2,\n          priority: -20,\n          reuseExistingChunk: true\n        }\n      }\n    }\n  }\n};\n```\n\n* `splitChunks`: 配置一个分离chunk(代替老版本的CommonsChunkPlugin)\n* `cacheGroups`: 自定义配置主要使用它来决定生成的文件:\n\n1. `test`: 限制范围\n2. `name`: 生成文件名\n3. `priority`: 优先级\n\n\n* `minSize`: number: 最小尺寸必须大于此值，默认30000B\n* `minChunks`: 其他entry引用次数大于此值，默认1\n* `maxInitialRequests`: entry文件请求的chunks不应该超过此值（请求过多，耗时）\n* `maxAsyncRequests`: 异步请求的chunks不应该超过此值\n* `automaticNameDelimiter`: 自动命名连接符\n* `chunks`: 值为\"initial\", \"async\"（默认） 或 \"all\":\n\n1. `initial`: 入口chunk，对于异步导入的文件不处理\n2. `async`: 异步chunk，只对异步导入的文件处理\n3. `all`: 全部chunk\n\n\n\n","source":"_posts/最新React全家桶实战使用配置指南.md","raw":"---\ntitle: 最新React全家桶实战使用配置指南\ndate: 2018-10-18 20:23:10\ntags:\n- react\n- react全家桶\n- 配置指南\ncategories:\n- 793\n\nphotos: https://qiniu.nihaoshijie.com.cn/images/reactquanjiatong.png\n---\n\n### 写在前面\n\n这篇文档 是我结合以往的项目经验 加上自己本身对react webpack redux理解写下的总结文档，总共耗时一周总结下来的，希望能对读者能够有收获。\n\n# 目录\n\n1. [版本说明](#版本说明)\n2. [目录结构](#目录结构)\n3. [初始化项目](#初始化项目)\n4. [webpack](#webpack)\n5. [react](#react)\n6. [配置loader(sass,jsx)](#配置loader(sass,jsx))\n7. [引入babel](#引入babel)\n8. [使用HtmlWebpackPlugin](#使用HtmlWebpackPlugin)\n9. [redux](#redux)\n10. [使用webpack-dev-server](#使用webpack-dev-server)\n11. [多入口页面配置](#多入口页面配置)\n12. [如何理解`entry point(bundle)`,`chunk`,`module`](#entry)\n13. [多入口页面html配置](#多入口页面html配置)\n14. [模块热替换（Hot Module Replacement）](#hmr)\n15. [使用ESLint](#使用ESLint)\n16. [使用react-router](#使用react-router)\n16. [使用redux-thunk](#使用redux-thunk)\n17. [使用axios和async/await](#使用axios和async/await)\n18. [Code Splitting](#CodeSplitting)\n19. [使用CommonsChunkPlugin](#使用CommonsChunkPlugin)\n\n<!--more-->\n\n\n# 版本说明<div id=\"banben\"></div>\n由于构建相关例如webpack，babel等更新的较快，所以本教程以下面各种模块的版本号为主，切勿轻易修改或更新版本。\n```javascript\n\"dependencies\": {\n    \"babel-core\": \"^6.26.3\",\n    \"babel-eslint\": \"^8.2.3\",\n    \"babel-loader\": \"^7.1.4\",\n    \"babel-plugin-transform-async-to-generator\": \"^6.24.1\",\n    \"babel-plugin-transform-runtime\": \"^6.23.0\",\n    \"babel-preset-es2015\": \"^6.24.1\",\n    \"babel-preset-react\": \"^6.24.1\",\n    \"babel-preset-stage-0\": \"^6.24.1\",\n    \"babel-preset-stage-3\": \"^6.24.1\",\n    \"css-loader\": \"^0.28.11\",\n    \"eslint\": \"^4.19.1\",\n    \"eslint-loader\": \"^2.0.0\",\n    \"eslint-plugin-react\": \"^7.9.1\",\n    \"file-loader\": \"^1.1.11\",\n    \"history\": \"^4.7.2\",\n    \"html-webpack-plugin\": \"^3.2.0\",\n    \"react\": \"^16.4.0\",\n    \"react-dom\": \"^16.4.0\",\n    \"react-hot-loader\": \"^4.0.0\",\n    \"react-redux\": \"^5.0.7\",\n    \"react-router-dom\": \"^4.3.1\",\n    \"react-router-redux\": \"^5.0.0-alpha.9\",\n    \"redux\": \"^4.0.0\",\n    \"sass-loader\": \"^7.0.3\",\n    \"style-loader\": \"^0.21.0\",\n    \"url-loader\": \"^1.0.1\",\n    \"webpack\": \"^4.12.0\",\n    \"webpack-cli\": \"^3.0.3\",\n    \"webpack-dev-server\": \"^3.1.1\"\n}\n```\n# 目录结构<div id=\"mulu\"></div>\n开发和发布版本的配置文件是分开的，多入口页面的目录结构。\n```\nreact-family/\n    |\n    |──dist/                                    * 发布版本构建输出路径\n    |\n    |──dev/                                     * 调试版本构建输出路径\n    |\n    |──src/                                     * 工具函数\n    |     |\n    |     |—— component/                        * 各页面公用组件\n    |     |\n    |     |—— page/                             * 页面代码\n    |     |      |—— index/                     * 页面代码\n    |     |      |        |—— Main/             * 组件代码\n    |     |      |        |       |—— Main.jsx  * 组件jsx\n    |     |      |        |       |—— Main.scss * 组件css\n    |     |      |\n    |     |      |—— detail/                    * 页面代码\n    |     |\n    |     |—— static/                           * 静态文件js，css\n    |\n    |\n    |──webpack.config.build.js                  * 发布版本使用的webpack配置文件\n    |──webpack.config.dev.js                    * 调试版本使用的webpack配置文件\n    |──.eslint                                  * eslint配置文件\n    |__.babelrc                                 * babel配置文件\n```\n\n# 初始化项目<div id=\"initcode\"></div>\n1. 创建文件夹\n\n```bash\nmkdir react-family-bucket\n```\n2. 初始化npm\n```bash\ncd react-family-bucket\nnpm init\n```\n如果有特殊需要，可以填入自己的配置，一路回车下来，会生成一个`package.json`，里面是你项目的基本信息，后面的npm依赖安装也会配置在这里。\n# webpack<div id=\"webpack\"></div>\n1. 安装[webpack](https://webpack.js.org/)\n```bash\nnpm install webpack --save\nor\nnpm install webpack --g\n```\n`--save`是将当前webpack安装到react-family-bucket下的`/node_modules`。<br>\n`--g`是将当前webpack安装到全局下面，可以在node的安装目录下找到全局的`/node_modules`。\n\n2. 配置webopack配置文件\n\n```bash\ntouch webpack.config.dev.js\n```\n新建一个app.js\n```bash\ntouch app.js\n```\n写入基本的webpack配置，可以[参考这里](https://webpack.js.org/)：\n\n```javascript\nconst path = require('path');\nconst srcRoot = './src';\nmodule.exports = {\n\n    // 输入配置\n    entry: [\n      './app.js'\n    ],,\n\n    // 输出配置\n    output: {\n        path: path.resolve(__dirname, './dev'),\n\n        filename: 'bundle.min.js'\n    },\n\n};\n```\n3, 执行webpack命令\n如果是全局安装：\n```bash\nwebpack --config webpack.config.dev.js\n```\n如果是当前目录安装：\n```bash\n./node_modules/.bin/webpack --config webpack.config.dev.js\n```\n在package.json中添加执行命令：\n```json\n  \"scripts\": {\n    \"dev\": \"./node_modules/.bin/webpack --config webpack.config.dev.js\",\n  },\n```\n执行`npm run dev`命令之后，会发现需要安装`webpack-cli`，（webpack4之后需要安装这个）\n```bash\nnpm install webpack-cli --save\n```\n\n去除`WARNING in configuration`警告,在webpack.config.dev.js增加一个配置即可：\n\n```javascript\n...\nmode: 'development'\n...\n```\n成功之后会在dev下面生成bundle.min.js代表正常。<br>\n如果想要动态监听文件变化需要在命令后面添加  `--watch`\n# react<div id=\"react\"></div>\n1. 安装[react](https://reactjs.org/)\n\n```bash\nnpm install react react-dom --save\n```\n2. 创建page目录和index页面文件：\n\n```bash\nmkdir src\nmkdir page\ncd page\n```\n创建index\n```bash\nmkdir index\ncd index & touch index.js & touch index.html\n```\nindex.js\n\n```javascript\nimport ReactDom from 'react-dom';\nimport Main from './Main/Main.jsx';\n\nReactDom.render(<Main />, document.getElementById('root'));\n```\nindex.html\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title>index</title>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\">\n\n</head>\n<body>\n<div id=\"root\"></div>\n</body>\n</html>\n```\n3. 创建Main组件\n\n```javascript\n\nimport React from 'react';\n\nclass Main extends React.Component {\n\n    constructor(props) {\n        super(props);\n\n    }\n\n    render() {\n\n        return (<div>Main</div>);\n    }\n}\n\nexport default Main;\n```\n* `export` 和 `export default`区别：\n\nexport可以有多个\n\n```javascript\nxx.js:\nexport const test1 = 'a'\nexport function test2() {}\n\nyy.js:\nimport { test1, test2 } from 'xx.js';\n```\nexport default只能有1个\n\n```javascript\nxx.js:\nlet test1 = 'a';\nexport default test1;\n\nyy.js:\nimport test1 from 'xx.js';\n```\n* `export` 和 `module.exports`\n\n```javascript\nlet exports = module.exports;\n```\n4. 修改webpack配置入口文件\n\n```javascript\nentry: [\n    path.resolve(srcRoot,'./page/index/index.js')\n],\n```\n# 配置loader<div id=\"loader\"></div>\n\n1. 处理样式文件需要这些loader:\n* [css-loader](https://github.com/webpack-contrib/css-loader)\n* [sass-loader](https://github.com/webpack-contrib/sass-loader)\n* [style-loader](https://github.com/webpack-contrib/style-loader)\n\n```bash\nnpm install css-loader sass-loader style-loader file-loader --save\n```\n配置：\n\n```javascript\n    module: {\n        // 加载器配置\n        rules: [\n            { test: /\\.css$/, use: ['style-loader', 'css-loader'], include: path.resolve(srcRoot)},\n            { test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'], include: path.resolve(srcRoot)}\n        ]\n    },\n```\n2. [url-loader](https://github.com/webpack-contrib/url-loader)处理处理静态文件\n\n```bash\nnpm install url-loader --save\n```\n配置：\n```\n    module: {\n        // 加载器配置\n        rules: [\n            { test: /\\.(png|jpg|jpeg)$/, use: 'url-loader?limit=8192&name=images/[name].[hash].[ext]', include: path.resolve(srcRoot)}\n        ]\n    },\n```\n`limit:`表示超过多少就使用base64来代替，单位是byte<br>\n`name:`可以设置图片的路径，名称和是否使用hash 具体[参考这里](https://github.com/webpack-contrib/url-loader)\n\n# 引入babel<div id=\"babel\"></div>\n\n[bebel](https://babeljs.io/)是用来解析es6语法或者是es7语法分解析器，让开发者能够使用新的es语法，同时支持jsx，vue等多种框架。\n1. 安装babel\n* [babel-core](https://www.npmjs.com/package/babel-core)\n* [babel-loader](https://www.npmjs.com/package/babel-loader)\n\n```bash\nnpm install babel-core babel-loader --save\n```\n配置：\n```\n    module: {\n        // 加载器配置\n        rules: [\n            { test: /\\.(js|jsx)$/, use: [{loader:'babel-loader'}] ,include: path.resolve(srcRoot)},\n        ]\n    },\n```\nbabel配置文件：`.babelrc`\n\n```bash\ntouch .babelrc\n```\n配置：\n\n```javascript\n{\n    \"presets\": [\n        \"es2015\",\n        \"react\",\n        \"stage-0\"\n    ],\n    \"plugins\": []\n}\n```\nbabel支持自定义的预设(presets)或插件(plugins),只有配置了这两个才能让babel生效，单独的安装babel是无意义的<br>\n<br>\n`presets`：代表babel支持那种语法(就是你用那种语法写)，优先级是从下往上,`state-0|1|2|..`代表有很多没有列入标准的语法回已state-x表示,[参考这里](https://babeljs.io/docs/en/babel-preset-stage-0.html)<br>\n`plugins`:代表babel解析的时候使用哪些插件，作用和presets类似，优先级是从上往下。\n依次安装：\n* [babel-preset-es2015](https://www.npmjs.com/package/babel-preset-es2015)\n* [babel-preset-react](https://www.npmjs.com/package/babel-preset-react)\n* [babel-preset-stage-0](https://www.npmjs.com/package/babel-preset-stage-0)\n\n```bash\nnpm install babel-preset-es2015 babel-preset-react babel-preset-stage-0 --save\n```\n\n2. [babel-polyfill](https://babeljs.io/docs/en/babel-polyfill.html)是什么？<br>\n我们之前使用的babel，babel-loader 默认只转换新的 JavaScript 语法，而不转换新的 API。例如，Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转译。如果想使用这些新的对象和方法，必须使用 babel-polyfill，为当前环境提供一个垫片。\n\n```bash\nnpm install --save babel-polyfill\n```\n使用：\n\n```javascript\nimport \"babel-polyfill\";\n```\n3. [transform-runtime](https://babeljs.io/docs/en/babel-plugin-transform-runtime)有什么区别？<br>\n当使用`babel-polyfill`时有一些问题：<br>\n* 默认会引入所有babel支持的新语法，这样就会导致你的文件代码非常庞大。\n* 通过向全局对象和内置对象的prototype上添加方法来达成目的,造成全局变量污染。\n\n这时就需要`transform-runtime`来帮我们有选择性的引入\n\n```bash\nnpm install --save babel-plugin-transform-runtime\n```\n配置文件：\n\n```javascript\n{\n  \"plugins\": [\n    [\"transform-runtime\", {\n      \"helpers\": false,\n      \"polyfill\": false,\n      \"regenerator\": true,\n      \"moduleName\": \"babel-runtime\"\n    }]\n  ]\n}\n```\n# 使用HtmlWebpackPlugin<div id=\"HtmlWebpackPlugin\"></div>\n记得我们之前新建的index.html么 我们执行构建命令之后并没有将index.html打包到dev目录下 我们需要[HtmlWebpackPlugin](https://github.com/jantimon/html-webpack-plugin)来将我们output的js和html结合起来\n\n```bash\nnpm install html-webpack-plugin --save\n```\n配置：\n\n```javascript\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n...\nplugins: [\n    new HtmlWebpackPlugin({\n        filename: path.resolve(devPath, 'index.html'),\n        template: path.resolve(srcRoot, './page/index/index.html'),\n    })\n]\n```\n`filename`:可以设置html输出的路径和文件名<br>\n`template`:可以设置已哪个html文件为模版\n更多参数配置可以[参考这里](https://github.com/jantimon/html-webpack-plugin)\n\n# redux<div id=\"redux\"></div>\n\n关于[redux](http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html)的使用可以参考阮一峰老师的入门[教程](http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html)\n\n1. 安装redux\n* [redux](https://www.npmjs.com/package/redux)\n* [react-redux](https://www.npmjs.com/package/react-redux)\n\n```bash\nnpm install redux react-redux --save\n```\n\n2. 新建`reducers`，`actions`目录和文件\n```\n|—— index/                          \n|—— Main/                   * 组件代码\n|       |—— Main.jsx        * 组件jsx\n|       |—— Main.scss       * 组件css\n|\n|—— actions/ \n|       |—— actionTypes.js  * action常量\n|       |—— todoAction.js   * action\n|\n|—— reducers/ \n|       |—— todoReducer.js  * reducer\n|\n|—— store.js\n|\n|—— index.js\n\n```\n\n3. 修改代码，引入redux,这里以一个redux todo为demo例子：<br>\n\n`index.js`\n\n```javascript\nimport ReactDom from 'react-dom';\nimport React from 'react';\nimport Main from './Main/Main.jsx';\nimport store from './store.js';\nimport { Provider } from 'react-redux';\n\nReactDom.render(\n    <Provider store={store}>\n        <Main />\n    </Provider>\n, document.getElementById('root'));\n```\n`store.js`\n\n```javascript\nimport { createStore } from 'redux';\nimport todoReducer from './reducers/todoReducer.js';\n\nconst store = createStore(todoReducer);\n\nexport default store;\n```\n`tabReducer.js`\n\n```javascript\nimport { ADD_TODO } from '../actions/actionTypes.js';\n\nconst initialState = {\n      todoList: []\n};\n\nconst addTodo = (state, action) => {\n\n  return { ...state, todoList: state.todoList.concat(action.obj) }\n}\n\nconst todoReducer = (state = initialState, action) => {\n  switch(action.type) {\n    case ADD_TODO: return addTodo(state, action);\n    default: return state;\n  }\n};\nexport default todoReducer;\n\n```\n`Main.jsx`\n\n```javascript\nimport React from 'react';\nimport { connect } from 'react-redux';\nimport { addTodo } from '../actions/todoAction.js';\n\nclass Main extends React.Component {\n\n    onClick(){\n        let text = this.refs.input;\n\n        this.props.dispatch(addTodo({\n            text: text.value\n        }))\n    }\n    render() {\n        return (\n            <div>\n                <input ref=\"input\" type=\"text\"></input>\n                <button onClick={()=>this.onClick()}>提交</button>\n                <ul>\n                {this.props.todoList.map((item, index)=>{\n                    return <li key={index}>{item.text}</li>\n                })}\n                </ul>\n            </div>\n        );\n    }\n}\n\nexport default connect(\n    state => ({\n        todoList: state.todoList\n    })\n)(Main);\n```\n`todoAction.js`\n\n```javascript\nimport { ADD_TODO } from './actionTypes.js';\n\nexport const addTodo = (obj) => {\n  return {\n    type: ADD_TODO,\n    obj: obj\n  };\n};\n```\n\n# 使用webpack-dev-server<div id=\"webpack-dev-server\"></div>\n[webpack-dev-server](https://github.com/jantimon/webpack-dev-server)是一个小型的`Node.js Express`服务器,它使用webpack-dev-middleware来服务于webpack的包。\n1. 安装\n\n```bash\nnpm install webpack-dev-server --save\n```\n修改在package.json中添加的执行命令：\n```json\n  \"scripts\": {\n    \"dev\": \"./node_modules/.bin/webpack-dev-server --config webpack.config.dev.js\",\n  },\n```\n2. 配置webpack配置文件：\n\n```json\ndevServer: {\n    \"contentBase\": devPath,\n    \"compress\": true,\n},\n```\n`contentBase` 表示server文件的根目录\n`compress` 表示开启gzip\n更多的配置文档[参考这里](https://webpack.docschina.org/configuration/dev-server/)\n\n* `webpack-dev-server`默认情况下会将output的内容放在内存中，是看不到物理的文件的，如果想要看到物理的dev下面的文件可以安装[write-file-webpack-plugin](https://www.npmjs.com/package/webpack-dev-server)这个插件。\n\n* `webpack-dev-server`默认会开启livereload功能\n\n3. `devtool`功能：<br>\n具体来说添加了`devtool: 'inline-source-map'`之后，利用source-map你在chrome控制台看到的source源码都是真正的源码，未压缩，未编译前的代码，没有添加，你看到的代码是真实的压缩过，编译过的代码，更多devtool的配置可以[参考这里](https://webpack.docschina.org/configuration/devtool/)\n\n# 多入口文件配置<div id=\"rukou\"></div>\n在之前的配置中，都是基于单入口页面配置的，entry和output只有一个文件，但是实际项目很多情况下是多页面的，在配置多页面时，有2中方法可以选择：\n\n1. 在entry入口配置时，传入对象而不是单独数组,output时利用`[name]`关键字来区分输出文件例如：\n\n```javascript\nentry: {\n    index: [path.resolve(srcRoot,'./page/index/index1.js'),path.resolve(srcRoot,'./page/index/index2.js')],\n    detail: path.resolve(srcRoot,'./page/detail/detail.js'),\n    home: path.resolve(srcRoot,'./page/home/home.js'),\n},\noutput: {\n    path: path.resolve(__dirname, './dev'),\n\n    filename: '[name].min.js'\n},\n```\n2. 通过node动态遍历需要entry point的目录，来动态生成entry：\n\n```javascript\nconst pageDir = path.resolve(srcRoot, 'page');\nfunction getEntry() {\n    let entryMap = {};\n\n    fs.readdirSync(pageDir).forEach((pathname)=>{\n        let fullPathName = path.resolve(pageDir, pathname);\n        let stat = fs.statSync(fullPathName);\n        let fileName = path.resolve(fullPathName, 'index.js');\n\n        if (stat.isDirectory() && fs.existsSync(fileName)) {\n            entryMap[pathname] = fileName;\n        }\n\n    });\n\n    return entryMap;\n}\n{\n    ...\n    entry: getEntry()\n    ...\n}\n```\n\n本demo采用的是第二中写法，能够更加灵活。\n\n# 如何理解`entry point(bundle)`,`chunk`,`module`<div id=\"entry\"></div>\n\n在webpack中，如何理解`entry point(bundle)`,`chunk`,`module`?\n![](https://qiniu.nihaoshijie.com.cn/image/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-15%20%E4%B8%8B%E5%8D%889.06.45.png)\n\n根据图上的表述，我这里简单说一下便于理解的结论：<br>\n* 配置中每个文件例如index1.js,index2.js,detail.js,home.js都属于`entry point`.\n* entry这个配置中，每个key值,index,detail,home都相当于`chunk`。\n* 我们在代码中的require或者import的都属于`module`，这点很好理解。\n* `chunk`的分类比较特别，有`entry chunk`,`initial chunk`,`normal chunk`,参考[这个文章](https://github.com/webpack/webpack.js.org/issues/970)\n* 正常情况下，一个`chunk`对应一个output,在使用了`CommonsChunkPlugin`或者`require.ensure`之后，`chunk`就变成了`initial chunk`,`normal chunk`，这时，一个`chunk`对应多个output。<br>\n理解这些概念对于后续使用webpack插件有很大的帮助。\n\n# 多入口页面html配置<div id=\"html\"></div>\n\n之前我们配置`HtmlWebpackPlugin`时，同样采用的是但页面的配置，这里我们将进行多页面改造,`entryMap`是上一步得到的entry：\n\n```javascript\nfunction htmlAarray(entryMap) {\n    let htmlAarray = [];\n\n    Object.keys(entryMap).forEach(function(key){\n        let fullPathName = path.resolve(pageDir, key);\n        let fileName = path.resolve(fullPathName, key + '.html')\n        if (fs.existsSync(fileName)) {\n            htmlAarray.push(new HtmlWebpackPlugin({\n                chunks: key, // 注意这里的key就是chunk\n                filename: key + '.html',\n                template: fileName,\n                inlineSource:  '.(js|css)'\n            }))\n        }\n    });\n\n    return htmlAarray;\n\n}\n```\n修改plugin配置：\n\n```javascript\nplugins: [\n     ...\n].concat(htmlMap)\n```\n# 模块热替换（Hot Module Replacement）<div id=\"hmr\"></div>\n\n[模块热替换](https://webpack.docschina.org/guides/hot-module-replacement)(Hot Module Replacement 或 HMR)是 webpack 提供的最有用的功能之一。它允许在运行时更新各种模块，而无需进行完全刷新,很高大上有木有！\n\n下面说一下配置方法，它需要结合`devServer`使用：\n\n```javascript\ndevServer: {\n    hot: true // 开启HMR\n},\n```\n开启plugin：\n\n```javascript\nconst webpack = require('webpack');\nplugins: [\n    new webpack.NamedModulesPlugin(),\n    new webpack.HotModuleReplacementPlugin(),\n].concat(htmlMap)\n```\n\n结合React一起使用：<br>\n\n1. 安装[react-hot-loader](https://github.com/jantimon/react-hot-loader),\n\n```bash\nnpm install react-hot-loader --save\n```\n并新建一个Container.jsx:<br>\n\n```javascript\nimport React from 'react';\nimport Main from './Main.jsx';\nimport { hot } from 'react-hot-loader'\n\nclass Container extends React.Component {\n\n    render() {\n        return <Main />\n    }\n        \n}\nexport default hot(module)(Container);\n```\n\n结合redux：如果项目没有使用redux，可以无需配置后面2步<br>\n2. 修改store.js新增下面代码，为了让reducer也能实时热替换\n\n```javascript\nif (module.hot) {\n    module.hot.accept('./reducers/todoReducer.js', () => {\n      const nextRootReducer = require('./reducers/todoReducer.js').default;\n      store.replaceReducer(nextRootReducer);\n    });\n}\n```\n3. 修改index.js\n\n```javascript\nimport ReactDom from 'react-dom';\nimport React from 'react';\nimport Container from './Main/Container.jsx';\nimport store from './store.js';\n\nimport { Provider } from 'react-redux';\n\nReactDom.render(\n    <Provider store={store}>\n        <Container />\n    </Provider>\n, document.getElementById('root'));\n```\n\n当控制台看到`[WDS] Hot Module Replacement enabled.`代表开启成功\n\n# 使用ESLint<div id=\"eslint\"></div>\n[ESLint](https://eslint.org/) 是众多 Javascript Linter 中的其中一种，其他比较常见的还有 [JSLint](https://www.jslint.com/) 跟 [JSHint](http://jshint.com/)，之所以用 ESLint 是因为他可以自由选择要使用哪些规则，也有很多现成的 plugin 可以使用，另外他对 ES6 还有 JSX 的支持程度跟其他 linter 相比之下也是最高的。\n\n1. 安装ESLint\n\n```bash\nnpm install eslint eslint-loader babel-eslint --save\n```\n其中`eslint-loader`是将webpack和eslint结合起来在webpack的配置文件中新增一个eslint-loader种，修改如下\n\n```javascript\n{ test: /\\.(js|jsx)$/, use: [{loader:'babel-loader'},{loader:'eslint-loader'}] ,include: path.resolve(srcRoot)},\n```\n\n2. 新建`.eslintrc`配置文件,将parser配置成`babel-eslint`\n\n```json\n{\n    \"extends\": [\"eslint:recommended\"],\n    \n    \"parser\": \"babel-eslint\",\n\n    \"globals\": {\n    },\n    \"rules\": {\n    }\n}\n```\n\n3. 安装[eslint-plugin-react](https://github.com/jantimon/eslint-plugin-react):\n\n```bash\nnpm install eslint-plugin-react --save\n```\n* 说明一下，正常情况下每个eslint规则都是需要在`rule`下面配置，如果什么都不配置，其实本身eslint是不生效的。\n* eslint本身有很多默认的规则模版，可以通过`extends`来配置，默认可以使用`eslint:recommended`。\n* 在使用react开发时可以安装`eslint-plugin-react`来告知使用react专用的规则来lint。\n3. 修改`.eslintrc`配置文件,增加rules，更多rules配置可以[参考这里](https://eslint.org/docs/rules/)\n\n```javascript\n{\n    \"extends\": [\"eslint:recommended\",\"plugin:react/recommended\"],\n    \n    \"parser\": \"babel-eslint\",\n\n    \"globals\": {\n        \"window\": true,\n        \"document\": true,\n        \"module\": true,\n        \"require\": true\n    },\n    \"rules\": {\n        \"react/prop-types\" : \"off\",\n        \"no-console\" : \"off\"\n    }\n}\n```\n\n# 使用react-router<div id=\"react-router\"></div>\nreact-router强大指出在于方便代码管理，结合redux使用更加强大，同时支持web，native更多[参考这里](https://reacttraining.com/react-router/)\n1. 安装[react-router-dom](https://github.com/jantimon/react-router-dom)\n\n```bash\nnpm install react-router-dom --save\n```\n2. 如果项目中用了redux，可以安装[react-router-redux](https://github.com/ReactTraining/react-router/tree/master/packages/react-router-redux)\n\n```bash\nnpm install react-router-redux@next history --save\n```\n\n3. 修改代码：<br>\n`index.js`:\n\n```javascript\nimport ReactDom from 'react-dom';\nimport React from 'react';\nimport Container from './Main/Container.jsx';\nimport { store, history } from './store.js';\n\nimport { Provider } from 'react-redux';\n\nimport createHistory from 'history/createHashHistory';\nimport { ConnectedRouter } from 'react-router-redux';\n\nconst history = createHistory();\n\nReactDom.render(\n    <Provider store={store}>\n        <ConnectedRouter history={history}>\n            <Container />\n        </ConnectedRouter>\n    </Provider>\n, document.getElementById('root'));\n```\n\n结合`history`,react-router一共有3中不同的router：\n* [BrowserRouter](https://reacttraining.com/react-router/web/api/BrowserRouter)通过`history/createBrowserHistory`引入:当切换时，url会动态更新，底层使用的时html5的[pushState](https://blog.csdn.net/tianyitianyi1/article/details/7426606)。\n* [HashRouter](https://reacttraining.com/react-router/web/api/HashRouter)通过`history/createHashHistory`引入:当切换时，动态修改hash，利用hashchange事件。\n* [MemoryRouter](https://reacttraining.com/react-router/web/api/MemoryRouter)通过`history/createMemoryHistory`引入:将路径，路由相关数据存入内存中，不涉及url相关更新，兼容性好。\n\n更多配置可以[参考这里](https://reacttraining.com/react-router/)\n\n4. 如果想要在代码逻辑中获取当前的route路径需要引入`router-reducer`:<br>\n新建`main.js`:\n\n```javascript\nimport { combineReducers } from 'redux';\nimport { routerReducer } from \"react-router-redux\";\nimport todoReducer from './todoReducer.js';\n\nconst reducers = combineReducers({\n  todoReducer,\n  router: routerReducer\n});\nexport default reducers;\n```\n\n修改`store.js`:\n\n```javascript\nimport { createStore } from 'redux';\nimport mainReducer from './reducers/main.js';\n\nconst store = createStore(mainReducer);\n\nexport default store;\n```\n然后就可以在`this.props.router`里面获取单相关的路径信息\n4. 如果需要自己通过action来触发router的跳转，需要引入`routerMiddleware`:\n\n```javascript\nimport { createStore,applyMiddleware } from 'redux';\nimport { routerMiddleware } from \"react-router-redux\";\nconst middleware = routerMiddleware(history);\nconst store = createStore(mainReducer,applyMiddleware(middleware));\n```\n\n5. 使用`Route`和`Link`和`withRouter`:<br>\n先说说都是干嘛的：<br>\n* [Route](https://reacttraining.com/react-router/web/api/Route):component里面的内容即是tab的主要内容，这个从react-router4开始生效：\n\n```javascript\n<Route exact path=\"/\" component={Div1}></Route>\n<Route path=\"/2\" component={Div2}></Route>\n```\n* [Link](https://reacttraining.com/react-router/web/api/Link):通常也可以用[NavLink](https://reacttraining.com/react-router/web/api/NavLink)，相当于tab按钮，控制router的切换,`activeClass`表示当前tab处于激活态时应用上的class。\n* [withRouter](https://reacttraining.com/react-router/web/api/withRouter):如果你用了redux，那么你一定要引入它。\n\n```javascript\nexport default withRouter(connect(\n    state => ({\n        todoList: state.todoReducer.todoList\n    })\n)(Main));\n```\n\n*如果你在使用hash时遇到`Warning: Hash history cannot PUSH the same path; a new entry will not be added to the history stack`错误，可以将push改为replace即*\n\n```javascript\n<NavLink\n    replace={true}\n    to=\"/2\"\n    activeClassName=\"selected\"\n    >切换到2号</NavLink>\n```\n6. 设置初始化路由：\n* `BrowserRouter`和`HashRouter`:\n\n```javascript\nconst history = createHistory();\nhistory.push('2');\n```\n* `MemoryRouter`:\n\n```javascript\nconst history = createMemoryHistory({\n    initialEntries: ['/2']\n});\n```\n\n# 使用redux-thunk<div id=\"redux-thunk\"></div>\n\n[redux-thunk](https://www.npmjs.com/package/redux-thunk) 是一个比较流行的 redux 异步 action 中间件，比如 action 中有 setTimeout 或者通过 fetch通用远程 API 这些场景，那么久应该使用 redux-thunk 了。redux-thunk 帮助你统一了异步和同步 action 的调用方式，把异步过程放在 action 级别解决，对 component 没有影响。\n\n1. 安装`redux-thunk`:\n```bash\nnpm install redux-thunk --save\n```\n2. 修改`store.js`:\n\n```javascript\n\nimport { createStore,applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport mainReducer from './reducers/main';\n...\nconst store = createStore(mainReducer, applyMiddleware(thunk));\n...\nexport default store;\n```\n3. 在`action.js`使用redux-thunk：\n\n```javascript\nexport const getData = (obj) => (dispatch, getState) => {\n  setTimeout(()=>{\n    dispatch({\n        type: GET_DATA,\n        obj: obj\n    });\n  },1000);\n};\n```\n\n# 使用axios和async/await<div id=\"axios\"></div>\n\n[axios](https://github.com/axios/axios) 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端：\n\n* 从浏览器中创建 XMLHttpRequest\n* 从 node.js 发出 http 请求\n* 支持 Promise API\n* 自动转换JSON数据\n\n1. 安装axios:\n\n```bash\nnpm install axios --save\n```\n\n2. 在action中使用axios：\n\n```javascript\nimport axios from 'axios';\nexport const getData = (obj) => (dispatch, getState) => {\n    axios.get('/json/comments.json').then((resp)=>{\n        dispatch({\n            type: GET_DATA,\n            obj: resp\n        });\n    });\n};\n```\n[async/await](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function)：<br>\n\nJavascript的回调地狱，相信很多人都知道，尤其是在node端，近些年比较流行的是[Promise](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)的解决方案，但是随着 Node 7 的发布，编程终级解决方案的 async/await应声而出。\n\n```javascript\nfunction resolveAfter2Seconds() {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve('resolved');\n    }, 2000);\n  });\n}\n\nasync function asyncCall() {\n  var result = await resolveAfter2Seconds();\n}\n\nasyncCall();\n```\nasync/await的用途是简化使用 promises 异步调用的操作，并对一组 Promises执行某些操作。await前提是方法返回的是一个Promise对象，正如Promises类似于结构化回调，async/await类似于组合生成器和 promises。<br>\n\n1. `async/await`需要安装[babel-plugin-transform-async-to-generator](https://www.npmjs.com/package/babel-plugin-transform-async-to-generator)。\n\n```bash\nnpm install babel-plugin-transform-async-to-generator --save\n```\n\n2. 在`.babelrc`中增加配置：\n\n```javascript\n    \"plugins\": [\n        \"transform-async-to-generator\"\n    ]\n```\n\n这样做仅仅是将async转换generator，如果你当前的浏览器不支持generator，你将会收到一个`Uncaught ReferenceError: regeneratorRuntime is not defined`的错误，你需要：<br>\n3. 安装[babel-plugin-transform-runtime](https://www.npmjs.com/package/babel-plugin-transform-runtime):\n\n```bash\nnpm install babel-plugin-transform-async-to-generator --save\n```\n\n4. 修改`.babelrc`中的配置(可以去掉之前配置的transform-async-to-generator)：\n\n```javascript\n    \"plugins\": [\n        \"transform-runtime\"\n    ]\n```\n5. 如果不想引入所有的polyfill(参考上面对babel的解释),可以增加配置：\n\n```javascript\n    \"plugins\": [\n        \"transform-runtime\",\n            {\n                \"polyfill\": false,\n\n                \"regenerator\": true,\n            }\n    ]\n```\n6. 结合axios使用：\n\n```javascript\nimport axios from 'axios';\nexport const getData = (obj) => async (dispatch, getState) => {\n    let resp = axios.get('/json/comments.json');\n    dispatch({\n        type: GET_DATA,\n        obj: resp\n    });\n};\n```\n\n# Code Splitting<div id=\"CodeSplitting\"></div>\n1. 对于webpack1，2之前，你可以使用`require.ensure`来控制一个组件的懒加载：<br>\n\n```javascript\nrequire.ensure([], _require => {\n    let Component = _require('./Component.jsx');\n},'lazyname')\n```\n2. 在webpack4中，官方已经不再推荐使用`require.ensure`来使用懒加载功能*Dynamic Imports*，取而代之的是ES6的`import()`方法：\n\n```javascript\nimport(\n  /* webpackChunkName: \"my-chunk-name\" */\n  /* webpackMode: \"lazy\" */\n  'module'\n);\n```\n不小小看注释里的代码，webpack在打包时会动态识别这里的代码来做相关的配置，例如chunk name等等。\n3. [Prefetching/Preloading modules](https://webpack.js.org/guides/code-splitting/#prefetching-preloading-modules):<br>\n\nwebpack 4.6.0+支持了Prefetching/Preloading的写法:\n\n```javascript\n//...\nimport(/* webpackPreload: true */ 'ChartingLibrary');\n```\n4. 结合React-Router使用:<br>\n\n[react-loadable](https://www.npmjs.com/package/react-loadable)对上述的功能做了封装，丰富了一些功能，结合`React-Router`起来使用更加方便。\n\n```bash\nnpm install react-loadable --save\n```\n在react-router里使用：\n\n```javascript\nfunction Loading() {\n  return <div>Loading...</div>;\n}\n\nlet Div2 = Loadable({\n  loader: () => import('./Div2'), \n  loading: Loading,\n});\n\n<Route path=\"/2\" component={Div2}></Route>\n```\n\n\n# 使用CommonsChunkPlugin\n\n`CommonsChunkPlugin` 插件，是一个可选的用于建立一个独立文件(又称作 chunk)的功能，这个文件包括多个入口 chunk 的公共模块。通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存起来到缓存中供后续使用。<br>\n\n1. 在webpack4之前的用法：\n\n```javascript\nnew webpack.optimize.CommonsChunkPlugin({\n    name: 'common',\n    chunks: ['page1','page2'],\n    minChunks: 3\n})\n```\n* `name`: string: 提出出的名称\n* `chunks`: string[]: webpack会从传入的chunk里面提取公共代码,默认从所有entry里提取\n* `minChunks`: number|infinity|function(module,count)->boolean: 如果传入数字或infinity(默认值为3)，就是告诉webpack，只有当模块重复的次数大于等于该数字时，这个模块才会被提取出来。当传入为函数时，所有符合条件的chunk中的模块都会被传入该函数做计算，返回true的模块会被提取到目标chunk。\n更多的参数配置，可以[参考这里](https://webpack.js.org/plugins/commons-chunk-plugin/#src/components/Sidebar/Sidebar.jsx)\n\n2. 在webpack4之后的用法：\n\n\n```javascript\n\nmodule.exports = {\n  //...\n  optimization: {\n    splitChunks: {\n      chunks: 'async',\n      minSize: 30000,\n      minChunks: 1,\n      maxAsyncRequests: 5,\n      maxInitialRequests: 3,\n      automaticNameDelimiter: '~',\n      name: true,\n      cacheGroups: {\n        vendors: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          priority: -10\n        },\n        default: {\n          minChunks: 2,\n          priority: -20,\n          reuseExistingChunk: true\n        }\n      }\n    }\n  }\n};\n```\n\n* `splitChunks`: 配置一个分离chunk(代替老版本的CommonsChunkPlugin)\n* `cacheGroups`: 自定义配置主要使用它来决定生成的文件:\n\n1. `test`: 限制范围\n2. `name`: 生成文件名\n3. `priority`: 优先级\n\n\n* `minSize`: number: 最小尺寸必须大于此值，默认30000B\n* `minChunks`: 其他entry引用次数大于此值，默认1\n* `maxInitialRequests`: entry文件请求的chunks不应该超过此值（请求过多，耗时）\n* `maxAsyncRequests`: 异步请求的chunks不应该超过此值\n* `automaticNameDelimiter`: 自动命名连接符\n* `chunks`: 值为\"initial\", \"async\"（默认） 或 \"all\":\n\n1. `initial`: 入口chunk，对于异步导入的文件不处理\n2. `async`: 异步chunk，只对异步导入的文件处理\n3. `all`: 全部chunk\n\n\n\n","slug":"最新React全家桶实战使用配置指南","published":1,"updated":"2019-04-02T16:49:36.000Z","comments":1,"layout":"post","link":"","_id":"ckx434q1f003f2wvj1g13n4og","content":"<h3><span id=\"写在前面\">写在前面</span></h3><p>这篇文档 是我结合以往的项目经验 加上自己本身对react webpack redux理解写下的总结文档，总共耗时一周总结下来的，希望能对读者能够有收获。</p>\n<h1><span id=\"目录\">目录</span></h1><ol>\n<li><a href=\"#版本说明\">版本说明</a></li>\n<li><a href=\"#目录结构\">目录结构</a></li>\n<li><a href=\"#初始化项目\">初始化项目</a></li>\n<li><a href=\"#webpack\">webpack</a></li>\n<li><a href=\"#react\">react</a></li>\n<li><a href=\"#配置loader(sass,jsx\">配置loader(sass,jsx)</a>)</li>\n<li><a href=\"#引入babel\">引入babel</a></li>\n<li><a href=\"#使用HtmlWebpackPlugin\">使用HtmlWebpackPlugin</a></li>\n<li><a href=\"#redux\">redux</a></li>\n<li><a href=\"#使用webpack-dev-server\">使用webpack-dev-server</a></li>\n<li><a href=\"#多入口页面配置\">多入口页面配置</a></li>\n<li><a href=\"#entry\">如何理解<code>entry point(bundle)</code>,<code>chunk</code>,<code>module</code></a></li>\n<li><a href=\"#多入口页面html配置\">多入口页面html配置</a></li>\n<li><a href=\"#hmr\">模块热替换（Hot Module Replacement）</a></li>\n<li><a href=\"#使用ESLint\">使用ESLint</a></li>\n<li><a href=\"#使用react-router\">使用react-router</a></li>\n<li><a href=\"#使用redux-thunk\">使用redux-thunk</a></li>\n<li><a href=\"#使用axios和async/await\">使用axios和async/await</a></li>\n<li><a href=\"#CodeSplitting\">Code Splitting</a></li>\n<li><a href=\"#使用CommonsChunkPlugin\">使用CommonsChunkPlugin</a></li>\n</ol>\n<a id=\"more\"></a>\n<h1><span id=\"版本说明\">版本说明<div id=\"banben\"></div></span></h1><p>由于构建相关例如webpack，babel等更新的较快，所以本教程以下面各种模块的版本号为主，切勿轻易修改或更新版本。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"dependencies\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"babel-core\"</span>: <span class=\"string\">\"^6.26.3\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"babel-eslint\"</span>: <span class=\"string\">\"^8.2.3\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"babel-loader\"</span>: <span class=\"string\">\"^7.1.4\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"babel-plugin-transform-async-to-generator\"</span>: <span class=\"string\">\"^6.24.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"babel-plugin-transform-runtime\"</span>: <span class=\"string\">\"^6.23.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"babel-preset-es2015\"</span>: <span class=\"string\">\"^6.24.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"babel-preset-react\"</span>: <span class=\"string\">\"^6.24.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"babel-preset-stage-0\"</span>: <span class=\"string\">\"^6.24.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"babel-preset-stage-3\"</span>: <span class=\"string\">\"^6.24.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"css-loader\"</span>: <span class=\"string\">\"^0.28.11\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"eslint\"</span>: <span class=\"string\">\"^4.19.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"eslint-loader\"</span>: <span class=\"string\">\"^2.0.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"eslint-plugin-react\"</span>: <span class=\"string\">\"^7.9.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"file-loader\"</span>: <span class=\"string\">\"^1.1.11\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"history\"</span>: <span class=\"string\">\"^4.7.2\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"html-webpack-plugin\"</span>: <span class=\"string\">\"^3.2.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"react\"</span>: <span class=\"string\">\"^16.4.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"react-dom\"</span>: <span class=\"string\">\"^16.4.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"react-hot-loader\"</span>: <span class=\"string\">\"^4.0.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"react-redux\"</span>: <span class=\"string\">\"^5.0.7\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"react-router-dom\"</span>: <span class=\"string\">\"^4.3.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"react-router-redux\"</span>: <span class=\"string\">\"^5.0.0-alpha.9\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"redux\"</span>: <span class=\"string\">\"^4.0.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"sass-loader\"</span>: <span class=\"string\">\"^7.0.3\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"style-loader\"</span>: <span class=\"string\">\"^0.21.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"url-loader\"</span>: <span class=\"string\">\"^1.0.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"webpack\"</span>: <span class=\"string\">\"^4.12.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"webpack-cli\"</span>: <span class=\"string\">\"^3.0.3\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"webpack-dev-server\"</span>: <span class=\"string\">\"^3.1.1\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1><span id=\"目录结构\">目录结构<div id=\"mulu\"></div></span></h1><p>开发和发布版本的配置文件是分开的，多入口页面的目录结构。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">react-family/</span><br><span class=\"line\">    |</span><br><span class=\"line\">    |──dist/                                    * 发布版本构建输出路径</span><br><span class=\"line\">    |</span><br><span class=\"line\">    |──dev/                                     * 调试版本构建输出路径</span><br><span class=\"line\">    |</span><br><span class=\"line\">    |──src/                                     * 工具函数</span><br><span class=\"line\">    |     |</span><br><span class=\"line\">    |     |—— component/                        * 各页面公用组件</span><br><span class=\"line\">    |     |</span><br><span class=\"line\">    |     |—— page/                             * 页面代码</span><br><span class=\"line\">    |     |      |—— index/                     * 页面代码</span><br><span class=\"line\">    |     |      |        |—— Main/             * 组件代码</span><br><span class=\"line\">    |     |      |        |       |—— Main.jsx  * 组件jsx</span><br><span class=\"line\">    |     |      |        |       |—— Main.scss * 组件css</span><br><span class=\"line\">    |     |      |</span><br><span class=\"line\">    |     |      |—— detail/                    * 页面代码</span><br><span class=\"line\">    |     |</span><br><span class=\"line\">    |     |—— static/                           * 静态文件js，css</span><br><span class=\"line\">    |</span><br><span class=\"line\">    |</span><br><span class=\"line\">    |──webpack.config.build.js                  * 发布版本使用的webpack配置文件</span><br><span class=\"line\">    |──webpack.config.dev.js                    * 调试版本使用的webpack配置文件</span><br><span class=\"line\">    |──.eslint                                  * eslint配置文件</span><br><span class=\"line\">    |__.babelrc                                 * babel配置文件</span><br></pre></td></tr></table></figure></p>\n<h1><span id=\"初始化项目\">初始化项目<div id=\"initcode\"></div></span></h1><ol>\n<li>创建文件夹</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir react-family-bucket</span><br></pre></td></tr></table></figure>\n<ol>\n<li>初始化npm<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> react-family-bucket</span><br><span class=\"line\">npm init</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>如果有特殊需要，可以填入自己的配置，一路回车下来，会生成一个<code>package.json</code>，里面是你项目的基本信息，后面的npm依赖安装也会配置在这里。</p>\n<h1><span id=\"webpack\">webpack<div id=\"webpack\"></div></span></h1><ol>\n<li>安装<a href=\"https://webpack.js.org/\" target=\"_blank\" rel=\"noopener\">webpack</a><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install webpack --save</span><br><span class=\"line\">or</span><br><span class=\"line\">npm install webpack --g</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><code>--save</code>是将当前webpack安装到react-family-bucket下的<code>/node_modules</code>。<br><br><code>--g</code>是将当前webpack安装到全局下面，可以在node的安装目录下找到全局的<code>/node_modules</code>。</p>\n<ol>\n<li>配置webopack配置文件</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch webpack.config.dev.js</span><br></pre></td></tr></table></figure>\n<p>新建一个app.js<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch app.js</span><br></pre></td></tr></table></figure></p>\n<p>写入基本的webpack配置，可以<a href=\"https://webpack.js.org/\" target=\"_blank\" rel=\"noopener\">参考这里</a>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> srcRoot = <span class=\"string\">'./src'</span>;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 输入配置</span></span><br><span class=\"line\">    entry: [</span><br><span class=\"line\">      <span class=\"string\">'./app.js'</span></span><br><span class=\"line\">    ],,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 输出配置</span></span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        path: path.resolve(__dirname, <span class=\"string\">'./dev'</span>),</span><br><span class=\"line\"></span><br><span class=\"line\">        filename: <span class=\"string\">'bundle.min.js'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>3, 执行webpack命令<br>如果是全局安装：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack --config webpack.config.dev.js</span><br></pre></td></tr></table></figure></p>\n<p>如果是当前目录安装：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./node_modules/.bin/webpack --config webpack.config.dev.js</span><br></pre></td></tr></table></figure></p>\n<p>在package.json中添加执行命令：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"scripts\": &#123;</span><br><span class=\"line\">  \"dev\": \"./node_modules/.bin/webpack --config webpack.config.dev.js\",</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>执行<code>npm run dev</code>命令之后，会发现需要安装<code>webpack-cli</code>，（webpack4之后需要安装这个）<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install webpack-cli --save</span><br></pre></td></tr></table></figure></p>\n<p>去除<code>WARNING in configuration</code>警告,在webpack.config.dev.js增加一个配置即可：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">mode: <span class=\"string\">'development'</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>成功之后会在dev下面生成bundle.min.js代表正常。<br><br>如果想要动态监听文件变化需要在命令后面添加  <code>--watch</code></p>\n<h1><span id=\"react\">react<div id=\"react\"></div></span></h1><ol>\n<li>安装<a href=\"https://reactjs.org/\" target=\"_blank\" rel=\"noopener\">react</a></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install react react-dom --save</span><br></pre></td></tr></table></figure>\n<ol>\n<li>创建page目录和index页面文件：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir src</span><br><span class=\"line\">mkdir page</span><br><span class=\"line\"><span class=\"built_in\">cd</span> page</span><br></pre></td></tr></table></figure>\n<p>创建index<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir index</span><br><span class=\"line\"><span class=\"built_in\">cd</span> index &amp; touch index.js &amp; touch index.html</span><br></pre></td></tr></table></figure></p>\n<p>index.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ReactDom <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Main <span class=\"keyword\">from</span> <span class=\"string\">'./Main/Main.jsx'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDom.render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Main</span> /&gt;</span>, document.getElementById('root'));</span></span><br></pre></td></tr></table></figure>\n<p>index.html<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>index<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"root\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>创建Main组件</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Main<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Main;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>export</code> 和 <code>export default</code>区别：</li>\n</ul>\n<p>export可以有多个</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xx.js:</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> test1 = <span class=\"string\">'a'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test2</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">yy.js:</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; test1, test2 &#125; <span class=\"keyword\">from</span> <span class=\"string\">'xx.js'</span>;</span><br></pre></td></tr></table></figure>\n<p>export default只能有1个</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xx.js:</span><br><span class=\"line\"><span class=\"keyword\">let</span> test1 = <span class=\"string\">'a'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> test1;</span><br><span class=\"line\"></span><br><span class=\"line\">yy.js:</span><br><span class=\"line\"><span class=\"keyword\">import</span> test1 <span class=\"keyword\">from</span> <span class=\"string\">'xx.js'</span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>export</code> 和 <code>module.exports</code></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> exports = <span class=\"built_in\">module</span>.exports;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>修改webpack配置入口文件</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: [</span><br><span class=\"line\">    path.resolve(srcRoot,<span class=\"string\">'./page/index/index.js'</span>)</span><br><span class=\"line\">],</span><br></pre></td></tr></table></figure>\n<h1><span id=\"配置loader\">配置loader<div id=\"loader\"></div></span></h1><ol>\n<li>处理样式文件需要这些loader:</li>\n</ol>\n<ul>\n<li><a href=\"https://github.com/webpack-contrib/css-loader\" target=\"_blank\" rel=\"noopener\">css-loader</a></li>\n<li><a href=\"https://github.com/webpack-contrib/sass-loader\" target=\"_blank\" rel=\"noopener\">sass-loader</a></li>\n<li><a href=\"https://github.com/webpack-contrib/style-loader\" target=\"_blank\" rel=\"noopener\">style-loader</a></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install css-loader sass-loader style-loader file-loader --save</span><br></pre></td></tr></table></figure>\n<p>配置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 加载器配置</span></span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">        &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.css$/</span>, <span class=\"attr\">use</span>: [<span class=\"string\">'style-loader'</span>, <span class=\"string\">'css-loader'</span>], <span class=\"attr\">include</span>: path.resolve(srcRoot)&#125;,</span><br><span class=\"line\">        &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.scss$/</span>, <span class=\"attr\">use</span>: [<span class=\"string\">'style-loader'</span>, <span class=\"string\">'css-loader'</span>, <span class=\"string\">'sass-loader'</span>], <span class=\"attr\">include</span>: path.resolve(srcRoot)&#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<ol>\n<li><a href=\"https://github.com/webpack-contrib/url-loader\" target=\"_blank\" rel=\"noopener\">url-loader</a>处理处理静态文件</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install url-loader --save</span><br></pre></td></tr></table></figure>\n<p>配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module: &#123;</span><br><span class=\"line\">    // 加载器配置</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">        &#123; test: /\\.(png|jpg|jpeg)$/, use: &apos;url-loader?limit=8192&amp;name=images/[name].[hash].[ext]&apos;, include: path.resolve(srcRoot)&#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p><code>limit:</code>表示超过多少就使用base64来代替，单位是byte<br><br><code>name:</code>可以设置图片的路径，名称和是否使用hash 具体<a href=\"https://github.com/webpack-contrib/url-loader\" target=\"_blank\" rel=\"noopener\">参考这里</a></p>\n<h1><span id=\"引入babel\">引入babel<div id=\"babel\"></div></span></h1><p><a href=\"https://babeljs.io/\" target=\"_blank\" rel=\"noopener\">bebel</a>是用来解析es6语法或者是es7语法分解析器，让开发者能够使用新的es语法，同时支持jsx，vue等多种框架。</p>\n<ol>\n<li>安装babel</li>\n</ol>\n<ul>\n<li><a href=\"https://www.npmjs.com/package/babel-core\" target=\"_blank\" rel=\"noopener\">babel-core</a></li>\n<li><a href=\"https://www.npmjs.com/package/babel-loader\" target=\"_blank\" rel=\"noopener\">babel-loader</a></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install babel-core babel-loader --save</span><br></pre></td></tr></table></figure>\n<p>配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module: &#123;</span><br><span class=\"line\">    // 加载器配置</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">        &#123; test: /\\.(js|jsx)$/, use: [&#123;loader:&apos;babel-loader&apos;&#125;] ,include: path.resolve(srcRoot)&#125;,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>babel配置文件：<code>.babelrc</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch .babelrc</span><br></pre></td></tr></table></figure>\n<p>配置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"presets\"</span>: [</span><br><span class=\"line\">        <span class=\"string\">\"es2015\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"react\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"stage-0\"</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">\"plugins\"</span>: []</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>babel支持自定义的预设(presets)或插件(plugins),只有配置了这两个才能让babel生效，单独的安装babel是无意义的<br><br><br><br><code>presets</code>：代表babel支持那种语法(就是你用那种语法写)，优先级是从下往上,<code>state-0|1|2|..</code>代表有很多没有列入标准的语法回已state-x表示,<a href=\"https://babeljs.io/docs/en/babel-preset-stage-0.html\" target=\"_blank\" rel=\"noopener\">参考这里</a><br><br><code>plugins</code>:代表babel解析的时候使用哪些插件，作用和presets类似，优先级是从上往下。<br>依次安装：</p>\n<ul>\n<li><a href=\"https://www.npmjs.com/package/babel-preset-es2015\" target=\"_blank\" rel=\"noopener\">babel-preset-es2015</a></li>\n<li><a href=\"https://www.npmjs.com/package/babel-preset-react\" target=\"_blank\" rel=\"noopener\">babel-preset-react</a></li>\n<li><a href=\"https://www.npmjs.com/package/babel-preset-stage-0\" target=\"_blank\" rel=\"noopener\">babel-preset-stage-0</a></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install babel-preset-es2015 babel-preset-react babel-preset-stage-0 --save</span><br></pre></td></tr></table></figure>\n<ol>\n<li><a href=\"https://babeljs.io/docs/en/babel-polyfill.html\" target=\"_blank\" rel=\"noopener\">babel-polyfill</a>是什么？<br><br>我们之前使用的babel，babel-loader 默认只转换新的 JavaScript 语法，而不转换新的 API。例如，Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转译。如果想使用这些新的对象和方法，必须使用 babel-polyfill，为当前环境提供一个垫片。</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save babel-polyfill</span><br></pre></td></tr></table></figure>\n<p>使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"babel-polyfill\"</span>;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><a href=\"https://babeljs.io/docs/en/babel-plugin-transform-runtime\" target=\"_blank\" rel=\"noopener\">transform-runtime</a>有什么区别？<br><br>当使用<code>babel-polyfill</code>时有一些问题：<br></li>\n</ol>\n<ul>\n<li>默认会引入所有babel支持的新语法，这样就会导致你的文件代码非常庞大。</li>\n<li>通过向全局对象和内置对象的prototype上添加方法来达成目的,造成全局变量污染。</li>\n</ul>\n<p>这时就需要<code>transform-runtime</code>来帮我们有选择性的引入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save babel-plugin-transform-runtime</span><br></pre></td></tr></table></figure>\n<p>配置文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"plugins\"</span>: [</span><br><span class=\"line\">    [<span class=\"string\">\"transform-runtime\"</span>, &#123;</span><br><span class=\"line\">      <span class=\"string\">\"helpers\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"string\">\"polyfill\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"string\">\"regenerator\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"string\">\"moduleName\"</span>: <span class=\"string\">\"babel-runtime\"</span></span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><span id=\"使用htmlwebpackplugin\">使用HtmlWebpackPlugin<div id=\"HtmlWebpackPlugin\"></div></span></h1><p>记得我们之前新建的index.html么 我们执行构建命令之后并没有将index.html打包到dev目录下 我们需要<a href=\"https://github.com/jantimon/html-webpack-plugin\" target=\"_blank\" rel=\"noopener\">HtmlWebpackPlugin</a>来将我们output的js和html结合起来</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install html-webpack-plugin --save</span><br></pre></td></tr></table></figure>\n<p>配置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>);</span><br><span class=\"line\">...</span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">        filename: path.resolve(devPath, <span class=\"string\">'index.html'</span>),</span><br><span class=\"line\">        template: path.resolve(srcRoot, <span class=\"string\">'./page/index/index.html'</span>),</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p><code>filename</code>:可以设置html输出的路径和文件名<br><br><code>template</code>:可以设置已哪个html文件为模版<br>更多参数配置可以<a href=\"https://github.com/jantimon/html-webpack-plugin\" target=\"_blank\" rel=\"noopener\">参考这里</a></p>\n<h1><span id=\"redux\">redux<div id=\"redux\"></div></span></h1><p>关于<a href=\"http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html\" target=\"_blank\" rel=\"noopener\">redux</a>的使用可以参考阮一峰老师的入门<a href=\"http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html\" target=\"_blank\" rel=\"noopener\">教程</a></p>\n<ol>\n<li>安装redux</li>\n</ol>\n<ul>\n<li><a href=\"https://www.npmjs.com/package/redux\" target=\"_blank\" rel=\"noopener\">redux</a></li>\n<li><a href=\"https://www.npmjs.com/package/react-redux\" target=\"_blank\" rel=\"noopener\">react-redux</a></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install redux react-redux --save</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>新建<code>reducers</code>，<code>actions</code>目录和文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|—— index/                          </span><br><span class=\"line\">|—— Main/                   * 组件代码</span><br><span class=\"line\">|       |—— Main.jsx        * 组件jsx</span><br><span class=\"line\">|       |—— Main.scss       * 组件css</span><br><span class=\"line\">|</span><br><span class=\"line\">|—— actions/ </span><br><span class=\"line\">|       |—— actionTypes.js  * action常量</span><br><span class=\"line\">|       |—— todoAction.js   * action</span><br><span class=\"line\">|</span><br><span class=\"line\">|—— reducers/ </span><br><span class=\"line\">|       |—— todoReducer.js  * reducer</span><br><span class=\"line\">|</span><br><span class=\"line\">|—— store.js</span><br><span class=\"line\">|</span><br><span class=\"line\">|—— index.js</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改代码，引入redux,这里以一个redux todo为demo例子：<br></p>\n</li>\n</ol>\n<p><code>index.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ReactDom <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Main <span class=\"keyword\">from</span> <span class=\"string\">'./Main/Main.jsx'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">'./store.js'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDom.render(</span><br><span class=\"line\">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">        &lt;Main /&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/Provider&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">, document.getElementById('root'));</span></span><br></pre></td></tr></table></figure>\n<p><code>store.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> todoReducer <span class=\"keyword\">from</span> <span class=\"string\">'./reducers/todoReducer.js'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(todoReducer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> store;</span><br></pre></td></tr></table></figure>\n<p><code>tabReducer.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; ADD_TODO &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../actions/actionTypes.js'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> initialState = &#123;</span><br><span class=\"line\">      todoList: []</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> addTodo = <span class=\"function\">(<span class=\"params\">state, action</span>) =&gt;</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; ...state, <span class=\"attr\">todoList</span>: state.todoList.concat(action.obj) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> todoReducer = <span class=\"function\">(<span class=\"params\">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span>(action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> ADD_TODO: <span class=\"keyword\">return</span> addTodo(state, action);</span><br><span class=\"line\">    <span class=\"keyword\">default</span>: <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> todoReducer;</span><br></pre></td></tr></table></figure>\n<p><code>Main.jsx</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; addTodo &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../actions/todoAction.js'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    onClick()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> text = <span class=\"keyword\">this</span>.refs.input;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.props.dispatch(addTodo(&#123;</span><br><span class=\"line\">            text: text.value</span><br><span class=\"line\">        &#125;))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                &lt;input ref=<span class=\"string\">\"input\"</span> type=<span class=\"string\">\"text\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">input</span>&gt;</span></span></span><br><span class=\"line\">                &lt;button onClick=&#123;()=&gt;<span class=\"keyword\">this</span>.onClick()&#125;&gt;提交&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                &lt;ul&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                &#123;this.props.todoList.map((item, index)=&gt;&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">                    return &lt;li key=&#123;index&#125;&gt;&#123;item.text&#125;&lt;/</span>li&gt;</span><br><span class=\"line\">                &#125;)&#125;</span><br><span class=\"line\">                &lt;<span class=\"regexp\">/ul&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;/</span>div&gt;</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(</span><br><span class=\"line\">    state =&gt; (&#123;</span><br><span class=\"line\">        todoList: state.todoList</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">)(Main);</span><br></pre></td></tr></table></figure>\n<p><code>todoAction.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; ADD_TODO &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./actionTypes.js'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> addTodo = <span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: ADD_TODO,</span><br><span class=\"line\">    obj: obj</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1><span id=\"使用webpack-dev-server\">使用webpack-dev-server<div id=\"webpack-dev-server\"></div></span></h1><p><a href=\"https://github.com/jantimon/webpack-dev-server\" target=\"_blank\" rel=\"noopener\">webpack-dev-server</a>是一个小型的<code>Node.js Express</code>服务器,它使用webpack-dev-middleware来服务于webpack的包。</p>\n<ol>\n<li>安装</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install webpack-dev-server --save</span><br></pre></td></tr></table></figure>\n<p>修改在package.json中添加的执行命令：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"scripts\": &#123;</span><br><span class=\"line\">  \"dev\": \"./node_modules/.bin/webpack-dev-server --config webpack.config.dev.js\",</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>配置webpack配置文件：</li>\n</ol>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">devServer: &#123;</span><br><span class=\"line\">    \"contentBase\": devPath,</span><br><span class=\"line\">    \"compress\": true,</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p><code>contentBase</code> 表示server文件的根目录<br><code>compress</code> 表示开启gzip<br>更多的配置文档<a href=\"https://webpack.docschina.org/configuration/dev-server/\" target=\"_blank\" rel=\"noopener\">参考这里</a></p>\n<ul>\n<li><p><code>webpack-dev-server</code>默认情况下会将output的内容放在内存中，是看不到物理的文件的，如果想要看到物理的dev下面的文件可以安装<a href=\"https://www.npmjs.com/package/webpack-dev-server\" target=\"_blank\" rel=\"noopener\">write-file-webpack-plugin</a>这个插件。</p>\n</li>\n<li><p><code>webpack-dev-server</code>默认会开启livereload功能</p>\n</li>\n</ul>\n<ol>\n<li><code>devtool</code>功能：<br><br>具体来说添加了<code>devtool: &#39;inline-source-map&#39;</code>之后，利用source-map你在chrome控制台看到的source源码都是真正的源码，未压缩，未编译前的代码，没有添加，你看到的代码是真实的压缩过，编译过的代码，更多devtool的配置可以<a href=\"https://webpack.docschina.org/configuration/devtool/\" target=\"_blank\" rel=\"noopener\">参考这里</a></li>\n</ol>\n<h1><span id=\"多入口文件配置\">多入口文件配置<div id=\"rukou\"></div></span></h1><p>在之前的配置中，都是基于单入口页面配置的，entry和output只有一个文件，但是实际项目很多情况下是多页面的，在配置多页面时，有2中方法可以选择：</p>\n<ol>\n<li>在entry入口配置时，传入对象而不是单独数组,output时利用<code>[name]</code>关键字来区分输出文件例如：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: &#123;</span><br><span class=\"line\">    index: [path.resolve(srcRoot,<span class=\"string\">'./page/index/index1.js'</span>),path.resolve(srcRoot,<span class=\"string\">'./page/index/index2.js'</span>)],</span><br><span class=\"line\">    detail: path.resolve(srcRoot,<span class=\"string\">'./page/detail/detail.js'</span>),</span><br><span class=\"line\">    home: path.resolve(srcRoot,<span class=\"string\">'./page/home/home.js'</span>),</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">output: &#123;</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'./dev'</span>),</span><br><span class=\"line\"></span><br><span class=\"line\">    filename: <span class=\"string\">'[name].min.js'</span></span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<ol>\n<li>通过node动态遍历需要entry point的目录，来动态生成entry：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pageDir = path.resolve(srcRoot, <span class=\"string\">'page'</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getEntry</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> entryMap = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    fs.readdirSync(pageDir).forEach(<span class=\"function\">(<span class=\"params\">pathname</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> fullPathName = path.resolve(pageDir, pathname);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> stat = fs.statSync(fullPathName);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> fileName = path.resolve(fullPathName, <span class=\"string\">'index.js'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (stat.isDirectory() &amp;&amp; fs.existsSync(fileName)) &#123;</span><br><span class=\"line\">            entryMap[pathname] = fileName;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> entryMap;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    entry: getEntry()</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>本demo采用的是第二中写法，能够更加灵活。</p>\n<h1><span id=\"如何理解entry-pointbundlechunkmodule\">如何理解<code>entry point(bundle)</code>,<code>chunk</code>,<code>module</code><div id=\"entry\"></div></span></h1><p>在webpack中，如何理解<code>entry point(bundle)</code>,<code>chunk</code>,<code>module</code>?<br><img src=\"https://qiniu.nihaoshijie.com.cn/image/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-15%20%E4%B8%8B%E5%8D%889.06.45.png\" alt></p>\n<p>根据图上的表述，我这里简单说一下便于理解的结论：<br></p>\n<ul>\n<li>配置中每个文件例如index1.js,index2.js,detail.js,home.js都属于<code>entry point</code>.</li>\n<li>entry这个配置中，每个key值,index,detail,home都相当于<code>chunk</code>。</li>\n<li>我们在代码中的require或者import的都属于<code>module</code>，这点很好理解。</li>\n<li><code>chunk</code>的分类比较特别，有<code>entry chunk</code>,<code>initial chunk</code>,<code>normal chunk</code>,参考<a href=\"https://github.com/webpack/webpack.js.org/issues/970\" target=\"_blank\" rel=\"noopener\">这个文章</a></li>\n<li>正常情况下，一个<code>chunk</code>对应一个output,在使用了<code>CommonsChunkPlugin</code>或者<code>require.ensure</code>之后，<code>chunk</code>就变成了<code>initial chunk</code>,<code>normal chunk</code>，这时，一个<code>chunk</code>对应多个output。<br><br>理解这些概念对于后续使用webpack插件有很大的帮助。</li>\n</ul>\n<h1><span id=\"多入口页面html配置\">多入口页面html配置<div id=\"html\"></div></span></h1><p>之前我们配置<code>HtmlWebpackPlugin</code>时，同样采用的是但页面的配置，这里我们将进行多页面改造,<code>entryMap</code>是上一步得到的entry：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">htmlAarray</span>(<span class=\"params\">entryMap</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> htmlAarray = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.keys(entryMap).forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> fullPathName = path.resolve(pageDir, key);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> fileName = path.resolve(fullPathName, key + <span class=\"string\">'.html'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fs.existsSync(fileName)) &#123;</span><br><span class=\"line\">            htmlAarray.push(<span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">                chunks: key, <span class=\"comment\">// 注意这里的key就是chunk</span></span><br><span class=\"line\">                filename: key + <span class=\"string\">'.html'</span>,</span><br><span class=\"line\">                template: fileName,</span><br><span class=\"line\">                inlineSource:  <span class=\"string\">'.(js|css)'</span></span><br><span class=\"line\">            &#125;))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> htmlAarray;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改plugin配置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">     ...</span><br><span class=\"line\">].concat(htmlMap)</span><br></pre></td></tr></table></figure>\n<h1><span id=\"模块热替换hot-module-replacement\">模块热替换（Hot Module Replacement）<div id=\"hmr\"></div></span></h1><p><a href=\"https://webpack.docschina.org/guides/hot-module-replacement\" target=\"_blank\" rel=\"noopener\">模块热替换</a>(Hot Module Replacement 或 HMR)是 webpack 提供的最有用的功能之一。它允许在运行时更新各种模块，而无需进行完全刷新,很高大上有木有！</p>\n<p>下面说一下配置方法，它需要结合<code>devServer</code>使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">devServer: &#123;</span><br><span class=\"line\">    hot: <span class=\"literal\">true</span> <span class=\"comment\">// 开启HMR</span></span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>开启plugin：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.NamedModulesPlugin(),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class=\"line\">].concat(htmlMap)</span><br></pre></td></tr></table></figure>\n<p>结合React一起使用：<br></p>\n<ol>\n<li>安装<a href=\"https://github.com/jantimon/react-hot-loader\" target=\"_blank\" rel=\"noopener\">react-hot-loader</a>,</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install react-hot-loader --save</span><br></pre></td></tr></table></figure>\n<p>并新建一个Container.jsx:<br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Main <span class=\"keyword\">from</span> <span class=\"string\">'./Main.jsx'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; hot &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-hot-loader'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Container</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Main</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">        </span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br><span class=\"line\"><span class=\"xml\">export default hot(module)(Container);</span></span><br></pre></td></tr></table></figure>\n<p>结合redux：如果项目没有使用redux，可以无需配置后面2步<br></p>\n<ol>\n<li>修改store.js新增下面代码，为了让reducer也能实时热替换</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">module</span>.hot) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">module</span>.hot.accept(<span class=\"string\">'./reducers/todoReducer.js'</span>, () =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> nextRootReducer = <span class=\"built_in\">require</span>(<span class=\"string\">'./reducers/todoReducer.js'</span>).default;</span><br><span class=\"line\">      store.replaceReducer(nextRootReducer);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>修改index.js</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ReactDom <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Container <span class=\"keyword\">from</span> <span class=\"string\">'./Main/Container.jsx'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">'./store.js'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDom.render(</span><br><span class=\"line\">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">        &lt;Container /&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/Provider&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">, document.getElementById('root'));</span></span><br></pre></td></tr></table></figure>\n<p>当控制台看到<code>[WDS] Hot Module Replacement enabled.</code>代表开启成功</p>\n<h1><span id=\"使用eslint\">使用ESLint<div id=\"eslint\"></div></span></h1><p><a href=\"https://eslint.org/\" target=\"_blank\" rel=\"noopener\">ESLint</a> 是众多 Javascript Linter 中的其中一种，其他比较常见的还有 <a href=\"https://www.jslint.com/\" target=\"_blank\" rel=\"noopener\">JSLint</a> 跟 <a href=\"http://jshint.com/\" target=\"_blank\" rel=\"noopener\">JSHint</a>，之所以用 ESLint 是因为他可以自由选择要使用哪些规则，也有很多现成的 plugin 可以使用，另外他对 ES6 还有 JSX 的支持程度跟其他 linter 相比之下也是最高的。</p>\n<ol>\n<li>安装ESLint</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install eslint eslint-loader babel-eslint --save</span><br></pre></td></tr></table></figure>\n<p>其中<code>eslint-loader</code>是将webpack和eslint结合起来在webpack的配置文件中新增一个eslint-loader种，修改如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.(js|jsx)$/</span>, <span class=\"attr\">use</span>: [&#123;<span class=\"attr\">loader</span>:<span class=\"string\">'babel-loader'</span>&#125;,&#123;<span class=\"attr\">loader</span>:<span class=\"string\">'eslint-loader'</span>&#125;] ,<span class=\"attr\">include</span>: path.resolve(srcRoot)&#125;,</span><br></pre></td></tr></table></figure>\n<ol>\n<li>新建<code>.eslintrc</code>配置文件,将parser配置成<code>babel-eslint</code></li>\n</ol>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"extends\"</span>: [<span class=\"string\">\"eslint:recommended\"</span>],</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"attr\">\"parser\"</span>: <span class=\"string\">\"babel-eslint\"</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">\"globals\"</span>: &#123;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"rules\"</span>: &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>安装<a href=\"https://github.com/jantimon/eslint-plugin-react\" target=\"_blank\" rel=\"noopener\">eslint-plugin-react</a>:</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install eslint-plugin-react --save</span><br></pre></td></tr></table></figure>\n<ul>\n<li>说明一下，正常情况下每个eslint规则都是需要在<code>rule</code>下面配置，如果什么都不配置，其实本身eslint是不生效的。</li>\n<li>eslint本身有很多默认的规则模版，可以通过<code>extends</code>来配置，默认可以使用<code>eslint:recommended</code>。</li>\n<li>在使用react开发时可以安装<code>eslint-plugin-react</code>来告知使用react专用的规则来lint。</li>\n</ul>\n<ol>\n<li>修改<code>.eslintrc</code>配置文件,增加rules，更多rules配置可以<a href=\"https://eslint.org/docs/rules/\" target=\"_blank\" rel=\"noopener\">参考这里</a></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"extends\"</span>: [<span class=\"string\">\"eslint:recommended\"</span>,<span class=\"string\">\"plugin:react/recommended\"</span>],</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"string\">\"parser\"</span>: <span class=\"string\">\"babel-eslint\"</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">\"globals\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"window\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"string\">\"document\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"string\">\"module\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"string\">\"require\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"rules\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"react/prop-types\"</span> : <span class=\"string\">\"off\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"no-console\"</span> : <span class=\"string\">\"off\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><span id=\"使用react-router\">使用react-router<div id=\"react-router\"></div></span></h1><p>react-router强大指出在于方便代码管理，结合redux使用更加强大，同时支持web，native更多<a href=\"https://reacttraining.com/react-router/\" target=\"_blank\" rel=\"noopener\">参考这里</a></p>\n<ol>\n<li>安装<a href=\"https://github.com/jantimon/react-router-dom\" target=\"_blank\" rel=\"noopener\">react-router-dom</a></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install react-router-dom --save</span><br></pre></td></tr></table></figure>\n<ol>\n<li>如果项目中用了redux，可以安装<a href=\"https://github.com/ReactTraining/react-router/tree/master/packages/react-router-redux\" target=\"_blank\" rel=\"noopener\">react-router-redux</a></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install react-router-redux@next <span class=\"built_in\">history</span> --save</span><br></pre></td></tr></table></figure>\n<ol>\n<li>修改代码：<br><br><code>index.js</code>:</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ReactDom <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Container <span class=\"keyword\">from</span> <span class=\"string\">'./Main/Container.jsx'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; store, history &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./store.js'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> createHistory <span class=\"keyword\">from</span> <span class=\"string\">'history/createHashHistory'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; ConnectedRouter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-router-redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> history = createHistory();</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDom.render(</span><br><span class=\"line\">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">        &lt;ConnectedRouter history=&#123;history&#125;&gt;</span><br><span class=\"line\">            &lt;Container /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/ConnectedRouter&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>Provider&gt;</span><br><span class=\"line\">, <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>));</span><br></pre></td></tr></table></figure>\n<p>结合<code>history</code>,react-router一共有3中不同的router：</p>\n<ul>\n<li><a href=\"https://reacttraining.com/react-router/web/api/BrowserRouter\" target=\"_blank\" rel=\"noopener\">BrowserRouter</a>通过<code>history/createBrowserHistory</code>引入:当切换时，url会动态更新，底层使用的时html5的<a href=\"https://blog.csdn.net/tianyitianyi1/article/details/7426606\" target=\"_blank\" rel=\"noopener\">pushState</a>。</li>\n<li><a href=\"https://reacttraining.com/react-router/web/api/HashRouter\" target=\"_blank\" rel=\"noopener\">HashRouter</a>通过<code>history/createHashHistory</code>引入:当切换时，动态修改hash，利用hashchange事件。</li>\n<li><a href=\"https://reacttraining.com/react-router/web/api/MemoryRouter\" target=\"_blank\" rel=\"noopener\">MemoryRouter</a>通过<code>history/createMemoryHistory</code>引入:将路径，路由相关数据存入内存中，不涉及url相关更新，兼容性好。</li>\n</ul>\n<p>更多配置可以<a href=\"https://reacttraining.com/react-router/\" target=\"_blank\" rel=\"noopener\">参考这里</a></p>\n<ol>\n<li>如果想要在代码逻辑中获取当前的route路径需要引入<code>router-reducer</code>:<br><br>新建<code>main.js</code>:</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; combineReducers &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; routerReducer &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"react-router-redux\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> todoReducer <span class=\"keyword\">from</span> <span class=\"string\">'./todoReducer.js'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> reducers = combineReducers(&#123;</span><br><span class=\"line\">  todoReducer,</span><br><span class=\"line\">  router: routerReducer</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> reducers;</span><br></pre></td></tr></table></figure>\n<p>修改<code>store.js</code>:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> mainReducer <span class=\"keyword\">from</span> <span class=\"string\">'./reducers/main.js'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(mainReducer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> store;</span><br></pre></td></tr></table></figure>\n<p>然后就可以在<code>this.props.router</code>里面获取单相关的路径信息</p>\n<ol>\n<li>如果需要自己通过action来触发router的跳转，需要引入<code>routerMiddleware</code>:</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore,applyMiddleware &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; routerMiddleware &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"react-router-redux\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> middleware = routerMiddleware(history);</span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(mainReducer,applyMiddleware(middleware));</span><br></pre></td></tr></table></figure>\n<ol>\n<li>使用<code>Route</code>和<code>Link</code>和<code>withRouter</code>:<br><br>先说说都是干嘛的：<br></li>\n</ol>\n<ul>\n<li><a href=\"https://reacttraining.com/react-router/web/api/Route\" target=\"_blank\" rel=\"noopener\">Route</a>:component里面的内容即是tab的主要内容，这个从react-router4开始生效：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Route exact path=<span class=\"string\">\"/\"</span> component=&#123;Div1&#125;&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">Route</span>&gt;</span></span></span><br><span class=\"line\">&lt;Route path=<span class=\"string\">\"/2\"</span> component=&#123;Div2&#125;&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">Route</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"https://reacttraining.com/react-router/web/api/Link\" target=\"_blank\" rel=\"noopener\">Link</a>:通常也可以用<a href=\"https://reacttraining.com/react-router/web/api/NavLink\" target=\"_blank\" rel=\"noopener\">NavLink</a>，相当于tab按钮，控制router的切换,<code>activeClass</code>表示当前tab处于激活态时应用上的class。</li>\n<li><a href=\"https://reacttraining.com/react-router/web/api/withRouter\" target=\"_blank\" rel=\"noopener\">withRouter</a>:如果你用了redux，那么你一定要引入它。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> withRouter(connect(</span><br><span class=\"line\">    state =&gt; (&#123;</span><br><span class=\"line\">        todoList: state.todoReducer.todoList</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">)(Main));</span><br></pre></td></tr></table></figure>\n<p><em>如果你在使用hash时遇到<code>Warning: Hash history cannot PUSH the same path; a new entry will not be added to the history stack</code>错误，可以将push改为replace即</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;NavLink</span><br><span class=\"line\">    replace=&#123;<span class=\"literal\">true</span>&#125;</span><br><span class=\"line\">    to=<span class=\"string\">\"/2\"</span></span><br><span class=\"line\">    activeClassName=<span class=\"string\">\"selected\"</span></span><br><span class=\"line\">    &gt;切换到<span class=\"number\">2</span>号&lt;<span class=\"regexp\">/NavLink&gt;</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>设置初始化路由：</li>\n</ol>\n<ul>\n<li><code>BrowserRouter</code>和<code>HashRouter</code>:</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> history = createHistory();</span><br><span class=\"line\">history.push(<span class=\"string\">'2'</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>MemoryRouter</code>:</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> history = createMemoryHistory(&#123;</span><br><span class=\"line\">    initialEntries: [<span class=\"string\">'/2'</span>]</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h1><span id=\"使用redux-thunk\">使用redux-thunk<div id=\"redux-thunk\"></div></span></h1><p><a href=\"https://www.npmjs.com/package/redux-thunk\" target=\"_blank\" rel=\"noopener\">redux-thunk</a> 是一个比较流行的 redux 异步 action 中间件，比如 action 中有 setTimeout 或者通过 fetch通用远程 API 这些场景，那么久应该使用 redux-thunk 了。redux-thunk 帮助你统一了异步和同步 action 的调用方式，把异步过程放在 action 级别解决，对 component 没有影响。</p>\n<ol>\n<li><p>安装<code>redux-thunk</code>:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install redux-thunk --save</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改<code>store.js</code>:</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore,applyMiddleware &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> thunk <span class=\"keyword\">from</span> <span class=\"string\">'redux-thunk'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> mainReducer <span class=\"keyword\">from</span> <span class=\"string\">'./reducers/main'</span>;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(mainReducer, applyMiddleware(thunk));</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> store;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>在<code>action.js</code>使用redux-thunk：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> getData = <span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> (dispatch, getState) =&gt; &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">    dispatch(&#123;</span><br><span class=\"line\">        type: GET_DATA,</span><br><span class=\"line\">        obj: obj</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,<span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1><span id=\"使用axios和asyncawait\">使用axios和async/await<div id=\"axios\"></div></span></h1><p><a href=\"https://github.com/axios/axios\" target=\"_blank\" rel=\"noopener\">axios</a> 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端：</p>\n<ul>\n<li>从浏览器中创建 XMLHttpRequest</li>\n<li>从 node.js 发出 http 请求</li>\n<li>支持 Promise API</li>\n<li>自动转换JSON数据</li>\n</ul>\n<ol>\n<li>安装axios:</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install axios --save</span><br></pre></td></tr></table></figure>\n<ol>\n<li>在action中使用axios：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">'axios'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> getData = <span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> (dispatch, getState) =&gt; &#123;</span><br><span class=\"line\">    axios.get(<span class=\"string\">'/json/comments.json'</span>).then(<span class=\"function\">(<span class=\"params\">resp</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        dispatch(&#123;</span><br><span class=\"line\">            type: GET_DATA,</span><br><span class=\"line\">            obj: resp</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function\" target=\"_blank\" rel=\"noopener\">async/await</a>：<br></p>\n<p>Javascript的回调地狱，相信很多人都知道，尤其是在node端，近些年比较流行的是<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\" target=\"_blank\" rel=\"noopener\">Promise</a>的解决方案，但是随着 Node 7 的发布，编程终级解决方案的 async/await应声而出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolveAfter2Seconds</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      resolve(<span class=\"string\">'resolved'</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncCall</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"keyword\">await</span> resolveAfter2Seconds();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">asyncCall();</span><br></pre></td></tr></table></figure>\n<p>async/await的用途是简化使用 promises 异步调用的操作，并对一组 Promises执行某些操作。await前提是方法返回的是一个Promise对象，正如Promises类似于结构化回调，async/await类似于组合生成器和 promises。<br></p>\n<ol>\n<li><code>async/await</code>需要安装<a href=\"https://www.npmjs.com/package/babel-plugin-transform-async-to-generator\" target=\"_blank\" rel=\"noopener\">babel-plugin-transform-async-to-generator</a>。</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install babel-plugin-transform-async-to-generator --save</span><br></pre></td></tr></table></figure>\n<ol>\n<li>在<code>.babelrc</code>中增加配置：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"plugins\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"transform-async-to-generator\"</span></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>这样做仅仅是将async转换generator，如果你当前的浏览器不支持generator，你将会收到一个<code>Uncaught ReferenceError: regeneratorRuntime is not defined</code>的错误，你需要：<br></p>\n<ol>\n<li>安装<a href=\"https://www.npmjs.com/package/babel-plugin-transform-runtime\" target=\"_blank\" rel=\"noopener\">babel-plugin-transform-runtime</a>:</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install babel-plugin-transform-async-to-generator --save</span><br></pre></td></tr></table></figure>\n<ol>\n<li>修改<code>.babelrc</code>中的配置(可以去掉之前配置的transform-async-to-generator)：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"plugins\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"transform-runtime\"</span></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<ol>\n<li>如果不想引入所有的polyfill(参考上面对babel的解释),可以增加配置：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"plugins\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"transform-runtime\"</span>,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">\"polyfill\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"string\">\"regenerator\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<ol>\n<li>结合axios使用：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">'axios'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> getData = <span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> <span class=\"keyword\">async</span> (dispatch, getState) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> resp = axios.get(<span class=\"string\">'/json/comments.json'</span>);</span><br><span class=\"line\">    dispatch(&#123;</span><br><span class=\"line\">        type: GET_DATA,</span><br><span class=\"line\">        obj: resp</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1><span id=\"code-splitting\">Code Splitting<div id=\"CodeSplitting\"></div></span></h1><ol>\n<li>对于webpack1，2之前，你可以使用<code>require.ensure</code>来控制一个组件的懒加载：<br></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>.ensure([], _require =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> Component = _require(<span class=\"string\">'./Component.jsx'</span>);</span><br><span class=\"line\">&#125;,<span class=\"string\">'lazyname'</span>)</span><br></pre></td></tr></table></figure>\n<ol>\n<li>在webpack4中，官方已经不再推荐使用<code>require.ensure</code>来使用懒加载功能<em>Dynamic Imports</em>，取而代之的是ES6的<code>import()</code>方法：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span>(</span><br><span class=\"line\">  <span class=\"comment\">/* webpackChunkName: \"my-chunk-name\" */</span></span><br><span class=\"line\">  <span class=\"comment\">/* webpackMode: \"lazy\" */</span></span><br><span class=\"line\">  <span class=\"string\">'module'</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>不小小看注释里的代码，webpack在打包时会动态识别这里的代码来做相关的配置，例如chunk name等等。</p>\n<ol>\n<li><a href=\"https://webpack.js.org/guides/code-splitting/#prefetching-preloading-modules\" target=\"_blank\" rel=\"noopener\">Prefetching/Preloading modules</a>:<br></li>\n</ol>\n<p>webpack 4.6.0+支持了Prefetching/Preloading的写法:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"keyword\">import</span>(<span class=\"comment\">/* webpackPreload: true */</span> <span class=\"string\">'ChartingLibrary'</span>);</span><br></pre></td></tr></table></figure>\n<ol>\n<li>结合React-Router使用:<br></li>\n</ol>\n<p><a href=\"https://www.npmjs.com/package/react-loadable\" target=\"_blank\" rel=\"noopener\">react-loadable</a>对上述的功能做了封装，丰富了一些功能，结合<code>React-Router</code>起来使用更加方便。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install react-loadable --save</span><br></pre></td></tr></table></figure>\n<p>在react-router里使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Loading</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Loading...<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> Div2 = Loadable(&#123;</span><br><span class=\"line\">  loader: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"string\">'./Div2'</span>), </span><br><span class=\"line\">  loading: Loading,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;Route path=<span class=\"string\">\"/2\"</span> component=&#123;Div2&#125;&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">Route</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<h1><span id=\"使用commonschunkplugin\">使用CommonsChunkPlugin</span></h1><p><code>CommonsChunkPlugin</code> 插件，是一个可选的用于建立一个独立文件(又称作 chunk)的功能，这个文件包括多个入口 chunk 的公共模块。通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存起来到缓存中供后续使用。<br></p>\n<ol>\n<li>在webpack4之前的用法：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">    name: <span class=\"string\">'common'</span>,</span><br><span class=\"line\">    chunks: [<span class=\"string\">'page1'</span>,<span class=\"string\">'page2'</span>],</span><br><span class=\"line\">    minChunks: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>name</code>: string: 提出出的名称</li>\n<li><code>chunks</code>: string[]: webpack会从传入的chunk里面提取公共代码,默认从所有entry里提取</li>\n<li><code>minChunks</code>: number|infinity|function(module,count)-&gt;boolean: 如果传入数字或infinity(默认值为3)，就是告诉webpack，只有当模块重复的次数大于等于该数字时，这个模块才会被提取出来。当传入为函数时，所有符合条件的chunk中的模块都会被传入该函数做计算，返回true的模块会被提取到目标chunk。<br>更多的参数配置，可以<a href=\"https://webpack.js.org/plugins/commons-chunk-plugin/#src/components/Sidebar/Sidebar.jsx\" target=\"_blank\" rel=\"noopener\">参考这里</a></li>\n</ul>\n<ol>\n<li>在webpack4之后的用法：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  optimization: &#123;</span><br><span class=\"line\">    splitChunks: &#123;</span><br><span class=\"line\">      chunks: <span class=\"string\">'async'</span>,</span><br><span class=\"line\">      minSize: <span class=\"number\">30000</span>,</span><br><span class=\"line\">      minChunks: <span class=\"number\">1</span>,</span><br><span class=\"line\">      maxAsyncRequests: <span class=\"number\">5</span>,</span><br><span class=\"line\">      maxInitialRequests: <span class=\"number\">3</span>,</span><br><span class=\"line\">      automaticNameDelimiter: <span class=\"string\">'~'</span>,</span><br><span class=\"line\">      name: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      cacheGroups: &#123;</span><br><span class=\"line\">        vendors: &#123;</span><br><span class=\"line\">          test: <span class=\"regexp\">/[\\\\/]node_modules[\\\\/]/</span>,</span><br><span class=\"line\">          priority: <span class=\"number\">-10</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"keyword\">default</span>: &#123;</span><br><span class=\"line\">          minChunks: <span class=\"number\">2</span>,</span><br><span class=\"line\">          priority: <span class=\"number\">-20</span>,</span><br><span class=\"line\">          reuseExistingChunk: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>splitChunks</code>: 配置一个分离chunk(代替老版本的CommonsChunkPlugin)</li>\n<li><code>cacheGroups</code>: 自定义配置主要使用它来决定生成的文件:</li>\n</ul>\n<ol>\n<li><code>test</code>: 限制范围</li>\n<li><code>name</code>: 生成文件名</li>\n<li><code>priority</code>: 优先级</li>\n</ol>\n<ul>\n<li><code>minSize</code>: number: 最小尺寸必须大于此值，默认30000B</li>\n<li><code>minChunks</code>: 其他entry引用次数大于此值，默认1</li>\n<li><code>maxInitialRequests</code>: entry文件请求的chunks不应该超过此值（请求过多，耗时）</li>\n<li><code>maxAsyncRequests</code>: 异步请求的chunks不应该超过此值</li>\n<li><code>automaticNameDelimiter</code>: 自动命名连接符</li>\n<li><code>chunks</code>: 值为”initial”, “async”（默认） 或 “all”:</li>\n</ul>\n<ol>\n<li><code>initial</code>: 入口chunk，对于异步导入的文件不处理</li>\n<li><code>async</code>: 异步chunk，只对异步导入的文件处理</li>\n<li><code>all</code>: 全部chunk</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h3><p>这篇文档 是我结合以往的项目经验 加上自己本身对react webpack redux理解写下的总结文档，总共耗时一周总结下来的，希望能对读者能够有收获。</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><ol>\n<li><a href=\"#版本说明\">版本说明</a></li>\n<li><a href=\"#目录结构\">目录结构</a></li>\n<li><a href=\"#初始化项目\">初始化项目</a></li>\n<li><a href=\"#webpack\">webpack</a></li>\n<li><a href=\"#react\">react</a></li>\n<li><a href=\"#配置loader(sass,jsx\">配置loader(sass,jsx)</a>)</li>\n<li><a href=\"#引入babel\">引入babel</a></li>\n<li><a href=\"#使用HtmlWebpackPlugin\">使用HtmlWebpackPlugin</a></li>\n<li><a href=\"#redux\">redux</a></li>\n<li><a href=\"#使用webpack-dev-server\">使用webpack-dev-server</a></li>\n<li><a href=\"#多入口页面配置\">多入口页面配置</a></li>\n<li><a href=\"#entry\">如何理解<code>entry point(bundle)</code>,<code>chunk</code>,<code>module</code></a></li>\n<li><a href=\"#多入口页面html配置\">多入口页面html配置</a></li>\n<li><a href=\"#hmr\">模块热替换（Hot Module Replacement）</a></li>\n<li><a href=\"#使用ESLint\">使用ESLint</a></li>\n<li><a href=\"#使用react-router\">使用react-router</a></li>\n<li><a href=\"#使用redux-thunk\">使用redux-thunk</a></li>\n<li><a href=\"#使用axios和async/await\">使用axios和async/await</a></li>\n<li><a href=\"#CodeSplitting\">Code Splitting</a></li>\n<li><a href=\"#使用CommonsChunkPlugin\">使用CommonsChunkPlugin</a></li>\n</ol>","more":"<h1 id=\"版本说明\"><a href=\"#版本说明\" class=\"headerlink\" title=\"版本说明\"></a>版本说明<div id=\"banben\"></div></h1><p>由于构建相关例如webpack，babel等更新的较快，所以本教程以下面各种模块的版本号为主，切勿轻易修改或更新版本。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"dependencies\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"babel-core\"</span>: <span class=\"string\">\"^6.26.3\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"babel-eslint\"</span>: <span class=\"string\">\"^8.2.3\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"babel-loader\"</span>: <span class=\"string\">\"^7.1.4\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"babel-plugin-transform-async-to-generator\"</span>: <span class=\"string\">\"^6.24.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"babel-plugin-transform-runtime\"</span>: <span class=\"string\">\"^6.23.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"babel-preset-es2015\"</span>: <span class=\"string\">\"^6.24.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"babel-preset-react\"</span>: <span class=\"string\">\"^6.24.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"babel-preset-stage-0\"</span>: <span class=\"string\">\"^6.24.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"babel-preset-stage-3\"</span>: <span class=\"string\">\"^6.24.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"css-loader\"</span>: <span class=\"string\">\"^0.28.11\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"eslint\"</span>: <span class=\"string\">\"^4.19.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"eslint-loader\"</span>: <span class=\"string\">\"^2.0.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"eslint-plugin-react\"</span>: <span class=\"string\">\"^7.9.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"file-loader\"</span>: <span class=\"string\">\"^1.1.11\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"history\"</span>: <span class=\"string\">\"^4.7.2\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"html-webpack-plugin\"</span>: <span class=\"string\">\"^3.2.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"react\"</span>: <span class=\"string\">\"^16.4.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"react-dom\"</span>: <span class=\"string\">\"^16.4.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"react-hot-loader\"</span>: <span class=\"string\">\"^4.0.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"react-redux\"</span>: <span class=\"string\">\"^5.0.7\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"react-router-dom\"</span>: <span class=\"string\">\"^4.3.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"react-router-redux\"</span>: <span class=\"string\">\"^5.0.0-alpha.9\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"redux\"</span>: <span class=\"string\">\"^4.0.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"sass-loader\"</span>: <span class=\"string\">\"^7.0.3\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"style-loader\"</span>: <span class=\"string\">\"^0.21.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"url-loader\"</span>: <span class=\"string\">\"^1.0.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"webpack\"</span>: <span class=\"string\">\"^4.12.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"webpack-cli\"</span>: <span class=\"string\">\"^3.0.3\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"webpack-dev-server\"</span>: <span class=\"string\">\"^3.1.1\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构<div id=\"mulu\"></div></h1><p>开发和发布版本的配置文件是分开的，多入口页面的目录结构。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">react-family/</span><br><span class=\"line\">    |</span><br><span class=\"line\">    |──dist/                                    * 发布版本构建输出路径</span><br><span class=\"line\">    |</span><br><span class=\"line\">    |──dev/                                     * 调试版本构建输出路径</span><br><span class=\"line\">    |</span><br><span class=\"line\">    |──src/                                     * 工具函数</span><br><span class=\"line\">    |     |</span><br><span class=\"line\">    |     |—— component/                        * 各页面公用组件</span><br><span class=\"line\">    |     |</span><br><span class=\"line\">    |     |—— page/                             * 页面代码</span><br><span class=\"line\">    |     |      |—— index/                     * 页面代码</span><br><span class=\"line\">    |     |      |        |—— Main/             * 组件代码</span><br><span class=\"line\">    |     |      |        |       |—— Main.jsx  * 组件jsx</span><br><span class=\"line\">    |     |      |        |       |—— Main.scss * 组件css</span><br><span class=\"line\">    |     |      |</span><br><span class=\"line\">    |     |      |—— detail/                    * 页面代码</span><br><span class=\"line\">    |     |</span><br><span class=\"line\">    |     |—— static/                           * 静态文件js，css</span><br><span class=\"line\">    |</span><br><span class=\"line\">    |</span><br><span class=\"line\">    |──webpack.config.build.js                  * 发布版本使用的webpack配置文件</span><br><span class=\"line\">    |──webpack.config.dev.js                    * 调试版本使用的webpack配置文件</span><br><span class=\"line\">    |──.eslint                                  * eslint配置文件</span><br><span class=\"line\">    |__.babelrc                                 * babel配置文件</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"初始化项目\"><a href=\"#初始化项目\" class=\"headerlink\" title=\"初始化项目\"></a>初始化项目<div id=\"initcode\"></div></h1><ol>\n<li>创建文件夹</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir react-family-bucket</span><br></pre></td></tr></table></figure>\n<ol>\n<li>初始化npm<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> react-family-bucket</span><br><span class=\"line\">npm init</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>如果有特殊需要，可以填入自己的配置，一路回车下来，会生成一个<code>package.json</code>，里面是你项目的基本信息，后面的npm依赖安装也会配置在这里。</p>\n<h1 id=\"webpack\"><a href=\"#webpack\" class=\"headerlink\" title=\"webpack\"></a>webpack<div id=\"webpack\"></div></h1><ol>\n<li>安装<a href=\"https://webpack.js.org/\" target=\"_blank\" rel=\"noopener\">webpack</a><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install webpack --save</span><br><span class=\"line\">or</span><br><span class=\"line\">npm install webpack --g</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><code>--save</code>是将当前webpack安装到react-family-bucket下的<code>/node_modules</code>。<br><br><code>--g</code>是将当前webpack安装到全局下面，可以在node的安装目录下找到全局的<code>/node_modules</code>。</p>\n<ol>\n<li>配置webopack配置文件</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch webpack.config.dev.js</span><br></pre></td></tr></table></figure>\n<p>新建一个app.js<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch app.js</span><br></pre></td></tr></table></figure></p>\n<p>写入基本的webpack配置，可以<a href=\"https://webpack.js.org/\" target=\"_blank\" rel=\"noopener\">参考这里</a>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> srcRoot = <span class=\"string\">'./src'</span>;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 输入配置</span></span><br><span class=\"line\">    entry: [</span><br><span class=\"line\">      <span class=\"string\">'./app.js'</span></span><br><span class=\"line\">    ],,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 输出配置</span></span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        path: path.resolve(__dirname, <span class=\"string\">'./dev'</span>),</span><br><span class=\"line\"></span><br><span class=\"line\">        filename: <span class=\"string\">'bundle.min.js'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>3, 执行webpack命令<br>如果是全局安装：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack --config webpack.config.dev.js</span><br></pre></td></tr></table></figure></p>\n<p>如果是当前目录安装：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./node_modules/.bin/webpack --config webpack.config.dev.js</span><br></pre></td></tr></table></figure></p>\n<p>在package.json中添加执行命令：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"scripts\": &#123;</span><br><span class=\"line\">  \"dev\": \"./node_modules/.bin/webpack --config webpack.config.dev.js\",</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>执行<code>npm run dev</code>命令之后，会发现需要安装<code>webpack-cli</code>，（webpack4之后需要安装这个）<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install webpack-cli --save</span><br></pre></td></tr></table></figure></p>\n<p>去除<code>WARNING in configuration</code>警告,在webpack.config.dev.js增加一个配置即可：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">mode: <span class=\"string\">'development'</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>成功之后会在dev下面生成bundle.min.js代表正常。<br><br>如果想要动态监听文件变化需要在命令后面添加  <code>--watch</code></p>\n<h1 id=\"react\"><a href=\"#react\" class=\"headerlink\" title=\"react\"></a>react<div id=\"react\"></div></h1><ol>\n<li>安装<a href=\"https://reactjs.org/\" target=\"_blank\" rel=\"noopener\">react</a></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install react react-dom --save</span><br></pre></td></tr></table></figure>\n<ol>\n<li>创建page目录和index页面文件：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir src</span><br><span class=\"line\">mkdir page</span><br><span class=\"line\"><span class=\"built_in\">cd</span> page</span><br></pre></td></tr></table></figure>\n<p>创建index<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir index</span><br><span class=\"line\"><span class=\"built_in\">cd</span> index &amp; touch index.js &amp; touch index.html</span><br></pre></td></tr></table></figure></p>\n<p>index.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ReactDom <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Main <span class=\"keyword\">from</span> <span class=\"string\">'./Main/Main.jsx'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDom.render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Main</span> /&gt;</span>, document.getElementById('root'));</span></span><br></pre></td></tr></table></figure>\n<p>index.html<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>index<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"root\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>创建Main组件</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Main<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Main;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>export</code> 和 <code>export default</code>区别：</li>\n</ul>\n<p>export可以有多个</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xx.js:</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> test1 = <span class=\"string\">'a'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test2</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">yy.js:</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; test1, test2 &#125; <span class=\"keyword\">from</span> <span class=\"string\">'xx.js'</span>;</span><br></pre></td></tr></table></figure>\n<p>export default只能有1个</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xx.js:</span><br><span class=\"line\"><span class=\"keyword\">let</span> test1 = <span class=\"string\">'a'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> test1;</span><br><span class=\"line\"></span><br><span class=\"line\">yy.js:</span><br><span class=\"line\"><span class=\"keyword\">import</span> test1 <span class=\"keyword\">from</span> <span class=\"string\">'xx.js'</span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>export</code> 和 <code>module.exports</code></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> exports = <span class=\"built_in\">module</span>.exports;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>修改webpack配置入口文件</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: [</span><br><span class=\"line\">    path.resolve(srcRoot,<span class=\"string\">'./page/index/index.js'</span>)</span><br><span class=\"line\">],</span><br></pre></td></tr></table></figure>\n<h1 id=\"配置loader\"><a href=\"#配置loader\" class=\"headerlink\" title=\"配置loader\"></a>配置loader<div id=\"loader\"></div></h1><ol>\n<li>处理样式文件需要这些loader:</li>\n</ol>\n<ul>\n<li><a href=\"https://github.com/webpack-contrib/css-loader\" target=\"_blank\" rel=\"noopener\">css-loader</a></li>\n<li><a href=\"https://github.com/webpack-contrib/sass-loader\" target=\"_blank\" rel=\"noopener\">sass-loader</a></li>\n<li><a href=\"https://github.com/webpack-contrib/style-loader\" target=\"_blank\" rel=\"noopener\">style-loader</a></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install css-loader sass-loader style-loader file-loader --save</span><br></pre></td></tr></table></figure>\n<p>配置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 加载器配置</span></span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">        &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.css$/</span>, <span class=\"attr\">use</span>: [<span class=\"string\">'style-loader'</span>, <span class=\"string\">'css-loader'</span>], <span class=\"attr\">include</span>: path.resolve(srcRoot)&#125;,</span><br><span class=\"line\">        &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.scss$/</span>, <span class=\"attr\">use</span>: [<span class=\"string\">'style-loader'</span>, <span class=\"string\">'css-loader'</span>, <span class=\"string\">'sass-loader'</span>], <span class=\"attr\">include</span>: path.resolve(srcRoot)&#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<ol>\n<li><a href=\"https://github.com/webpack-contrib/url-loader\" target=\"_blank\" rel=\"noopener\">url-loader</a>处理处理静态文件</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install url-loader --save</span><br></pre></td></tr></table></figure>\n<p>配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module: &#123;</span><br><span class=\"line\">    // 加载器配置</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">        &#123; test: /\\.(png|jpg|jpeg)$/, use: &apos;url-loader?limit=8192&amp;name=images/[name].[hash].[ext]&apos;, include: path.resolve(srcRoot)&#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p><code>limit:</code>表示超过多少就使用base64来代替，单位是byte<br><br><code>name:</code>可以设置图片的路径，名称和是否使用hash 具体<a href=\"https://github.com/webpack-contrib/url-loader\" target=\"_blank\" rel=\"noopener\">参考这里</a></p>\n<h1 id=\"引入babel\"><a href=\"#引入babel\" class=\"headerlink\" title=\"引入babel\"></a>引入babel<div id=\"babel\"></div></h1><p><a href=\"https://babeljs.io/\" target=\"_blank\" rel=\"noopener\">bebel</a>是用来解析es6语法或者是es7语法分解析器，让开发者能够使用新的es语法，同时支持jsx，vue等多种框架。</p>\n<ol>\n<li>安装babel</li>\n</ol>\n<ul>\n<li><a href=\"https://www.npmjs.com/package/babel-core\" target=\"_blank\" rel=\"noopener\">babel-core</a></li>\n<li><a href=\"https://www.npmjs.com/package/babel-loader\" target=\"_blank\" rel=\"noopener\">babel-loader</a></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install babel-core babel-loader --save</span><br></pre></td></tr></table></figure>\n<p>配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module: &#123;</span><br><span class=\"line\">    // 加载器配置</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">        &#123; test: /\\.(js|jsx)$/, use: [&#123;loader:&apos;babel-loader&apos;&#125;] ,include: path.resolve(srcRoot)&#125;,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>babel配置文件：<code>.babelrc</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch .babelrc</span><br></pre></td></tr></table></figure>\n<p>配置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"presets\"</span>: [</span><br><span class=\"line\">        <span class=\"string\">\"es2015\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"react\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"stage-0\"</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">\"plugins\"</span>: []</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>babel支持自定义的预设(presets)或插件(plugins),只有配置了这两个才能让babel生效，单独的安装babel是无意义的<br><br><br><br><code>presets</code>：代表babel支持那种语法(就是你用那种语法写)，优先级是从下往上,<code>state-0|1|2|..</code>代表有很多没有列入标准的语法回已state-x表示,<a href=\"https://babeljs.io/docs/en/babel-preset-stage-0.html\" target=\"_blank\" rel=\"noopener\">参考这里</a><br><br><code>plugins</code>:代表babel解析的时候使用哪些插件，作用和presets类似，优先级是从上往下。<br>依次安装：</p>\n<ul>\n<li><a href=\"https://www.npmjs.com/package/babel-preset-es2015\" target=\"_blank\" rel=\"noopener\">babel-preset-es2015</a></li>\n<li><a href=\"https://www.npmjs.com/package/babel-preset-react\" target=\"_blank\" rel=\"noopener\">babel-preset-react</a></li>\n<li><a href=\"https://www.npmjs.com/package/babel-preset-stage-0\" target=\"_blank\" rel=\"noopener\">babel-preset-stage-0</a></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install babel-preset-es2015 babel-preset-react babel-preset-stage-0 --save</span><br></pre></td></tr></table></figure>\n<ol>\n<li><a href=\"https://babeljs.io/docs/en/babel-polyfill.html\" target=\"_blank\" rel=\"noopener\">babel-polyfill</a>是什么？<br><br>我们之前使用的babel，babel-loader 默认只转换新的 JavaScript 语法，而不转换新的 API。例如，Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转译。如果想使用这些新的对象和方法，必须使用 babel-polyfill，为当前环境提供一个垫片。</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save babel-polyfill</span><br></pre></td></tr></table></figure>\n<p>使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"babel-polyfill\"</span>;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><a href=\"https://babeljs.io/docs/en/babel-plugin-transform-runtime\" target=\"_blank\" rel=\"noopener\">transform-runtime</a>有什么区别？<br><br>当使用<code>babel-polyfill</code>时有一些问题：<br></li>\n</ol>\n<ul>\n<li>默认会引入所有babel支持的新语法，这样就会导致你的文件代码非常庞大。</li>\n<li>通过向全局对象和内置对象的prototype上添加方法来达成目的,造成全局变量污染。</li>\n</ul>\n<p>这时就需要<code>transform-runtime</code>来帮我们有选择性的引入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save babel-plugin-transform-runtime</span><br></pre></td></tr></table></figure>\n<p>配置文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"plugins\"</span>: [</span><br><span class=\"line\">    [<span class=\"string\">\"transform-runtime\"</span>, &#123;</span><br><span class=\"line\">      <span class=\"string\">\"helpers\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"string\">\"polyfill\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"string\">\"regenerator\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"string\">\"moduleName\"</span>: <span class=\"string\">\"babel-runtime\"</span></span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用HtmlWebpackPlugin\"><a href=\"#使用HtmlWebpackPlugin\" class=\"headerlink\" title=\"使用HtmlWebpackPlugin\"></a>使用HtmlWebpackPlugin<div id=\"HtmlWebpackPlugin\"></div></h1><p>记得我们之前新建的index.html么 我们执行构建命令之后并没有将index.html打包到dev目录下 我们需要<a href=\"https://github.com/jantimon/html-webpack-plugin\" target=\"_blank\" rel=\"noopener\">HtmlWebpackPlugin</a>来将我们output的js和html结合起来</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install html-webpack-plugin --save</span><br></pre></td></tr></table></figure>\n<p>配置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>);</span><br><span class=\"line\">...</span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">        filename: path.resolve(devPath, <span class=\"string\">'index.html'</span>),</span><br><span class=\"line\">        template: path.resolve(srcRoot, <span class=\"string\">'./page/index/index.html'</span>),</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p><code>filename</code>:可以设置html输出的路径和文件名<br><br><code>template</code>:可以设置已哪个html文件为模版<br>更多参数配置可以<a href=\"https://github.com/jantimon/html-webpack-plugin\" target=\"_blank\" rel=\"noopener\">参考这里</a></p>\n<h1 id=\"redux\"><a href=\"#redux\" class=\"headerlink\" title=\"redux\"></a>redux<div id=\"redux\"></div></h1><p>关于<a href=\"http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html\" target=\"_blank\" rel=\"noopener\">redux</a>的使用可以参考阮一峰老师的入门<a href=\"http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html\" target=\"_blank\" rel=\"noopener\">教程</a></p>\n<ol>\n<li>安装redux</li>\n</ol>\n<ul>\n<li><a href=\"https://www.npmjs.com/package/redux\" target=\"_blank\" rel=\"noopener\">redux</a></li>\n<li><a href=\"https://www.npmjs.com/package/react-redux\" target=\"_blank\" rel=\"noopener\">react-redux</a></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install redux react-redux --save</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>新建<code>reducers</code>，<code>actions</code>目录和文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|—— index/                          </span><br><span class=\"line\">|—— Main/                   * 组件代码</span><br><span class=\"line\">|       |—— Main.jsx        * 组件jsx</span><br><span class=\"line\">|       |—— Main.scss       * 组件css</span><br><span class=\"line\">|</span><br><span class=\"line\">|—— actions/ </span><br><span class=\"line\">|       |—— actionTypes.js  * action常量</span><br><span class=\"line\">|       |—— todoAction.js   * action</span><br><span class=\"line\">|</span><br><span class=\"line\">|—— reducers/ </span><br><span class=\"line\">|       |—— todoReducer.js  * reducer</span><br><span class=\"line\">|</span><br><span class=\"line\">|—— store.js</span><br><span class=\"line\">|</span><br><span class=\"line\">|—— index.js</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改代码，引入redux,这里以一个redux todo为demo例子：<br></p>\n</li>\n</ol>\n<p><code>index.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ReactDom <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Main <span class=\"keyword\">from</span> <span class=\"string\">'./Main/Main.jsx'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">'./store.js'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDom.render(</span><br><span class=\"line\">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">        &lt;Main /&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/Provider&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">, document.getElementById('root'));</span></span><br></pre></td></tr></table></figure>\n<p><code>store.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> todoReducer <span class=\"keyword\">from</span> <span class=\"string\">'./reducers/todoReducer.js'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(todoReducer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> store;</span><br></pre></td></tr></table></figure>\n<p><code>tabReducer.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; ADD_TODO &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../actions/actionTypes.js'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> initialState = &#123;</span><br><span class=\"line\">      todoList: []</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> addTodo = <span class=\"function\">(<span class=\"params\">state, action</span>) =&gt;</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; ...state, <span class=\"attr\">todoList</span>: state.todoList.concat(action.obj) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> todoReducer = <span class=\"function\">(<span class=\"params\">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span>(action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> ADD_TODO: <span class=\"keyword\">return</span> addTodo(state, action);</span><br><span class=\"line\">    <span class=\"keyword\">default</span>: <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> todoReducer;</span><br></pre></td></tr></table></figure>\n<p><code>Main.jsx</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; addTodo &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../actions/todoAction.js'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    onClick()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> text = <span class=\"keyword\">this</span>.refs.input;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.props.dispatch(addTodo(&#123;</span><br><span class=\"line\">            text: text.value</span><br><span class=\"line\">        &#125;))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                &lt;input ref=<span class=\"string\">\"input\"</span> type=<span class=\"string\">\"text\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">input</span>&gt;</span></span></span><br><span class=\"line\">                &lt;button onClick=&#123;()=&gt;<span class=\"keyword\">this</span>.onClick()&#125;&gt;提交&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                &lt;ul&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                &#123;this.props.todoList.map((item, index)=&gt;&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">                    return &lt;li key=&#123;index&#125;&gt;&#123;item.text&#125;&lt;/</span>li&gt;</span><br><span class=\"line\">                &#125;)&#125;</span><br><span class=\"line\">                &lt;<span class=\"regexp\">/ul&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;/</span>div&gt;</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(</span><br><span class=\"line\">    state =&gt; (&#123;</span><br><span class=\"line\">        todoList: state.todoList</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">)(Main);</span><br></pre></td></tr></table></figure>\n<p><code>todoAction.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; ADD_TODO &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./actionTypes.js'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> addTodo = <span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: ADD_TODO,</span><br><span class=\"line\">    obj: obj</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用webpack-dev-server\"><a href=\"#使用webpack-dev-server\" class=\"headerlink\" title=\"使用webpack-dev-server\"></a>使用webpack-dev-server<div id=\"webpack-dev-server\"></div></h1><p><a href=\"https://github.com/jantimon/webpack-dev-server\" target=\"_blank\" rel=\"noopener\">webpack-dev-server</a>是一个小型的<code>Node.js Express</code>服务器,它使用webpack-dev-middleware来服务于webpack的包。</p>\n<ol>\n<li>安装</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install webpack-dev-server --save</span><br></pre></td></tr></table></figure>\n<p>修改在package.json中添加的执行命令：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"scripts\": &#123;</span><br><span class=\"line\">  \"dev\": \"./node_modules/.bin/webpack-dev-server --config webpack.config.dev.js\",</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>配置webpack配置文件：</li>\n</ol>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">devServer: &#123;</span><br><span class=\"line\">    \"contentBase\": devPath,</span><br><span class=\"line\">    \"compress\": true,</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p><code>contentBase</code> 表示server文件的根目录<br><code>compress</code> 表示开启gzip<br>更多的配置文档<a href=\"https://webpack.docschina.org/configuration/dev-server/\" target=\"_blank\" rel=\"noopener\">参考这里</a></p>\n<ul>\n<li><p><code>webpack-dev-server</code>默认情况下会将output的内容放在内存中，是看不到物理的文件的，如果想要看到物理的dev下面的文件可以安装<a href=\"https://www.npmjs.com/package/webpack-dev-server\" target=\"_blank\" rel=\"noopener\">write-file-webpack-plugin</a>这个插件。</p>\n</li>\n<li><p><code>webpack-dev-server</code>默认会开启livereload功能</p>\n</li>\n</ul>\n<ol>\n<li><code>devtool</code>功能：<br><br>具体来说添加了<code>devtool: &#39;inline-source-map&#39;</code>之后，利用source-map你在chrome控制台看到的source源码都是真正的源码，未压缩，未编译前的代码，没有添加，你看到的代码是真实的压缩过，编译过的代码，更多devtool的配置可以<a href=\"https://webpack.docschina.org/configuration/devtool/\" target=\"_blank\" rel=\"noopener\">参考这里</a></li>\n</ol>\n<h1 id=\"多入口文件配置\"><a href=\"#多入口文件配置\" class=\"headerlink\" title=\"多入口文件配置\"></a>多入口文件配置<div id=\"rukou\"></div></h1><p>在之前的配置中，都是基于单入口页面配置的，entry和output只有一个文件，但是实际项目很多情况下是多页面的，在配置多页面时，有2中方法可以选择：</p>\n<ol>\n<li>在entry入口配置时，传入对象而不是单独数组,output时利用<code>[name]</code>关键字来区分输出文件例如：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: &#123;</span><br><span class=\"line\">    index: [path.resolve(srcRoot,<span class=\"string\">'./page/index/index1.js'</span>),path.resolve(srcRoot,<span class=\"string\">'./page/index/index2.js'</span>)],</span><br><span class=\"line\">    detail: path.resolve(srcRoot,<span class=\"string\">'./page/detail/detail.js'</span>),</span><br><span class=\"line\">    home: path.resolve(srcRoot,<span class=\"string\">'./page/home/home.js'</span>),</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">output: &#123;</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'./dev'</span>),</span><br><span class=\"line\"></span><br><span class=\"line\">    filename: <span class=\"string\">'[name].min.js'</span></span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<ol>\n<li>通过node动态遍历需要entry point的目录，来动态生成entry：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pageDir = path.resolve(srcRoot, <span class=\"string\">'page'</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getEntry</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> entryMap = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    fs.readdirSync(pageDir).forEach(<span class=\"function\">(<span class=\"params\">pathname</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> fullPathName = path.resolve(pageDir, pathname);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> stat = fs.statSync(fullPathName);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> fileName = path.resolve(fullPathName, <span class=\"string\">'index.js'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (stat.isDirectory() &amp;&amp; fs.existsSync(fileName)) &#123;</span><br><span class=\"line\">            entryMap[pathname] = fileName;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> entryMap;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    entry: getEntry()</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>本demo采用的是第二中写法，能够更加灵活。</p>\n<h1 id=\"如何理解entry-point-bundle-chunk-module\"><a href=\"#如何理解entry-point-bundle-chunk-module\" class=\"headerlink\" title=\"如何理解entry point(bundle),chunk,module\"></a>如何理解<code>entry point(bundle)</code>,<code>chunk</code>,<code>module</code><div id=\"entry\"></div></h1><p>在webpack中，如何理解<code>entry point(bundle)</code>,<code>chunk</code>,<code>module</code>?<br><img src=\"https://qiniu.nihaoshijie.com.cn/image/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-15%20%E4%B8%8B%E5%8D%889.06.45.png\" alt=\"\"></p>\n<p>根据图上的表述，我这里简单说一下便于理解的结论：<br></p>\n<ul>\n<li>配置中每个文件例如index1.js,index2.js,detail.js,home.js都属于<code>entry point</code>.</li>\n<li>entry这个配置中，每个key值,index,detail,home都相当于<code>chunk</code>。</li>\n<li>我们在代码中的require或者import的都属于<code>module</code>，这点很好理解。</li>\n<li><code>chunk</code>的分类比较特别，有<code>entry chunk</code>,<code>initial chunk</code>,<code>normal chunk</code>,参考<a href=\"https://github.com/webpack/webpack.js.org/issues/970\" target=\"_blank\" rel=\"noopener\">这个文章</a></li>\n<li>正常情况下，一个<code>chunk</code>对应一个output,在使用了<code>CommonsChunkPlugin</code>或者<code>require.ensure</code>之后，<code>chunk</code>就变成了<code>initial chunk</code>,<code>normal chunk</code>，这时，一个<code>chunk</code>对应多个output。<br><br>理解这些概念对于后续使用webpack插件有很大的帮助。</li>\n</ul>\n<h1 id=\"多入口页面html配置\"><a href=\"#多入口页面html配置\" class=\"headerlink\" title=\"多入口页面html配置\"></a>多入口页面html配置<div id=\"html\"></div></h1><p>之前我们配置<code>HtmlWebpackPlugin</code>时，同样采用的是但页面的配置，这里我们将进行多页面改造,<code>entryMap</code>是上一步得到的entry：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">htmlAarray</span>(<span class=\"params\">entryMap</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> htmlAarray = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.keys(entryMap).forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> fullPathName = path.resolve(pageDir, key);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> fileName = path.resolve(fullPathName, key + <span class=\"string\">'.html'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fs.existsSync(fileName)) &#123;</span><br><span class=\"line\">            htmlAarray.push(<span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">                chunks: key, <span class=\"comment\">// 注意这里的key就是chunk</span></span><br><span class=\"line\">                filename: key + <span class=\"string\">'.html'</span>,</span><br><span class=\"line\">                template: fileName,</span><br><span class=\"line\">                inlineSource:  <span class=\"string\">'.(js|css)'</span></span><br><span class=\"line\">            &#125;))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> htmlAarray;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改plugin配置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">     ...</span><br><span class=\"line\">].concat(htmlMap)</span><br></pre></td></tr></table></figure>\n<h1 id=\"模块热替换（Hot-Module-Replacement）\"><a href=\"#模块热替换（Hot-Module-Replacement）\" class=\"headerlink\" title=\"模块热替换（Hot Module Replacement）\"></a>模块热替换（Hot Module Replacement）<div id=\"hmr\"></div></h1><p><a href=\"https://webpack.docschina.org/guides/hot-module-replacement\" target=\"_blank\" rel=\"noopener\">模块热替换</a>(Hot Module Replacement 或 HMR)是 webpack 提供的最有用的功能之一。它允许在运行时更新各种模块，而无需进行完全刷新,很高大上有木有！</p>\n<p>下面说一下配置方法，它需要结合<code>devServer</code>使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">devServer: &#123;</span><br><span class=\"line\">    hot: <span class=\"literal\">true</span> <span class=\"comment\">// 开启HMR</span></span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>开启plugin：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.NamedModulesPlugin(),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class=\"line\">].concat(htmlMap)</span><br></pre></td></tr></table></figure>\n<p>结合React一起使用：<br></p>\n<ol>\n<li>安装<a href=\"https://github.com/jantimon/react-hot-loader\" target=\"_blank\" rel=\"noopener\">react-hot-loader</a>,</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install react-hot-loader --save</span><br></pre></td></tr></table></figure>\n<p>并新建一个Container.jsx:<br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Main <span class=\"keyword\">from</span> <span class=\"string\">'./Main.jsx'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; hot &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-hot-loader'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Container</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Main</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">        </span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br><span class=\"line\"><span class=\"xml\">export default hot(module)(Container);</span></span><br></pre></td></tr></table></figure>\n<p>结合redux：如果项目没有使用redux，可以无需配置后面2步<br></p>\n<ol>\n<li>修改store.js新增下面代码，为了让reducer也能实时热替换</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">module</span>.hot) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">module</span>.hot.accept(<span class=\"string\">'./reducers/todoReducer.js'</span>, () =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> nextRootReducer = <span class=\"built_in\">require</span>(<span class=\"string\">'./reducers/todoReducer.js'</span>).default;</span><br><span class=\"line\">      store.replaceReducer(nextRootReducer);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>修改index.js</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ReactDom <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Container <span class=\"keyword\">from</span> <span class=\"string\">'./Main/Container.jsx'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">'./store.js'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDom.render(</span><br><span class=\"line\">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">        &lt;Container /&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/Provider&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">, document.getElementById('root'));</span></span><br></pre></td></tr></table></figure>\n<p>当控制台看到<code>[WDS] Hot Module Replacement enabled.</code>代表开启成功</p>\n<h1 id=\"使用ESLint\"><a href=\"#使用ESLint\" class=\"headerlink\" title=\"使用ESLint\"></a>使用ESLint<div id=\"eslint\"></div></h1><p><a href=\"https://eslint.org/\" target=\"_blank\" rel=\"noopener\">ESLint</a> 是众多 Javascript Linter 中的其中一种，其他比较常见的还有 <a href=\"https://www.jslint.com/\" target=\"_blank\" rel=\"noopener\">JSLint</a> 跟 <a href=\"http://jshint.com/\" target=\"_blank\" rel=\"noopener\">JSHint</a>，之所以用 ESLint 是因为他可以自由选择要使用哪些规则，也有很多现成的 plugin 可以使用，另外他对 ES6 还有 JSX 的支持程度跟其他 linter 相比之下也是最高的。</p>\n<ol>\n<li>安装ESLint</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install eslint eslint-loader babel-eslint --save</span><br></pre></td></tr></table></figure>\n<p>其中<code>eslint-loader</code>是将webpack和eslint结合起来在webpack的配置文件中新增一个eslint-loader种，修改如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.(js|jsx)$/</span>, <span class=\"attr\">use</span>: [&#123;<span class=\"attr\">loader</span>:<span class=\"string\">'babel-loader'</span>&#125;,&#123;<span class=\"attr\">loader</span>:<span class=\"string\">'eslint-loader'</span>&#125;] ,<span class=\"attr\">include</span>: path.resolve(srcRoot)&#125;,</span><br></pre></td></tr></table></figure>\n<ol>\n<li>新建<code>.eslintrc</code>配置文件,将parser配置成<code>babel-eslint</code></li>\n</ol>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"extends\"</span>: [<span class=\"string\">\"eslint:recommended\"</span>],</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"attr\">\"parser\"</span>: <span class=\"string\">\"babel-eslint\"</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">\"globals\"</span>: &#123;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"rules\"</span>: &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>安装<a href=\"https://github.com/jantimon/eslint-plugin-react\" target=\"_blank\" rel=\"noopener\">eslint-plugin-react</a>:</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install eslint-plugin-react --save</span><br></pre></td></tr></table></figure>\n<ul>\n<li>说明一下，正常情况下每个eslint规则都是需要在<code>rule</code>下面配置，如果什么都不配置，其实本身eslint是不生效的。</li>\n<li>eslint本身有很多默认的规则模版，可以通过<code>extends</code>来配置，默认可以使用<code>eslint:recommended</code>。</li>\n<li>在使用react开发时可以安装<code>eslint-plugin-react</code>来告知使用react专用的规则来lint。</li>\n</ul>\n<ol>\n<li>修改<code>.eslintrc</code>配置文件,增加rules，更多rules配置可以<a href=\"https://eslint.org/docs/rules/\" target=\"_blank\" rel=\"noopener\">参考这里</a></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"extends\"</span>: [<span class=\"string\">\"eslint:recommended\"</span>,<span class=\"string\">\"plugin:react/recommended\"</span>],</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"string\">\"parser\"</span>: <span class=\"string\">\"babel-eslint\"</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">\"globals\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"window\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"string\">\"document\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"string\">\"module\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"string\">\"require\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"rules\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"react/prop-types\"</span> : <span class=\"string\">\"off\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"no-console\"</span> : <span class=\"string\">\"off\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用react-router\"><a href=\"#使用react-router\" class=\"headerlink\" title=\"使用react-router\"></a>使用react-router<div id=\"react-router\"></div></h1><p>react-router强大指出在于方便代码管理，结合redux使用更加强大，同时支持web，native更多<a href=\"https://reacttraining.com/react-router/\" target=\"_blank\" rel=\"noopener\">参考这里</a></p>\n<ol>\n<li>安装<a href=\"https://github.com/jantimon/react-router-dom\" target=\"_blank\" rel=\"noopener\">react-router-dom</a></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install react-router-dom --save</span><br></pre></td></tr></table></figure>\n<ol>\n<li>如果项目中用了redux，可以安装<a href=\"https://github.com/ReactTraining/react-router/tree/master/packages/react-router-redux\" target=\"_blank\" rel=\"noopener\">react-router-redux</a></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install react-router-redux@next <span class=\"built_in\">history</span> --save</span><br></pre></td></tr></table></figure>\n<ol>\n<li>修改代码：<br><br><code>index.js</code>:</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ReactDom <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Container <span class=\"keyword\">from</span> <span class=\"string\">'./Main/Container.jsx'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; store, history &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./store.js'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> createHistory <span class=\"keyword\">from</span> <span class=\"string\">'history/createHashHistory'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; ConnectedRouter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-router-redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> history = createHistory();</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDom.render(</span><br><span class=\"line\">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">        &lt;ConnectedRouter history=&#123;history&#125;&gt;</span><br><span class=\"line\">            &lt;Container /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/ConnectedRouter&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>Provider&gt;</span><br><span class=\"line\">, <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>));</span><br></pre></td></tr></table></figure>\n<p>结合<code>history</code>,react-router一共有3中不同的router：</p>\n<ul>\n<li><a href=\"https://reacttraining.com/react-router/web/api/BrowserRouter\" target=\"_blank\" rel=\"noopener\">BrowserRouter</a>通过<code>history/createBrowserHistory</code>引入:当切换时，url会动态更新，底层使用的时html5的<a href=\"https://blog.csdn.net/tianyitianyi1/article/details/7426606\" target=\"_blank\" rel=\"noopener\">pushState</a>。</li>\n<li><a href=\"https://reacttraining.com/react-router/web/api/HashRouter\" target=\"_blank\" rel=\"noopener\">HashRouter</a>通过<code>history/createHashHistory</code>引入:当切换时，动态修改hash，利用hashchange事件。</li>\n<li><a href=\"https://reacttraining.com/react-router/web/api/MemoryRouter\" target=\"_blank\" rel=\"noopener\">MemoryRouter</a>通过<code>history/createMemoryHistory</code>引入:将路径，路由相关数据存入内存中，不涉及url相关更新，兼容性好。</li>\n</ul>\n<p>更多配置可以<a href=\"https://reacttraining.com/react-router/\" target=\"_blank\" rel=\"noopener\">参考这里</a></p>\n<ol>\n<li>如果想要在代码逻辑中获取当前的route路径需要引入<code>router-reducer</code>:<br><br>新建<code>main.js</code>:</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; combineReducers &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; routerReducer &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"react-router-redux\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> todoReducer <span class=\"keyword\">from</span> <span class=\"string\">'./todoReducer.js'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> reducers = combineReducers(&#123;</span><br><span class=\"line\">  todoReducer,</span><br><span class=\"line\">  router: routerReducer</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> reducers;</span><br></pre></td></tr></table></figure>\n<p>修改<code>store.js</code>:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> mainReducer <span class=\"keyword\">from</span> <span class=\"string\">'./reducers/main.js'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(mainReducer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> store;</span><br></pre></td></tr></table></figure>\n<p>然后就可以在<code>this.props.router</code>里面获取单相关的路径信息</p>\n<ol>\n<li>如果需要自己通过action来触发router的跳转，需要引入<code>routerMiddleware</code>:</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore,applyMiddleware &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; routerMiddleware &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"react-router-redux\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> middleware = routerMiddleware(history);</span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(mainReducer,applyMiddleware(middleware));</span><br></pre></td></tr></table></figure>\n<ol>\n<li>使用<code>Route</code>和<code>Link</code>和<code>withRouter</code>:<br><br>先说说都是干嘛的：<br></li>\n</ol>\n<ul>\n<li><a href=\"https://reacttraining.com/react-router/web/api/Route\" target=\"_blank\" rel=\"noopener\">Route</a>:component里面的内容即是tab的主要内容，这个从react-router4开始生效：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Route exact path=<span class=\"string\">\"/\"</span> component=&#123;Div1&#125;&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">Route</span>&gt;</span></span></span><br><span class=\"line\">&lt;Route path=<span class=\"string\">\"/2\"</span> component=&#123;Div2&#125;&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">Route</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"https://reacttraining.com/react-router/web/api/Link\" target=\"_blank\" rel=\"noopener\">Link</a>:通常也可以用<a href=\"https://reacttraining.com/react-router/web/api/NavLink\" target=\"_blank\" rel=\"noopener\">NavLink</a>，相当于tab按钮，控制router的切换,<code>activeClass</code>表示当前tab处于激活态时应用上的class。</li>\n<li><a href=\"https://reacttraining.com/react-router/web/api/withRouter\" target=\"_blank\" rel=\"noopener\">withRouter</a>:如果你用了redux，那么你一定要引入它。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> withRouter(connect(</span><br><span class=\"line\">    state =&gt; (&#123;</span><br><span class=\"line\">        todoList: state.todoReducer.todoList</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">)(Main));</span><br></pre></td></tr></table></figure>\n<p><em>如果你在使用hash时遇到<code>Warning: Hash history cannot PUSH the same path; a new entry will not be added to the history stack</code>错误，可以将push改为replace即</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;NavLink</span><br><span class=\"line\">    replace=&#123;<span class=\"literal\">true</span>&#125;</span><br><span class=\"line\">    to=<span class=\"string\">\"/2\"</span></span><br><span class=\"line\">    activeClassName=<span class=\"string\">\"selected\"</span></span><br><span class=\"line\">    &gt;切换到<span class=\"number\">2</span>号&lt;<span class=\"regexp\">/NavLink&gt;</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>设置初始化路由：</li>\n</ol>\n<ul>\n<li><code>BrowserRouter</code>和<code>HashRouter</code>:</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> history = createHistory();</span><br><span class=\"line\">history.push(<span class=\"string\">'2'</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>MemoryRouter</code>:</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> history = createMemoryHistory(&#123;</span><br><span class=\"line\">    initialEntries: [<span class=\"string\">'/2'</span>]</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用redux-thunk\"><a href=\"#使用redux-thunk\" class=\"headerlink\" title=\"使用redux-thunk\"></a>使用redux-thunk<div id=\"redux-thunk\"></div></h1><p><a href=\"https://www.npmjs.com/package/redux-thunk\" target=\"_blank\" rel=\"noopener\">redux-thunk</a> 是一个比较流行的 redux 异步 action 中间件，比如 action 中有 setTimeout 或者通过 fetch通用远程 API 这些场景，那么久应该使用 redux-thunk 了。redux-thunk 帮助你统一了异步和同步 action 的调用方式，把异步过程放在 action 级别解决，对 component 没有影响。</p>\n<ol>\n<li><p>安装<code>redux-thunk</code>:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install redux-thunk --save</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改<code>store.js</code>:</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore,applyMiddleware &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> thunk <span class=\"keyword\">from</span> <span class=\"string\">'redux-thunk'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> mainReducer <span class=\"keyword\">from</span> <span class=\"string\">'./reducers/main'</span>;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(mainReducer, applyMiddleware(thunk));</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> store;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>在<code>action.js</code>使用redux-thunk：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> getData = <span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> (dispatch, getState) =&gt; &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">    dispatch(&#123;</span><br><span class=\"line\">        type: GET_DATA,</span><br><span class=\"line\">        obj: obj</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,<span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用axios和async-await\"><a href=\"#使用axios和async-await\" class=\"headerlink\" title=\"使用axios和async/await\"></a>使用axios和async/await<div id=\"axios\"></div></h1><p><a href=\"https://github.com/axios/axios\" target=\"_blank\" rel=\"noopener\">axios</a> 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端：</p>\n<ul>\n<li>从浏览器中创建 XMLHttpRequest</li>\n<li>从 node.js 发出 http 请求</li>\n<li>支持 Promise API</li>\n<li>自动转换JSON数据</li>\n</ul>\n<ol>\n<li>安装axios:</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install axios --save</span><br></pre></td></tr></table></figure>\n<ol>\n<li>在action中使用axios：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">'axios'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> getData = <span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> (dispatch, getState) =&gt; &#123;</span><br><span class=\"line\">    axios.get(<span class=\"string\">'/json/comments.json'</span>).then(<span class=\"function\">(<span class=\"params\">resp</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        dispatch(&#123;</span><br><span class=\"line\">            type: GET_DATA,</span><br><span class=\"line\">            obj: resp</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function\" target=\"_blank\" rel=\"noopener\">async/await</a>：<br></p>\n<p>Javascript的回调地狱，相信很多人都知道，尤其是在node端，近些年比较流行的是<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\" target=\"_blank\" rel=\"noopener\">Promise</a>的解决方案，但是随着 Node 7 的发布，编程终级解决方案的 async/await应声而出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolveAfter2Seconds</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      resolve(<span class=\"string\">'resolved'</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncCall</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"keyword\">await</span> resolveAfter2Seconds();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">asyncCall();</span><br></pre></td></tr></table></figure>\n<p>async/await的用途是简化使用 promises 异步调用的操作，并对一组 Promises执行某些操作。await前提是方法返回的是一个Promise对象，正如Promises类似于结构化回调，async/await类似于组合生成器和 promises。<br></p>\n<ol>\n<li><code>async/await</code>需要安装<a href=\"https://www.npmjs.com/package/babel-plugin-transform-async-to-generator\" target=\"_blank\" rel=\"noopener\">babel-plugin-transform-async-to-generator</a>。</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install babel-plugin-transform-async-to-generator --save</span><br></pre></td></tr></table></figure>\n<ol>\n<li>在<code>.babelrc</code>中增加配置：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"plugins\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"transform-async-to-generator\"</span></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>这样做仅仅是将async转换generator，如果你当前的浏览器不支持generator，你将会收到一个<code>Uncaught ReferenceError: regeneratorRuntime is not defined</code>的错误，你需要：<br></p>\n<ol>\n<li>安装<a href=\"https://www.npmjs.com/package/babel-plugin-transform-runtime\" target=\"_blank\" rel=\"noopener\">babel-plugin-transform-runtime</a>:</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install babel-plugin-transform-async-to-generator --save</span><br></pre></td></tr></table></figure>\n<ol>\n<li>修改<code>.babelrc</code>中的配置(可以去掉之前配置的transform-async-to-generator)：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"plugins\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"transform-runtime\"</span></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<ol>\n<li>如果不想引入所有的polyfill(参考上面对babel的解释),可以增加配置：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"plugins\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"transform-runtime\"</span>,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">\"polyfill\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"string\">\"regenerator\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<ol>\n<li>结合axios使用：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">'axios'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> getData = <span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> <span class=\"keyword\">async</span> (dispatch, getState) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> resp = axios.get(<span class=\"string\">'/json/comments.json'</span>);</span><br><span class=\"line\">    dispatch(&#123;</span><br><span class=\"line\">        type: GET_DATA,</span><br><span class=\"line\">        obj: resp</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Code-Splitting\"><a href=\"#Code-Splitting\" class=\"headerlink\" title=\"Code Splitting\"></a>Code Splitting<div id=\"CodeSplitting\"></div></h1><ol>\n<li>对于webpack1，2之前，你可以使用<code>require.ensure</code>来控制一个组件的懒加载：<br></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>.ensure([], _require =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> Component = _require(<span class=\"string\">'./Component.jsx'</span>);</span><br><span class=\"line\">&#125;,<span class=\"string\">'lazyname'</span>)</span><br></pre></td></tr></table></figure>\n<ol>\n<li>在webpack4中，官方已经不再推荐使用<code>require.ensure</code>来使用懒加载功能<em>Dynamic Imports</em>，取而代之的是ES6的<code>import()</code>方法：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span>(</span><br><span class=\"line\">  <span class=\"comment\">/* webpackChunkName: \"my-chunk-name\" */</span></span><br><span class=\"line\">  <span class=\"comment\">/* webpackMode: \"lazy\" */</span></span><br><span class=\"line\">  <span class=\"string\">'module'</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>不小小看注释里的代码，webpack在打包时会动态识别这里的代码来做相关的配置，例如chunk name等等。</p>\n<ol>\n<li><a href=\"https://webpack.js.org/guides/code-splitting/#prefetching-preloading-modules\" target=\"_blank\" rel=\"noopener\">Prefetching/Preloading modules</a>:<br></li>\n</ol>\n<p>webpack 4.6.0+支持了Prefetching/Preloading的写法:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"keyword\">import</span>(<span class=\"comment\">/* webpackPreload: true */</span> <span class=\"string\">'ChartingLibrary'</span>);</span><br></pre></td></tr></table></figure>\n<ol>\n<li>结合React-Router使用:<br></li>\n</ol>\n<p><a href=\"https://www.npmjs.com/package/react-loadable\" target=\"_blank\" rel=\"noopener\">react-loadable</a>对上述的功能做了封装，丰富了一些功能，结合<code>React-Router</code>起来使用更加方便。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install react-loadable --save</span><br></pre></td></tr></table></figure>\n<p>在react-router里使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Loading</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Loading...<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> Div2 = Loadable(&#123;</span><br><span class=\"line\">  loader: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"string\">'./Div2'</span>), </span><br><span class=\"line\">  loading: Loading,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;Route path=<span class=\"string\">\"/2\"</span> component=&#123;Div2&#125;&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">Route</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<h1 id=\"使用CommonsChunkPlugin\"><a href=\"#使用CommonsChunkPlugin\" class=\"headerlink\" title=\"使用CommonsChunkPlugin\"></a>使用CommonsChunkPlugin</h1><p><code>CommonsChunkPlugin</code> 插件，是一个可选的用于建立一个独立文件(又称作 chunk)的功能，这个文件包括多个入口 chunk 的公共模块。通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存起来到缓存中供后续使用。<br></p>\n<ol>\n<li>在webpack4之前的用法：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">    name: <span class=\"string\">'common'</span>,</span><br><span class=\"line\">    chunks: [<span class=\"string\">'page1'</span>,<span class=\"string\">'page2'</span>],</span><br><span class=\"line\">    minChunks: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>name</code>: string: 提出出的名称</li>\n<li><code>chunks</code>: string[]: webpack会从传入的chunk里面提取公共代码,默认从所有entry里提取</li>\n<li><code>minChunks</code>: number|infinity|function(module,count)-&gt;boolean: 如果传入数字或infinity(默认值为3)，就是告诉webpack，只有当模块重复的次数大于等于该数字时，这个模块才会被提取出来。当传入为函数时，所有符合条件的chunk中的模块都会被传入该函数做计算，返回true的模块会被提取到目标chunk。<br>更多的参数配置，可以<a href=\"https://webpack.js.org/plugins/commons-chunk-plugin/#src/components/Sidebar/Sidebar.jsx\" target=\"_blank\" rel=\"noopener\">参考这里</a></li>\n</ul>\n<ol>\n<li>在webpack4之后的用法：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  optimization: &#123;</span><br><span class=\"line\">    splitChunks: &#123;</span><br><span class=\"line\">      chunks: <span class=\"string\">'async'</span>,</span><br><span class=\"line\">      minSize: <span class=\"number\">30000</span>,</span><br><span class=\"line\">      minChunks: <span class=\"number\">1</span>,</span><br><span class=\"line\">      maxAsyncRequests: <span class=\"number\">5</span>,</span><br><span class=\"line\">      maxInitialRequests: <span class=\"number\">3</span>,</span><br><span class=\"line\">      automaticNameDelimiter: <span class=\"string\">'~'</span>,</span><br><span class=\"line\">      name: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      cacheGroups: &#123;</span><br><span class=\"line\">        vendors: &#123;</span><br><span class=\"line\">          test: <span class=\"regexp\">/[\\\\/]node_modules[\\\\/]/</span>,</span><br><span class=\"line\">          priority: <span class=\"number\">-10</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"keyword\">default</span>: &#123;</span><br><span class=\"line\">          minChunks: <span class=\"number\">2</span>,</span><br><span class=\"line\">          priority: <span class=\"number\">-20</span>,</span><br><span class=\"line\">          reuseExistingChunk: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>splitChunks</code>: 配置一个分离chunk(代替老版本的CommonsChunkPlugin)</li>\n<li><code>cacheGroups</code>: 自定义配置主要使用它来决定生成的文件:</li>\n</ul>\n<ol>\n<li><code>test</code>: 限制范围</li>\n<li><code>name</code>: 生成文件名</li>\n<li><code>priority</code>: 优先级</li>\n</ol>\n<ul>\n<li><code>minSize</code>: number: 最小尺寸必须大于此值，默认30000B</li>\n<li><code>minChunks</code>: 其他entry引用次数大于此值，默认1</li>\n<li><code>maxInitialRequests</code>: entry文件请求的chunks不应该超过此值（请求过多，耗时）</li>\n<li><code>maxAsyncRequests</code>: 异步请求的chunks不应该超过此值</li>\n<li><code>automaticNameDelimiter</code>: 自动命名连接符</li>\n<li><code>chunks</code>: 值为”initial”, “async”（默认） 或 “all”:</li>\n</ul>\n<ol>\n<li><code>initial</code>: 入口chunk，对于异步导入的文件不处理</li>\n<li><code>async</code>: 异步chunk，只对异步导入的文件处理</li>\n<li><code>all</code>: 全部chunk</li>\n</ol>"},{"title":"移动web之滚动篇","date":"2017-04-18T03:21:55.000Z","_content":"<blockquote>在移动端，使用滚动来处理业务逻辑的情况有很多，例如列表的滚动加载数据，下拉刷新等等都需要利用滚动的相关知识，但是滚动事件在不同的移动端机型却又有不同的表现，下面就来一一总结一下。</blockquote>\n<!--more-->\n<h2 id=\"-1-web-\">知识点1:移动web滚动问题</h2>\n<ol>\n \t<li><strong>滚动事件</strong>：即onscroll事件，形成原因通俗解释是：当子元素的高度超过父元素的高度，并且且父元素的高度是定值（window除外），就会形成滚动条，滚动分为两种：局部滚动和body滚动。</li>\n \t<li><strong>onscroll方法</strong>： 一般情况下当我们需要监听一个滚动事件时通常会用到onscroll方法来监听滚动事件的触发。 如果在浏览器上调试这个方法在浏览器上很好用，但是如果跑在手机端就没有想象中的效果了。</li>\n \t<li><strong>body滚动</strong>：在移动端如果使用body滚动，意思就是页面的高度由内容自动撑大，body自然形成滚动条，这时我们监听window.onscroll，发现onscroll并没有实时触发，只在手指触摸的屏幕上一直滑动时和滚动停止的那一刻才触发,采用了wk内核的webview除外。\n<img style=\"magin:auto;\" src=\"https://qiniu.nihaoshijie.com.cn/QQ20170414-0@2x.png\" width=\"320\" /> body滚动\n<img src=\"https://qiniu.nihaoshijie.com.cn/QQ20170414-1@2x.png\" width=\"320\" />局部滚动</li>\n \t<li><strong>局部滚动</strong>：在移动端如果使用局部滚动，意思就是我们的滚动在一个固定宽高的div内触发，将该div设置成overflow:scroll/auto;来形成div内部的滚动，这时我们监听div的onscroll发现触发的时机区分android和ios两种情况，具体可以看下面表格：</li>\n \t<li><strong>不同机型onscroll事件触发情况：</strong>\n\n|         | body滚动       | 局部滚动  |\n| ------------- |:-------------:| -----:|\n| ios      | 不能实时触发 | 不能实时触发 |\n| android      | 实时触发      |   实时触发 |\n| ios wkwebview内核 | 实时触发      |    实时触发 |\n</li>\n \t<li><strong>wkwebview内核</strong>:这里说明一下关于ios的wkwebview内核是ios从ios8开始提供的新型webview内核，和之前的uiwebview相比，性能要好，具体大家可以自行查看关于wkwebview的相关概念。</li>\n \t<li><strong>body滚动和局部滚动demo</strong>：这里我需要指出的是在采用wkwebview内核的页面中scroll是可以实时触发的，如果使用的是原本的uiwebview则不能够实时触发，手q目前使用的是uiwebview而新版微信使用的是wkwebview，大家可以分别使用来尝试一下下面的demo：\n<img src=\"https://qiniu.nihaoshijie.com.cn/1492155048.png\" width=\"220\" />局部滚动\n<img src=\"https://qiniu.nihaoshijie.com.cn/1492155773.png\" width=\"220\" />body滚动\n分别用ios手q和微信和android手q体验会有不同的结果。</li>\n</ol>\n<h2 id=\"-2-\">知识点2:关于模拟滚动</h2>\n<ol>\n \t<li><strong>正常的滚动</strong>：我们平时使用的scroll，包括上面讲的滚动都属于正常滚动，利用浏览器自身提供的滚动条来实现滚动，底层是由浏览器内核控制。</li>\n \t<li><strong>模拟滚动</strong>：最典型的例子就是iscroll了，原理一般有两种：\n<strong>1). </strong>监听滚动元素的touchmove事件，当事件触发时修改元素的transform属性来实现元素的位移，让手指离开时触发touchend事件，然后采用requestanimationframe来在一个线型函数下不断的修改元素的transform来实现手指离开时的一段惯性滚动距离。\n<strong>2).</strong>监听滚动元素的touchmove事件，当事件触发时修改元素的transform属性来实现元素的位移，让手指离开时触发touchend事件，然后给元素一个css的animation，并设置好duration和function来实现手指离开时的一段惯性距离。</li>\n \t<li><strong>方案区别</strong>：这两种方案对比起来各有好处，第一种方案由于惯性滚动的时机时由js自己控制所以可以拿到滚动触发阶段的scrolltop值，并且滚动的回调函数onscroll在滚动的阶段都会触发。</li>\n \t<li>第二种方案相比第一种要劣势一些，区别在于手指离开时，采用的时css的animation来实现惯性滚动，所以无法直接触发惯性滚动过程中的onscroll事件，只有在animation结束时才可以借助animationend来获取到事件，当然也有一种方法可以实时获取滚动事件，也是借助于requestanimationframe来不断的去读取滚动元素的transform来拿到scrolltop同时触发onscroll回调。</li>\n \t<li><strong>demo体验</strong>：关于模拟滚动和正常滚动，两者在性能上差别还是比较明显的，下面时两个demo，可以扫描体验一下：\n<img src=\"https://qiniu.nihaoshijie.com.cn/1495680143.png\" width=\"220\" />正常滚动<img src=\"https://qiniu.nihaoshijie.com.cn/blog/1495679733.png\" width=\"220\" />模拟滚动\n<strong>衡量指标</strong>：衡量滚动是否流畅的指标fps，我这边也统计了一下正常滚动和模拟滚动的fps数据：\n<img src=\"https://qiniu.nihaoshijie.com.cn/normaltu.jpg\" />正常滚动\n<img src=\"https://qiniu.nihaoshijie.com.cn/iscrolltu.jpg\" />模拟滚动\n<strong>结论</strong>： 模拟滚动的fps值波动较大，这样滚动起来会有明显的卡顿感觉，各位体验的时候如果滚动超过10屏之后就可以明显感觉到两着的区别。\n在使用模拟滚动时，浏览器在js层面会消耗更多的性能去改变dom元素的位置，在dom复杂层级深的页面更为高，所以在长列表滚动时还要使用正常滚动更好。</li>\n</ol>\n<h2 id=\"-3-\">知识点3:滚动和下拉刷新</h2>\n<ol>\n \t<li>下拉刷新的元素在页面顶部，正常浏览时不可见的。</li>\n \t<li>当在页面顶部往下滚动时出现下拉刷新元素，当手指离开时收起。</li>\n \t<li>以上两点时实现一个下拉刷新组件的基本步骤，结合我们上述关于滚动的描述，我们可以这样实现下拉刷新：\n<img src=\"https://qiniu.nihaoshijie.com.cn/10AA2031-24A3-4858-BFA9-FF702231FB4C.png\" width=\"220\" />\n<strong>方案1</strong>：借助iscroll的原理，整个页面使用模拟滚动，将下拉刷新元素放在顶部，当页面滚动到顶部下拉时，下拉刷新元素随着页面的滚动出现，当手指离开时收回，此方案实现起来较为简单直接借助iscoll即可，但是使用了模拟滚动之后在正常的列表滚动时性能上不如正常滚动。\n<strong>方案2</strong>：页面使用正常滚动，将下拉刷新元素放置在顶部top值为负值（正常情况下不可见），当页面处于顶部时下拉，这时监听touchmove事件，修改scrollcontent的tranlateY值，同时修改下拉刷新元素的tranlateY值，将两者同时位移来将下拉刷新元素显示出来，手指离开时（touchend）收回，这种方案满足了在正常列表滚动时使用原生的滚动节省性能，只在下拉刷新时使用模拟滚动来实现效果。\n<strong>方案3</strong>：方案2的改良版，唯一不同是将下拉刷新元素和scrollcontent放在一个div里，将下拉刷新元素的margintop设为负值，在下拉刷新时，只需要修改scrollcontent一个元素的tranlateY值即可实现下拉，在性能上要比方案2好。\n<img src=\"https://qiniu.nihaoshijie.com.cn/pullrefresh3.gif\" width=\"220\" /></li>\n \t<li><strong>性能问题</strong>：在采用了上述方案之后，还会有一个性能上的问题就是：当页面的列表过长，dom元素过多时，在模拟滚动，下拉刷新这段时间内，页面也会有卡顿现象，这里采取了一个</li>\n \t<li><strong>优化策略</strong>：\n1) 列表较长时dom数量较多时，在触发下拉刷新的时机时将页面视窗之外的dom元素<strong>隐藏</strong>或者存放在fragment里面。\n2) 在刷新完成之后手指离开（touchend）时将隐藏的元素显示出来。\n3) 需要注意的是，隐藏和显示视窗外的元素这个操作在下拉刷新时只会<strong>执行一次</strong>，并且只有在下拉刷新时才会执行。</li>\n</ol>\n<h1 id=\"alloypullrefresh\">AlloyPullRefresh（基于上述知识点开发的组件）</h1>\n<ol>\n \t<li>定义下拉刷新元素样式</li>\n \t<li>下拉刷新事件回调</li>\n \t<li>支持zepto版本和react版本</li>\n</ol>\ngithub地址：<a href=\"https://github.com/AlloyTeam/AlloyPullRefresh/\">https://github.com/AlloyTeam/AlloyPullRefresh/</a>","source":"_posts/移动web之滚动篇.md","raw":"---\ntitle: 移动web之滚动篇\ndate: 2017-04-18 11:21:55\ntags:\n- 移动web\n- 滚动\ncategories:\n- 690\n\n---\n<blockquote>在移动端，使用滚动来处理业务逻辑的情况有很多，例如列表的滚动加载数据，下拉刷新等等都需要利用滚动的相关知识，但是滚动事件在不同的移动端机型却又有不同的表现，下面就来一一总结一下。</blockquote>\n<!--more-->\n<h2 id=\"-1-web-\">知识点1:移动web滚动问题</h2>\n<ol>\n \t<li><strong>滚动事件</strong>：即onscroll事件，形成原因通俗解释是：当子元素的高度超过父元素的高度，并且且父元素的高度是定值（window除外），就会形成滚动条，滚动分为两种：局部滚动和body滚动。</li>\n \t<li><strong>onscroll方法</strong>： 一般情况下当我们需要监听一个滚动事件时通常会用到onscroll方法来监听滚动事件的触发。 如果在浏览器上调试这个方法在浏览器上很好用，但是如果跑在手机端就没有想象中的效果了。</li>\n \t<li><strong>body滚动</strong>：在移动端如果使用body滚动，意思就是页面的高度由内容自动撑大，body自然形成滚动条，这时我们监听window.onscroll，发现onscroll并没有实时触发，只在手指触摸的屏幕上一直滑动时和滚动停止的那一刻才触发,采用了wk内核的webview除外。\n<img style=\"magin:auto;\" src=\"https://qiniu.nihaoshijie.com.cn/QQ20170414-0@2x.png\" width=\"320\" /> body滚动\n<img src=\"https://qiniu.nihaoshijie.com.cn/QQ20170414-1@2x.png\" width=\"320\" />局部滚动</li>\n \t<li><strong>局部滚动</strong>：在移动端如果使用局部滚动，意思就是我们的滚动在一个固定宽高的div内触发，将该div设置成overflow:scroll/auto;来形成div内部的滚动，这时我们监听div的onscroll发现触发的时机区分android和ios两种情况，具体可以看下面表格：</li>\n \t<li><strong>不同机型onscroll事件触发情况：</strong>\n\n|         | body滚动       | 局部滚动  |\n| ------------- |:-------------:| -----:|\n| ios      | 不能实时触发 | 不能实时触发 |\n| android      | 实时触发      |   实时触发 |\n| ios wkwebview内核 | 实时触发      |    实时触发 |\n</li>\n \t<li><strong>wkwebview内核</strong>:这里说明一下关于ios的wkwebview内核是ios从ios8开始提供的新型webview内核，和之前的uiwebview相比，性能要好，具体大家可以自行查看关于wkwebview的相关概念。</li>\n \t<li><strong>body滚动和局部滚动demo</strong>：这里我需要指出的是在采用wkwebview内核的页面中scroll是可以实时触发的，如果使用的是原本的uiwebview则不能够实时触发，手q目前使用的是uiwebview而新版微信使用的是wkwebview，大家可以分别使用来尝试一下下面的demo：\n<img src=\"https://qiniu.nihaoshijie.com.cn/1492155048.png\" width=\"220\" />局部滚动\n<img src=\"https://qiniu.nihaoshijie.com.cn/1492155773.png\" width=\"220\" />body滚动\n分别用ios手q和微信和android手q体验会有不同的结果。</li>\n</ol>\n<h2 id=\"-2-\">知识点2:关于模拟滚动</h2>\n<ol>\n \t<li><strong>正常的滚动</strong>：我们平时使用的scroll，包括上面讲的滚动都属于正常滚动，利用浏览器自身提供的滚动条来实现滚动，底层是由浏览器内核控制。</li>\n \t<li><strong>模拟滚动</strong>：最典型的例子就是iscroll了，原理一般有两种：\n<strong>1). </strong>监听滚动元素的touchmove事件，当事件触发时修改元素的transform属性来实现元素的位移，让手指离开时触发touchend事件，然后采用requestanimationframe来在一个线型函数下不断的修改元素的transform来实现手指离开时的一段惯性滚动距离。\n<strong>2).</strong>监听滚动元素的touchmove事件，当事件触发时修改元素的transform属性来实现元素的位移，让手指离开时触发touchend事件，然后给元素一个css的animation，并设置好duration和function来实现手指离开时的一段惯性距离。</li>\n \t<li><strong>方案区别</strong>：这两种方案对比起来各有好处，第一种方案由于惯性滚动的时机时由js自己控制所以可以拿到滚动触发阶段的scrolltop值，并且滚动的回调函数onscroll在滚动的阶段都会触发。</li>\n \t<li>第二种方案相比第一种要劣势一些，区别在于手指离开时，采用的时css的animation来实现惯性滚动，所以无法直接触发惯性滚动过程中的onscroll事件，只有在animation结束时才可以借助animationend来获取到事件，当然也有一种方法可以实时获取滚动事件，也是借助于requestanimationframe来不断的去读取滚动元素的transform来拿到scrolltop同时触发onscroll回调。</li>\n \t<li><strong>demo体验</strong>：关于模拟滚动和正常滚动，两者在性能上差别还是比较明显的，下面时两个demo，可以扫描体验一下：\n<img src=\"https://qiniu.nihaoshijie.com.cn/1495680143.png\" width=\"220\" />正常滚动<img src=\"https://qiniu.nihaoshijie.com.cn/blog/1495679733.png\" width=\"220\" />模拟滚动\n<strong>衡量指标</strong>：衡量滚动是否流畅的指标fps，我这边也统计了一下正常滚动和模拟滚动的fps数据：\n<img src=\"https://qiniu.nihaoshijie.com.cn/normaltu.jpg\" />正常滚动\n<img src=\"https://qiniu.nihaoshijie.com.cn/iscrolltu.jpg\" />模拟滚动\n<strong>结论</strong>： 模拟滚动的fps值波动较大，这样滚动起来会有明显的卡顿感觉，各位体验的时候如果滚动超过10屏之后就可以明显感觉到两着的区别。\n在使用模拟滚动时，浏览器在js层面会消耗更多的性能去改变dom元素的位置，在dom复杂层级深的页面更为高，所以在长列表滚动时还要使用正常滚动更好。</li>\n</ol>\n<h2 id=\"-3-\">知识点3:滚动和下拉刷新</h2>\n<ol>\n \t<li>下拉刷新的元素在页面顶部，正常浏览时不可见的。</li>\n \t<li>当在页面顶部往下滚动时出现下拉刷新元素，当手指离开时收起。</li>\n \t<li>以上两点时实现一个下拉刷新组件的基本步骤，结合我们上述关于滚动的描述，我们可以这样实现下拉刷新：\n<img src=\"https://qiniu.nihaoshijie.com.cn/10AA2031-24A3-4858-BFA9-FF702231FB4C.png\" width=\"220\" />\n<strong>方案1</strong>：借助iscroll的原理，整个页面使用模拟滚动，将下拉刷新元素放在顶部，当页面滚动到顶部下拉时，下拉刷新元素随着页面的滚动出现，当手指离开时收回，此方案实现起来较为简单直接借助iscoll即可，但是使用了模拟滚动之后在正常的列表滚动时性能上不如正常滚动。\n<strong>方案2</strong>：页面使用正常滚动，将下拉刷新元素放置在顶部top值为负值（正常情况下不可见），当页面处于顶部时下拉，这时监听touchmove事件，修改scrollcontent的tranlateY值，同时修改下拉刷新元素的tranlateY值，将两者同时位移来将下拉刷新元素显示出来，手指离开时（touchend）收回，这种方案满足了在正常列表滚动时使用原生的滚动节省性能，只在下拉刷新时使用模拟滚动来实现效果。\n<strong>方案3</strong>：方案2的改良版，唯一不同是将下拉刷新元素和scrollcontent放在一个div里，将下拉刷新元素的margintop设为负值，在下拉刷新时，只需要修改scrollcontent一个元素的tranlateY值即可实现下拉，在性能上要比方案2好。\n<img src=\"https://qiniu.nihaoshijie.com.cn/pullrefresh3.gif\" width=\"220\" /></li>\n \t<li><strong>性能问题</strong>：在采用了上述方案之后，还会有一个性能上的问题就是：当页面的列表过长，dom元素过多时，在模拟滚动，下拉刷新这段时间内，页面也会有卡顿现象，这里采取了一个</li>\n \t<li><strong>优化策略</strong>：\n1) 列表较长时dom数量较多时，在触发下拉刷新的时机时将页面视窗之外的dom元素<strong>隐藏</strong>或者存放在fragment里面。\n2) 在刷新完成之后手指离开（touchend）时将隐藏的元素显示出来。\n3) 需要注意的是，隐藏和显示视窗外的元素这个操作在下拉刷新时只会<strong>执行一次</strong>，并且只有在下拉刷新时才会执行。</li>\n</ol>\n<h1 id=\"alloypullrefresh\">AlloyPullRefresh（基于上述知识点开发的组件）</h1>\n<ol>\n \t<li>定义下拉刷新元素样式</li>\n \t<li>下拉刷新事件回调</li>\n \t<li>支持zepto版本和react版本</li>\n</ol>\ngithub地址：<a href=\"https://github.com/AlloyTeam/AlloyPullRefresh/\">https://github.com/AlloyTeam/AlloyPullRefresh/</a>","slug":"移动web之滚动篇","published":1,"updated":"2019-04-02T16:49:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434q1g003j2wvjw2f37bm8","content":"<p><blockquote>在移动端，使用滚动来处理业务逻辑的情况有很多，例如列表的滚动加载数据，下拉刷新等等都需要利用滚动的相关知识，但是滚动事件在不同的移动端机型却又有不同的表现，下面就来一一总结一下。</blockquote><br><a id=\"more\"></a></p>\n<p></p><h2><span id=\"知识点1移动web滚动问题\">知识点1:移动web滚动问题</span></h2><p></p>\n<p><ol><br>     <li><strong>滚动事件</strong>：即onscroll事件，形成原因通俗解释是：当子元素的高度超过父元素的高度，并且且父元素的高度是定值（window除外），就会形成滚动条，滚动分为两种：局部滚动和body滚动。</li><br>     <li><strong>onscroll方法</strong>： 一般情况下当我们需要监听一个滚动事件时通常会用到onscroll方法来监听滚动事件的触发。 如果在浏览器上调试这个方法在浏览器上很好用，但是如果跑在手机端就没有想象中的效果了。</li><br>     <li><strong>body滚动</strong>：在移动端如果使用body滚动，意思就是页面的高度由内容自动撑大，body自然形成滚动条，这时我们监听window.onscroll，发现onscroll并没有实时触发，只在手指触摸的屏幕上一直滑动时和滚动停止的那一刻才触发,采用了wk内核的webview除外。<br><img style=\"magin:auto;\" src=\"https://qiniu.nihaoshijie.com.cn/QQ20170414-0@2x.png\" width=\"320\"> body滚动<br><img src=\"https://qiniu.nihaoshijie.com.cn/QQ20170414-1@2x.png\" width=\"320\">局部滚动</li><br>     <li><strong>局部滚动</strong>：在移动端如果使用局部滚动，意思就是我们的滚动在一个固定宽高的div内触发，将该div设置成overflow:scroll/auto;来形成div内部的滚动，这时我们监听div的onscroll发现触发的时机区分android和ios两种情况，具体可以看下面表格：</li><br>     <li><strong>不同机型onscroll事件触发情况：</strong></li></ol></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th style=\"text-align:center\">body滚动</th>\n<th style=\"text-align:right\">局部滚动</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ios</td>\n<td style=\"text-align:center\">不能实时触发</td>\n<td style=\"text-align:right\">不能实时触发</td>\n</tr>\n<tr>\n<td>android</td>\n<td style=\"text-align:center\">实时触发</td>\n<td style=\"text-align:right\">实时触发</td>\n</tr>\n<tr>\n<td>ios wkwebview内核</td>\n<td style=\"text-align:center\">实时触发</td>\n<td style=\"text-align:right\">实时触发</td>\n</tr>\n</tbody>\n</table>\n<p><br>     <li><strong>wkwebview内核</strong>:这里说明一下关于ios的wkwebview内核是ios从ios8开始提供的新型webview内核，和之前的uiwebview相比，性能要好，具体大家可以自行查看关于wkwebview的相关概念。</li><br>     <li><strong>body滚动和局部滚动demo</strong>：这里我需要指出的是在采用wkwebview内核的页面中scroll是可以实时触发的，如果使用的是原本的uiwebview则不能够实时触发，手q目前使用的是uiwebview而新版微信使用的是wkwebview，大家可以分别使用来尝试一下下面的demo：<br><img src=\"https://qiniu.nihaoshijie.com.cn/1492155048.png\" width=\"220\">局部滚动<br><img src=\"https://qiniu.nihaoshijie.com.cn/1492155773.png\" width=\"220\">body滚动<br>分别用ios手q和微信和android手q体验会有不同的结果。</li><br></p>\n<p></p><h2><span id=\"知识点2关于模拟滚动\">知识点2:关于模拟滚动</span></h2><p></p>\n<p><ol><br>     <li><strong>正常的滚动</strong>：我们平时使用的scroll，包括上面讲的滚动都属于正常滚动，利用浏览器自身提供的滚动条来实现滚动，底层是由浏览器内核控制。</li><br>     <li><strong>模拟滚动</strong>：最典型的例子就是iscroll了，原理一般有两种：<br><strong>1). </strong>监听滚动元素的touchmove事件，当事件触发时修改元素的transform属性来实现元素的位移，让手指离开时触发touchend事件，然后采用requestanimationframe来在一个线型函数下不断的修改元素的transform来实现手指离开时的一段惯性滚动距离。<br><strong>2).</strong>监听滚动元素的touchmove事件，当事件触发时修改元素的transform属性来实现元素的位移，让手指离开时触发touchend事件，然后给元素一个css的animation，并设置好duration和function来实现手指离开时的一段惯性距离。</li><br>     <li><strong>方案区别</strong>：这两种方案对比起来各有好处，第一种方案由于惯性滚动的时机时由js自己控制所以可以拿到滚动触发阶段的scrolltop值，并且滚动的回调函数onscroll在滚动的阶段都会触发。</li><br>     <li>第二种方案相比第一种要劣势一些，区别在于手指离开时，采用的时css的animation来实现惯性滚动，所以无法直接触发惯性滚动过程中的onscroll事件，只有在animation结束时才可以借助animationend来获取到事件，当然也有一种方法可以实时获取滚动事件，也是借助于requestanimationframe来不断的去读取滚动元素的transform来拿到scrolltop同时触发onscroll回调。</li><br>     <li><strong>demo体验</strong>：关于模拟滚动和正常滚动，两者在性能上差别还是比较明显的，下面时两个demo，可以扫描体验一下：<br><img src=\"https://qiniu.nihaoshijie.com.cn/1495680143.png\" width=\"220\">正常滚动<img src=\"https://qiniu.nihaoshijie.com.cn/blog/1495679733.png\" width=\"220\">模拟滚动<br><strong>衡量指标</strong>：衡量滚动是否流畅的指标fps，我这边也统计了一下正常滚动和模拟滚动的fps数据：<br><img src=\"https://qiniu.nihaoshijie.com.cn/normaltu.jpg\">正常滚动<br><img src=\"https://qiniu.nihaoshijie.com.cn/iscrolltu.jpg\">模拟滚动<br><strong>结论</strong>： 模拟滚动的fps值波动较大，这样滚动起来会有明显的卡顿感觉，各位体验的时候如果滚动超过10屏之后就可以明显感觉到两着的区别。<br>在使用模拟滚动时，浏览器在js层面会消耗更多的性能去改变dom元素的位置，在dom复杂层级深的页面更为高，所以在长列表滚动时还要使用正常滚动更好。</li><br></ol></p>\n<p></p><h2><span id=\"知识点3滚动和下拉刷新\">知识点3:滚动和下拉刷新</span></h2><p></p>\n<p><ol><br>     <li>下拉刷新的元素在页面顶部，正常浏览时不可见的。</li><br>     <li>当在页面顶部往下滚动时出现下拉刷新元素，当手指离开时收起。</li><br>     <li>以上两点时实现一个下拉刷新组件的基本步骤，结合我们上述关于滚动的描述，我们可以这样实现下拉刷新：<br><img src=\"https://qiniu.nihaoshijie.com.cn/10AA2031-24A3-4858-BFA9-FF702231FB4C.png\" width=\"220\"><br><strong>方案1</strong>：借助iscroll的原理，整个页面使用模拟滚动，将下拉刷新元素放在顶部，当页面滚动到顶部下拉时，下拉刷新元素随着页面的滚动出现，当手指离开时收回，此方案实现起来较为简单直接借助iscoll即可，但是使用了模拟滚动之后在正常的列表滚动时性能上不如正常滚动。<br><strong>方案2</strong>：页面使用正常滚动，将下拉刷新元素放置在顶部top值为负值（正常情况下不可见），当页面处于顶部时下拉，这时监听touchmove事件，修改scrollcontent的tranlateY值，同时修改下拉刷新元素的tranlateY值，将两者同时位移来将下拉刷新元素显示出来，手指离开时（touchend）收回，这种方案满足了在正常列表滚动时使用原生的滚动节省性能，只在下拉刷新时使用模拟滚动来实现效果。<br><strong>方案3</strong>：方案2的改良版，唯一不同是将下拉刷新元素和scrollcontent放在一个div里，将下拉刷新元素的margintop设为负值，在下拉刷新时，只需要修改scrollcontent一个元素的tranlateY值即可实现下拉，在性能上要比方案2好。<br><img src=\"https://qiniu.nihaoshijie.com.cn/pullrefresh3.gif\" width=\"220\"></li><br>     <li><strong>性能问题</strong>：在采用了上述方案之后，还会有一个性能上的问题就是：当页面的列表过长，dom元素过多时，在模拟滚动，下拉刷新这段时间内，页面也会有卡顿现象，这里采取了一个</li><br>     <li><strong>优化策略</strong>：<br>1) 列表较长时dom数量较多时，在触发下拉刷新的时机时将页面视窗之外的dom元素<strong>隐藏</strong>或者存放在fragment里面。<br>2) 在刷新完成之后手指离开（touchend）时将隐藏的元素显示出来。<br>3) 需要注意的是，隐藏和显示视窗外的元素这个操作在下拉刷新时只会<strong>执行一次</strong>，并且只有在下拉刷新时才会执行。</li><br></ol></p>\n<p></p><h1><span id=\"alloypullrefresh基于上述知识点开发的组件\">AlloyPullRefresh（基于上述知识点开发的组件）</span></h1><p></p>\n<p><ol><br>     <li>定义下拉刷新元素样式</li><br>     <li>下拉刷新事件回调</li><br>     <li>支持zepto版本和react版本</li><br></ol><br>github地址：<a href=\"https://github.com/AlloyTeam/AlloyPullRefresh/\" target=\"_blank\" rel=\"noopener\">https://github.com/AlloyTeam/AlloyPullRefresh/</a></p>\n","site":{"data":{}},"excerpt":"<p><blockquote>在移动端，使用滚动来处理业务逻辑的情况有很多，例如列表的滚动加载数据，下拉刷新等等都需要利用滚动的相关知识，但是滚动事件在不同的移动端机型却又有不同的表现，下面就来一一总结一下。</blockquote><br>","more":"</p>\n<p></p><h2 id=\"-1-web-\">知识点1:移动web滚动问题</h2><p></p>\n<p><ol><br>     <li><strong>滚动事件</strong>：即onscroll事件，形成原因通俗解释是：当子元素的高度超过父元素的高度，并且且父元素的高度是定值（window除外），就会形成滚动条，滚动分为两种：局部滚动和body滚动。</li><br>     <li><strong>onscroll方法</strong>： 一般情况下当我们需要监听一个滚动事件时通常会用到onscroll方法来监听滚动事件的触发。 如果在浏览器上调试这个方法在浏览器上很好用，但是如果跑在手机端就没有想象中的效果了。</li><br>     <li><strong>body滚动</strong>：在移动端如果使用body滚动，意思就是页面的高度由内容自动撑大，body自然形成滚动条，这时我们监听window.onscroll，发现onscroll并没有实时触发，只在手指触摸的屏幕上一直滑动时和滚动停止的那一刻才触发,采用了wk内核的webview除外。<br><img style=\"magin:auto;\" src=\"https://qiniu.nihaoshijie.com.cn/QQ20170414-0@2x.png\" width=\"320\"> body滚动<br><img src=\"https://qiniu.nihaoshijie.com.cn/QQ20170414-1@2x.png\" width=\"320\">局部滚动</li><br>     <li><strong>局部滚动</strong>：在移动端如果使用局部滚动，意思就是我们的滚动在一个固定宽高的div内触发，将该div设置成overflow:scroll/auto;来形成div内部的滚动，这时我们监听div的onscroll发现触发的时机区分android和ios两种情况，具体可以看下面表格：</li><br>     <li><strong>不同机型onscroll事件触发情况：</strong></li></ol></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th style=\"text-align:center\">body滚动</th>\n<th style=\"text-align:right\">局部滚动</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ios</td>\n<td style=\"text-align:center\">不能实时触发</td>\n<td style=\"text-align:right\">不能实时触发</td>\n</tr>\n<tr>\n<td>android</td>\n<td style=\"text-align:center\">实时触发</td>\n<td style=\"text-align:right\">实时触发</td>\n</tr>\n<tr>\n<td>ios wkwebview内核</td>\n<td style=\"text-align:center\">实时触发</td>\n<td style=\"text-align:right\">实时触发</td>\n</tr>\n</tbody>\n</table>\n<p><br>     <li><strong>wkwebview内核</strong>:这里说明一下关于ios的wkwebview内核是ios从ios8开始提供的新型webview内核，和之前的uiwebview相比，性能要好，具体大家可以自行查看关于wkwebview的相关概念。</li><br>     <li><strong>body滚动和局部滚动demo</strong>：这里我需要指出的是在采用wkwebview内核的页面中scroll是可以实时触发的，如果使用的是原本的uiwebview则不能够实时触发，手q目前使用的是uiwebview而新版微信使用的是wkwebview，大家可以分别使用来尝试一下下面的demo：<br><img src=\"https://qiniu.nihaoshijie.com.cn/1492155048.png\" width=\"220\">局部滚动<br><img src=\"https://qiniu.nihaoshijie.com.cn/1492155773.png\" width=\"220\">body滚动<br>分别用ios手q和微信和android手q体验会有不同的结果。</li><br></p>\n<p></p><h2 id=\"-2-\">知识点2:关于模拟滚动</h2><p></p>\n<p><ol><br>     <li><strong>正常的滚动</strong>：我们平时使用的scroll，包括上面讲的滚动都属于正常滚动，利用浏览器自身提供的滚动条来实现滚动，底层是由浏览器内核控制。</li><br>     <li><strong>模拟滚动</strong>：最典型的例子就是iscroll了，原理一般有两种：<br><strong>1). </strong>监听滚动元素的touchmove事件，当事件触发时修改元素的transform属性来实现元素的位移，让手指离开时触发touchend事件，然后采用requestanimationframe来在一个线型函数下不断的修改元素的transform来实现手指离开时的一段惯性滚动距离。<br><strong>2).</strong>监听滚动元素的touchmove事件，当事件触发时修改元素的transform属性来实现元素的位移，让手指离开时触发touchend事件，然后给元素一个css的animation，并设置好duration和function来实现手指离开时的一段惯性距离。</li><br>     <li><strong>方案区别</strong>：这两种方案对比起来各有好处，第一种方案由于惯性滚动的时机时由js自己控制所以可以拿到滚动触发阶段的scrolltop值，并且滚动的回调函数onscroll在滚动的阶段都会触发。</li><br>     <li>第二种方案相比第一种要劣势一些，区别在于手指离开时，采用的时css的animation来实现惯性滚动，所以无法直接触发惯性滚动过程中的onscroll事件，只有在animation结束时才可以借助animationend来获取到事件，当然也有一种方法可以实时获取滚动事件，也是借助于requestanimationframe来不断的去读取滚动元素的transform来拿到scrolltop同时触发onscroll回调。</li><br>     <li><strong>demo体验</strong>：关于模拟滚动和正常滚动，两者在性能上差别还是比较明显的，下面时两个demo，可以扫描体验一下：<br><img src=\"https://qiniu.nihaoshijie.com.cn/1495680143.png\" width=\"220\">正常滚动<img src=\"https://qiniu.nihaoshijie.com.cn/blog/1495679733.png\" width=\"220\">模拟滚动<br><strong>衡量指标</strong>：衡量滚动是否流畅的指标fps，我这边也统计了一下正常滚动和模拟滚动的fps数据：<br><img src=\"https://qiniu.nihaoshijie.com.cn/normaltu.jpg\">正常滚动<br><img src=\"https://qiniu.nihaoshijie.com.cn/iscrolltu.jpg\">模拟滚动<br><strong>结论</strong>： 模拟滚动的fps值波动较大，这样滚动起来会有明显的卡顿感觉，各位体验的时候如果滚动超过10屏之后就可以明显感觉到两着的区别。<br>在使用模拟滚动时，浏览器在js层面会消耗更多的性能去改变dom元素的位置，在dom复杂层级深的页面更为高，所以在长列表滚动时还要使用正常滚动更好。</li><br></ol></p>\n<p></p><h2 id=\"-3-\">知识点3:滚动和下拉刷新</h2><p></p>\n<p><ol><br>     <li>下拉刷新的元素在页面顶部，正常浏览时不可见的。</li><br>     <li>当在页面顶部往下滚动时出现下拉刷新元素，当手指离开时收起。</li><br>     <li>以上两点时实现一个下拉刷新组件的基本步骤，结合我们上述关于滚动的描述，我们可以这样实现下拉刷新：<br><img src=\"https://qiniu.nihaoshijie.com.cn/10AA2031-24A3-4858-BFA9-FF702231FB4C.png\" width=\"220\"><br><strong>方案1</strong>：借助iscroll的原理，整个页面使用模拟滚动，将下拉刷新元素放在顶部，当页面滚动到顶部下拉时，下拉刷新元素随着页面的滚动出现，当手指离开时收回，此方案实现起来较为简单直接借助iscoll即可，但是使用了模拟滚动之后在正常的列表滚动时性能上不如正常滚动。<br><strong>方案2</strong>：页面使用正常滚动，将下拉刷新元素放置在顶部top值为负值（正常情况下不可见），当页面处于顶部时下拉，这时监听touchmove事件，修改scrollcontent的tranlateY值，同时修改下拉刷新元素的tranlateY值，将两者同时位移来将下拉刷新元素显示出来，手指离开时（touchend）收回，这种方案满足了在正常列表滚动时使用原生的滚动节省性能，只在下拉刷新时使用模拟滚动来实现效果。<br><strong>方案3</strong>：方案2的改良版，唯一不同是将下拉刷新元素和scrollcontent放在一个div里，将下拉刷新元素的margintop设为负值，在下拉刷新时，只需要修改scrollcontent一个元素的tranlateY值即可实现下拉，在性能上要比方案2好。<br><img src=\"https://qiniu.nihaoshijie.com.cn/pullrefresh3.gif\" width=\"220\"></li><br>     <li><strong>性能问题</strong>：在采用了上述方案之后，还会有一个性能上的问题就是：当页面的列表过长，dom元素过多时，在模拟滚动，下拉刷新这段时间内，页面也会有卡顿现象，这里采取了一个</li><br>     <li><strong>优化策略</strong>：<br>1) 列表较长时dom数量较多时，在触发下拉刷新的时机时将页面视窗之外的dom元素<strong>隐藏</strong>或者存放在fragment里面。<br>2) 在刷新完成之后手指离开（touchend）时将隐藏的元素显示出来。<br>3) 需要注意的是，隐藏和显示视窗外的元素这个操作在下拉刷新时只会<strong>执行一次</strong>，并且只有在下拉刷新时才会执行。</li><br></ol></p>\n<p></p><h1 id=\"alloypullrefresh\">AlloyPullRefresh（基于上述知识点开发的组件）</h1><p></p>\n<p><ol><br>     <li>定义下拉刷新元素样式</li><br>     <li>下拉刷新事件回调</li><br>     <li>支持zepto版本和react版本</li><br></ol><br>github地址：<a href=\"https://github.com/AlloyTeam/AlloyPullRefresh/\" target=\"_blank\" rel=\"noopener\">https://github.com/AlloyTeam/AlloyPullRefresh/</a></p>"},{"title":"移动web开发实战课程","date":"2018-07-09T15:00:13.000Z","top":35,"_content":"\n### 历时半年打造的慕课网移动web实战课程\n\n![](https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-05%2021.07.05.png)\n\n### 课程介绍\n\n* 本课程带领大家一步步开发及结合Hybrid将美团外卖实战项目打造成完整的移动Web APP，理解并掌握移动Web开发的基本技能。\n* 开发过程中也会讲解到移动web的技巧和遇到问题时解决方法和针对不同场景技术的选型。从而提升对移动端适配以及React 全家桶和组件化开发实战技能。\n* 本课程还覆盖了工作中常见移动Web开发问题，并且可以通过课程学习找到对应的技术解决方案。\n\n[课程链接](https://coding.imooc.com/class/272.html?mc_marking=d1fd61f18d73135fd74382c68a85e10e&mc_channel=syb18)\n\n#### 想要学习移动web的同学不妨试试！","source":"_posts/移动web开发实战课程.md","raw":"---\ntitle: 移动web开发实战课程\ndate: 2018-07-09 23:00:13\ntags:\n- 移动web\n- React全家桶\ncategories:\n- 888\n\ntop: 35\n---\n\n### 历时半年打造的慕课网移动web实战课程\n\n![](https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-05%2021.07.05.png)\n\n### 课程介绍\n\n* 本课程带领大家一步步开发及结合Hybrid将美团外卖实战项目打造成完整的移动Web APP，理解并掌握移动Web开发的基本技能。\n* 开发过程中也会讲解到移动web的技巧和遇到问题时解决方法和针对不同场景技术的选型。从而提升对移动端适配以及React 全家桶和组件化开发实战技能。\n* 本课程还覆盖了工作中常见移动Web开发问题，并且可以通过课程学习找到对应的技术解决方案。\n\n[课程链接](https://coding.imooc.com/class/272.html?mc_marking=d1fd61f18d73135fd74382c68a85e10e&mc_channel=syb18)\n\n#### 想要学习移动web的同学不妨试试！","slug":"移动web开发实战课程","published":1,"updated":"2019-04-02T16:49:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434q1i003m2wvjnvyc7wuc","content":"<h3><span id=\"历时半年打造的慕课网移动web实战课程\">历时半年打造的慕课网移动web实战课程</span></h3><p><img src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-05%2021.07.05.png\" alt></p>\n<h3><span id=\"课程介绍\">课程介绍</span></h3><ul>\n<li>本课程带领大家一步步开发及结合Hybrid将美团外卖实战项目打造成完整的移动Web APP，理解并掌握移动Web开发的基本技能。</li>\n<li>开发过程中也会讲解到移动web的技巧和遇到问题时解决方法和针对不同场景技术的选型。从而提升对移动端适配以及React 全家桶和组件化开发实战技能。</li>\n<li>本课程还覆盖了工作中常见移动Web开发问题，并且可以通过课程学习找到对应的技术解决方案。</li>\n</ul>\n<p><a href=\"https://coding.imooc.com/class/272.html?mc_marking=d1fd61f18d73135fd74382c68a85e10e&amp;mc_channel=syb18\" target=\"_blank\" rel=\"noopener\">课程链接</a></p>\n<h4><span id=\"想要学习移动web的同学不妨试试\">想要学习移动web的同学不妨试试！</span></h4>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"历时半年打造的慕课网移动web实战课程\"><a href=\"#历时半年打造的慕课网移动web实战课程\" class=\"headerlink\" title=\"历时半年打造的慕课网移动web实战课程\"></a>历时半年打造的慕课网移动web实战课程</h3><p><img src=\"https://qiniu.nihaoshijie.com.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-05%2021.07.05.png\" alt=\"\"></p>\n<h3 id=\"课程介绍\"><a href=\"#课程介绍\" class=\"headerlink\" title=\"课程介绍\"></a>课程介绍</h3><ul>\n<li>本课程带领大家一步步开发及结合Hybrid将美团外卖实战项目打造成完整的移动Web APP，理解并掌握移动Web开发的基本技能。</li>\n<li>开发过程中也会讲解到移动web的技巧和遇到问题时解决方法和针对不同场景技术的选型。从而提升对移动端适配以及React 全家桶和组件化开发实战技能。</li>\n<li>本课程还覆盖了工作中常见移动Web开发问题，并且可以通过课程学习找到对应的技术解决方案。</li>\n</ul>\n<p><a href=\"https://coding.imooc.com/class/272.html?mc_marking=d1fd61f18d73135fd74382c68a85e10e&amp;mc_channel=syb18\" target=\"_blank\" rel=\"noopener\">课程链接</a></p>\n<h4 id=\"想要学习移动web的同学不妨试试！\"><a href=\"#想要学习移动web的同学不妨试试！\" class=\"headerlink\" title=\"想要学习移动web的同学不妨试试！\"></a>想要学习移动web的同学不妨试试！</h4>"},{"title":"移动web日志查看工具","date":"2016-01-07T13:31:07.000Z","photos":["https://qiniu.nihaoshijie.com.cn/banabanb.jpg"],"_content":"<h1><span style=\"color: #008000;\">MLogger</span></h1>\n<!--more-->\n\n一个浮在页面上的日志查看工具\n<h2><a id=\"user-content-功能简介\" class=\"anchor\" style=\"color: #4078c0;\" href=\"https://github.com/lvming6816077/MLogger#功能简介\"></a><span style=\"color: #008000;\">功能简介</span></h2>\n<a href=\"https://github.com/lvming6816077/MLogger\" target=\"_blank\">github地址</a>\n\n一个浮在页面上的console面板，资源保证按需加载最大化保证性能。\n\n1.查看移动web页面上的console信息，自己可以在代码里面任意使用console，然后在手机端呼起该log便可以查看自己所打印的信息。\n2.查看移动web页面的ajax请求信息，包括返回数据，请求参数等等，类似与fiddler的抓包。\n<h2><a id=\"user-content-功能清单\" class=\"anchor\" style=\"color: #4078c0;\" href=\"https://github.com/lvming6816077/MLogger#功能清单\"></a><span style=\"color: #008000;\">功能清单</span></h2>\n项目分为3个资源文件\n\n1.inline的js 这个js需要在页面的所有js之前引入(因为会拦截console方法和ajax方法).\n2.非inline的js 这个js可以放在cdn上面，在初始化的时候配置进去即可。\n2.非inline的css 这个css可以放在cdn上面，在初始化的时候配置进去即可。\n<h2><a id=\"user-content-功能截图\" class=\"anchor\" style=\"color: #4078c0;\" href=\"https://github.com/lvming6816077/MLogger#功能截图\"></a><span style=\"color: #008000;\">功能截图</span></h2>\n<img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/20150818153137955.gif\" alt=\"\" width=\"319\" height=\"567\" />\n<h2><a id=\"user-content-快速上手\" class=\"anchor\" style=\"color: #4078c0;\" href=\"https://github.com/lvming6816077/MLogger#快速上手\"></a><span style=\"color: #008000;\">快速上手</span></h2>\n```html\n<script src=\"log_inline.js\"></script>\n<script type=\"text/javascript\">\n    var opt = {\n        'logExtJs': 'log_ext.js',\n        'logExtCss': 'log.css'\n    };\n    window.MLogger.init(opt);\n    console.log(1);\n    console.log({a:1,b: {x:'ccc'}});\n</script>\n```\n\n欢迎接入使用！","source":"_posts/移动web日志查看工具.md","raw":"---\ntitle: 移动web日志查看工具\ndate: 2016-01-07 21:31:07\ntags: 工具\ncategories:\n- 568\nphotos:\n- https://qiniu.nihaoshijie.com.cn/banabanb.jpg\n---\n<h1><span style=\"color: #008000;\">MLogger</span></h1>\n<!--more-->\n\n一个浮在页面上的日志查看工具\n<h2><a id=\"user-content-功能简介\" class=\"anchor\" style=\"color: #4078c0;\" href=\"https://github.com/lvming6816077/MLogger#功能简介\"></a><span style=\"color: #008000;\">功能简介</span></h2>\n<a href=\"https://github.com/lvming6816077/MLogger\" target=\"_blank\">github地址</a>\n\n一个浮在页面上的console面板，资源保证按需加载最大化保证性能。\n\n1.查看移动web页面上的console信息，自己可以在代码里面任意使用console，然后在手机端呼起该log便可以查看自己所打印的信息。\n2.查看移动web页面的ajax请求信息，包括返回数据，请求参数等等，类似与fiddler的抓包。\n<h2><a id=\"user-content-功能清单\" class=\"anchor\" style=\"color: #4078c0;\" href=\"https://github.com/lvming6816077/MLogger#功能清单\"></a><span style=\"color: #008000;\">功能清单</span></h2>\n项目分为3个资源文件\n\n1.inline的js 这个js需要在页面的所有js之前引入(因为会拦截console方法和ajax方法).\n2.非inline的js 这个js可以放在cdn上面，在初始化的时候配置进去即可。\n2.非inline的css 这个css可以放在cdn上面，在初始化的时候配置进去即可。\n<h2><a id=\"user-content-功能截图\" class=\"anchor\" style=\"color: #4078c0;\" href=\"https://github.com/lvming6816077/MLogger#功能截图\"></a><span style=\"color: #008000;\">功能截图</span></h2>\n<img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/20150818153137955.gif\" alt=\"\" width=\"319\" height=\"567\" />\n<h2><a id=\"user-content-快速上手\" class=\"anchor\" style=\"color: #4078c0;\" href=\"https://github.com/lvming6816077/MLogger#快速上手\"></a><span style=\"color: #008000;\">快速上手</span></h2>\n```html\n<script src=\"log_inline.js\"></script>\n<script type=\"text/javascript\">\n    var opt = {\n        'logExtJs': 'log_ext.js',\n        'logExtCss': 'log.css'\n    };\n    window.MLogger.init(opt);\n    console.log(1);\n    console.log({a:1,b: {x:'ccc'}});\n</script>\n```\n\n欢迎接入使用！","slug":"移动web日志查看工具","published":1,"updated":"2019-04-02T16:52:30.000Z","comments":1,"layout":"post","link":"","_id":"ckx434q1j003p2wvjuy38qt3l","content":"<p></p><h1><span id=\"mlogger\"><span style=\"color: #008000;\">MLogger</span></span></h1><br><a id=\"more\"></a><p></p>\n<p>一个浮在页面上的日志查看工具</p>\n<p></p><h2><span id=\"功能简介\"><span style=\"color: #008000;\">功能简介</span></span></h2><br><a href=\"https://github.com/lvming6816077/MLogger\" target=\"_blank\">github地址</a><p></p>\n<p>一个浮在页面上的console面板，资源保证按需加载最大化保证性能。</p>\n<p>1.查看移动web页面上的console信息，自己可以在代码里面任意使用console，然后在手机端呼起该log便可以查看自己所打印的信息。<br>2.查看移动web页面的ajax请求信息，包括返回数据，请求参数等等，类似与fiddler的抓包。</p>\n<p></p><h2><span id=\"功能清单\"><span style=\"color: #008000;\">功能清单</span></span></h2><br>项目分为3个资源文件<p></p>\n<p>1.inline的js 这个js需要在页面的所有js之前引入(因为会拦截console方法和ajax方法).<br>2.非inline的js 这个js可以放在cdn上面，在初始化的时候配置进去即可。<br>2.非inline的css 这个css可以放在cdn上面，在初始化的时候配置进去即可。</p>\n<p></p><h2><span id=\"功能截图\"><span style=\"color: #008000;\">功能截图</span></span></h2><br><img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/20150818153137955.gif\" alt width=\"319\" height=\"567\"><p></p>\n<p></p><h2><span id=\"快速上手\"><span style=\"color: #008000;\">快速上手</span></span></h2><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"log_inline.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> opt = &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"string\">'logExtJs'</span>: <span class=\"string\">'log_ext.js'</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"string\">'logExtCss'</span>: <span class=\"string\">'log.css'</span></span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">window</span>.MLogger.init(opt);</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(&#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>,<span class=\"attr\">b</span>: &#123;<span class=\"attr\">x</span>:<span class=\"string\">'ccc'</span>&#125;&#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p>\n<p>欢迎接入使用！</p>\n","site":{"data":{}},"excerpt":"<p></p><h1><span style=\"color: #008000;\">MLogger</span></h1><br>","more":"<p></p>\n<p>一个浮在页面上的日志查看工具</p>\n<p></p><h2><a id=\"user-content-功能简介\" class=\"anchor\" style=\"color: #4078c0;\" href=\"https://github.com/lvming6816077/MLogger#功能简介\" target=\"_blank\" rel=\"noopener\"></a><span style=\"color: #008000;\">功能简介</span></h2><br><a href=\"https://github.com/lvming6816077/MLogger\" target=\"_blank\">github地址</a><p></p>\n<p>一个浮在页面上的console面板，资源保证按需加载最大化保证性能。</p>\n<p>1.查看移动web页面上的console信息，自己可以在代码里面任意使用console，然后在手机端呼起该log便可以查看自己所打印的信息。<br>2.查看移动web页面的ajax请求信息，包括返回数据，请求参数等等，类似与fiddler的抓包。</p>\n<p></p><h2><a id=\"user-content-功能清单\" class=\"anchor\" style=\"color: #4078c0;\" href=\"https://github.com/lvming6816077/MLogger#功能清单\" target=\"_blank\" rel=\"noopener\"></a><span style=\"color: #008000;\">功能清单</span></h2><br>项目分为3个资源文件<p></p>\n<p>1.inline的js 这个js需要在页面的所有js之前引入(因为会拦截console方法和ajax方法).<br>2.非inline的js 这个js可以放在cdn上面，在初始化的时候配置进去即可。<br>2.非inline的css 这个css可以放在cdn上面，在初始化的时候配置进去即可。</p>\n<p></p><h2><a id=\"user-content-功能截图\" class=\"anchor\" style=\"color: #4078c0;\" href=\"https://github.com/lvming6816077/MLogger#功能截图\" target=\"_blank\" rel=\"noopener\"></a><span style=\"color: #008000;\">功能截图</span></h2><br><img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/20150818153137955.gif\" alt=\"\" width=\"319\" height=\"567\"><p></p>\n<p></p><h2><a id=\"user-content-快速上手\" class=\"anchor\" style=\"color: #4078c0;\" href=\"https://github.com/lvming6816077/MLogger#快速上手\" target=\"_blank\" rel=\"noopener\"></a><span style=\"color: #008000;\">快速上手</span></h2><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"log_inline.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> opt = &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"string\">'logExtJs'</span>: <span class=\"string\">'log_ext.js'</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"string\">'logExtCss'</span>: <span class=\"string\">'log.css'</span></span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">window</span>.MLogger.init(opt);</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(&#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>,<span class=\"attr\">b</span>: &#123;<span class=\"attr\">x</span>:<span class=\"string\">'ccc'</span>&#125;&#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p>\n<p>欢迎接入使用！</p>"},{"title":"移动web适配之--vh,vw,vmin,vmax","date":"2018-04-09T15:00:13.000Z","_content":"\n## 前言\n\n其实关于vh,vw,vmin,vmax这四个单位，伴随着css3的出现就已经有了，但是当时移动web的浪潮已经来临，并且rem出现的要早，所以很多人忽略这个，但是rem使用适配是要依赖js来进行处理，今天介绍的vh,vw,vmin,vmax是完全基于css的自适应方案，关于rem的适配可以参考笔者之前写的[文章](https://www.nihaoshijie.com.cn/index.php/archives/593/)。\n<!--more-->\n## 关于vh,vw,vmin,vmax\n\n先来看下这些单位分别代表什么意思：\n\n* vw : 1vw 等于视口宽度的1%\n* vh : 1vh 等于视口高度的1%\n* vmin : 选取 vw 和 vh 中最小的那个\n* vmax : 选取 vw 和 vh 中最大的那个\n\n那么什么是视口宽度呢？你一定不会陌生：\n```html\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\">\n```\n没错，浏览器利用`viewport`的meta标签中的width来定义浏览器的视口大小，然而width可以使用数字单位来定义，只是我们常用的方法是：将width设置成设备的宽度 即`device-width`，关于浏览器的视口介绍可以参考这个[文章](https://www.quirksmode.org/mobile/viewports.html)。使用`document.documentElement.clientWidth`可以获取到浏览器的视口大小，这里要注意不一样的是类似`window.innerWidth`或者`window.screen.width`这些拿到的是浏览器的物理宽度，当width!=device-width时是不等效的哦。\n\n## vh/vw与%区别在于\n\n| 单位  | 基于情况  |\n| ------------ | ------------ |\n|  % | 基于父元素  |\n| vh/vw  | 基于视口  |\n\n\nSo，vh,vw,vmin,vmax都是基于viewport定义的width来定义单位，它是利用视口单位实现，依赖于视口大小而自动缩放，所以不同的设备视口大小不一样自然就达到的适配的效果。\n\n```css\n        .main {\n            width: 60vw;\n            height: 60vw;\n            background-color: red;\n            text-align: center;\n            line-height: 60vw;\n        }\n```\n![](https://qiniu.nihaoshijie.com.cn/1522579500_92_w551_h894.gif)\n\n## 和rem相比优势？\n\n关于rem的适配大部分需要2个步骤：\n1. 在页面头部引入js来动态设置页面的html的font-size，一般情况下基于屏幕宽度来计算 即：`var rem = docEl.clientWidth / 10;docEl.style.fontSize = rem + 'px';`\n2. 在使用css时，使用less或者scss来动态计算dom的实际rem数值\n```css\n@function px2rem($px) {\n  $rem: 75px;\n  @return ($px / $rem) + rem;\n}\n```\n由此会有2个问题：\n- 依赖页面头部的js设置，虽说基本上不会阻塞页面渲染，但是放在头部始终要进行一次dom计算，不算优雅。\n- 通常使用宽度来计算html的font-size时，对于那种很宽的手机或者是ipad，会导致适配的不准确(可以参考rem的页面放在ipad上横屏观察一下)。\n\n\n那么使用vmin基本上可以规避上面的问题：\n- 不依赖js执行。\n- 选取宽高之中较小的值进行适配。\n\n![](https://qiniu.nihaoshijie.com.cn/1522580497_97_w1044_h720.gif)\n## 浏览器兼容性？\n那么vh,vw,vmin,vmax这么方便，为什么还是没有流行起来呢？让我们来看看浏览器的[兼容性](https://caniuse.com/#search=vh)：\n![](https://qiniu.nihaoshijie.com.cn/1522580229_33_w2608_h1258.png)\n\nAndroid4.4之前不支持是硬伤！\n\n","source":"_posts/移动web适配之--vh,vw,vmin,vmax.md","raw":"---\ntitle: 移动web适配之--vh,vw,vmin,vmax\ndate: 2018-04-09 23:00:13\ntags:\n- 移动web适配\n- vmin\ncategories:\n- 788\n---\n\n## 前言\n\n其实关于vh,vw,vmin,vmax这四个单位，伴随着css3的出现就已经有了，但是当时移动web的浪潮已经来临，并且rem出现的要早，所以很多人忽略这个，但是rem使用适配是要依赖js来进行处理，今天介绍的vh,vw,vmin,vmax是完全基于css的自适应方案，关于rem的适配可以参考笔者之前写的[文章](https://www.nihaoshijie.com.cn/index.php/archives/593/)。\n<!--more-->\n## 关于vh,vw,vmin,vmax\n\n先来看下这些单位分别代表什么意思：\n\n* vw : 1vw 等于视口宽度的1%\n* vh : 1vh 等于视口高度的1%\n* vmin : 选取 vw 和 vh 中最小的那个\n* vmax : 选取 vw 和 vh 中最大的那个\n\n那么什么是视口宽度呢？你一定不会陌生：\n```html\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\">\n```\n没错，浏览器利用`viewport`的meta标签中的width来定义浏览器的视口大小，然而width可以使用数字单位来定义，只是我们常用的方法是：将width设置成设备的宽度 即`device-width`，关于浏览器的视口介绍可以参考这个[文章](https://www.quirksmode.org/mobile/viewports.html)。使用`document.documentElement.clientWidth`可以获取到浏览器的视口大小，这里要注意不一样的是类似`window.innerWidth`或者`window.screen.width`这些拿到的是浏览器的物理宽度，当width!=device-width时是不等效的哦。\n\n## vh/vw与%区别在于\n\n| 单位  | 基于情况  |\n| ------------ | ------------ |\n|  % | 基于父元素  |\n| vh/vw  | 基于视口  |\n\n\nSo，vh,vw,vmin,vmax都是基于viewport定义的width来定义单位，它是利用视口单位实现，依赖于视口大小而自动缩放，所以不同的设备视口大小不一样自然就达到的适配的效果。\n\n```css\n        .main {\n            width: 60vw;\n            height: 60vw;\n            background-color: red;\n            text-align: center;\n            line-height: 60vw;\n        }\n```\n![](https://qiniu.nihaoshijie.com.cn/1522579500_92_w551_h894.gif)\n\n## 和rem相比优势？\n\n关于rem的适配大部分需要2个步骤：\n1. 在页面头部引入js来动态设置页面的html的font-size，一般情况下基于屏幕宽度来计算 即：`var rem = docEl.clientWidth / 10;docEl.style.fontSize = rem + 'px';`\n2. 在使用css时，使用less或者scss来动态计算dom的实际rem数值\n```css\n@function px2rem($px) {\n  $rem: 75px;\n  @return ($px / $rem) + rem;\n}\n```\n由此会有2个问题：\n- 依赖页面头部的js设置，虽说基本上不会阻塞页面渲染，但是放在头部始终要进行一次dom计算，不算优雅。\n- 通常使用宽度来计算html的font-size时，对于那种很宽的手机或者是ipad，会导致适配的不准确(可以参考rem的页面放在ipad上横屏观察一下)。\n\n\n那么使用vmin基本上可以规避上面的问题：\n- 不依赖js执行。\n- 选取宽高之中较小的值进行适配。\n\n![](https://qiniu.nihaoshijie.com.cn/1522580497_97_w1044_h720.gif)\n## 浏览器兼容性？\n那么vh,vw,vmin,vmax这么方便，为什么还是没有流行起来呢？让我们来看看浏览器的[兼容性](https://caniuse.com/#search=vh)：\n![](https://qiniu.nihaoshijie.com.cn/1522580229_33_w2608_h1258.png)\n\nAndroid4.4之前不支持是硬伤！\n\n","slug":"移动web适配之--vh,vw,vmin,vmax","published":1,"updated":"2019-04-02T16:49:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434q1k003q2wvjeenb2989","content":"<h2><span id=\"前言\">前言</span></h2><p>其实关于vh,vw,vmin,vmax这四个单位，伴随着css3的出现就已经有了，但是当时移动web的浪潮已经来临，并且rem出现的要早，所以很多人忽略这个，但是rem使用适配是要依赖js来进行处理，今天介绍的vh,vw,vmin,vmax是完全基于css的自适应方案，关于rem的适配可以参考笔者之前写的<a href=\"https://www.nihaoshijie.com.cn/index.php/archives/593/\">文章</a>。<br><a id=\"more\"></a></p>\n<h2><span id=\"关于vhvwvminvmax\">关于vh,vw,vmin,vmax</span></h2><p>先来看下这些单位分别代表什么意思：</p>\n<ul>\n<li>vw : 1vw 等于视口宽度的1%</li>\n<li>vh : 1vh 等于视口高度的1%</li>\n<li>vmin : 选取 vw 和 vh 中最小的那个</li>\n<li>vmax : 选取 vw 和 vh 中最大的那个</li>\n</ul>\n<p>那么什么是视口宽度呢？你一定不会陌生：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>没错，浏览器利用<code>viewport</code>的meta标签中的width来定义浏览器的视口大小，然而width可以使用数字单位来定义，只是我们常用的方法是：将width设置成设备的宽度 即<code>device-width</code>，关于浏览器的视口介绍可以参考这个<a href=\"https://www.quirksmode.org/mobile/viewports.html\" target=\"_blank\" rel=\"noopener\">文章</a>。使用<code>document.documentElement.clientWidth</code>可以获取到浏览器的视口大小，这里要注意不一样的是类似<code>window.innerWidth</code>或者<code>window.screen.width</code>这些拿到的是浏览器的物理宽度，当width!=device-width时是不等效的哦。</p>\n<h2><span id=\"vhvw与区别在于\">vh/vw与%区别在于</span></h2><table>\n<thead>\n<tr>\n<th>单位</th>\n<th>基于情况</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>%</td>\n<td>基于父元素</td>\n</tr>\n<tr>\n<td>vh/vw</td>\n<td>基于视口</td>\n</tr>\n</tbody>\n</table>\n<p>So，vh,vw,vmin,vmax都是基于viewport定义的width来定义单位，它是利用视口单位实现，依赖于视口大小而自动缩放，所以不同的设备视口大小不一样自然就达到的适配的效果。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.main</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">60vw</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">60vw</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: red;</span><br><span class=\"line\">    <span class=\"attribute\">text-align</span>: center;</span><br><span class=\"line\">    <span class=\"attribute\">line-height</span>: <span class=\"number\">60vw</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://qiniu.nihaoshijie.com.cn/1522579500_92_w551_h894.gif\" alt></p>\n<h2><span id=\"和rem相比优势\">和rem相比优势？</span></h2><p>关于rem的适配大部分需要2个步骤：</p>\n<ol>\n<li>在页面头部引入js来动态设置页面的html的font-size，一般情况下基于屏幕宽度来计算 即：<code>var rem = docEl.clientWidth / 10;docEl.style.fontSize = rem + &#39;px&#39;;</code></li>\n<li>在使用css时，使用less或者scss来动态计算dom的实际rem数值<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">function</span> px2rem($px) &#123;</span><br><span class=\"line\">  $rem: 75px;</span><br><span class=\"line\">  @<span class=\"keyword\">return</span> ($px / $rem) + rem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>由此会有2个问题：</p>\n<ul>\n<li>依赖页面头部的js设置，虽说基本上不会阻塞页面渲染，但是放在头部始终要进行一次dom计算，不算优雅。</li>\n<li>通常使用宽度来计算html的font-size时，对于那种很宽的手机或者是ipad，会导致适配的不准确(可以参考rem的页面放在ipad上横屏观察一下)。</li>\n</ul>\n<p>那么使用vmin基本上可以规避上面的问题：</p>\n<ul>\n<li>不依赖js执行。</li>\n<li>选取宽高之中较小的值进行适配。</li>\n</ul>\n<p><img src=\"https://qiniu.nihaoshijie.com.cn/1522580497_97_w1044_h720.gif\" alt></p>\n<h2><span id=\"浏览器兼容性\">浏览器兼容性？</span></h2><p>那么vh,vw,vmin,vmax这么方便，为什么还是没有流行起来呢？让我们来看看浏览器的<a href=\"https://caniuse.com/#search=vh\" target=\"_blank\" rel=\"noopener\">兼容性</a>：<br><img src=\"https://qiniu.nihaoshijie.com.cn/1522580229_33_w2608_h1258.png\" alt></p>\n<p>Android4.4之前不支持是硬伤！</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>其实关于vh,vw,vmin,vmax这四个单位，伴随着css3的出现就已经有了，但是当时移动web的浪潮已经来临，并且rem出现的要早，所以很多人忽略这个，但是rem使用适配是要依赖js来进行处理，今天介绍的vh,vw,vmin,vmax是完全基于css的自适应方案，关于rem的适配可以参考笔者之前写的<a href=\"https://www.nihaoshijie.com.cn/index.php/archives/593/\">文章</a>。<br>","more":"</p>\n<h2 id=\"关于vh-vw-vmin-vmax\"><a href=\"#关于vh-vw-vmin-vmax\" class=\"headerlink\" title=\"关于vh,vw,vmin,vmax\"></a>关于vh,vw,vmin,vmax</h2><p>先来看下这些单位分别代表什么意思：</p>\n<ul>\n<li>vw : 1vw 等于视口宽度的1%</li>\n<li>vh : 1vh 等于视口高度的1%</li>\n<li>vmin : 选取 vw 和 vh 中最小的那个</li>\n<li>vmax : 选取 vw 和 vh 中最大的那个</li>\n</ul>\n<p>那么什么是视口宽度呢？你一定不会陌生：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>没错，浏览器利用<code>viewport</code>的meta标签中的width来定义浏览器的视口大小，然而width可以使用数字单位来定义，只是我们常用的方法是：将width设置成设备的宽度 即<code>device-width</code>，关于浏览器的视口介绍可以参考这个<a href=\"https://www.quirksmode.org/mobile/viewports.html\" target=\"_blank\" rel=\"noopener\">文章</a>。使用<code>document.documentElement.clientWidth</code>可以获取到浏览器的视口大小，这里要注意不一样的是类似<code>window.innerWidth</code>或者<code>window.screen.width</code>这些拿到的是浏览器的物理宽度，当width!=device-width时是不等效的哦。</p>\n<h2 id=\"vh-vw与-区别在于\"><a href=\"#vh-vw与-区别在于\" class=\"headerlink\" title=\"vh/vw与%区别在于\"></a>vh/vw与%区别在于</h2><table>\n<thead>\n<tr>\n<th>单位</th>\n<th>基于情况</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>%</td>\n<td>基于父元素</td>\n</tr>\n<tr>\n<td>vh/vw</td>\n<td>基于视口</td>\n</tr>\n</tbody>\n</table>\n<p>So，vh,vw,vmin,vmax都是基于viewport定义的width来定义单位，它是利用视口单位实现，依赖于视口大小而自动缩放，所以不同的设备视口大小不一样自然就达到的适配的效果。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.main</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">60vw</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">60vw</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: red;</span><br><span class=\"line\">    <span class=\"attribute\">text-align</span>: center;</span><br><span class=\"line\">    <span class=\"attribute\">line-height</span>: <span class=\"number\">60vw</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://qiniu.nihaoshijie.com.cn/1522579500_92_w551_h894.gif\" alt=\"\"></p>\n<h2 id=\"和rem相比优势？\"><a href=\"#和rem相比优势？\" class=\"headerlink\" title=\"和rem相比优势？\"></a>和rem相比优势？</h2><p>关于rem的适配大部分需要2个步骤：</p>\n<ol>\n<li>在页面头部引入js来动态设置页面的html的font-size，一般情况下基于屏幕宽度来计算 即：<code>var rem = docEl.clientWidth / 10;docEl.style.fontSize = rem + &#39;px&#39;;</code></li>\n<li>在使用css时，使用less或者scss来动态计算dom的实际rem数值<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">function</span> px2rem($px) &#123;</span><br><span class=\"line\">  $rem: 75px;</span><br><span class=\"line\">  @<span class=\"keyword\">return</span> ($px / $rem) + rem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>由此会有2个问题：</p>\n<ul>\n<li>依赖页面头部的js设置，虽说基本上不会阻塞页面渲染，但是放在头部始终要进行一次dom计算，不算优雅。</li>\n<li>通常使用宽度来计算html的font-size时，对于那种很宽的手机或者是ipad，会导致适配的不准确(可以参考rem的页面放在ipad上横屏观察一下)。</li>\n</ul>\n<p>那么使用vmin基本上可以规避上面的问题：</p>\n<ul>\n<li>不依赖js执行。</li>\n<li>选取宽高之中较小的值进行适配。</li>\n</ul>\n<p><img src=\"https://qiniu.nihaoshijie.com.cn/1522580497_97_w1044_h720.gif\" alt=\"\"></p>\n<h2 id=\"浏览器兼容性？\"><a href=\"#浏览器兼容性？\" class=\"headerlink\" title=\"浏览器兼容性？\"></a>浏览器兼容性？</h2><p>那么vh,vw,vmin,vmax这么方便，为什么还是没有流行起来呢？让我们来看看浏览器的<a href=\"https://caniuse.com/#search=vh\" target=\"_blank\" rel=\"noopener\">兼容性</a>：<br><img src=\"https://qiniu.nihaoshijie.com.cn/1522580229_33_w2608_h1258.png\" alt=\"\"></p>\n<p>Android4.4之前不支持是硬伤！</p>"},{"title":"移动web适配之rem","date":"2016-03-14T13:13:42.000Z","_content":"<h2><span style=\"color: #008000;\">前言</span></h2>\n提到rem，大家首先会想到的是rm，px这类的词语，大多数人眼中这些单位是用于设置字体的大小的，没错这的确是用来设置字体大小的，但是对于rem来说它可以用来做移动端的响应式适配哦。\n<!--more-->\n&nbsp;\n<h2><span style=\"color: #008000;\">兼容性</span></h2>\n<img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/caniuse.png\" alt=\"\" width=\"1270\" height=\"548\" /> 先看看兼容性，大部分主流浏览器都支持，可以安心的往下看了。\n\n&nbsp;\n<h2><span style=\"color: #008000;\">rem设置字体大小</span></h2>\nrem是<span style=\"color: #111111;\">（font size of the root element），官方解释</span>\n\n<span style=\"color: #111111;\"><img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/QQ%E5%9B%BE%E7%89%8720160313181850.png\" alt=\"\" width=\"868\" height=\"129\" />，</span>\n\n<span style=\"color: #111111;\">意思就是根据网页的跟元素来设置字体大小，和em（font size of the element）的区别是，em是根据其父元素的字体大小来设置，而rem是根据网页的跟元素（html）来设置字体大小的，举一个简单的例子，</span>\n\n<span style=\"color: #111111;\">现在大部分浏览器<span style=\"color: #4a4a4a;\">IE9+，Firefox、Chrome、Safari、Opera </span>，如果我们不修改相关的字体配置，都是默认显示font-size是16px即</span>\n```css\nhtml {    \n\tfont-size:16px;\n}\n```\n那么如果我们想给一个P标签设置12px的字体大小那么用rem来写就是\n```css\np {    \n\tfont-size: 0.75rem; //12÷16=0.75（rem）\n}\n```\n基本上使用rem这个单位来设置字体大小基本上是这个套路，好处是加入用户自己修改了浏览器的默认字体大小，那么使用rem时就可以根据用的调整的大小来显示了。 但是rem不仅可以适用于字体，同样可以用于width height margin这些样式的单位。下面来具体说一下\n\n&nbsp;\n<h2><span style=\"color: #008000;\">rem进行屏幕适配</span></h2>\n在讲rem屏幕适配之前，先说一下一般做移动端适配的方法，一般可以分为： <strong>1</strong> 简单一点的页面，一般高度直接设置成固定值，宽度一般盛满整个屏幕。 <strong>2</strong> 稍复杂一些的是利用百分比设置元素的大小来进行适配，或者利用flex等css去设置一些需要定制的宽度。 <strong>3</strong> 再复杂负责一些的响应式页面，需要利用css3的media query属性来进行适配，大致思路是根据屏幕不同大小，来设置对应的css样式。 上面的一些方法，其实也可以解决屏幕适配等问题，但是既然出来的rem这个新东西，也一定能兼顾到这些方面，下面具体来说具体使用rem：\n\n&nbsp;\n\n<strong>rem适配</strong>\n\n&nbsp;\n\n先看一个简单的例子：\n```css\n.con {\n      width: 10rem;\n      height: 10rem;\n      background-color: red;\n }\n<div class=\"con\">\n        \n</div>\n```\n<img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/div.png\" alt=\"\" width=\"380\" height=\"231\" />\n\n这是一个div，宽度和高度都用rem来设置了，在浏览器里面是这样显示的，  可以看到，在浏览器里面width和height分别是160px，正好是16px * 10,那么如果将html根元素的默认font-size修改一下呢？\n```css\nhtml {\n    font-size: 17px;\n}\n.con {\n      width: 10rem;\n      height: 10rem;\n      background-color: red;\n }\n<div class=\"con\">\n        \n</div>\n```\n再来看看结果：\n\n<img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/div2.png\" alt=\"\" width=\"386\" height=\"222\" />\n\n这时width和height都是170px，这就说明了将rem应用与width和height时，同样适用与rem的特性，根据根元素的font-size值来改变自身的值，由此我们应该可以联想到我们可以给html设定不同的值，从而达到我们css样式中的适配效果。\n\n&nbsp;\n\n<strong>rem数值计算</strong>\n\n&nbsp;\n\n如果利用rem来设置css的值，一般要通过一层计算才行，比如如果要设置一个长宽为100px的div，那么就需要计算出100px对应的rem值是 100 / 16 =6.25rem，这在我们写css中，其实算比较繁琐的一步操作了，不过这其实都不是事。 想想我们现在的工程，哪个没有用构建的，前端构建中，完全可以利用scss来解决这个问题，例如我们可以写一个scss的function px2rem即：\n```css\n@function px2rem($px){\n    $rem : 37.5px;\n    @return ($px/$rem) + rem;\n}\n```\n这样，当我们写具体数值的时候就可以写成：\n```css\nheight: px2rem(90px);\nwidth: px2rem(90px);;\n```\n看到这里，你可能会发现一些不理解的地方，就是上面那个rem:37.5px是怎么来的，正常情况下不是默认的16px么，这个其实就是页面的基准值，和html的font-size有关。\n\n&nbsp;\n\n<strong>rem基准值计算</strong>\n\n&nbsp;\n\n关于rem的基准值，也就是上面那个37.5px其实是根据我们所拿到的视觉稿来决定的主要有以下几点原因：\n\n<strong>1</strong> 由于我们所写出的页面是要在不同的屏幕大小设备上运行的\n\n<strong>2</strong> 所以我们在写样式的时候必须要先已一个确定的屏幕来作为参考，这个就由我们拿到的视觉稿来定\n\n<strong>3</strong> 假如我们拿到的视觉稿是以iphone6的屏幕为基准设计的\n\n<strong>4</strong> iPhone6的屏幕大小是375px，\n<pre class=\"lang:default decode:true\">rem = window.innerWidth  / 10</pre>\n这样计算出来的rem基准值就是37.5（iphone6的视觉稿），这里为什么要除以10呢，其实这个值是随便定义的，假如不除以10，根据我们算出来的基准值会偏大，这样在设置html的font-size时候会偏小，我们知道浏览器的font-size如果小于12px就显示不出效果了，在这里列举一下其他手机的\n\niphone3gs: 320px / 10 = 32px\n\niphone4/5: 320px  / 10 = 32px\n\niphone6: 375px  / 10 =37.5px\n\n&nbsp;\n\n<strong>动态设置html的font-size</strong>\n\n&nbsp;\n\n现在关键问题来了，我们该如何通过不同的屏幕去动态设置html的font-size呢，这里一般分为两种办法\n\n<strong>1</strong> 利用css的media query来设置即\n```css\n@media (min-device-width : 375px) and (max-device-width : 667px) and (-webkit-min-device-pixel-ratio : 2){\n      html{\n      \tfont-size: 37.5px;\n      }\n}\n```\n<strong>2</strong> 利用javascript来动态设置 根据我们之前算出的基准值，我们可以利用js动态算出当前屏幕所适配的font-size即：\n```javasript\ndocument.getElementsByTagName('html')[0].style.fontSize = window.innerWidth / 10 + 'px';\n```\n然后我们看一下之前那个demo展示的效果\n```css\n.con {\n      width: px2rem(200px);\n      height: px2rem(200px);\n      background-color: red;\n}\n<div class=\"con\">\n        \n</div>\n```javascript\ndocument.addEventListener('DOMContentLoaded', function(e) {\n                document.getElementsByTagName('html')[0].style.fontSize = window.innerWidth / 10 + 'px';\n}, false);\n```\niPhone6下，正常显示200px\n\n<img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/div3.png\" alt=\"\" width=\"349\" height=\"321\" />\n\n在iphone4下，显示169px\n\n<img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/div4.png\" alt=\"\" width=\"320\" height=\"284\" />\n\n由此可见我们可以通过设置不同的html基础值来达到在不同页面适配的目的，当然在使用js来设置时，需要绑定页面的resize事件来达到变化时更新html的font-size。\n\n&nbsp;\n<h2><span style=\"color: #008000;\">rem适配进阶</span></h2>\n我们知道，一般我们获取到的视觉稿大部分是iphone6的，所以我们看到的尺寸一般是双倍大小的，在使用rem之前，我们一般会自觉的将标注/2，其实这也并无道理，但是当我们配合rem'使用时，完全可以按照视觉稿上的尺寸来设置。\n\n1 设计给的稿子双倍的原因是iphone6这种屏幕属于高清屏，也即是设备像素比(device pixel ratio)dpr比较大，所以显示的像素较为清晰。\n\n2 一般手机的dpr是1，iphone这种高清屏是2，可以通过js的window.devicePixelRatio获取到当前设备的dpr，所以iphone6给的视觉稿大小是（*2）750×1334了。\n\n3 拿到了dpr之后，我们就可以在viewport meta头里，取消让浏览器自动缩放页面，而自己去设置viewport的content例如\n```javascript\nmeta.setAttribute('content', 'initial-scale=' + 1/dpr + ', maximum-scale=' + 1/dpr + ', minimum-scale=' + 1/dpr + ', user-scalable=no');\n```\n4 设置完之后配合rem，修改\n```css\n@function px2rem($px){\n    $rem : 75px;\n    @return ($px/$rem) + rem;\n}\n```\n双倍75，这样就可以完全按照视觉稿上的尺寸来了。不用在/2了，这样做的好处是：\n\n1 解决了图片高清问题。\n\n2 解决了border 1px问题（我们设置的1px，在iphone上，由于viewport的scale是0.5，所以就自然缩放成0.5px）\n<h2><span style=\"color: #008000;\">rem进行屏幕适配总结</span></h2>\n下面这个网址是针对rem来写的一个简单的demo页面，大家可以在不同的手机上看一下效果\n\n<img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/democode.png\" alt=\"\" width=\"280\" height=\"280\" />\n\n但是rem也并不是万能的，下面也有一些场景是不适于使用rem的\n\n<strong> 1</strong> 当用作图片或者一些不能缩放的展示时，必须要使用固定的px值，因为缩放可能会导致图片压缩变形等。\n\n<strong> 2</strong> 再设置backgroundposition或者backgroundsize时不宜使用rem。\n\n在列举几个使用rem的线上网站：\n\n网易新闻：<a href=\"http://3g.163.com/touch/news/subchannel/all?version=v_standard\" target=\"_blank\">http://3g.163.com/touch/news/subchannel/all?version=v_standard</a>\n\n聚划算：<a href=\"https://jhs.m.taobao.com/m/index.htm#!all\" target=\"_blank\">https://jhs.m.taobao.com/m/index.htm#!all</a>","source":"_posts/移动web适配之rem.md","raw":"---\ntitle: 移动web适配之rem\ndate: 2016-03-14 21:13:42\ntags:\n- 移动web\n- rem\ncategories:\n- 593\n\n---\n<h2><span style=\"color: #008000;\">前言</span></h2>\n提到rem，大家首先会想到的是rm，px这类的词语，大多数人眼中这些单位是用于设置字体的大小的，没错这的确是用来设置字体大小的，但是对于rem来说它可以用来做移动端的响应式适配哦。\n<!--more-->\n&nbsp;\n<h2><span style=\"color: #008000;\">兼容性</span></h2>\n<img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/caniuse.png\" alt=\"\" width=\"1270\" height=\"548\" /> 先看看兼容性，大部分主流浏览器都支持，可以安心的往下看了。\n\n&nbsp;\n<h2><span style=\"color: #008000;\">rem设置字体大小</span></h2>\nrem是<span style=\"color: #111111;\">（font size of the root element），官方解释</span>\n\n<span style=\"color: #111111;\"><img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/QQ%E5%9B%BE%E7%89%8720160313181850.png\" alt=\"\" width=\"868\" height=\"129\" />，</span>\n\n<span style=\"color: #111111;\">意思就是根据网页的跟元素来设置字体大小，和em（font size of the element）的区别是，em是根据其父元素的字体大小来设置，而rem是根据网页的跟元素（html）来设置字体大小的，举一个简单的例子，</span>\n\n<span style=\"color: #111111;\">现在大部分浏览器<span style=\"color: #4a4a4a;\">IE9+，Firefox、Chrome、Safari、Opera </span>，如果我们不修改相关的字体配置，都是默认显示font-size是16px即</span>\n```css\nhtml {    \n\tfont-size:16px;\n}\n```\n那么如果我们想给一个P标签设置12px的字体大小那么用rem来写就是\n```css\np {    \n\tfont-size: 0.75rem; //12÷16=0.75（rem）\n}\n```\n基本上使用rem这个单位来设置字体大小基本上是这个套路，好处是加入用户自己修改了浏览器的默认字体大小，那么使用rem时就可以根据用的调整的大小来显示了。 但是rem不仅可以适用于字体，同样可以用于width height margin这些样式的单位。下面来具体说一下\n\n&nbsp;\n<h2><span style=\"color: #008000;\">rem进行屏幕适配</span></h2>\n在讲rem屏幕适配之前，先说一下一般做移动端适配的方法，一般可以分为： <strong>1</strong> 简单一点的页面，一般高度直接设置成固定值，宽度一般盛满整个屏幕。 <strong>2</strong> 稍复杂一些的是利用百分比设置元素的大小来进行适配，或者利用flex等css去设置一些需要定制的宽度。 <strong>3</strong> 再复杂负责一些的响应式页面，需要利用css3的media query属性来进行适配，大致思路是根据屏幕不同大小，来设置对应的css样式。 上面的一些方法，其实也可以解决屏幕适配等问题，但是既然出来的rem这个新东西，也一定能兼顾到这些方面，下面具体来说具体使用rem：\n\n&nbsp;\n\n<strong>rem适配</strong>\n\n&nbsp;\n\n先看一个简单的例子：\n```css\n.con {\n      width: 10rem;\n      height: 10rem;\n      background-color: red;\n }\n<div class=\"con\">\n        \n</div>\n```\n<img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/div.png\" alt=\"\" width=\"380\" height=\"231\" />\n\n这是一个div，宽度和高度都用rem来设置了，在浏览器里面是这样显示的，  可以看到，在浏览器里面width和height分别是160px，正好是16px * 10,那么如果将html根元素的默认font-size修改一下呢？\n```css\nhtml {\n    font-size: 17px;\n}\n.con {\n      width: 10rem;\n      height: 10rem;\n      background-color: red;\n }\n<div class=\"con\">\n        \n</div>\n```\n再来看看结果：\n\n<img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/div2.png\" alt=\"\" width=\"386\" height=\"222\" />\n\n这时width和height都是170px，这就说明了将rem应用与width和height时，同样适用与rem的特性，根据根元素的font-size值来改变自身的值，由此我们应该可以联想到我们可以给html设定不同的值，从而达到我们css样式中的适配效果。\n\n&nbsp;\n\n<strong>rem数值计算</strong>\n\n&nbsp;\n\n如果利用rem来设置css的值，一般要通过一层计算才行，比如如果要设置一个长宽为100px的div，那么就需要计算出100px对应的rem值是 100 / 16 =6.25rem，这在我们写css中，其实算比较繁琐的一步操作了，不过这其实都不是事。 想想我们现在的工程，哪个没有用构建的，前端构建中，完全可以利用scss来解决这个问题，例如我们可以写一个scss的function px2rem即：\n```css\n@function px2rem($px){\n    $rem : 37.5px;\n    @return ($px/$rem) + rem;\n}\n```\n这样，当我们写具体数值的时候就可以写成：\n```css\nheight: px2rem(90px);\nwidth: px2rem(90px);;\n```\n看到这里，你可能会发现一些不理解的地方，就是上面那个rem:37.5px是怎么来的，正常情况下不是默认的16px么，这个其实就是页面的基准值，和html的font-size有关。\n\n&nbsp;\n\n<strong>rem基准值计算</strong>\n\n&nbsp;\n\n关于rem的基准值，也就是上面那个37.5px其实是根据我们所拿到的视觉稿来决定的主要有以下几点原因：\n\n<strong>1</strong> 由于我们所写出的页面是要在不同的屏幕大小设备上运行的\n\n<strong>2</strong> 所以我们在写样式的时候必须要先已一个确定的屏幕来作为参考，这个就由我们拿到的视觉稿来定\n\n<strong>3</strong> 假如我们拿到的视觉稿是以iphone6的屏幕为基准设计的\n\n<strong>4</strong> iPhone6的屏幕大小是375px，\n<pre class=\"lang:default decode:true\">rem = window.innerWidth  / 10</pre>\n这样计算出来的rem基准值就是37.5（iphone6的视觉稿），这里为什么要除以10呢，其实这个值是随便定义的，假如不除以10，根据我们算出来的基准值会偏大，这样在设置html的font-size时候会偏小，我们知道浏览器的font-size如果小于12px就显示不出效果了，在这里列举一下其他手机的\n\niphone3gs: 320px / 10 = 32px\n\niphone4/5: 320px  / 10 = 32px\n\niphone6: 375px  / 10 =37.5px\n\n&nbsp;\n\n<strong>动态设置html的font-size</strong>\n\n&nbsp;\n\n现在关键问题来了，我们该如何通过不同的屏幕去动态设置html的font-size呢，这里一般分为两种办法\n\n<strong>1</strong> 利用css的media query来设置即\n```css\n@media (min-device-width : 375px) and (max-device-width : 667px) and (-webkit-min-device-pixel-ratio : 2){\n      html{\n      \tfont-size: 37.5px;\n      }\n}\n```\n<strong>2</strong> 利用javascript来动态设置 根据我们之前算出的基准值，我们可以利用js动态算出当前屏幕所适配的font-size即：\n```javasript\ndocument.getElementsByTagName('html')[0].style.fontSize = window.innerWidth / 10 + 'px';\n```\n然后我们看一下之前那个demo展示的效果\n```css\n.con {\n      width: px2rem(200px);\n      height: px2rem(200px);\n      background-color: red;\n}\n<div class=\"con\">\n        \n</div>\n```javascript\ndocument.addEventListener('DOMContentLoaded', function(e) {\n                document.getElementsByTagName('html')[0].style.fontSize = window.innerWidth / 10 + 'px';\n}, false);\n```\niPhone6下，正常显示200px\n\n<img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/div3.png\" alt=\"\" width=\"349\" height=\"321\" />\n\n在iphone4下，显示169px\n\n<img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/div4.png\" alt=\"\" width=\"320\" height=\"284\" />\n\n由此可见我们可以通过设置不同的html基础值来达到在不同页面适配的目的，当然在使用js来设置时，需要绑定页面的resize事件来达到变化时更新html的font-size。\n\n&nbsp;\n<h2><span style=\"color: #008000;\">rem适配进阶</span></h2>\n我们知道，一般我们获取到的视觉稿大部分是iphone6的，所以我们看到的尺寸一般是双倍大小的，在使用rem之前，我们一般会自觉的将标注/2，其实这也并无道理，但是当我们配合rem'使用时，完全可以按照视觉稿上的尺寸来设置。\n\n1 设计给的稿子双倍的原因是iphone6这种屏幕属于高清屏，也即是设备像素比(device pixel ratio)dpr比较大，所以显示的像素较为清晰。\n\n2 一般手机的dpr是1，iphone这种高清屏是2，可以通过js的window.devicePixelRatio获取到当前设备的dpr，所以iphone6给的视觉稿大小是（*2）750×1334了。\n\n3 拿到了dpr之后，我们就可以在viewport meta头里，取消让浏览器自动缩放页面，而自己去设置viewport的content例如\n```javascript\nmeta.setAttribute('content', 'initial-scale=' + 1/dpr + ', maximum-scale=' + 1/dpr + ', minimum-scale=' + 1/dpr + ', user-scalable=no');\n```\n4 设置完之后配合rem，修改\n```css\n@function px2rem($px){\n    $rem : 75px;\n    @return ($px/$rem) + rem;\n}\n```\n双倍75，这样就可以完全按照视觉稿上的尺寸来了。不用在/2了，这样做的好处是：\n\n1 解决了图片高清问题。\n\n2 解决了border 1px问题（我们设置的1px，在iphone上，由于viewport的scale是0.5，所以就自然缩放成0.5px）\n<h2><span style=\"color: #008000;\">rem进行屏幕适配总结</span></h2>\n下面这个网址是针对rem来写的一个简单的demo页面，大家可以在不同的手机上看一下效果\n\n<img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/democode.png\" alt=\"\" width=\"280\" height=\"280\" />\n\n但是rem也并不是万能的，下面也有一些场景是不适于使用rem的\n\n<strong> 1</strong> 当用作图片或者一些不能缩放的展示时，必须要使用固定的px值，因为缩放可能会导致图片压缩变形等。\n\n<strong> 2</strong> 再设置backgroundposition或者backgroundsize时不宜使用rem。\n\n在列举几个使用rem的线上网站：\n\n网易新闻：<a href=\"http://3g.163.com/touch/news/subchannel/all?version=v_standard\" target=\"_blank\">http://3g.163.com/touch/news/subchannel/all?version=v_standard</a>\n\n聚划算：<a href=\"https://jhs.m.taobao.com/m/index.htm#!all\" target=\"_blank\">https://jhs.m.taobao.com/m/index.htm#!all</a>","slug":"移动web适配之rem","published":1,"updated":"2017-04-27T13:21:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434q1n003u2wvjdauh9oxg","content":"<p></p><h2><span id=\"前言\"><span style=\"color: #008000;\">前言</span></span></h2><br>提到rem，大家首先会想到的是rm，px这类的词语，大多数人眼中这些单位是用于设置字体的大小的，没错这的确是用来设置字体大小的，但是对于rem来说它可以用来做移动端的响应式适配哦。<br><a id=\"more\"></a><br>&nbsp;<p></p>\n<p></p><h2><span id=\"兼容性\"><span style=\"color: #008000;\">兼容性</span></span></h2><br><img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/caniuse.png\" alt width=\"1270\" height=\"548\"> 先看看兼容性，大部分主流浏览器都支持，可以安心的往下看了。<p></p>\n<p>&nbsp;</p>\n<p></p><h2><span id=\"rem设置字体大小\"><span style=\"color: #008000;\">rem设置字体大小</span></span></h2><br>rem是<span style=\"color: #111111;\">（font size of the root element），官方解释</span><p></p>\n<p><span style=\"color: #111111;\"><img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/QQ%E5%9B%BE%E7%89%8720160313181850.png\" alt width=\"868\" height=\"129\">，</span></p>\n<p><span style=\"color: #111111;\">意思就是根据网页的跟元素来设置字体大小，和em（font size of the element）的区别是，em是根据其父元素的字体大小来设置，而rem是根据网页的跟元素（html）来设置字体大小的，举一个简单的例子，</span></p>\n<p><span style=\"color: #111111;\">现在大部分浏览器<span style=\"color: #4a4a4a;\">IE9+，Firefox、Chrome、Safari、Opera </span>，如果我们不修改相关的字体配置，都是默认显示font-size是16px即</span><br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span> &#123;    </span><br><span class=\"line\">\t<span class=\"attribute\">font-size</span>:<span class=\"number\">16px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>那么如果我们想给一个P标签设置12px的字体大小那么用rem来写就是<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">p</span> &#123;    </span><br><span class=\"line\">\tfont-size: 0.75rem; //12÷16=0.75（rem）</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>基本上使用rem这个单位来设置字体大小基本上是这个套路，好处是加入用户自己修改了浏览器的默认字体大小，那么使用rem时就可以根据用的调整的大小来显示了。 但是rem不仅可以适用于字体，同样可以用于width height margin这些样式的单位。下面来具体说一下</p>\n<p>&nbsp;</p>\n<p></p><h2><span id=\"rem进行屏幕适配\"><span style=\"color: #008000;\">rem进行屏幕适配</span></span></h2><br>在讲rem屏幕适配之前，先说一下一般做移动端适配的方法，一般可以分为： <strong>1</strong> 简单一点的页面，一般高度直接设置成固定值，宽度一般盛满整个屏幕。 <strong>2</strong> 稍复杂一些的是利用百分比设置元素的大小来进行适配，或者利用flex等css去设置一些需要定制的宽度。 <strong>3</strong> 再复杂负责一些的响应式页面，需要利用css3的media query属性来进行适配，大致思路是根据屏幕不同大小，来设置对应的css样式。 上面的一些方法，其实也可以解决屏幕适配等问题，但是既然出来的rem这个新东西，也一定能兼顾到这些方面，下面具体来说具体使用rem：<p></p>\n<p>&nbsp;</p>\n<p><strong>rem适配</strong></p>\n<p>&nbsp;</p>\n<p>先看一个简单的例子：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.con</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">width</span>: <span class=\"number\">10rem</span>;</span><br><span class=\"line\">      <span class=\"attribute\">height</span>: <span class=\"number\">10rem</span>;</span><br><span class=\"line\">      <span class=\"attribute\">background-color</span>: red;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&lt;div class=\"con\"&gt;</span><br><span class=\"line\">        </span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p><img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/div.png\" alt width=\"380\" height=\"231\"></p>\n<p>这是一个div，宽度和高度都用rem来设置了，在浏览器里面是这样显示的，  可以看到，在浏览器里面width和height分别是160px，正好是16px * 10,那么如果将html根元素的默认font-size修改一下呢？<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">17px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.con</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">width</span>: <span class=\"number\">10rem</span>;</span><br><span class=\"line\">      <span class=\"attribute\">height</span>: <span class=\"number\">10rem</span>;</span><br><span class=\"line\">      <span class=\"attribute\">background-color</span>: red;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&lt;div class=\"con\"&gt;</span><br><span class=\"line\">        </span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>再来看看结果：</p>\n<p><img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/div2.png\" alt width=\"386\" height=\"222\"></p>\n<p>这时width和height都是170px，这就说明了将rem应用与width和height时，同样适用与rem的特性，根据根元素的font-size值来改变自身的值，由此我们应该可以联想到我们可以给html设定不同的值，从而达到我们css样式中的适配效果。</p>\n<p>&nbsp;</p>\n<p><strong>rem数值计算</strong></p>\n<p>&nbsp;</p>\n<p>如果利用rem来设置css的值，一般要通过一层计算才行，比如如果要设置一个长宽为100px的div，那么就需要计算出100px对应的rem值是 100 / 16 =6.25rem，这在我们写css中，其实算比较繁琐的一步操作了，不过这其实都不是事。 想想我们现在的工程，哪个没有用构建的，前端构建中，完全可以利用scss来解决这个问题，例如我们可以写一个scss的function px2rem即：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">function</span> px2rem($px)&#123;</span><br><span class=\"line\">    $rem : 37.5px;</span><br><span class=\"line\">    @<span class=\"keyword\">return</span> ($px/$rem) + rem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样，当我们写具体数值的时候就可以写成：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">height</span>: <span class=\"selector-tag\">px2rem</span>(90<span class=\"selector-tag\">px</span>);</span><br><span class=\"line\"><span class=\"selector-tag\">width</span>: <span class=\"selector-tag\">px2rem</span>(90<span class=\"selector-tag\">px</span>);;</span><br></pre></td></tr></table></figure></p>\n<p>看到这里，你可能会发现一些不理解的地方，就是上面那个rem:37.5px是怎么来的，正常情况下不是默认的16px么，这个其实就是页面的基准值，和html的font-size有关。</p>\n<p>&nbsp;</p>\n<p><strong>rem基准值计算</strong></p>\n<p>&nbsp;</p>\n<p>关于rem的基准值，也就是上面那个37.5px其实是根据我们所拿到的视觉稿来决定的主要有以下几点原因：</p>\n<p><strong>1</strong> 由于我们所写出的页面是要在不同的屏幕大小设备上运行的</p>\n<p><strong>2</strong> 所以我们在写样式的时候必须要先已一个确定的屏幕来作为参考，这个就由我们拿到的视觉稿来定</p>\n<p><strong>3</strong> 假如我们拿到的视觉稿是以iphone6的屏幕为基准设计的</p>\n<p><strong>4</strong> iPhone6的屏幕大小是375px，</p>\n<p><pre class=\"lang:default decode:true\">rem = window.innerWidth  / 10</pre><br>这样计算出来的rem基准值就是37.5（iphone6的视觉稿），这里为什么要除以10呢，其实这个值是随便定义的，假如不除以10，根据我们算出来的基准值会偏大，这样在设置html的font-size时候会偏小，我们知道浏览器的font-size如果小于12px就显示不出效果了，在这里列举一下其他手机的</p>\n<p>iphone3gs: 320px / 10 = 32px</p>\n<p>iphone4/5: 320px  / 10 = 32px</p>\n<p>iphone6: 375px  / 10 =37.5px</p>\n<p>&nbsp;</p>\n<p><strong>动态设置html的font-size</strong></p>\n<p>&nbsp;</p>\n<p>现在关键问题来了，我们该如何通过不同的屏幕去动态设置html的font-size呢，这里一般分为两种办法</p>\n<p><strong>1</strong> 利用css的media query来设置即<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">media</span> (min-device-width : <span class=\"number\">375px</span>) and (max-device-width : <span class=\"number\">667px</span>) and (-webkit-min-device-pixel-ratio : <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">      <span class=\"selector-tag\">html</span>&#123;</span><br><span class=\"line\">      \t<span class=\"attribute\">font-size</span>: <span class=\"number\">37.5px</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>2</strong> 利用javascript来动态设置 根据我们之前算出的基准值，我们可以利用js动态算出当前屏幕所适配的font-size即：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.getElementsByTagName(&apos;html&apos;)[0].style.fontSize = window.innerWidth / 10 + &apos;px&apos;;</span><br></pre></td></tr></table></figure></p>\n<p>然后我们看一下之前那个demo展示的效果<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.con</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">width</span>: <span class=\"built_in\">px2rem</span>(200px);</span><br><span class=\"line\">      <span class=\"attribute\">height</span>: <span class=\"built_in\">px2rem</span>(200px);</span><br><span class=\"line\">      <span class=\"attribute\">background-color</span>: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;div class=\"con\"&gt;</span><br><span class=\"line\">        </span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">```<span class=\"selector-tag\">javascript</span></span><br><span class=\"line\">document.addEventListener('DOMContentLoaded', function(e) &#123;</span><br><span class=\"line\">                document.getElementsByTagName('html')[0].style.fontSize = window.innerWidth / 10 + 'px';</span><br><span class=\"line\">&#125;, <span class=\"selector-tag\">false</span>);</span><br></pre></td></tr></table></figure></p>\n<p>iPhone6下，正常显示200px</p>\n<p><img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/div3.png\" alt width=\"349\" height=\"321\"></p>\n<p>在iphone4下，显示169px</p>\n<p><img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/div4.png\" alt width=\"320\" height=\"284\"></p>\n<p>由此可见我们可以通过设置不同的html基础值来达到在不同页面适配的目的，当然在使用js来设置时，需要绑定页面的resize事件来达到变化时更新html的font-size。</p>\n<p>&nbsp;</p>\n<p></p><h2><span id=\"rem适配进阶\"><span style=\"color: #008000;\">rem适配进阶</span></span></h2><br>我们知道，一般我们获取到的视觉稿大部分是iphone6的，所以我们看到的尺寸一般是双倍大小的，在使用rem之前，我们一般会自觉的将标注/2，其实这也并无道理，但是当我们配合rem’使用时，完全可以按照视觉稿上的尺寸来设置。<p></p>\n<p>1 设计给的稿子双倍的原因是iphone6这种屏幕属于高清屏，也即是设备像素比(device pixel ratio)dpr比较大，所以显示的像素较为清晰。</p>\n<p>2 一般手机的dpr是1，iphone这种高清屏是2，可以通过js的window.devicePixelRatio获取到当前设备的dpr，所以iphone6给的视觉稿大小是（*2）750×1334了。</p>\n<p>3 拿到了dpr之后，我们就可以在viewport meta头里，取消让浏览器自动缩放页面，而自己去设置viewport的content例如<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">meta.setAttribute(<span class=\"string\">'content'</span>, <span class=\"string\">'initial-scale='</span> + <span class=\"number\">1</span>/dpr + <span class=\"string\">', maximum-scale='</span> + <span class=\"number\">1</span>/dpr + <span class=\"string\">', minimum-scale='</span> + <span class=\"number\">1</span>/dpr + <span class=\"string\">', user-scalable=no'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>4 设置完之后配合rem，修改<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">function</span> px2rem($px)&#123;</span><br><span class=\"line\">    $rem : 75px;</span><br><span class=\"line\">    @<span class=\"keyword\">return</span> ($px/$rem) + rem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>双倍75，这样就可以完全按照视觉稿上的尺寸来了。不用在/2了，这样做的好处是：</p>\n<p>1 解决了图片高清问题。</p>\n<p>2 解决了border 1px问题（我们设置的1px，在iphone上，由于viewport的scale是0.5，所以就自然缩放成0.5px）</p>\n<p></p><h2><span id=\"rem进行屏幕适配总结\"><span style=\"color: #008000;\">rem进行屏幕适配总结</span></span></h2><br>下面这个网址是针对rem来写的一个简单的demo页面，大家可以在不同的手机上看一下效果<p></p>\n<p><img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/democode.png\" alt width=\"280\" height=\"280\"></p>\n<p>但是rem也并不是万能的，下面也有一些场景是不适于使用rem的</p>\n<p><strong> 1</strong> 当用作图片或者一些不能缩放的展示时，必须要使用固定的px值，因为缩放可能会导致图片压缩变形等。</p>\n<p><strong> 2</strong> 再设置backgroundposition或者backgroundsize时不宜使用rem。</p>\n<p>在列举几个使用rem的线上网站：</p>\n<p>网易新闻：<a href=\"http://3g.163.com/touch/news/subchannel/all?version=v_standard\" target=\"_blank\">http://3g.163.com/touch/news/subchannel/all?version=v_standard</a></p>\n<p>聚划算：<a href=\"https://jhs.m.taobao.com/m/index.htm#!all\" target=\"_blank\">https://jhs.m.taobao.com/m/index.htm#!all</a></p>\n","site":{"data":{}},"excerpt":"<p></p><h2><span style=\"color: #008000;\">前言</span></h2><br>提到rem，大家首先会想到的是rm，px这类的词语，大多数人眼中这些单位是用于设置字体的大小的，没错这的确是用来设置字体大小的，但是对于rem来说它可以用来做移动端的响应式适配哦。<br>","more":"<br>&nbsp;<p></p>\n<p></p><h2><span style=\"color: #008000;\">兼容性</span></h2><br><img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/caniuse.png\" alt=\"\" width=\"1270\" height=\"548\"> 先看看兼容性，大部分主流浏览器都支持，可以安心的往下看了。<p></p>\n<p>&nbsp;</p>\n<p></p><h2><span style=\"color: #008000;\">rem设置字体大小</span></h2><br>rem是<span style=\"color: #111111;\">（font size of the root element），官方解释</span><p></p>\n<p><span style=\"color: #111111;\"><img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/QQ%E5%9B%BE%E7%89%8720160313181850.png\" alt=\"\" width=\"868\" height=\"129\">，</span></p>\n<p><span style=\"color: #111111;\">意思就是根据网页的跟元素来设置字体大小，和em（font size of the element）的区别是，em是根据其父元素的字体大小来设置，而rem是根据网页的跟元素（html）来设置字体大小的，举一个简单的例子，</span></p>\n<p><span style=\"color: #111111;\">现在大部分浏览器<span style=\"color: #4a4a4a;\">IE9+，Firefox、Chrome、Safari、Opera </span>，如果我们不修改相关的字体配置，都是默认显示font-size是16px即</span><br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span> &#123;    </span><br><span class=\"line\">\t<span class=\"attribute\">font-size</span>:<span class=\"number\">16px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>那么如果我们想给一个P标签设置12px的字体大小那么用rem来写就是<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">p</span> &#123;    </span><br><span class=\"line\">\tfont-size: 0.75rem; //12÷16=0.75（rem）</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>基本上使用rem这个单位来设置字体大小基本上是这个套路，好处是加入用户自己修改了浏览器的默认字体大小，那么使用rem时就可以根据用的调整的大小来显示了。 但是rem不仅可以适用于字体，同样可以用于width height margin这些样式的单位。下面来具体说一下</p>\n<p>&nbsp;</p>\n<p></p><h2><span style=\"color: #008000;\">rem进行屏幕适配</span></h2><br>在讲rem屏幕适配之前，先说一下一般做移动端适配的方法，一般可以分为： <strong>1</strong> 简单一点的页面，一般高度直接设置成固定值，宽度一般盛满整个屏幕。 <strong>2</strong> 稍复杂一些的是利用百分比设置元素的大小来进行适配，或者利用flex等css去设置一些需要定制的宽度。 <strong>3</strong> 再复杂负责一些的响应式页面，需要利用css3的media query属性来进行适配，大致思路是根据屏幕不同大小，来设置对应的css样式。 上面的一些方法，其实也可以解决屏幕适配等问题，但是既然出来的rem这个新东西，也一定能兼顾到这些方面，下面具体来说具体使用rem：<p></p>\n<p>&nbsp;</p>\n<p><strong>rem适配</strong></p>\n<p>&nbsp;</p>\n<p>先看一个简单的例子：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.con</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">width</span>: <span class=\"number\">10rem</span>;</span><br><span class=\"line\">      <span class=\"attribute\">height</span>: <span class=\"number\">10rem</span>;</span><br><span class=\"line\">      <span class=\"attribute\">background-color</span>: red;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&lt;div class=\"con\"&gt;</span><br><span class=\"line\">        </span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p><img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/div.png\" alt=\"\" width=\"380\" height=\"231\"></p>\n<p>这是一个div，宽度和高度都用rem来设置了，在浏览器里面是这样显示的，  可以看到，在浏览器里面width和height分别是160px，正好是16px * 10,那么如果将html根元素的默认font-size修改一下呢？<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">17px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.con</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">width</span>: <span class=\"number\">10rem</span>;</span><br><span class=\"line\">      <span class=\"attribute\">height</span>: <span class=\"number\">10rem</span>;</span><br><span class=\"line\">      <span class=\"attribute\">background-color</span>: red;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&lt;div class=\"con\"&gt;</span><br><span class=\"line\">        </span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>再来看看结果：</p>\n<p><img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/div2.png\" alt=\"\" width=\"386\" height=\"222\"></p>\n<p>这时width和height都是170px，这就说明了将rem应用与width和height时，同样适用与rem的特性，根据根元素的font-size值来改变自身的值，由此我们应该可以联想到我们可以给html设定不同的值，从而达到我们css样式中的适配效果。</p>\n<p>&nbsp;</p>\n<p><strong>rem数值计算</strong></p>\n<p>&nbsp;</p>\n<p>如果利用rem来设置css的值，一般要通过一层计算才行，比如如果要设置一个长宽为100px的div，那么就需要计算出100px对应的rem值是 100 / 16 =6.25rem，这在我们写css中，其实算比较繁琐的一步操作了，不过这其实都不是事。 想想我们现在的工程，哪个没有用构建的，前端构建中，完全可以利用scss来解决这个问题，例如我们可以写一个scss的function px2rem即：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">function</span> px2rem($px)&#123;</span><br><span class=\"line\">    $rem : 37.5px;</span><br><span class=\"line\">    @<span class=\"keyword\">return</span> ($px/$rem) + rem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样，当我们写具体数值的时候就可以写成：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">height</span>: <span class=\"selector-tag\">px2rem</span>(90<span class=\"selector-tag\">px</span>);</span><br><span class=\"line\"><span class=\"selector-tag\">width</span>: <span class=\"selector-tag\">px2rem</span>(90<span class=\"selector-tag\">px</span>);;</span><br></pre></td></tr></table></figure></p>\n<p>看到这里，你可能会发现一些不理解的地方，就是上面那个rem:37.5px是怎么来的，正常情况下不是默认的16px么，这个其实就是页面的基准值，和html的font-size有关。</p>\n<p>&nbsp;</p>\n<p><strong>rem基准值计算</strong></p>\n<p>&nbsp;</p>\n<p>关于rem的基准值，也就是上面那个37.5px其实是根据我们所拿到的视觉稿来决定的主要有以下几点原因：</p>\n<p><strong>1</strong> 由于我们所写出的页面是要在不同的屏幕大小设备上运行的</p>\n<p><strong>2</strong> 所以我们在写样式的时候必须要先已一个确定的屏幕来作为参考，这个就由我们拿到的视觉稿来定</p>\n<p><strong>3</strong> 假如我们拿到的视觉稿是以iphone6的屏幕为基准设计的</p>\n<p><strong>4</strong> iPhone6的屏幕大小是375px，</p>\n<p><pre class=\"lang:default decode:true\">rem = window.innerWidth  / 10</pre><br>这样计算出来的rem基准值就是37.5（iphone6的视觉稿），这里为什么要除以10呢，其实这个值是随便定义的，假如不除以10，根据我们算出来的基准值会偏大，这样在设置html的font-size时候会偏小，我们知道浏览器的font-size如果小于12px就显示不出效果了，在这里列举一下其他手机的</p>\n<p>iphone3gs: 320px / 10 = 32px</p>\n<p>iphone4/5: 320px  / 10 = 32px</p>\n<p>iphone6: 375px  / 10 =37.5px</p>\n<p>&nbsp;</p>\n<p><strong>动态设置html的font-size</strong></p>\n<p>&nbsp;</p>\n<p>现在关键问题来了，我们该如何通过不同的屏幕去动态设置html的font-size呢，这里一般分为两种办法</p>\n<p><strong>1</strong> 利用css的media query来设置即<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">media</span> (min-device-width : <span class=\"number\">375px</span>) and (max-device-width : <span class=\"number\">667px</span>) and (-webkit-min-device-pixel-ratio : <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">      <span class=\"selector-tag\">html</span>&#123;</span><br><span class=\"line\">      \t<span class=\"attribute\">font-size</span>: <span class=\"number\">37.5px</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>2</strong> 利用javascript来动态设置 根据我们之前算出的基准值，我们可以利用js动态算出当前屏幕所适配的font-size即：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.getElementsByTagName(&apos;html&apos;)[0].style.fontSize = window.innerWidth / 10 + &apos;px&apos;;</span><br></pre></td></tr></table></figure></p>\n<p>然后我们看一下之前那个demo展示的效果<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.con</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">width</span>: <span class=\"built_in\">px2rem</span>(200px);</span><br><span class=\"line\">      <span class=\"attribute\">height</span>: <span class=\"built_in\">px2rem</span>(200px);</span><br><span class=\"line\">      <span class=\"attribute\">background-color</span>: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;div class=\"con\"&gt;</span><br><span class=\"line\">        </span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">```<span class=\"selector-tag\">javascript</span></span><br><span class=\"line\">document.addEventListener('DOMContentLoaded', function(e) &#123;</span><br><span class=\"line\">                document.getElementsByTagName('html')[0].style.fontSize = window.innerWidth / 10 + 'px';</span><br><span class=\"line\">&#125;, <span class=\"selector-tag\">false</span>);</span><br></pre></td></tr></table></figure></p>\n<p>iPhone6下，正常显示200px</p>\n<p><img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/div3.png\" alt=\"\" width=\"349\" height=\"321\"></p>\n<p>在iphone4下，显示169px</p>\n<p><img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/div4.png\" alt=\"\" width=\"320\" height=\"284\"></p>\n<p>由此可见我们可以通过设置不同的html基础值来达到在不同页面适配的目的，当然在使用js来设置时，需要绑定页面的resize事件来达到变化时更新html的font-size。</p>\n<p>&nbsp;</p>\n<p></p><h2><span style=\"color: #008000;\">rem适配进阶</span></h2><br>我们知道，一般我们获取到的视觉稿大部分是iphone6的，所以我们看到的尺寸一般是双倍大小的，在使用rem之前，我们一般会自觉的将标注/2，其实这也并无道理，但是当我们配合rem’使用时，完全可以按照视觉稿上的尺寸来设置。<p></p>\n<p>1 设计给的稿子双倍的原因是iphone6这种屏幕属于高清屏，也即是设备像素比(device pixel ratio)dpr比较大，所以显示的像素较为清晰。</p>\n<p>2 一般手机的dpr是1，iphone这种高清屏是2，可以通过js的window.devicePixelRatio获取到当前设备的dpr，所以iphone6给的视觉稿大小是（*2）750×1334了。</p>\n<p>3 拿到了dpr之后，我们就可以在viewport meta头里，取消让浏览器自动缩放页面，而自己去设置viewport的content例如<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">meta.setAttribute(<span class=\"string\">'content'</span>, <span class=\"string\">'initial-scale='</span> + <span class=\"number\">1</span>/dpr + <span class=\"string\">', maximum-scale='</span> + <span class=\"number\">1</span>/dpr + <span class=\"string\">', minimum-scale='</span> + <span class=\"number\">1</span>/dpr + <span class=\"string\">', user-scalable=no'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>4 设置完之后配合rem，修改<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">function</span> px2rem($px)&#123;</span><br><span class=\"line\">    $rem : 75px;</span><br><span class=\"line\">    @<span class=\"keyword\">return</span> ($px/$rem) + rem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>双倍75，这样就可以完全按照视觉稿上的尺寸来了。不用在/2了，这样做的好处是：</p>\n<p>1 解决了图片高清问题。</p>\n<p>2 解决了border 1px问题（我们设置的1px，在iphone上，由于viewport的scale是0.5，所以就自然缩放成0.5px）</p>\n<p></p><h2><span style=\"color: #008000;\">rem进行屏幕适配总结</span></h2><br>下面这个网址是针对rem来写的一个简单的demo页面，大家可以在不同的手机上看一下效果<p></p>\n<p><img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/democode.png\" alt=\"\" width=\"280\" height=\"280\"></p>\n<p>但是rem也并不是万能的，下面也有一些场景是不适于使用rem的</p>\n<p><strong> 1</strong> 当用作图片或者一些不能缩放的展示时，必须要使用固定的px值，因为缩放可能会导致图片压缩变形等。</p>\n<p><strong> 2</strong> 再设置backgroundposition或者backgroundsize时不宜使用rem。</p>\n<p>在列举几个使用rem的线上网站：</p>\n<p>网易新闻：<a href=\"http://3g.163.com/touch/news/subchannel/all?version=v_standard\" target=\"_blank\">http://3g.163.com/touch/news/subchannel/all?version=v_standard</a></p>\n<p>聚划算：<a href=\"https://jhs.m.taobao.com/m/index.htm#!all\" target=\"_blank\">https://jhs.m.taobao.com/m/index.htm#!all</a></p>"},{"title":"移动web问题小结","date":"2014-10-11T09:02:14.000Z","_content":"本文主要收集一些移动web开发中常见的问题和解决办法，在日常的工作中遇到新的问题会不定时更新到文章中。<h3><span style=\"color: #008000;\">屏蔽阴影：</span></h3>\n```html\n-webkit-appearance:none\n```\n<p>亲测，可以同时屏蔽输入框怪异的内阴影，解决iOS下无法修改按钮样式，测试还发现一个小问题就是，加了上面的属性后，iOS下默认还是带有圆角的，不过可以使用 border-radius属性修改。  </p><h3><span style=\"color: #008000;\">Meta标签：</span></h3>\n<!--more-->\n```html\n<meta content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;\" name=\"viewport\" />\n```\n<p>这个想必大家都知道，当页面在手机上显示时，增加这个meta可以让页面强制让文档的宽度与设备的宽度保持1:1，并且文档最大的宽度比例是1.0，且不允许用户点击屏幕放大浏览。 <!--more--></p>\n```html\n<meta content=\"telephone=no\" name=\"format-detection\" />\n<meta content=\"email=no\" name=\"format-detection\" />\n```\n<p>这两个属性分别对ios上自动识别电话和android上自动识别邮箱做了限制。  </p><h3><span style=\"color: #008000;\"> 获取滚动条的值：</span></h3>\n```html\nwindow.scrollY  window.scrollX\n```\n<p>桌面浏览器中想要获取滚动条的值是通过document.scrollTop和document.scrollLeft得到的，但在iOS中你会发现这两个属性是未定义的，为什么呢？因为在iOS中没有滚动条的概念，在Android中通过这两个属性可以正常获取到滚动条的值，那么在iOS中我们该如何获取滚动条的值呢？就是上面两个属性，但是事实证明android也支持这属性，所以索性都用woindow.scroll.  </p><h3><span style=\"color: #008000;\">禁止选择文本：</span></h3>\n```html\n-webkit-user-select:none\n```\n<p>禁止用户选择文本，ios和android都支持  </p><h3> </h3><h3><span style=\"color: #006400;\"> css之border-box：</span></h3>\n```html\nelement{\n        width: 100%;\n        padding-left: 10px;\n        box-sizing:border-box;\n        -webkit-box-sizing:border-box;\n        border: 1px solid blue;\n}\n```\n<p><span style=\"color: #222222;\">那我想要一个元素100%显示，又必须有一个固定的padding-left／padding-right，还有1px的边框，怎么办？</span>这样编写代码必然导致出现横向滚动条，肿么办？要相信问题就是用来解决的。这时候伟大的css3为我们提供了box-sizing属性，对于这个属性的具体解释不做赘述（想深入了解的同学可以到w3school查看，要知道自己动手会更容易记忆）。让我们看看如何解决上面的问题：  </p><h3><span style=\"color: #006400;\"> css3多文本换行：</span></h3>```html\np {\n    overflow : hidden;\n    text-overflow: ellipsis;\n    display: -webkit-box;\n    -webkit-line-clamp: 2;\n    -webkit-box-orient: vertical;\n}```\n<p>Webkit支持一个名为-webkit-line-clamp的属性，参见<a href=\"http://developer.apple.com/safari/library/documentation/AppleApplications/Reference/SafariCSSRef/Articles/StandardCSSProperties.html#//apple_ref/doc/uid/TP30001266-UnsupportedProperties\">链接</a>，也就是说这个属性并不是标准的一部分，可能是Webkit内部使用的，或者被弃用的属性。需要注意的是display需要设置成box，-webkit-line-clamp表示需要显示几行。  </p><h3><span style=\"color: #006400;\"> Retina屏幕高清图片：</span></h3>\n```html\nselector {\n  background-image: url(no-image-set.png);\n  background: image-set(url(foo-lowres.png) 1x,url(foo-highres.png) 2x) center;\n}```\n<p>image-set的语法，类似于不同的文本，图像也会显示成不同的：</p><ol><li> <strong>不支持image-set</strong>：在不支持image-set的浏览器下，他会支持background-image图像，也就是说不支持image-set的浏览器下，他们解析background-image中的背景图像；</li><li> <strong>支持image-set</strong>：如果你的浏览器支持image-sete，而且是普通显屏下，此时浏览器会选择image-set中的@1x背景图像；</li><li> <strong>Retina屏幕下的image-set</strong>：如果你的浏览器支持image-set，而且是在Retina屏幕下，此时浏览器会选择image-set中的@2x背景图像。</li></ol><p>&nbsp;</p><h3><strong> </strong></h3><h3><span style=\"color: #006400;\"> html5重力感应事件：</span></h3>\n```html\nif (window.DeviceMotionEvent) { \n         window.addEventListener('devicemotion',deviceMotionHandler, false);  \n} \nvar speed = 30;//speed\nvar x = y = z = lastX = lastY = lastZ = 0;\nfunction deviceMotionHandler(eventData) {  \n  var acceleration =event.accelerationIncludingGravity;\n        x = acceleration.x;\n        y = acceleration.y;\n        z = acceleration.z;\n        if(Math.abs(x-lastX) > speed || Math.abs(y-lastY) > speed || Math.abs(z-lastZ) > speed) {\n            //简单的摇一摇触发代码\n            alert(1);\n        }\n        lastX = x;\n        lastY = y;\n        lastZ = z;\n}\n```\n<p>关于deviceMotionEvent是HTML5新增的事件，用来检测手机重力感应效果具体可参考<a href=\"http://w3c.github.io/deviceorientation/spec-source-orientation.html\" target=\"_blank\">http://w3c.github.io/deviceorientation/spec-source-orientation.html</a>  </p><h3><span style=\"color: #006400;\">移动端touch事件：</span></h3><ul><li>touchstart //当手指接触屏幕时触发</li><li>touchmove //当已经接触屏幕的手指开始移动后触发</li><li>touchend //当手指离开屏幕时触发</li><li>touchcancel//当某种touch事件非正常结束时触发</li></ul><p>这4个事件的触发顺序为： touchstart -> touchmove ->  touchend ->touchcancel 对于某些android系统touch的bug: 比如手指在屏幕由上向下拖动页面时，理论上是会触发 一个 touchstart ，很多次 touchmove ，和最终的 touchend ，可是在android 4.0上，touchmove只被触发一次，触发时间和touchstart 差不多，而touchend直接没有被触发。这是一个非常严重的bug，在<a href=\"http://code.google.com/p/android/issues/detail?id=19827\" target=\"_blank\">google Issue</a>已有不少人提出 ,这个很蛋疼的bug是在模拟下拉刷新是遇到的尤其当touchmove的dom节点数量变多时比出现，当时解决办法就是用settimeout来稀释touchmove。  </p><h3><span style=\"color: #006400;\">单击延迟：</span></h3><p>click 事件因为要等待双击确认，会有 300ms 的延迟，体验并不是很好。 开发者大多数会使用封装的 tap 事件来代替click 事件，所谓的 tap 事件由 touchstart 事件 + touchmove 判断 + touchend 事件封装组成。 <a style=\"color: #4183c4;\" title=\"article5\" href=\"https://developers.google.com/mobile/articles/fast_buttons?hl=de-DE\">Creating Fast Buttons for Mobile Web Applications</a> <a style=\"color: #4183c4;\" title=\"article5\" href=\"http://stackoverflow.com/questions/12238587/eliminate-300ms-delay-on-click-events-in-mobile-safari\">Eliminate 300ms delay on click events in mobile Safari</a>  </p><h3><span style=\"color: #006400;\">IOS里面fixed的文本框焦点居中</span></h3>\n```html\n<!DOCTYPE html>\n    <head>\n    input {\n       position:fixed;\n       top:0;left:0;\n    }\n    </head>\n    <body>\n        <div class=\"header\">\n            <form action=\"\">\n                <label>Testfield: <input type=\"text\" /></label>\n            </form>\n        </div>\n    </body>\n</html>\n```\n<p>在ios里面，当一个文本框的样式为fixed时候，如果这个文本框获得焦点，它的位置就会乱掉，由于ios里面做了自适应居中，这个fixed的文本框会跑到页面中间。类似： <img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/111030pvtt0t0nfen6tef4.png\" alt=\"\" width=\"242\" height=\"364\" />   <strong>解决办法有两个：</strong> 可以在文本框获得焦点的时候将fixed改为absolute，失去焦点时在改回fixed，但是这样会让屏幕有上下滑动的体验不太好。</p>\n```html\n.fixfixed {\n    position:absolute;\n}\n$(document)\n    .on('focus', 'input', function(e) {\n        $this.addClass('fixfixed');\n    })\n    .on('blur', 'input', function(e) {\n        $this.removeClass('fixfixed');\n    });\n```\n<p>  还有一种就是用一个假的fixed的文本框放在页面顶部，一个absolute的文本框隐藏在页面顶部，当fixed的文本框获得焦点时候将其隐藏，然后显示absolute的文本框，当失去焦点时，在把absolute的文本框隐藏，fixed的文本框显示。</p>\n```html\n.fixfixed {\n    position:absolute;\n}\n$(document)\n    .on('focus', 'input', function(e) {\n        $absolute..show();\n        $this.hide();\n    })\n    .on('blur', 'input', function(e) {\n         $fixed..show();\n        $this.hide();\n    });\n```\n<p>  最后一种就是顶部的input不参与滚动，只让其下面滚动。  </p><h3><span style=\"color: #006400;\">position:sticky</span></h3><p><span style=\"color: #444444;\">position:sticky是一个新的css3属性，它的表现类似position:relative和position:fixed的合体，在目标区域在屏幕中可见时，它的行为就像position:relative; 而当页面滚动超出目标区域时，它的表现就像position:fixed，它会固定在目标位置。</span></p>\n```html\n.sticky { \n    position: -webkit-sticky; \n    position:sticky; \n    top: 15px; \n}\n```\n<p><span style=\"color: #444444;\"><strong>浏览器兼容性</strong>：</span> 由于这是一个全新的属性，以至于到现在都没有一个规范，W3C也刚刚开始讨论它，而现在只有webkit nightly版本和chrome 开发版(Chrome 23.0.1247.0+ Canary)才开始支持它。 另外需要注意的是，如果同时定义了left和right值，那么left生效，right会无效，同样，同时定义了top和bottom，top赢～～ <strong><span style=\"color: #006400;\">移动端点透事件</span></strong> 简单的说，由于在移动端我们经常会使用tap(touchstart)事件来替换掉click事件，那么就会有一种场景是：</p>\n```html\n<div id=\"mengceng\"></div>\n\n<a href=\"www.qq.com\">www.qq.com</a>\n```\n<p>div是绝对定位的蒙层z-index高于a，而a标签是页面中的一个链接，我们给div绑定tap事件：</p>\n```html\n$('#mengceng').on('tap',function(){\n$('#mengceng').hide();\n});\n```\n<p>我们点击蒙层时 div正常消失，但是当我们在a标签上点击蒙层时，发现a链接被触发，这就是所谓的点透事件。 原因： <span style=\"background-color: #f5f8fd; color: #000000; font-family: arial,宋体; font-size: 14px;\">touchstart 早于 touchend 早于 click。亦即click的触发是有延迟的，这个时间大概在300ms左右，也就是说我们tap触发之后蒙层隐藏，此时click还没有触发，300ms之后由于蒙层隐藏，我们的click触发到了下面的a链接上。</span> 解决办法： 1 尽量都使用touch事件来替换click事件。 2 阻止a链接的click的preventDefault   <strong><span style=\"color: #006400;\">base64编码图片替换url图片</span></strong> u在移动端，网络请求是很珍贵的资源，尤其在2g或者3g网络下，所以能不发请求的资源都尽量不要发，对于一些小图片icon之类的，可以将图片用base64编码，来减少网络请求。  </p><h4><span style=\"color: #006400;\">手机拍照和上传图片</span></h4><p><input type=\"file\">的accept 属性</p>\n```html\n<!-- 选择照片 -->\n<input type=file accept=\"image/*\">\n<!-- 选择视频 -->\n<input type=file accept=\"video/*\">\n```\n<p>  <strong><span style=\"color: #006400;\">动画效果时开启硬件加速</span></strong> 我们在制作动画效果时经常会想要改版元素的top或者left来让元素动起来，在pc端还好但是移动端就会有较大的卡顿感，这么我们需要使用css3的  transform: translate3d;来替换， 此效果可以让浏览器开启<a href=\"http://www.cnblogs.com/PeunZhang/p/3510083.html\">gpu</a>加速，渲染更流畅，但是笔着实验时在ios上体验良好，但在一些低端android机型可能会出现意想不到的效果。  </p><h4><span style=\"color: #006400;\">快速回弹滚动</span></h4><p>在iOS上如果你想让一个元素拥有像 Native 的滚动效果，你可以这样做：</p>\n```html\n.div {\n        overflow: auto;\n        -webkit-overflow-scrolling: touch;\n    }\n```\n<p>经笔着测试，此效果在不同的ios系统表现不一致， 对于局部滚动，ios8以上，不加此效果，滚动的超级慢，ios8一下，不加此效果，滚动还算比较流畅 对于body滚动，ios8以上，不加此效果同样拥有弹性滚动效果。  </p>\n<h4><span style=\"color: #006400;\">ios和android局部滚动时隐藏原生滚动条</span></h4>\n<p>android</p>\n```css\n::-webkit-scrollbar{\n    opacity: 0;\n}\n\n<p>ios 使用一个稍微高一些div包裹住这个有滚动条的div然后设置overflow:hidden挡住之</p>\n```css\n.wrap{\n    height: 100px;\n    overflow: hidden;\n}\n.box{\n    width: 100%;\n    height: -webkit-calc(100% + 5px);\n    overflow-x: auto;\n    overflow-y: hidden;\n    -webkit-overflow-scrolling: touch;\n}\n<div class=\"wrap\">\n    <div class=\"box\"></div>\n</div>\n```\n<h4><span style=\"color: #006400;\">设置placeholder时候 focus时候文字没有隐藏</span></h4>\n\n```css\ninput:focus::-webkit-input-placeholder{\n    opacity: 0;\n}\n```\n<h4><span style=\"color: #006400;\">移动端不同的input对应不同的键盘展示样式</span></h4><p>ios ---- android type email <img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/QQ截图20150830183824.png\" alt=\"\" width=\"868\" height=\"288\" /> type url <img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/QQ截图20150830184045.png\" alt=\"\" width=\"646\" height=\"441\" /> type tel <img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/QQ截图20150830184138.png\" alt=\"\" width=\"873\" height=\"292\" /> type search <img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/QQ截图20150830184250.png\" alt=\"\" width=\"316\" height=\"324\" />  </p><h4><span style=\"color: #006400;\">background-image和image的加载区别</span></h4><p><span style=\"color: #000000;\">在网页加载的过程中，以css背景图存在的图片background-image会等到结构加载完成（网页的内容全部显示以后）才开始加载，而html中的</span><span style=\"color: #323e32;\"><span style=\"color: #000000;\">标签img是网页结构（内容）的一部分会在加载结构的过程中加载，换句话讲，网页会先加载</span><span style=\"color: #000000;\">标签img的内容，再加载背景图片background-image，如果你用</span><span style=\"color: #000000;\">引入了一个很大的图片，那么在这个图片下载完成之前，img</span><span style=\"color: #000000;\">后的内容都不会显示。而如果用css来引入同样的图片，网页结构和内容加载完成之后，才开始加载背景图片，不会影响你浏览网页内容。</span></span> 未完待续 参考资料：<a href=\"http://www.nihaoshijie.com.cn/index.php/archives/455\">http://www.nihaoshijie.com.cn/index.php/archives/455</a></p>","source":"_posts/移动web问题小结.md","raw":"---\ntitle: 移动web问题小结\ndate: 2014-10-11 17:02:14\ntags:\n- 移动web\n- HTML5\ncategories:\n- 455\n---\n本文主要收集一些移动web开发中常见的问题和解决办法，在日常的工作中遇到新的问题会不定时更新到文章中。<h3><span style=\"color: #008000;\">屏蔽阴影：</span></h3>\n```html\n-webkit-appearance:none\n```\n<p>亲测，可以同时屏蔽输入框怪异的内阴影，解决iOS下无法修改按钮样式，测试还发现一个小问题就是，加了上面的属性后，iOS下默认还是带有圆角的，不过可以使用 border-radius属性修改。  </p><h3><span style=\"color: #008000;\">Meta标签：</span></h3>\n<!--more-->\n```html\n<meta content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;\" name=\"viewport\" />\n```\n<p>这个想必大家都知道，当页面在手机上显示时，增加这个meta可以让页面强制让文档的宽度与设备的宽度保持1:1，并且文档最大的宽度比例是1.0，且不允许用户点击屏幕放大浏览。 <!--more--></p>\n```html\n<meta content=\"telephone=no\" name=\"format-detection\" />\n<meta content=\"email=no\" name=\"format-detection\" />\n```\n<p>这两个属性分别对ios上自动识别电话和android上自动识别邮箱做了限制。  </p><h3><span style=\"color: #008000;\"> 获取滚动条的值：</span></h3>\n```html\nwindow.scrollY  window.scrollX\n```\n<p>桌面浏览器中想要获取滚动条的值是通过document.scrollTop和document.scrollLeft得到的，但在iOS中你会发现这两个属性是未定义的，为什么呢？因为在iOS中没有滚动条的概念，在Android中通过这两个属性可以正常获取到滚动条的值，那么在iOS中我们该如何获取滚动条的值呢？就是上面两个属性，但是事实证明android也支持这属性，所以索性都用woindow.scroll.  </p><h3><span style=\"color: #008000;\">禁止选择文本：</span></h3>\n```html\n-webkit-user-select:none\n```\n<p>禁止用户选择文本，ios和android都支持  </p><h3> </h3><h3><span style=\"color: #006400;\"> css之border-box：</span></h3>\n```html\nelement{\n        width: 100%;\n        padding-left: 10px;\n        box-sizing:border-box;\n        -webkit-box-sizing:border-box;\n        border: 1px solid blue;\n}\n```\n<p><span style=\"color: #222222;\">那我想要一个元素100%显示，又必须有一个固定的padding-left／padding-right，还有1px的边框，怎么办？</span>这样编写代码必然导致出现横向滚动条，肿么办？要相信问题就是用来解决的。这时候伟大的css3为我们提供了box-sizing属性，对于这个属性的具体解释不做赘述（想深入了解的同学可以到w3school查看，要知道自己动手会更容易记忆）。让我们看看如何解决上面的问题：  </p><h3><span style=\"color: #006400;\"> css3多文本换行：</span></h3>```html\np {\n    overflow : hidden;\n    text-overflow: ellipsis;\n    display: -webkit-box;\n    -webkit-line-clamp: 2;\n    -webkit-box-orient: vertical;\n}```\n<p>Webkit支持一个名为-webkit-line-clamp的属性，参见<a href=\"http://developer.apple.com/safari/library/documentation/AppleApplications/Reference/SafariCSSRef/Articles/StandardCSSProperties.html#//apple_ref/doc/uid/TP30001266-UnsupportedProperties\">链接</a>，也就是说这个属性并不是标准的一部分，可能是Webkit内部使用的，或者被弃用的属性。需要注意的是display需要设置成box，-webkit-line-clamp表示需要显示几行。  </p><h3><span style=\"color: #006400;\"> Retina屏幕高清图片：</span></h3>\n```html\nselector {\n  background-image: url(no-image-set.png);\n  background: image-set(url(foo-lowres.png) 1x,url(foo-highres.png) 2x) center;\n}```\n<p>image-set的语法，类似于不同的文本，图像也会显示成不同的：</p><ol><li> <strong>不支持image-set</strong>：在不支持image-set的浏览器下，他会支持background-image图像，也就是说不支持image-set的浏览器下，他们解析background-image中的背景图像；</li><li> <strong>支持image-set</strong>：如果你的浏览器支持image-sete，而且是普通显屏下，此时浏览器会选择image-set中的@1x背景图像；</li><li> <strong>Retina屏幕下的image-set</strong>：如果你的浏览器支持image-set，而且是在Retina屏幕下，此时浏览器会选择image-set中的@2x背景图像。</li></ol><p>&nbsp;</p><h3><strong> </strong></h3><h3><span style=\"color: #006400;\"> html5重力感应事件：</span></h3>\n```html\nif (window.DeviceMotionEvent) { \n         window.addEventListener('devicemotion',deviceMotionHandler, false);  \n} \nvar speed = 30;//speed\nvar x = y = z = lastX = lastY = lastZ = 0;\nfunction deviceMotionHandler(eventData) {  \n  var acceleration =event.accelerationIncludingGravity;\n        x = acceleration.x;\n        y = acceleration.y;\n        z = acceleration.z;\n        if(Math.abs(x-lastX) > speed || Math.abs(y-lastY) > speed || Math.abs(z-lastZ) > speed) {\n            //简单的摇一摇触发代码\n            alert(1);\n        }\n        lastX = x;\n        lastY = y;\n        lastZ = z;\n}\n```\n<p>关于deviceMotionEvent是HTML5新增的事件，用来检测手机重力感应效果具体可参考<a href=\"http://w3c.github.io/deviceorientation/spec-source-orientation.html\" target=\"_blank\">http://w3c.github.io/deviceorientation/spec-source-orientation.html</a>  </p><h3><span style=\"color: #006400;\">移动端touch事件：</span></h3><ul><li>touchstart //当手指接触屏幕时触发</li><li>touchmove //当已经接触屏幕的手指开始移动后触发</li><li>touchend //当手指离开屏幕时触发</li><li>touchcancel//当某种touch事件非正常结束时触发</li></ul><p>这4个事件的触发顺序为： touchstart -> touchmove ->  touchend ->touchcancel 对于某些android系统touch的bug: 比如手指在屏幕由上向下拖动页面时，理论上是会触发 一个 touchstart ，很多次 touchmove ，和最终的 touchend ，可是在android 4.0上，touchmove只被触发一次，触发时间和touchstart 差不多，而touchend直接没有被触发。这是一个非常严重的bug，在<a href=\"http://code.google.com/p/android/issues/detail?id=19827\" target=\"_blank\">google Issue</a>已有不少人提出 ,这个很蛋疼的bug是在模拟下拉刷新是遇到的尤其当touchmove的dom节点数量变多时比出现，当时解决办法就是用settimeout来稀释touchmove。  </p><h3><span style=\"color: #006400;\">单击延迟：</span></h3><p>click 事件因为要等待双击确认，会有 300ms 的延迟，体验并不是很好。 开发者大多数会使用封装的 tap 事件来代替click 事件，所谓的 tap 事件由 touchstart 事件 + touchmove 判断 + touchend 事件封装组成。 <a style=\"color: #4183c4;\" title=\"article5\" href=\"https://developers.google.com/mobile/articles/fast_buttons?hl=de-DE\">Creating Fast Buttons for Mobile Web Applications</a> <a style=\"color: #4183c4;\" title=\"article5\" href=\"http://stackoverflow.com/questions/12238587/eliminate-300ms-delay-on-click-events-in-mobile-safari\">Eliminate 300ms delay on click events in mobile Safari</a>  </p><h3><span style=\"color: #006400;\">IOS里面fixed的文本框焦点居中</span></h3>\n```html\n<!DOCTYPE html>\n    <head>\n    input {\n       position:fixed;\n       top:0;left:0;\n    }\n    </head>\n    <body>\n        <div class=\"header\">\n            <form action=\"\">\n                <label>Testfield: <input type=\"text\" /></label>\n            </form>\n        </div>\n    </body>\n</html>\n```\n<p>在ios里面，当一个文本框的样式为fixed时候，如果这个文本框获得焦点，它的位置就会乱掉，由于ios里面做了自适应居中，这个fixed的文本框会跑到页面中间。类似： <img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/111030pvtt0t0nfen6tef4.png\" alt=\"\" width=\"242\" height=\"364\" />   <strong>解决办法有两个：</strong> 可以在文本框获得焦点的时候将fixed改为absolute，失去焦点时在改回fixed，但是这样会让屏幕有上下滑动的体验不太好。</p>\n```html\n.fixfixed {\n    position:absolute;\n}\n$(document)\n    .on('focus', 'input', function(e) {\n        $this.addClass('fixfixed');\n    })\n    .on('blur', 'input', function(e) {\n        $this.removeClass('fixfixed');\n    });\n```\n<p>  还有一种就是用一个假的fixed的文本框放在页面顶部，一个absolute的文本框隐藏在页面顶部，当fixed的文本框获得焦点时候将其隐藏，然后显示absolute的文本框，当失去焦点时，在把absolute的文本框隐藏，fixed的文本框显示。</p>\n```html\n.fixfixed {\n    position:absolute;\n}\n$(document)\n    .on('focus', 'input', function(e) {\n        $absolute..show();\n        $this.hide();\n    })\n    .on('blur', 'input', function(e) {\n         $fixed..show();\n        $this.hide();\n    });\n```\n<p>  最后一种就是顶部的input不参与滚动，只让其下面滚动。  </p><h3><span style=\"color: #006400;\">position:sticky</span></h3><p><span style=\"color: #444444;\">position:sticky是一个新的css3属性，它的表现类似position:relative和position:fixed的合体，在目标区域在屏幕中可见时，它的行为就像position:relative; 而当页面滚动超出目标区域时，它的表现就像position:fixed，它会固定在目标位置。</span></p>\n```html\n.sticky { \n    position: -webkit-sticky; \n    position:sticky; \n    top: 15px; \n}\n```\n<p><span style=\"color: #444444;\"><strong>浏览器兼容性</strong>：</span> 由于这是一个全新的属性，以至于到现在都没有一个规范，W3C也刚刚开始讨论它，而现在只有webkit nightly版本和chrome 开发版(Chrome 23.0.1247.0+ Canary)才开始支持它。 另外需要注意的是，如果同时定义了left和right值，那么left生效，right会无效，同样，同时定义了top和bottom，top赢～～ <strong><span style=\"color: #006400;\">移动端点透事件</span></strong> 简单的说，由于在移动端我们经常会使用tap(touchstart)事件来替换掉click事件，那么就会有一种场景是：</p>\n```html\n<div id=\"mengceng\"></div>\n\n<a href=\"www.qq.com\">www.qq.com</a>\n```\n<p>div是绝对定位的蒙层z-index高于a，而a标签是页面中的一个链接，我们给div绑定tap事件：</p>\n```html\n$('#mengceng').on('tap',function(){\n$('#mengceng').hide();\n});\n```\n<p>我们点击蒙层时 div正常消失，但是当我们在a标签上点击蒙层时，发现a链接被触发，这就是所谓的点透事件。 原因： <span style=\"background-color: #f5f8fd; color: #000000; font-family: arial,宋体; font-size: 14px;\">touchstart 早于 touchend 早于 click。亦即click的触发是有延迟的，这个时间大概在300ms左右，也就是说我们tap触发之后蒙层隐藏，此时click还没有触发，300ms之后由于蒙层隐藏，我们的click触发到了下面的a链接上。</span> 解决办法： 1 尽量都使用touch事件来替换click事件。 2 阻止a链接的click的preventDefault   <strong><span style=\"color: #006400;\">base64编码图片替换url图片</span></strong> u在移动端，网络请求是很珍贵的资源，尤其在2g或者3g网络下，所以能不发请求的资源都尽量不要发，对于一些小图片icon之类的，可以将图片用base64编码，来减少网络请求。  </p><h4><span style=\"color: #006400;\">手机拍照和上传图片</span></h4><p><input type=\"file\">的accept 属性</p>\n```html\n<!-- 选择照片 -->\n<input type=file accept=\"image/*\">\n<!-- 选择视频 -->\n<input type=file accept=\"video/*\">\n```\n<p>  <strong><span style=\"color: #006400;\">动画效果时开启硬件加速</span></strong> 我们在制作动画效果时经常会想要改版元素的top或者left来让元素动起来，在pc端还好但是移动端就会有较大的卡顿感，这么我们需要使用css3的  transform: translate3d;来替换， 此效果可以让浏览器开启<a href=\"http://www.cnblogs.com/PeunZhang/p/3510083.html\">gpu</a>加速，渲染更流畅，但是笔着实验时在ios上体验良好，但在一些低端android机型可能会出现意想不到的效果。  </p><h4><span style=\"color: #006400;\">快速回弹滚动</span></h4><p>在iOS上如果你想让一个元素拥有像 Native 的滚动效果，你可以这样做：</p>\n```html\n.div {\n        overflow: auto;\n        -webkit-overflow-scrolling: touch;\n    }\n```\n<p>经笔着测试，此效果在不同的ios系统表现不一致， 对于局部滚动，ios8以上，不加此效果，滚动的超级慢，ios8一下，不加此效果，滚动还算比较流畅 对于body滚动，ios8以上，不加此效果同样拥有弹性滚动效果。  </p>\n<h4><span style=\"color: #006400;\">ios和android局部滚动时隐藏原生滚动条</span></h4>\n<p>android</p>\n```css\n::-webkit-scrollbar{\n    opacity: 0;\n}\n\n<p>ios 使用一个稍微高一些div包裹住这个有滚动条的div然后设置overflow:hidden挡住之</p>\n```css\n.wrap{\n    height: 100px;\n    overflow: hidden;\n}\n.box{\n    width: 100%;\n    height: -webkit-calc(100% + 5px);\n    overflow-x: auto;\n    overflow-y: hidden;\n    -webkit-overflow-scrolling: touch;\n}\n<div class=\"wrap\">\n    <div class=\"box\"></div>\n</div>\n```\n<h4><span style=\"color: #006400;\">设置placeholder时候 focus时候文字没有隐藏</span></h4>\n\n```css\ninput:focus::-webkit-input-placeholder{\n    opacity: 0;\n}\n```\n<h4><span style=\"color: #006400;\">移动端不同的input对应不同的键盘展示样式</span></h4><p>ios ---- android type email <img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/QQ截图20150830183824.png\" alt=\"\" width=\"868\" height=\"288\" /> type url <img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/QQ截图20150830184045.png\" alt=\"\" width=\"646\" height=\"441\" /> type tel <img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/QQ截图20150830184138.png\" alt=\"\" width=\"873\" height=\"292\" /> type search <img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/QQ截图20150830184250.png\" alt=\"\" width=\"316\" height=\"324\" />  </p><h4><span style=\"color: #006400;\">background-image和image的加载区别</span></h4><p><span style=\"color: #000000;\">在网页加载的过程中，以css背景图存在的图片background-image会等到结构加载完成（网页的内容全部显示以后）才开始加载，而html中的</span><span style=\"color: #323e32;\"><span style=\"color: #000000;\">标签img是网页结构（内容）的一部分会在加载结构的过程中加载，换句话讲，网页会先加载</span><span style=\"color: #000000;\">标签img的内容，再加载背景图片background-image，如果你用</span><span style=\"color: #000000;\">引入了一个很大的图片，那么在这个图片下载完成之前，img</span><span style=\"color: #000000;\">后的内容都不会显示。而如果用css来引入同样的图片，网页结构和内容加载完成之后，才开始加载背景图片，不会影响你浏览网页内容。</span></span> 未完待续 参考资料：<a href=\"http://www.nihaoshijie.com.cn/index.php/archives/455\">http://www.nihaoshijie.com.cn/index.php/archives/455</a></p>","slug":"移动web问题小结","published":1,"updated":"2021-12-10T16:08:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx434q1s003x2wvjx13gxby8","content":"<p>本文主要收集一些移动web开发中常见的问题和解决办法，在日常的工作中遇到新的问题会不定时更新到文章中。</p><h3><span id=\"屏蔽阴影\"><span style=\"color: #008000;\">屏蔽阴影：</span></span></h3><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-webkit-appearance:none</span><br></pre></td></tr></table></figure><p></p>\n<p>亲测，可以同时屏蔽输入框怪异的内阴影，解决iOS下无法修改按钮样式，测试还发现一个小问题就是，加了上面的属性后，iOS下默认还是带有圆角的，不过可以使用 border-radius属性修改。  </p><h3><span id=\"meta标签\"><span style=\"color: #008000;\">Meta标签：</span></span></h3><br><a id=\"more\"></a><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> /&gt;</span></span><br></pre></td></tr></table></figure><br><br><p>这个想必大家都知道，当页面在手机上显示时，增加这个meta可以让页面强制让文档的宽度与设备的宽度保持1:1，并且文档最大的宽度比例是1.0，且不允许用户点击屏幕放大浏览。 <!--more--></p><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">content</span>=<span class=\"string\">\"telephone=no\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"format-detection\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">content</span>=<span class=\"string\">\"email=no\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"format-detection\"</span> /&gt;</span></span><br></pre></td></tr></table></figure><br><br><p>这两个属性分别对ios上自动识别电话和android上自动识别邮箱做了限制。  </p><h3><span id=\"获取滚动条的值\"><span style=\"color: #008000;\"> 获取滚动条的值：</span></span></h3><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.scrollY  window.scrollX</span><br></pre></td></tr></table></figure><br><br><p>桌面浏览器中想要获取滚动条的值是通过document.scrollTop和document.scrollLeft得到的，但在iOS中你会发现这两个属性是未定义的，为什么呢？因为在iOS中没有滚动条的概念，在Android中通过这两个属性可以正常获取到滚动条的值，那么在iOS中我们该如何获取滚动条的值呢？就是上面两个属性，但是事实证明android也支持这属性，所以索性都用woindow.scroll.  </p><h3><span id=\"禁止选择文本\"><span style=\"color: #008000;\">禁止选择文本：</span></span></h3><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-webkit-user-select:none</span><br></pre></td></tr></table></figure><br><br><p>禁止用户选择文本，ios和android都支持  </p><h3><span id> </span></h3><h3><span id=\"css之border-box\"><span style=\"color: #006400;\"> css之border-box：</span></span></h3><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">element&#123;</span><br><span class=\"line\">        width: 100%;</span><br><span class=\"line\">        padding-left: 10px;</span><br><span class=\"line\">        box-sizing:border-box;</span><br><span class=\"line\">        -webkit-box-sizing:border-box;</span><br><span class=\"line\">        border: 1px solid blue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br><p><span style=\"color: #222222;\">那我想要一个元素100%显示，又必须有一个固定的padding-left／padding-right，还有1px的边框，怎么办？</span>这样编写代码必然导致出现横向滚动条，肿么办？要相信问题就是用来解决的。这时候伟大的css3为我们提供了box-sizing属性，对于这个属性的具体解释不做赘述（想深入了解的同学可以到w3school查看，要知道自己动手会更容易记忆）。让我们看看如何解决上面的问题：  </p><h3><span id=\"css3多文本换行\"><span style=\"color: #006400;\"> css3多文本换行：</span></span></h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p &#123;</span><br><span class=\"line\">    overflow : hidden;</span><br><span class=\"line\">    text-overflow: ellipsis;</span><br><span class=\"line\">    display: -webkit-box;</span><br><span class=\"line\">    -webkit-line-clamp: 2;</span><br><span class=\"line\">    -webkit-box-orient: vertical;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br><p>Webkit支持一个名为-webkit-line-clamp的属性，参见<a href=\"http://developer.apple.com/safari/library/documentation/AppleApplications/Reference/SafariCSSRef/Articles/StandardCSSProperties.html#//apple_ref/doc/uid/TP30001266-UnsupportedProperties\" target=\"_blank\" rel=\"noopener\">链接</a>，也就是说这个属性并不是标准的一部分，可能是Webkit内部使用的，或者被弃用的属性。需要注意的是display需要设置成box，-webkit-line-clamp表示需要显示几行。  </p><h3><span id=\"retina屏幕高清图片\"><span style=\"color: #006400;\"> Retina屏幕高清图片：</span></span></h3><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">selector &#123;</span><br><span class=\"line\">  background-image: url(no-image-set.png);</span><br><span class=\"line\">  background: image-set(url(foo-lowres.png) 1x,url(foo-highres.png) 2x) center;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br><p>image-set的语法，类似于不同的文本，图像也会显示成不同的：</p><ol><li> <strong>不支持image-set</strong>：在不支持image-set的浏览器下，他会支持background-image图像，也就是说不支持image-set的浏览器下，他们解析background-image中的背景图像；</li><li> <strong>支持image-set</strong>：如果你的浏览器支持image-sete，而且是普通显屏下，此时浏览器会选择image-set中的@1x背景图像；</li><li> <strong>Retina屏幕下的image-set</strong>：如果你的浏览器支持image-set，而且是在Retina屏幕下，此时浏览器会选择image-set中的@2x背景图像。</li></ol><p>&nbsp;</p><h3><span id><strong> </strong></span></h3><h3><span id=\"html5重力感应事件\"><span style=\"color: #006400;\"> html5重力感应事件：</span></span></h3><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (window.DeviceMotionEvent) &#123; </span><br><span class=\"line\">         window.addEventListener('devicemotion',deviceMotionHandler, false);  </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">var speed = 30;//speed</span><br><span class=\"line\">var x = y = z = lastX = lastY = lastZ = 0;</span><br><span class=\"line\">function deviceMotionHandler(eventData) &#123;  </span><br><span class=\"line\">  var acceleration =event.accelerationIncludingGravity;</span><br><span class=\"line\">        x = acceleration.x;</span><br><span class=\"line\">        y = acceleration.y;</span><br><span class=\"line\">        z = acceleration.z;</span><br><span class=\"line\">        if(Math.abs(x-lastX) &gt; speed || Math.abs(y-lastY) &gt; speed || Math.abs(z-lastZ) &gt; speed) &#123;</span><br><span class=\"line\">            //简单的摇一摇触发代码</span><br><span class=\"line\">            alert(1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        lastX = x;</span><br><span class=\"line\">        lastY = y;</span><br><span class=\"line\">        lastZ = z;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br><p>关于deviceMotionEvent是HTML5新增的事件，用来检测手机重力感应效果具体可参考<a href=\"http://w3c.github.io/deviceorientation/spec-source-orientation.html\" target=\"_blank\">http://w3c.github.io/deviceorientation/spec-source-orientation.html</a>  </p><h3><span id=\"移动端touch事件\"><span style=\"color: #006400;\">移动端touch事件：</span></span></h3><ul><li>touchstart //当手指接触屏幕时触发</li><li>touchmove //当已经接触屏幕的手指开始移动后触发</li><li>touchend //当手指离开屏幕时触发</li><li>touchcancel//当某种touch事件非正常结束时触发</li></ul><p>这4个事件的触发顺序为： touchstart -&gt; touchmove -&gt;  touchend -&gt;touchcancel 对于某些android系统touch的bug: 比如手指在屏幕由上向下拖动页面时，理论上是会触发 一个 touchstart ，很多次 touchmove ，和最终的 touchend ，可是在android 4.0上，touchmove只被触发一次，触发时间和touchstart 差不多，而touchend直接没有被触发。这是一个非常严重的bug，在<a href=\"http://code.google.com/p/android/issues/detail?id=19827\" target=\"_blank\">google Issue</a>已有不少人提出 ,这个很蛋疼的bug是在模拟下拉刷新是遇到的尤其当touchmove的dom节点数量变多时比出现，当时解决办法就是用settimeout来稀释touchmove。  </p><h3><span id=\"单击延迟\"><span style=\"color: #006400;\">单击延迟：</span></span></h3><p>click 事件因为要等待双击确认，会有 300ms 的延迟，体验并不是很好。 开发者大多数会使用封装的 tap 事件来代替click 事件，所谓的 tap 事件由 touchstart 事件 + touchmove 判断 + touchend 事件封装组成。 <a style=\"color: #4183c4;\" title=\"article5\" href=\"https://developers.google.com/mobile/articles/fast_buttons?hl=de-DE\" target=\"_blank\" rel=\"noopener\">Creating Fast Buttons for Mobile Web Applications</a> <a style=\"color: #4183c4;\" title=\"article5\" href=\"http://stackoverflow.com/questions/12238587/eliminate-300ms-delay-on-click-events-in-mobile-safari\" target=\"_blank\" rel=\"noopener\">Eliminate 300ms delay on click events in mobile Safari</a>  </p><h3><span id=\"ios里面fixed的文本框焦点居中\"><span style=\"color: #006400;\">IOS里面fixed的文本框焦点居中</span></span></h3><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    input &#123;</span><br><span class=\"line\">       position:fixed;</span><br><span class=\"line\">       top:0;left:0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"header\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"\"</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>Testfield: <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure><br><br><p>在ios里面，当一个文本框的样式为fixed时候，如果这个文本框获得焦点，它的位置就会乱掉，由于ios里面做了自适应居中，这个fixed的文本框会跑到页面中间。类似： <img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/111030pvtt0t0nfen6tef4.png\" alt width=\"242\" height=\"364\">   <strong>解决办法有两个：</strong> 可以在文本框获得焦点的时候将fixed改为absolute，失去焦点时在改回fixed，但是这样会让屏幕有上下滑动的体验不太好。</p><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.fixfixed &#123;</span><br><span class=\"line\">    position:absolute;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$(document)</span><br><span class=\"line\">    .on('focus', 'input', function(e) &#123;</span><br><span class=\"line\">        $this.addClass('fixfixed');</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .on('blur', 'input', function(e) &#123;</span><br><span class=\"line\">        $this.removeClass('fixfixed');</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure><br><br><p>  还有一种就是用一个假的fixed的文本框放在页面顶部，一个absolute的文本框隐藏在页面顶部，当fixed的文本框获得焦点时候将其隐藏，然后显示absolute的文本框，当失去焦点时，在把absolute的文本框隐藏，fixed的文本框显示。</p><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.fixfixed &#123;</span><br><span class=\"line\">    position:absolute;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$(document)</span><br><span class=\"line\">    .on('focus', 'input', function(e) &#123;</span><br><span class=\"line\">        $absolute..show();</span><br><span class=\"line\">        $this.hide();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .on('blur', 'input', function(e) &#123;</span><br><span class=\"line\">         $fixed..show();</span><br><span class=\"line\">        $this.hide();</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure><br><br><p>  最后一种就是顶部的input不参与滚动，只让其下面滚动。  </p><h3><span id=\"positionsticky\"><span style=\"color: #006400;\">position:sticky</span></span></h3><p><span style=\"color: #444444;\">position:sticky是一个新的css3属性，它的表现类似position:relative和position:fixed的合体，在目标区域在屏幕中可见时，它的行为就像position:relative; 而当页面滚动超出目标区域时，它的表现就像position:fixed，它会固定在目标位置。</span></p><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.sticky &#123; </span><br><span class=\"line\">    position: -webkit-sticky; </span><br><span class=\"line\">    position:sticky; </span><br><span class=\"line\">    top: 15px; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br><p><span style=\"color: #444444;\"><strong>浏览器兼容性</strong>：</span> 由于这是一个全新的属性，以至于到现在都没有一个规范，W3C也刚刚开始讨论它，而现在只有webkit nightly版本和chrome 开发版(Chrome 23.0.1247.0+ Canary)才开始支持它。 另外需要注意的是，如果同时定义了left和right值，那么left生效，right会无效，同样，同时定义了top和bottom，top赢～～ <strong><span style=\"color: #006400;\">移动端点透事件</span></strong> 简单的说，由于在移动端我们经常会使用tap(touchstart)事件来替换掉click事件，那么就会有一种场景是：</p><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mengceng\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"www.qq.com\"</span>&gt;</span>www.qq.com<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure><br><br><p>div是绝对定位的蒙层z-index高于a，而a标签是页面中的一个链接，我们给div绑定tap事件：</p><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$('#mengceng').on('tap',function()&#123;</span><br><span class=\"line\">$('#mengceng').hide();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure><br><br><p>我们点击蒙层时 div正常消失，但是当我们在a标签上点击蒙层时，发现a链接被触发，这就是所谓的点透事件。 原因： <span style=\"background-color: #f5f8fd; color: #000000; font-family: arial,宋体; font-size: 14px;\">touchstart 早于 touchend 早于 click。亦即click的触发是有延迟的，这个时间大概在300ms左右，也就是说我们tap触发之后蒙层隐藏，此时click还没有触发，300ms之后由于蒙层隐藏，我们的click触发到了下面的a链接上。</span> 解决办法： 1 尽量都使用touch事件来替换click事件。 2 阻止a链接的click的preventDefault   <strong><span style=\"color: #006400;\">base64编码图片替换url图片</span></strong> u在移动端，网络请求是很珍贵的资源，尤其在2g或者3g网络下，所以能不发请求的资源都尽量不要发，对于一些小图片icon之类的，可以将图片用base64编码，来减少网络请求。  </p><h4><span id=\"手机拍照和上传图片\"><span style=\"color: #006400;\">手机拍照和上传图片</span></span></h4><p><input type=\"file\">的accept 属性</p><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 选择照片 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">file</span> <span class=\"attr\">accept</span>=<span class=\"string\">\"image/*\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 选择视频 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">file</span> <span class=\"attr\">accept</span>=<span class=\"string\">\"video/*\"</span>&gt;</span></span><br></pre></td></tr></table></figure><br><br><p>  <strong><span style=\"color: #006400;\">动画效果时开启硬件加速</span></strong> 我们在制作动画效果时经常会想要改版元素的top或者left来让元素动起来，在pc端还好但是移动端就会有较大的卡顿感，这么我们需要使用css3的  transform: translate3d;来替换， 此效果可以让浏览器开启<a href=\"http://www.cnblogs.com/PeunZhang/p/3510083.html\" target=\"_blank\" rel=\"noopener\">gpu</a>加速，渲染更流畅，但是笔着实验时在ios上体验良好，但在一些低端android机型可能会出现意想不到的效果。  </p><h4><span id=\"快速回弹滚动\"><span style=\"color: #006400;\">快速回弹滚动</span></span></h4><p>在iOS上如果你想让一个元素拥有像 Native 的滚动效果，你可以这样做：</p><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.div &#123;</span><br><span class=\"line\">        overflow: auto;</span><br><span class=\"line\">        -webkit-overflow-scrolling: touch;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br><br><p>经笔着测试，此效果在不同的ios系统表现不一致， 对于局部滚动，ios8以上，不加此效果，滚动的超级慢，ios8一下，不加此效果，滚动还算比较流畅 对于body滚动，ios8以上，不加此效果同样拥有弹性滚动效果。  </p><br><h4><span id=\"ios和android局部滚动时隐藏原生滚动条\"><span style=\"color: #006400;\">ios和android局部滚动时隐藏原生滚动条</span></span></h4><br><p>android</p><br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-pseudo\">::-webkit-scrollbar</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;p&gt;ios 使用一个稍微高一些div包裹住这个有滚动条的div然后设置overflow:hidden挡住之&lt;/p&gt;</span><br><span class=\"line\">```<span class=\"selector-tag\">css</span></span><br><span class=\"line\"><span class=\"selector-class\">.wrap</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"built_in\">-webkit-calc</span>(100% + 5px);</span><br><span class=\"line\">    <span class=\"attribute\">overflow-x</span>: auto;</span><br><span class=\"line\">    <span class=\"attribute\">overflow-y</span>: hidden;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-overflow-scrolling</span>: touch;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;div class=\"wrap\"&gt;</span><br><span class=\"line\">    &lt;div class=\"box\"&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure><br><br><h4><span id=\"设置placeholder时候-focus时候文字没有隐藏\"><span style=\"color: #006400;\">设置placeholder时候 focus时候文字没有隐藏</span></span></h4><br><br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">input</span><span class=\"selector-pseudo\">:focus</span><span class=\"selector-pseudo\">::-webkit-input-placeholder</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br><h4><span id=\"移动端不同的input对应不同的键盘展示样式\"><span style=\"color: #006400;\">移动端不同的input对应不同的键盘展示样式</span></span></h4><p>ios —- android type email <img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/QQ截图20150830183824.png\" alt width=\"868\" height=\"288\"> type url <img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/QQ截图20150830184045.png\" alt width=\"646\" height=\"441\"> type tel <img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/QQ截图20150830184138.png\" alt width=\"873\" height=\"292\"> type search <img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/QQ截图20150830184250.png\" alt width=\"316\" height=\"324\">  </p><h4><span id=\"background-image和image的加载区别\"><span style=\"color: #006400;\">background-image和image的加载区别</span></span></h4><p><span style=\"color: #000000;\">在网页加载的过程中，以css背景图存在的图片background-image会等到结构加载完成（网页的内容全部显示以后）才开始加载，而html中的</span><span style=\"color: #323e32;\"><span style=\"color: #000000;\">标签img是网页结构（内容）的一部分会在加载结构的过程中加载，换句话讲，网页会先加载</span><span style=\"color: #000000;\">标签img的内容，再加载背景图片background-image，如果你用</span><span style=\"color: #000000;\">引入了一个很大的图片，那么在这个图片下载完成之前，img</span><span style=\"color: #000000;\">后的内容都不会显示。而如果用css来引入同样的图片，网页结构和内容加载完成之后，才开始加载背景图片，不会影响你浏览网页内容。</span></span> 未完待续 参考资料：<a href=\"http://www.nihaoshijie.com.cn/index.php/archives/455\">http://www.nihaoshijie.com.cn/index.php/archives/455</a></p>","site":{"data":{}},"excerpt":"<p>本文主要收集一些移动web开发中常见的问题和解决办法，在日常的工作中遇到新的问题会不定时更新到文章中。</p><h3><span style=\"color: #008000;\">屏蔽阴影：</span></h3><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-webkit-appearance:none</span><br></pre></td></tr></table></figure><p></p>\n<p>亲测，可以同时屏蔽输入框怪异的内阴影，解决iOS下无法修改按钮样式，测试还发现一个小问题就是，加了上面的属性后，iOS下默认还是带有圆角的，不过可以使用 border-radius属性修改。  </p><h3><span style=\"color: #008000;\">Meta标签：</span></h3><br>","more":"<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> /&gt;</span></span><br></pre></td></tr></table></figure><br><br><p>这个想必大家都知道，当页面在手机上显示时，增加这个meta可以让页面强制让文档的宽度与设备的宽度保持1:1，并且文档最大的宽度比例是1.0，且不允许用户点击屏幕放大浏览。 <!--more--></p><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">content</span>=<span class=\"string\">\"telephone=no\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"format-detection\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">content</span>=<span class=\"string\">\"email=no\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"format-detection\"</span> /&gt;</span></span><br></pre></td></tr></table></figure><br><br><p>这两个属性分别对ios上自动识别电话和android上自动识别邮箱做了限制。  </p><h3><span style=\"color: #008000;\"> 获取滚动条的值：</span></h3><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.scrollY  window.scrollX</span><br></pre></td></tr></table></figure><br><br><p>桌面浏览器中想要获取滚动条的值是通过document.scrollTop和document.scrollLeft得到的，但在iOS中你会发现这两个属性是未定义的，为什么呢？因为在iOS中没有滚动条的概念，在Android中通过这两个属性可以正常获取到滚动条的值，那么在iOS中我们该如何获取滚动条的值呢？就是上面两个属性，但是事实证明android也支持这属性，所以索性都用woindow.scroll.  </p><h3><span style=\"color: #008000;\">禁止选择文本：</span></h3><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-webkit-user-select:none</span><br></pre></td></tr></table></figure><br><br><p>禁止用户选择文本，ios和android都支持  </p><h3> </h3><h3><span style=\"color: #006400;\"> css之border-box：</span></h3><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">element&#123;</span><br><span class=\"line\">        width: 100%;</span><br><span class=\"line\">        padding-left: 10px;</span><br><span class=\"line\">        box-sizing:border-box;</span><br><span class=\"line\">        -webkit-box-sizing:border-box;</span><br><span class=\"line\">        border: 1px solid blue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br><p><span style=\"color: #222222;\">那我想要一个元素100%显示，又必须有一个固定的padding-left／padding-right，还有1px的边框，怎么办？</span>这样编写代码必然导致出现横向滚动条，肿么办？要相信问题就是用来解决的。这时候伟大的css3为我们提供了box-sizing属性，对于这个属性的具体解释不做赘述（想深入了解的同学可以到w3school查看，要知道自己动手会更容易记忆）。让我们看看如何解决上面的问题：  </p><h3><span style=\"color: #006400;\"> css3多文本换行：</span></h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p &#123;</span><br><span class=\"line\">    overflow : hidden;</span><br><span class=\"line\">    text-overflow: ellipsis;</span><br><span class=\"line\">    display: -webkit-box;</span><br><span class=\"line\">    -webkit-line-clamp: 2;</span><br><span class=\"line\">    -webkit-box-orient: vertical;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br><p>Webkit支持一个名为-webkit-line-clamp的属性，参见<a href=\"http://developer.apple.com/safari/library/documentation/AppleApplications/Reference/SafariCSSRef/Articles/StandardCSSProperties.html#//apple_ref/doc/uid/TP30001266-UnsupportedProperties\" target=\"_blank\" rel=\"noopener\">链接</a>，也就是说这个属性并不是标准的一部分，可能是Webkit内部使用的，或者被弃用的属性。需要注意的是display需要设置成box，-webkit-line-clamp表示需要显示几行。  </p><h3><span style=\"color: #006400;\"> Retina屏幕高清图片：</span></h3><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">selector &#123;</span><br><span class=\"line\">  background-image: url(no-image-set.png);</span><br><span class=\"line\">  background: image-set(url(foo-lowres.png) 1x,url(foo-highres.png) 2x) center;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br><p>image-set的语法，类似于不同的文本，图像也会显示成不同的：</p><ol><li> <strong>不支持image-set</strong>：在不支持image-set的浏览器下，他会支持background-image图像，也就是说不支持image-set的浏览器下，他们解析background-image中的背景图像；</li><li> <strong>支持image-set</strong>：如果你的浏览器支持image-sete，而且是普通显屏下，此时浏览器会选择image-set中的@1x背景图像；</li><li> <strong>Retina屏幕下的image-set</strong>：如果你的浏览器支持image-set，而且是在Retina屏幕下，此时浏览器会选择image-set中的@2x背景图像。</li></ol><p>&nbsp;</p><h3><strong> </strong></h3><h3><span style=\"color: #006400;\"> html5重力感应事件：</span></h3><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (window.DeviceMotionEvent) &#123; </span><br><span class=\"line\">         window.addEventListener('devicemotion',deviceMotionHandler, false);  </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">var speed = 30;//speed</span><br><span class=\"line\">var x = y = z = lastX = lastY = lastZ = 0;</span><br><span class=\"line\">function deviceMotionHandler(eventData) &#123;  </span><br><span class=\"line\">  var acceleration =event.accelerationIncludingGravity;</span><br><span class=\"line\">        x = acceleration.x;</span><br><span class=\"line\">        y = acceleration.y;</span><br><span class=\"line\">        z = acceleration.z;</span><br><span class=\"line\">        if(Math.abs(x-lastX) &gt; speed || Math.abs(y-lastY) &gt; speed || Math.abs(z-lastZ) &gt; speed) &#123;</span><br><span class=\"line\">            //简单的摇一摇触发代码</span><br><span class=\"line\">            alert(1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        lastX = x;</span><br><span class=\"line\">        lastY = y;</span><br><span class=\"line\">        lastZ = z;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br><p>关于deviceMotionEvent是HTML5新增的事件，用来检测手机重力感应效果具体可参考<a href=\"http://w3c.github.io/deviceorientation/spec-source-orientation.html\" target=\"_blank\">http://w3c.github.io/deviceorientation/spec-source-orientation.html</a>  </p><h3><span style=\"color: #006400;\">移动端touch事件：</span></h3><ul><li>touchstart //当手指接触屏幕时触发</li><li>touchmove //当已经接触屏幕的手指开始移动后触发</li><li>touchend //当手指离开屏幕时触发</li><li>touchcancel//当某种touch事件非正常结束时触发</li></ul><p>这4个事件的触发顺序为： touchstart -&gt; touchmove -&gt;  touchend -&gt;touchcancel 对于某些android系统touch的bug: 比如手指在屏幕由上向下拖动页面时，理论上是会触发 一个 touchstart ，很多次 touchmove ，和最终的 touchend ，可是在android 4.0上，touchmove只被触发一次，触发时间和touchstart 差不多，而touchend直接没有被触发。这是一个非常严重的bug，在<a href=\"http://code.google.com/p/android/issues/detail?id=19827\" target=\"_blank\">google Issue</a>已有不少人提出 ,这个很蛋疼的bug是在模拟下拉刷新是遇到的尤其当touchmove的dom节点数量变多时比出现，当时解决办法就是用settimeout来稀释touchmove。  </p><h3><span style=\"color: #006400;\">单击延迟：</span></h3><p>click 事件因为要等待双击确认，会有 300ms 的延迟，体验并不是很好。 开发者大多数会使用封装的 tap 事件来代替click 事件，所谓的 tap 事件由 touchstart 事件 + touchmove 判断 + touchend 事件封装组成。 <a style=\"color: #4183c4;\" title=\"article5\" href=\"https://developers.google.com/mobile/articles/fast_buttons?hl=de-DE\" target=\"_blank\" rel=\"noopener\">Creating Fast Buttons for Mobile Web Applications</a> <a style=\"color: #4183c4;\" title=\"article5\" href=\"http://stackoverflow.com/questions/12238587/eliminate-300ms-delay-on-click-events-in-mobile-safari\" target=\"_blank\" rel=\"noopener\">Eliminate 300ms delay on click events in mobile Safari</a>  </p><h3><span style=\"color: #006400;\">IOS里面fixed的文本框焦点居中</span></h3><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    input &#123;</span><br><span class=\"line\">       position:fixed;</span><br><span class=\"line\">       top:0;left:0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"header\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"\"</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>Testfield: <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure><br><br><p>在ios里面，当一个文本框的样式为fixed时候，如果这个文本框获得焦点，它的位置就会乱掉，由于ios里面做了自适应居中，这个fixed的文本框会跑到页面中间。类似： <img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/111030pvtt0t0nfen6tef4.png\" alt=\"\" width=\"242\" height=\"364\">   <strong>解决办法有两个：</strong> 可以在文本框获得焦点的时候将fixed改为absolute，失去焦点时在改回fixed，但是这样会让屏幕有上下滑动的体验不太好。</p><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.fixfixed &#123;</span><br><span class=\"line\">    position:absolute;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$(document)</span><br><span class=\"line\">    .on('focus', 'input', function(e) &#123;</span><br><span class=\"line\">        $this.addClass('fixfixed');</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .on('blur', 'input', function(e) &#123;</span><br><span class=\"line\">        $this.removeClass('fixfixed');</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure><br><br><p>  还有一种就是用一个假的fixed的文本框放在页面顶部，一个absolute的文本框隐藏在页面顶部，当fixed的文本框获得焦点时候将其隐藏，然后显示absolute的文本框，当失去焦点时，在把absolute的文本框隐藏，fixed的文本框显示。</p><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.fixfixed &#123;</span><br><span class=\"line\">    position:absolute;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$(document)</span><br><span class=\"line\">    .on('focus', 'input', function(e) &#123;</span><br><span class=\"line\">        $absolute..show();</span><br><span class=\"line\">        $this.hide();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .on('blur', 'input', function(e) &#123;</span><br><span class=\"line\">         $fixed..show();</span><br><span class=\"line\">        $this.hide();</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure><br><br><p>  最后一种就是顶部的input不参与滚动，只让其下面滚动。  </p><h3><span style=\"color: #006400;\">position:sticky</span></h3><p><span style=\"color: #444444;\">position:sticky是一个新的css3属性，它的表现类似position:relative和position:fixed的合体，在目标区域在屏幕中可见时，它的行为就像position:relative; 而当页面滚动超出目标区域时，它的表现就像position:fixed，它会固定在目标位置。</span></p><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.sticky &#123; </span><br><span class=\"line\">    position: -webkit-sticky; </span><br><span class=\"line\">    position:sticky; </span><br><span class=\"line\">    top: 15px; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br><p><span style=\"color: #444444;\"><strong>浏览器兼容性</strong>：</span> 由于这是一个全新的属性，以至于到现在都没有一个规范，W3C也刚刚开始讨论它，而现在只有webkit nightly版本和chrome 开发版(Chrome 23.0.1247.0+ Canary)才开始支持它。 另外需要注意的是，如果同时定义了left和right值，那么left生效，right会无效，同样，同时定义了top和bottom，top赢～～ <strong><span style=\"color: #006400;\">移动端点透事件</span></strong> 简单的说，由于在移动端我们经常会使用tap(touchstart)事件来替换掉click事件，那么就会有一种场景是：</p><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mengceng\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"www.qq.com\"</span>&gt;</span>www.qq.com<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure><br><br><p>div是绝对定位的蒙层z-index高于a，而a标签是页面中的一个链接，我们给div绑定tap事件：</p><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$('#mengceng').on('tap',function()&#123;</span><br><span class=\"line\">$('#mengceng').hide();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure><br><br><p>我们点击蒙层时 div正常消失，但是当我们在a标签上点击蒙层时，发现a链接被触发，这就是所谓的点透事件。 原因： <span style=\"background-color: #f5f8fd; color: #000000; font-family: arial,宋体; font-size: 14px;\">touchstart 早于 touchend 早于 click。亦即click的触发是有延迟的，这个时间大概在300ms左右，也就是说我们tap触发之后蒙层隐藏，此时click还没有触发，300ms之后由于蒙层隐藏，我们的click触发到了下面的a链接上。</span> 解决办法： 1 尽量都使用touch事件来替换click事件。 2 阻止a链接的click的preventDefault   <strong><span style=\"color: #006400;\">base64编码图片替换url图片</span></strong> u在移动端，网络请求是很珍贵的资源，尤其在2g或者3g网络下，所以能不发请求的资源都尽量不要发，对于一些小图片icon之类的，可以将图片用base64编码，来减少网络请求。  </p><h4><span style=\"color: #006400;\">手机拍照和上传图片</span></h4><p><input type=\"file\">的accept 属性</p><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 选择照片 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">file</span> <span class=\"attr\">accept</span>=<span class=\"string\">\"image/*\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 选择视频 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">file</span> <span class=\"attr\">accept</span>=<span class=\"string\">\"video/*\"</span>&gt;</span></span><br></pre></td></tr></table></figure><br><br><p>  <strong><span style=\"color: #006400;\">动画效果时开启硬件加速</span></strong> 我们在制作动画效果时经常会想要改版元素的top或者left来让元素动起来，在pc端还好但是移动端就会有较大的卡顿感，这么我们需要使用css3的  transform: translate3d;来替换， 此效果可以让浏览器开启<a href=\"http://www.cnblogs.com/PeunZhang/p/3510083.html\" target=\"_blank\" rel=\"noopener\">gpu</a>加速，渲染更流畅，但是笔着实验时在ios上体验良好，但在一些低端android机型可能会出现意想不到的效果。  </p><h4><span style=\"color: #006400;\">快速回弹滚动</span></h4><p>在iOS上如果你想让一个元素拥有像 Native 的滚动效果，你可以这样做：</p><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.div &#123;</span><br><span class=\"line\">        overflow: auto;</span><br><span class=\"line\">        -webkit-overflow-scrolling: touch;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br><br><p>经笔着测试，此效果在不同的ios系统表现不一致， 对于局部滚动，ios8以上，不加此效果，滚动的超级慢，ios8一下，不加此效果，滚动还算比较流畅 对于body滚动，ios8以上，不加此效果同样拥有弹性滚动效果。  </p><br><h4><span style=\"color: #006400;\">ios和android局部滚动时隐藏原生滚动条</span></h4><br><p>android</p><br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-pseudo\">::-webkit-scrollbar</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;p&gt;ios 使用一个稍微高一些div包裹住这个有滚动条的div然后设置overflow:hidden挡住之&lt;/p&gt;</span><br><span class=\"line\">```<span class=\"selector-tag\">css</span></span><br><span class=\"line\"><span class=\"selector-class\">.wrap</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"built_in\">-webkit-calc</span>(100% + 5px);</span><br><span class=\"line\">    <span class=\"attribute\">overflow-x</span>: auto;</span><br><span class=\"line\">    <span class=\"attribute\">overflow-y</span>: hidden;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-overflow-scrolling</span>: touch;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;div class=\"wrap\"&gt;</span><br><span class=\"line\">    &lt;div class=\"box\"&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure><br><br><h4><span style=\"color: #006400;\">设置placeholder时候 focus时候文字没有隐藏</span></h4><br><br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">input</span><span class=\"selector-pseudo\">:focus</span><span class=\"selector-pseudo\">::-webkit-input-placeholder</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br><h4><span style=\"color: #006400;\">移动端不同的input对应不同的键盘展示样式</span></h4><p>ios —- android type email <img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/QQ截图20150830183824.png\" alt=\"\" width=\"868\" height=\"288\"> type url <img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/QQ截图20150830184045.png\" alt=\"\" width=\"646\" height=\"441\"> type tel <img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/QQ截图20150830184138.png\" alt=\"\" width=\"873\" height=\"292\"> type search <img class=\"alignnone\" src=\"http://7jpp2v.com1.z0.glb.clouddn.com/QQ截图20150830184250.png\" alt=\"\" width=\"316\" height=\"324\">  </p><h4><span style=\"color: #006400;\">background-image和image的加载区别</span></h4><p><span style=\"color: #000000;\">在网页加载的过程中，以css背景图存在的图片background-image会等到结构加载完成（网页的内容全部显示以后）才开始加载，而html中的</span><span style=\"color: #323e32;\"><span style=\"color: #000000;\">标签img是网页结构（内容）的一部分会在加载结构的过程中加载，换句话讲，网页会先加载</span><span style=\"color: #000000;\">标签img的内容，再加载背景图片background-image，如果你用</span><span style=\"color: #000000;\">引入了一个很大的图片，那么在这个图片下载完成之前，img</span><span style=\"color: #000000;\">后的内容都不会显示。而如果用css来引入同样的图片，网页结构和内容加载完成之后，才开始加载背景图片，不会影响你浏览网页内容。</span></span> 未完待续 参考资料：<a href=\"http://www.nihaoshijie.com.cn/index.php/archives/455\">http://www.nihaoshijie.com.cn/index.php/archives/455</a></p>"},{"title":"移动web性能优化从入门到进阶","date":"2019-03-01T08:06:08.000Z","photos":["https://img.mukewang.com/5c7bda1c000100a807400250.jpg"],"_content":"\n\n\n关于前端性能优化相关的技术知识，网上随便搜一些就有很多，本文将系统性的从初级到高级的思路，总结移动前端性能优化各个方面的相关技术点，内容来自笔者以往经验的总结，希望读者可以花些时间看看。\n\n在目前大多数刚从事前端开发，或者是正在学习前端开发的同学来说，性能优化对于他们可能还比较远，但是脱颖而出，拉开差距的点，往往就在与性能优化，和理论知识不同，性能优化往往来自日常的工作经验中总结而来，也是目前大厂面试前端必问的知识点，所以重要性就不言而喻了。\n\n## 一，入门篇\n\n首先，重要的事情说三遍：\n\n>移动web性能优化原理知识同样适用于PCweb端！\n>移动web性能优化原理知识同样适用于PCweb端！\n>移动web性能优化原理知识同样适用于PCweb端！\n\n<!--more-->\n\n### 1.资源合并与压缩\n**为什么要压缩**？\n\n不同于大部分放在服务端的后台代码，前端所有的文件程序代码都是要通过浏览器下载下来运行使用，这就牵扯到网络和请求延时，所以前端文件的精简和压缩决定了前端性能的第一步。\n\n介于目前的前端框架类库，webpack，vue-cli等等，已经可以直接将这一步操作集成到我们的系统项目中了，可以直接查看各个框架的文档来进行配置，单纯的使用原生技术，可以参考下面：\n\n#### html的压缩\n\n HTML代码压缩就是压缩这些在文本文件中有意义，但是在HTML中不显示的字符，包括空格,制表符,换行符等，还有一些其他意义的字符，如HTML注释也可以被压缩。\n\n - Nodejs的[html-minifier](https://www.npmjs.com/package/html-minifier)。\n - 在线压缩工具，站长工具等等。\n\n#### CSS和JavaScript文件的压缩\nJavaScript压缩，主要是去除多余的换行和空格等等，对于语法来说，JavaScript可以选择[混淆压缩](https://www.zhihu.com/question/47047191)和非混淆压缩，无论哪种压缩都是为了减少JavaScript的文件大小，当然出于前端代码保护来看，混淆压缩会大大破坏原有的阅读逻辑，增加压缩比，从而给代码添加一层保护。\nCSS压缩，同理是去除多余的换行和空格等等，由于CSS文件的特殊性暂时无法实现混淆压缩，压缩主要是将大量的换行去除，可以减少不少的文件大小。\n\n - Nodejs的[uglifyjs2](https://github.com/mishoo/UglifyJS2)是一个强大的JavaScript压缩库。\n - Nodejs的[clean-css](https://www.npmjs.com/package/clean-css)是一个强大的CSS压缩库。\n - 在线压缩工具，站长工具等等。\n \n#### 图片的压缩\n对于常见的前端项目，关于图片的使用，主要有以下两种：\n - 固定图标，背景，按钮icon等等，这些图片有一个特点就是固定和用户无关，一般是放在源码包里面，由前端代码直接引入。\n - 人物头像，文章配图，内容图片等等，这些非固定图片一般由用户上传，有很强的用户性，这些图片一般放在`CDN`上，前端通过链接请求。\n\n\n1. 对于**固定图片**，推荐[https://tinypng.com/](https://tinypng.com/)在线压缩之后再进行引入，支持png，jpeg类型的图片，属于有损压缩，去除图片一些不必要的元数据，把相似像素的24bit位用8bit位来表示，肉眼很难区分，压缩率70%。\n ![图片描述](//img.mukewang.com/5c738b1e0001a5a802690253.png)\n 2. 采用**CSS雪碧图**：把你的网站用到的一些图片整合到一张单独的图片中：\n   优点：减少HTTP请求的数量(通过`backgroundPosition`定位所需图片)。\n   缺点：整合图片比较大时，加载比较慢(如果这张图片没有加载成功，整个页面会失去图片信息)。\n2. 对于**非固定图片**，常见的优化压缩主要有以下几种原则：\n  优先使用压缩率高的`jpeg`类型图片，缺点是不支持透明。\n  有条件的话使用[webP](https://developers.google.com/speed/webp/)(一种Google开发的新类型)类型图片是最佳选择，相比于jpeg，有更小的文件尺寸和更高的图像质量。\n\n#### 资源合并\n在前端编码的时候将css、js等静态资源文件合并压缩之外，我们还可以在页面中将多个css、js的请求合并为一个请求。文件的合并带来的是http请求数的减少，尤其是在移动端，每一个http请求带来的是`慢启动`，`三次握手`，`连接建立`，所以资源的合并是由为重要的，合并和不合并对比：\n![图片描述](//img.mukewang.com/5c739365000133da04800363.png)\n\n### 2.浏览器加载原理优化\nHTML页面加载渲染的过程：\n![图片描述](//img.mukewang.com/5c739e320001bc8310380478.jpg)\n\n根据上图我们来屡一下整个流程：\n1. 当浏览器从服务器接收到了HTML文档，并把HTML在内存中转换成DOM树，在转换的过程中如果发现某个节点(node)上引用了CSS或者 IMAGE，就会再发1个request去请求CSS或image,然后继续执行下面的转换，而不需要等待request的返回，当request返回 后，只需要把返回的内容放入到DOM树中对应的位置就OK。\n2. 但当引用了JS的时候，浏览器发送1个js request就会一直等待该request的返回。\n3. 因为浏览器需要1个稳定的DOM树结构，而JS中很有可能有代码直接改变了DOM树结构，浏览器为了防止出现JS修改DOM树，需要重新构建DOM树的情况，所以 就会`阻塞`其他的下载和呈现。\n那么如何解决和避免阻塞的问题呢，我们通过测试代码分别测试不同情况下引入js和css的问题如下：\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>test</title>\n      <link rel=”stylesheet” type=”text/css” href=”stylesheet.css” media=”screen”>\n      <link rel=”stylesheet” type=”text/css” href=”page-animation.css” media=”screen”>\n      <script type =”text/javascript” >\n          var f = 1;\n          f++;\n      </script >\n  </head>\n  <body>\n    <img src=”download-button.png”>\n  </body>\n</html>\n```\n测试过程省略，可以参考[这里](https://www.nihaoshijie.com.cn/index.php/archives/530/)，我们可以得到如下的结论：\n\n - 浏览器存在并发加载：资源请求是并发请求的。\n - 浏览器中可以支持并发请求，不同浏览器所支持的并发数量不同（以域名划分），以Chrome为例，并发上限为6优化点： 把CDN资源分布在多个域名下。\n - css 在head中通过link引入会阻塞页面的渲染，处于页面样式，我们必须这样放置。\n - 直接通过`<script src>`引入的外部js会阻塞后面节点的渲染，所以外部js尽量放在body底部。\n - 在head里面尽量不要引入js。\n - 如果要引入js 尽量将js内嵌。\n - 把内嵌js放在所有link引入css的前面。\n - 对于要阻塞后续内容的的外部js`<script src>`，需要增加`defer`来解决。\n\n### 3.缓存优化\n\n> *如果一个H5页面没有利用任何缓存，那么这个页面将没有任何存在的意义。*\n\n从从HTTP协议缓存，到浏览器缓存，再到APP Cache，一直在最近比较火的Service worker，我们可以选择多种的缓存方式，入门基本来说说HTTP协议缓存：\n![图片描述](//img.mukewang.com/5c73a73f0001eff709030569.jpg)\n\n#### 强缓存：Expires&Cache-Control\n当浏览器对某个资源的请求命中了强缓存时，返回的HTTP状态为200，在chrome的开发者工具的network里面 size会显示为from disk cache，这种情况下是**不用发送任何请求**，如下图![图片描述](//img.mukewang.com/5c73a9b500011ffa07890592.jpg)\n\n - Expires：指定了在浏览器上缓冲存储的页距过期还有多少时间，等同Cache-control中的max-age的效果，如果同时存在，则被Cache-Control的max-age覆盖。\n - Cache-Control：\n   - public：响应被缓存，并且在多用户间共享。\n   - private：默认值，响应只能够作为私有的缓存(e.g., 在一个浏览器中)，不能再用户间共享；\n   - no-cache：响应不会被缓存,而是实时向服务器端请求资源。\n   - max-age：数值，单位是秒，从请求时间开始到过期时间之间的秒数。基于请求时间（Date字段）的相对时间间隔，而不是绝对过期时间；\n#### 协商缓存：Last-Modified&Etag\n当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串，比如你打开京东的首页，按f12打开开发者工具，再按f5刷新页面，查看network，可以看到有不少请求就是命中了协商缓存的：\n![图片描述](//img.mukewang.com/5c73aba800012d8e08000191.jpg)\n - Last-Modified/If-Modified-Since：本地文件在服务器上的最后一次修改时间。缓存过期时把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比，如果时间一致，那么返回304，客户端就直接使用本地缓存文件。\n - Etag/If-None-Match：(EntityTags)是URL的tag，用来标示URL对象是否改变，一般为资源实体的哈希值。和Last-Modified类似，如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。Etag的优先级高于Last-Modified，Etag主要为了解决\n - Last-Modified 无法解决的一些问题。\n   - 文件也许会周期性的更改，但是他的内容并不改变，不希望客户端重新get；\n   - If-Modified-Since能检查到的粒度是s级；\n   - 某些服务器不能精确的得到文件的最后修改时间。\n### 4.懒加载与预加载\n懒加载对于移动web端，尤其是最常见的滚动加载场景是一项非常重要的优化措施。而预加载则常常应用于多tab场景的页面，让用户更快的看到打开的下一个页面。\n#### 懒加载\n - 图片进入可视区域之后请求图片资源。\n - 对于电商等图片很多，页面很长的业务场景适用。\n - 减少无效资源的加载。\n - 并发加载的资源过多会会阻塞js的加载，影响网站的正常使用。\n img src被设置之后，webkit解析到之后才去请求这个资源。所以我们希望图片到达可视区域之后，`img src`才会被设置进来，没有到达可视区域前并不现实真正的src，而是类似一个1px的占位符。\n\n\n#### 预加载\n\n - 图片等静态资源在使用之前的提前请求。\n - 资源使用到时能从缓存中加载，提升用户体验。\n - 点击操作前预先加载下一屏数据。\n\n\nok，读到这里，对于一些刚入门的前端玩家，或者是还在学习前端的同学，掌握了上面的入门级性能优化基础知识，才能算是基本的合格，真正更进一步的优化，更适合移动端web的性能点，可以参考进阶版：\n## 二，进阶篇\n### 1.资源合并与压缩\n#### 启用GZIP\ngzip是GNUzip的缩写，最早用于UNIX系统的文件压缩。HTTP协议上的gzip编码是一种用来改进web应用程序性能的技术，web服务器和客户端（浏览器）必须共同支持gzip。目前主流的浏览器，Chrome,firefox,IE等都支持该协议。常见的服务器如Apache，Nginx，IIS同样支持gzip。\n**gizp流程**：\n\n - 浏览器请求url，并在request header中设置属性accept-encoding:gzip。\n - 服务器支持gzip，response headers返回包含content-encoding:gzip。\n - 开启gzip可以达到80%的压缩率，即1MB的文件下载下来只需要200K，大大减少传输效率，是一项非常重要的资源压缩手段。\n\nNginx中开启gzip：\n![图片描述](//img.mukewang.com/5c7601e40001ea1a06000122.jpg)\n#### 升级HTTP/2.0\nHTTP/2是HTTP协议自1999年HTTP 1.1发布后的首个更新，主要基于[SPDY](https://zh.wikipedia.org/zh-hans/SPDY)协议（是Google开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验）。\n**优化原理：**\n根据上文中说的资源合并问题，浏览器可以同时建立有限个TCP连接，而每个连接都要经过`慢启动`，`三次握手`，`连接建立`，HTTP1.1为了解决这个问题推出了keep-alive，即保持连接不被释放，但是真正的这些连接下载资源是一个线性的流程：一个资源的请求响应返回后，下一个请求才能发送。这被称为[线头阻塞](https://zh.wikipedia.org/wiki/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E)，为了彻底解决此问题，HTTP2.0带来了[多路复用](https://zhuanlan.zhihu.com/p/26559480)：\n![图片描述](//img.mukewang.com/5c7622b10001789107790765.png)\nHTTP2.0的其他新特性也有助于页面的打开速度：\n\n - [二进制分帧](https://zhuanlan.zhihu.com/p/26559480)\n - [服务器推送](https://zhuanlan.zhihu.com/p/26559480)\n - [头部压缩](https://zhuanlan.zhihu.com/p/26559480)\n\n#### 合并资源 vs 并行加载资源？\n现在回过头来探讨一下上文说的资源合并问题，有了HTTP2.0之后，我们是否还需要合并资源，目前看需要遵循下面的原则：\n\n - **停止合并文件**\n在HTTP/1.1中，CSS，JavaScript被压缩到了一个文件，图片被合并到了一张雪碧图上。合并CSS、JavaScript和图片极大地减少了HTTP的请求数，在HTTP/1.1中能获得显著的性能提升。\n但是，在HTTP/2.0中合并文件不再是一个好的办法。虽然合并依然可以提高压缩率，但它带来了代价高昂的缓存失效。即使有一行代码改变了，整个文件就要重新打包压缩，浏览器也会强制重新加载新的文件。\n\n - **尽量不要在HTML里内联资源**\n非特殊的代码（rem适配代码，上报代码等）之外，尽量不要使用内联资源，在极端情况下，这确实能够减少给定网页的HTTP请求数。但是，和文件合并一样，HTTP/2优化时你不应该内联文件。内联意味着浏览器不能缓存单个的资源。如果你将所有页面使用的CSS声明嵌入了每一个HTML文件，这些文件每次都要从服务端获取。这导致用户在访问任何页面时都要传输额外的字节。\n - **合并域名**\n 拆分域名是让浏览器建立更多TCP连接的通常手段，浏览器限制了单个服务器的连接数量，但是通过将网站上的资源切分到几个域上，你可以获得额外的TCP连接，但是每个拆分的域名都会带来额外的DNS查询、握手，新连接的建立，根据HTTP2.0多路复用的原则：*HTTP2采用多路复用是指，在同一个域名下，开启一个TCP的connection，每个请求以stream的方式传输*，域名的合并可以带来更多的多路复用，如下图在chrome的Network面板中查看HTTP2.0，注意protocol和ConnectID相同则表示启用复用:\n ![图片描述](//img.mukewang.com/5c762a8e0001458821940784.png)\n\n#### 合理使用icon类图片base64化\n```html\n<img src=\"data:image/gif;base64,R0...\"/>\n```\n在页面使用的背景类图片icon类图片，不多且比较小的情况下，可以把图片转成base64编码嵌入到html页面或者CSS文件中，这样可以减少页面的HTTP请求数。需要注意的是，要保证图片较小，一般超过5kb的就不推荐base64嵌入显示了。[为什么是5kb？](https://www.zhihu.com/question/31155574)。\n同时，采用Webpack的[url-loader](https://github.com/webpack-contrib/url-loader)可以帮我们在不影响代码可读性的情况下，解决base64字符串问题。\n\n#### Icon Font\nIconFont技术起源于Web领域的Web Font技术，它是把一些简单的图标制作成字体，然后让图标变成和字体一样使用，Icon 的设计和使用在近几年的发展中，也经历了由当初的 img 方案 到现如今的 svg 方案，有以下优点：\n\n - 字体是矢量的，所以可以随意改变大小。\n - 因为它是字体，所以所有字体的css都可以使用，比如font-size，color，background，opacity等。\n - 减少图片请求数。\n - iconfont没有兼容性问题，IE6，Android2.3都能够兼容。\n\n### 2.浏览器加载原理优化\n \n \n#### 首屏资源优化\n\n - 剥离首屏资源\n 首屏的快速显示，可以大大提升用户对页面速度的感知，因此应尽量针对首屏的快速显示做优化，基于联通3G网络平均338KB/s(2.71Mb/s)，所以首屏资源不应超过1014KB，剥离首屏需要的资源，非首屏的资源单独合并，采用懒加载。这个原则适用上文的资源合并和加载中的场景。\n\n - 按需加载\n 将不影响首屏的资源和当前屏幕资源不用的资源放到用户需要时才加载，可以大大提升重要资源的显示速度和降低总体流量，对于移动web端常见的多tab页面，Webpack的[Code Splitting](https://webpack.js.org/guides/code-splitting/)帮助我们更加便捷实现按需加载。\n  - 非首屏图片Lazyload\n  不用多说，在目前流量费用还算比较高昂的情况下，帮助用户节省更多的流量可以避免用户的投诉，为了保证页面内容最小化，加速页面渲染，尽可能节省首屏网络流量，页面中的图片资源推荐使用懒加载实现，在页面滚动时动态载入图片。\n\n#### 使用CDN\nCDN是将源站内容分发至最接近用户的节点，使用户可就近取得所需内容，提高用户访问的响应速度和成功率。解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景。\n对于web页面来说，将项目的js，css等静态资源存放在CDN是一个重要的优化手段，加入所有资源统一打包放在同一个域名下，很难达到用户就近获取的优势（目前最佳实践是html页面采用一个域名，静态资源文件采用CDN域名），所谓静态资源即是可以被浏览器缓存的资源，而对于html页面，由于是js和css等链接的入口，通常不采用缓存。常用的[阿里云CDN](https://cn.aliyun.com/product/cdn)和[腾讯云CDN](https://cloud.tencent.com/product/cdn-scd)都有开放接口，开发者可以按需选择。\n\n#### 预加载\n此预加载主要分为两个部分，一种是采用原生浏览器支持的API来对页面的一些资源进行预先拉取或者加载，另一种是通过自己写逻辑来加载一些重要的资源，立即下面内容的前提是要立即目前移动web常见的hybrid架构，webview外壳+H5页面：\n![图片描述](//img.mukewang.com/5c7779240001ae7004170297.png)\n - DNS预解析（dns-prefetch）\n DNS 作为互联网的基础协议，其解析的速度似乎很容易被网站优化人员忽视。现在大多数新浏览器已经针对DNS解析进行了优化，典型的一次DNS解析需要耗费 20-120 毫秒，减少DNS解析时间和次数是个很好的优化方式。DNS Prefetching 是让具有此属性的域名不需要用户点击链接就在后台解析，而域名解析和内容载入是串行的网络操作，所以这个方式能 减少用户的等待时间，提升用户体验 。\n   ```html\n   <link rel=\"dns-prefetch\" href=\"//haitao.nos.netease.com\">\n   ```\n - Preload 和 Prefetch\n   两者都是以`<link rel=\"preload\"> 和 <link rel=\"prefetch\">`作为引入方式。\n   **Preload** 一个基本的用法是提前加载资源,告诉浏览器预先请求当前页需要的资源，从而提高这些资源的请求优先级，加载但是不运行，占用浏览器对同一个域名的并发数:\n   ```html\n   <link rel=\"preload\" href=\"a.js\" as=\"script\" onload=\"preloadLoad()\">\n   ```\n   **Prefetch** 一个一本用法是浏览器会在空闲的时候，下载资源, 并缓存起来。当有页面使用的时候，直接从缓存中读取。其实就是把决定是否和什么时间加载这个资源的决定权交给浏览器。\n      ```html\n   <link rel=\"prefetch\" href=\"a.js\">\n   ```\n  遗憾的是对于这两个接口，移动端的浏览器支持性很不好，这也是没有普遍推广开勇的原因。![图片描述](//img.mukewang.com/5c773be00001940412540467.png)\n  ![图片描述](//img.mukewang.com/5c773f550001ffa512560418.png)\n  ![图片描述](//img.mukewang.com/5c773f610001c4a412590485.png)\n  什么时候使用Preload，什么时候使用Prefetch可以总结如下：\n  *对于当前页面很有必要的资源使用 preload，对于可能在将来的页面中使用的资源使用 prefetch。*\n  关于Preload 和 Prefetch可以[参考这里](https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/),另外还有[Prerender](https://css-tricks.com/prefetching-preloading-prebrowsing/)，[subresource](https://css-tricks.com/prefetching-preloading-prebrowsing/)，[Preconnect](https://css-tricks.com/prefetching-preloading-prebrowsing/)属性，由于目前能支持到这些属性的机型太少，这里就不在赘述了。\n - 业务逻辑的预加载\n   关于业务逻辑的预加载，在这里我可以举一个微信小程序的例子。小程序主要分为渲染层和逻辑层，逻辑层有iOS或者Android的**JavaScript core**来运行，渲染层由各自的**webview**组件负责渲染。我们用户实际体验到的UI还是跑在我们的webview里面，这个和大多数H5页面的渲染用的是一个组件。但是为什么我们体验小程序会比H5页面要快很多？尤其是新开页面时？\n   ![图片描述](//img.mukewang.com/5c7747e50001ad1523561746.png)\n   *小程序在启动时，会预先加载所有页面逻辑代码进内存，在 a页面跳转至 b页面 时，可以在内存中直接运行而无需在发送资源请求，a页面的逻辑代码 Javascript 数据也不会从内存中消失。b页面甚至可以直接访问 a页面中的数据，整个坏境在一个大的上下文中。*\n   当然这里你可能会有疑问？假如用户不会进入page2，那加载page2的逻辑代码岂不是浪费？这里就会牵扯到一个用户行为预测的问题，在小程序的架构中，整个逻辑代码是统一在一个包里，微信是统一将这些文件下载并加载到内存中，这可能会涉及到一些浪费，但是对于提速来讲收益大于弊端的。当然小程序页提供出[分包策略](https://developers.weixin.qq.com/ebook?action=get_post_info&docid=000c8a2f9ac0b0ab0086aafeb5d80a)来优化这些问题。\n   借助小程序的思路，我们的移动web同样适用这种预加载优化逻辑：\n     1. **预加载资源**：在多tab的单页应用中，我们可以在用户打开首屏之后，预先加载其他tab的资源。例如用户进入时在推荐tab，这时就可以预先加载订单，我的 这两个tab的资源了，当用户点击订单时，页面的展现就会快一些。![图片描述](//img.mukewang.com/5c774c9c0001f0a302230278.png)\n     2. **预加载数据**：预加载数据的时机最好是在空闲时，什么是空闲时呢？我们分析一下打开一个H5页面的流程：![图片描述](//img.mukewang.com/5c7772200001633505590182.png)\n     从图上可以看到，利用闲时可以做的事情有很多，预加载数据是一个典型的优化手段，提前把新页面所需要的数据加载好，在新页面打开后，可以直接用数据来进行渲染，当然这里涉及到的跨页面数据通信，我们可以利用localStroage来实现。\n     3. **预加载webview**\n       我利用闲时来做更多事情的前提是闲时够长，但这本书也不是一个很好的现象，尽量的减少闲时，也是我们需要做的一项优化，例如我们来减少webview的加载时间，这就需要提前加载webview，此项优化大多是由native端来完成：\n  \n   - 在APP启动后，就提前在内存中将webview加载好，而不是等到点击进入web页面时才去加载。\n   - 创建一个webview的复用池，例如最多只存在3个webview，每次从池子里获取webview，达到复用的目的。\n### 3.合理利用缓存\n上文说了浏览器缓存的基础知识，既然是基础，那就说明必须掌握，下面来说一些进阶篇的利用缓存来优化页面：\n#### 妙用localStorage\nHTML5 LocalStorage可以看做是加强版的cookie，数据存储大小提升，有更好的弹性以及架构，可以将数据写入到本机的ROM中，还可以在关闭浏览器后再次打开时恢复数据，以减少网络流量，日常使用localStorage来优化我们的页面大概有以下几种场景：\n - 缓存一些非实时更新的变量，例如某些闪屏的标志位信息，地理位置信息等等，取用方便，即存即用。\n - 使用localStorage缓存Js和css文的，为了提升页面的打开速度，或者是页面可以离线使用，有些页面会采用将静态资源文件直接缓存在localStorage中，当页面打开时将内容读取出并运行，使用此方法确实可以减少http请求，提速页面。\n - 在一些跨webview通信的场景中，localStorage是兼容性最好的数据通信方案，例如预加载的数据可以缓存在localStorage中，来实现各个页面的webview数据共享。\n - 需要注意的是，localStorage并不是无限大的，针对每个域名，PC端浏览器给localStorage分配的容量大概4.5m-5m，移动端类似微信等等的浏览器大概容量是2.5m-3m[参考这里](http://dev-test.nemikor.com/web-storage/support-test/)。所以在使用时需要做好异常捕获，让localstorage超出容量时，是无法在进行插入并报错，如果对容量有更高的要求，可以参考使用[indexeddb](https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API)。需要注意的是indexeddb的兼容性却不是很好，android4.4之前以及iOS7以前都无法使用。\n#### 老生常谈离线包\n离线包技术可以说是并不算很新的技术了，各个业务都有在使用，也都有自己的一套hybrid离线包系统，关键点在于离线包的打包，同时对文件加密/签名，更新离线包(增量)\n，安全教研以及容错机制等等，在这里列举一些大厂的离线包方案来参考：\n - 美团：[LsLoader——通用移动端WebApp离线化方案](https://tech.meituan.com/2017/07/06/lsloader.html)。\n - 腾讯：[手Q离线包Alloykit](http://www.alloyteam.com/2013/12/web-cache-6-hybrid-app-tailored-cache/)。\n - 阿里：[极致的 Hybrid：航旅离线包再加速](https://yq.aliyun.com/articles/2939)\n\n#### Service Worker探索\n提到缓存，那就不得不提近几年比较火的Service Worker了：\n![图片描述](//img.mukewang.com/5c778bc9000139b107760495.png)\n作为一个比较新的技术，大家可以把 Service Worker 理解为一个介于客户端和服务器之间的一个代理服务器。在 Service Worker 中我们可以做很多事情，比如拦截客户端的请求、向客户端发送消息、向服务器发起请求等等，其中最重要的作用之一就是离线资源缓存。\nService Worker的主要复杂点在于不断地对缓存策略的调整，笔者在这里就不过多展开，可以参考一下淘宝[Service worker实战](http://taobaofed.org/blog/2018/08/08/workbox3/)。\n### 4.Nodejs服务端渲染（SSR）优化首屏时间\n在前后端分离之后，后端语言的模板功能被弱化，整个页面的渲染基本上都由前端 js 动态渲染，但这样对于一些应用来说是有缺陷的。比如需要 SEO 的，需要打开页面不用等待就能看到页面的，另外前端页面展示过度依赖js和css逻辑执行，在极端情况或者网络较差，手机性能低下(尤其在低端Android机型较为明显)时，白屏时间较长，这时服务端渲染便应用而生，至于为什么是Nodejs，作为一个前端，难道还要用Java么。。？\n**为什么会有服务端渲染？**\n如果你说服务端渲染和早期web框架，例如SSH，JSP servlet，PHP等等一样的话，那我只能说呵呵，目前的服务端渲染和早期的框架是有本质区别的：\n - *Web 2.0时代最大的思想革命本质不是前后端分离，而是把网页当作独立的应用程序（app）*。建立在前后端分离的基础上，后端只负责提供数据json格式，前端还是负责页面交互逻辑，大多数的服务端渲染采用Nodejs层来进行数据组装，html拼接。\n - 重点在首屏！！首屏时间的优化，移动互联网时代的爆发，用户对网页性能的要求越来越高，但毕竟基于3G，4G网络，让用户更快的看到页面就能挽留更多的潜在商机。服务端只负责首屏的页面渲染，真正过了首屏，大多数的业务逻辑，页面交互，还是需要有单独的前端来实现的。\n\n**如何实现？**\n如果你的项目用的是React或者是vue，那么下面两个现场的开源框架是不错的选择。\n - next.js: 服务器端渲染 react 组件框架，参考查看[React服务端渲染指南](https://segmentfault.com/a/1190000015578803)。\n - nuxt.js: 服务器端渲染 vue 组件框架，参考查看 https://zh.nuxtjs.org/。\n - gatsbyjs:服务端React渲染框架，目前看比较新，网上的资料还不是很多，参考查看： https://www.gatsbyjs.org/\n\n当然，你也可以自己实现一套自己的服务端渲染框架，一般需要关注这些问题：\n\n - 实现自定义的Node端的window上下文对象Cookie & Session等。\n - 远程数据的获取，一般采用Nodejs的http模块。\n - React采用ReactDOMServer调用renderToString(),Vue采用vue-server-renderer调用renderToString()。\n - Node端内存泄露和控制等问题\n\n**代码同构(isomorphic)**\n使用Nodejs的服务端渲染的一大优势就是代码同构，这使得一个项目可以分别部署成走线上正常前端渲染版本，和走服务端渲染版本，这样可以更好的做到容灾机制，当任何一种分之挂掉之后，可以直接走另一个版本，提高稳定性。这也同构的魅力所在！因为在同构直出宕掉的时候，还有前端渲染页面可以提供正常的服务。\n![图片描述](//img.mukewang.com/5c77aacc000107f406780266.png)\n\n**取舍**\n虽然说服务端渲染这类优化确实可以提升一定的页面首屏时间，但是也是需要成本的，在前端开发接管了Node作为中间层时，需要额外的机器资源部署，并且一旦接触到后端，容灾机制，内存管理等性能指标都需要关注，这对于当前的业务系统架构可能需要有一定的调整，所以还是要斟酌来使用。\n### 5.渲染优化\n终于回到我们前端的老本家了，如果说前面的优化都是在框架，逻辑层面的优化，或者是参考后端，客户端的优化思路，那么真正涉及到UI渲染的优化才是我们作为前端工程师的立身之本了。\n\n - **何为渲染优化？**\n\n  抛开首屏加速，真正让用户体验web页面的另一个很重要的部分就是用户行为交互了，这包括用户的**点击相应**，**滚动流畅度**，**动画是否卡顿**流畅度等等，这些关于用户交互性的优化在已往的PC端可能不是很被重视，因为PC浏览器的性能要远远大于手机端，但是到了移动web就不一样了，用户都希望移动web能有PC端一样的性能。\n\n - **为什么同样的页面在iPhone里总比Android流畅？**\n\n  目前主流的Android硬件配置可以说是甩iPhone几条街了，那为什么高配置却得不到好的体验呢？关键两类机型的操作系统上的优化程度，其中一个原因就是iOS操作系统采用执行率较高的Object-c语言，大部分硬件接口可以直接调用和运行，而Android则采用Java语言，因为虚拟机的存在，虽然跨平台性提升了，但是通过虚拟机在和系统硬件交互，执行效率就低了很多，当然这只是其中一个原因。那么，我们移动web主要优化的群体就是Android机型了。\n\n - ****16ms优化****\n\n  目前大多数设备的屏幕刷新频率为60次/秒，每一帧所消耗的时间约为16ms（1000 ms / 60 = 16.66ms），这16ms就是渲染帧的时长，所谓渲染帧是指浏览器一次完整绘制过程，帧之间的时间间隔是DOM视图更新的最小间隔，但实际上，浏览器还有一些整理工作要做，因此开发者所做的所有工作需要在10ms内完成。\n  如果不能完成，帧率将会下降，网页会在屏幕上抖动，也就是通常所说的卡顿，这会对用户体验产生严重的负面影响。所以如果一个页面中有动画效果或者用户正在滚动页面，那么浏览器渲染动画或页面的速率也要尽可能地与设备屏幕的刷新频率保持一致，以保证良好的用户体验。在这一个间隔内，浏览器可能需要做以下事情：\n\n   - 脚本执行（JavaScript）：脚本造成了需要重绘的改动，比如增删 DOM、请求动画等\n   - 样式计算（CSS Object Model）：级联地生成每个节点的生效样式。\n   - 布局（Layout）：计算布局，执行渲染算法\n   - 重绘（Paint）：各层分别进行绘制（比如 3D 动画）\n   - 合成（Composite）：合成各层的渲染结果\n\n - **重绘和重排**\n  在上面浏览器需要做的这些事情中，会引发不同程度的重绘和重排，而重绘和重排正式影响流畅的重要因素：\n  1. 部分渲染树（或者整个渲染树）需要重新分析并且节点尺寸需要重新计算，这被称为重排。\n\n  2. 由于节点的几何属性发生改变或者由于样式发生改变，例如改变元素背景色时，屏幕上的部分内容需要更新，这样的更新被称为重绘。\n\n  重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，但是每次重排，必然会导致重绘，而每次重绘并不一定会发生重排，我们需要在以下几种场景来减少重排的发生：\n  当页面布局和几何属性改变时就需要回流。下述情况会发生浏览器回流：\n  1. 添加或者删除可见的DOM元素。\n  2. 元素位置改变。\n  3. 元素尺寸改变——边距、填充、边框、宽度和高度。\n  4. 内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变。\n  5. 页面渲染初始化。\n  6. 浏览器窗口尺寸改变——resize事件发生时。\n\n - **使用 requestAnimationFrame**\n提升动画流畅度的另一个重要因素是让浏览器变得智能起来，好在浏览器给我们提供了这个接口requestAnimationFrame，通过这个API,可以告诉浏览器某个JavaScript代码要执行动画，浏览器收到通知后，则会运行这些代码的时候进行优化，它会确保JS尽早在每一帧的开始执行，实现流畅的效果，而不再需要开发人员烦心刷新频率的问题了：\n  ```javascript\n  function animationWidth() {\n    var div = document.getElementById('box');\n    div.style.width = parseInt(div.style.width) + 1 + 'px';\n\n    if(parseInt(div.style.width) < 200) {\n      requestAnimationFrame(animationWidth)\n    }\n  }\n  requestAnimationFrame(animationWidth);\n\n  ```\n\n - **试试requestIdleCallback**\n requestIdleCallback的出现伴随着React 16 的Fiber特性，他的使用场景是当用户在做负责交互时，不希望因为一些不重要的任务（如统计上报）导致用户感觉到卡顿的话，就应该考虑使用了，因为requestIdleCallback回调的执行的前提条件是当前浏览器处于空闲状态，但是需要注意的是不要在requestIdleCallback操作任何DOM，这违背了这个接口的设计原则。\n   ```javascript\n       requestIdelCallback(myNonEssentialWork);\n      function myNonEssentialWork (deadline) {\n      \n        // deadline.timeRemaining()可以获取到当前帧剩余时间\n        while (deadline.timeRemaining() > 0 && tasks.length > 0) {\n          doWorkIfNeeded();\n        }\n        if (tasks.length > 0){\n          requestIdleCallback(myNonEssentialWork);\n        }\n      }\n   ```\n   \n\n - **fragment元素的应用**\n   在你使用dominnerHTML方法来插入大量dom节点时，不妨试试fragment，fragment文档片段是个轻量级的document对象，它的设计初衷就是为了完成这类任务——更新和移动节点。文档片段的一个便利的语法特性是当你附加一个片断到节点时，实际上被添加的是该片断的子节点，而不是片断本身。只触发了一次重排，而且只访问了一次实时的DOM。\n\n - **列表滚动优化**\n 长列表滚动在移动端是一种非常常见的交互模式，例如feeds流，图片流等等，这些列表的滚动流畅度优化对用户体验的提升是非常重要的，基于目前的优化思路，借助dom复用的方案，类似iOS的UITableView或者Android的recyclerview原理，在列表滚动时，只保证视窗区域内的dom节点存在，在有限的dom节点内实现滚动，而不在创建新的节点，在用户不断下拉翻页的过程中，保证整个页面有限的dom元素来减少内存的消耗，原理如下图：\n ![图片描述](//img.mukewang.com/5c78e94900013bc502610519.png)\n 复用的dom：\n ![图片描述](//img.mukewang.com/5c78e95b000190de01830324.png)\n 采用这一个方案的前端是借助浏览器的onscroll事件来做逻辑处理，但是问题在于有些机型例如iOS的UIWebview下，onscroll不能实时触发，这就给优化带来了难题，由此引发出了模拟滚动:\n\n - 正常的滚动：我们平时使用的scroll，包括上面讲的滚动都属于正常滚动，利用浏览器自身提供的滚动条来实现滚动，底层是由浏览器内核控制。\n - 模拟滚动：最典型的例子就是iscroll了，原理一般有两种：\n   - 1).监听滚动元素的touchmove事件，当事件触发时修改元素的transform属性来实现元素的位移，让手指离开时触发touchend事件，然后采用requestanimationframe来在一个线型函数下不断的修改元素的transform来实现手指离开时的一段惯性滚动距离。\n   - 2).监听滚动元素的touchmove事件，当事件触发时修改元素的transform属性来实现元素的位移，让手指离开时触发touchend事件，然后给元素一个css的animation，并设置好duration和function来实现手指离开时的一段惯性距离。\n\n  结论是如果要采用模拟滚动，可以解决onscroll不实时触发的问题，从而实现长列表的复用的优化，但是带来新的问题就是模拟滚动本身也是dom的重绘，增加额外的性能消耗，达到有优化效果并不理想，好在iOS的新版WKwebview解决了onscroll问题，让开发者有了更好的选择。\n\n - **滚动函数防抖**\n当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。\n  ```javascript\n  function debounce(fn, wait) {\n      var timeout = null;\n      return function() {\n          if(timeout !== null) \n                  clearTimeout(timeout);\n          timeout = setTimeout(fn, wait);\n      }\n  }\n  // 处理函数\n  function handle() {\n      console.log(Math.random()); \n  }\n  // 滚动事件\n  window.addEventListener('scroll', debounce(handle, 1000));\n  ```\n - **合理使用GPU**\n   动画卡顿是在移动web开发时经常遇到的问题，解决这个问题一般会用到CSS3硬件加速。硬件加速这个名字感觉上很高大上，其实它做的事情可以简单概括为：通过GPU进行渲染，解放CPU，我们可以利用GPU的图形层，将负责的动画操作放在这个层，如何开启？\n   ```css\n   webkit-transform: translateZ(0);\n   ```\n   强制把需要动画的dom的对象 ，放置在GPU的layout层来缓存从而达到任何移动，大小变化都在这个层。\n通过开启GPU硬件加速虽然可以提升动画渲染性能或解决一些棘手问题，但使用仍需谨慎，使用前一定要进行严谨的测试，否则它反而会大量占用浏览网页用户的系统资源，尤其是在移动端，肆无忌惮的开启GPU硬件加速会导致大量消耗内存，千万不要`* {webkit-transform: translateZ(0);}`。\n\n### 写在最后\n本文在性能优化的基础上，将移动web的性能点逐步展开和深入，大部分属于结论性介绍内容，真正实践还是需要开发人员亲身尝试来得到优化提升，总之，\n*技术就是在于不断折腾，愿各位在踩坑的道路上一帆风顺！*\n\n\n","source":"_posts/移动web性能优化从入门到进阶.md","raw":"---\ntitle: 移动web性能优化从入门到进阶\ndate: 2019-03-01 16:06:08\ntags:\n- 移动web\n- 性能优化\ncategories:\n- 795\n\nphotos: https://img.mukewang.com/5c7bda1c000100a807400250.jpg\n\n---\n\n\n\n关于前端性能优化相关的技术知识，网上随便搜一些就有很多，本文将系统性的从初级到高级的思路，总结移动前端性能优化各个方面的相关技术点，内容来自笔者以往经验的总结，希望读者可以花些时间看看。\n\n在目前大多数刚从事前端开发，或者是正在学习前端开发的同学来说，性能优化对于他们可能还比较远，但是脱颖而出，拉开差距的点，往往就在与性能优化，和理论知识不同，性能优化往往来自日常的工作经验中总结而来，也是目前大厂面试前端必问的知识点，所以重要性就不言而喻了。\n\n## 一，入门篇\n\n首先，重要的事情说三遍：\n\n>移动web性能优化原理知识同样适用于PCweb端！\n>移动web性能优化原理知识同样适用于PCweb端！\n>移动web性能优化原理知识同样适用于PCweb端！\n\n<!--more-->\n\n### 1.资源合并与压缩\n**为什么要压缩**？\n\n不同于大部分放在服务端的后台代码，前端所有的文件程序代码都是要通过浏览器下载下来运行使用，这就牵扯到网络和请求延时，所以前端文件的精简和压缩决定了前端性能的第一步。\n\n介于目前的前端框架类库，webpack，vue-cli等等，已经可以直接将这一步操作集成到我们的系统项目中了，可以直接查看各个框架的文档来进行配置，单纯的使用原生技术，可以参考下面：\n\n#### html的压缩\n\n HTML代码压缩就是压缩这些在文本文件中有意义，但是在HTML中不显示的字符，包括空格,制表符,换行符等，还有一些其他意义的字符，如HTML注释也可以被压缩。\n\n - Nodejs的[html-minifier](https://www.npmjs.com/package/html-minifier)。\n - 在线压缩工具，站长工具等等。\n\n#### CSS和JavaScript文件的压缩\nJavaScript压缩，主要是去除多余的换行和空格等等，对于语法来说，JavaScript可以选择[混淆压缩](https://www.zhihu.com/question/47047191)和非混淆压缩，无论哪种压缩都是为了减少JavaScript的文件大小，当然出于前端代码保护来看，混淆压缩会大大破坏原有的阅读逻辑，增加压缩比，从而给代码添加一层保护。\nCSS压缩，同理是去除多余的换行和空格等等，由于CSS文件的特殊性暂时无法实现混淆压缩，压缩主要是将大量的换行去除，可以减少不少的文件大小。\n\n - Nodejs的[uglifyjs2](https://github.com/mishoo/UglifyJS2)是一个强大的JavaScript压缩库。\n - Nodejs的[clean-css](https://www.npmjs.com/package/clean-css)是一个强大的CSS压缩库。\n - 在线压缩工具，站长工具等等。\n \n#### 图片的压缩\n对于常见的前端项目，关于图片的使用，主要有以下两种：\n - 固定图标，背景，按钮icon等等，这些图片有一个特点就是固定和用户无关，一般是放在源码包里面，由前端代码直接引入。\n - 人物头像，文章配图，内容图片等等，这些非固定图片一般由用户上传，有很强的用户性，这些图片一般放在`CDN`上，前端通过链接请求。\n\n\n1. 对于**固定图片**，推荐[https://tinypng.com/](https://tinypng.com/)在线压缩之后再进行引入，支持png，jpeg类型的图片，属于有损压缩，去除图片一些不必要的元数据，把相似像素的24bit位用8bit位来表示，肉眼很难区分，压缩率70%。\n ![图片描述](//img.mukewang.com/5c738b1e0001a5a802690253.png)\n 2. 采用**CSS雪碧图**：把你的网站用到的一些图片整合到一张单独的图片中：\n   优点：减少HTTP请求的数量(通过`backgroundPosition`定位所需图片)。\n   缺点：整合图片比较大时，加载比较慢(如果这张图片没有加载成功，整个页面会失去图片信息)。\n2. 对于**非固定图片**，常见的优化压缩主要有以下几种原则：\n  优先使用压缩率高的`jpeg`类型图片，缺点是不支持透明。\n  有条件的话使用[webP](https://developers.google.com/speed/webp/)(一种Google开发的新类型)类型图片是最佳选择，相比于jpeg，有更小的文件尺寸和更高的图像质量。\n\n#### 资源合并\n在前端编码的时候将css、js等静态资源文件合并压缩之外，我们还可以在页面中将多个css、js的请求合并为一个请求。文件的合并带来的是http请求数的减少，尤其是在移动端，每一个http请求带来的是`慢启动`，`三次握手`，`连接建立`，所以资源的合并是由为重要的，合并和不合并对比：\n![图片描述](//img.mukewang.com/5c739365000133da04800363.png)\n\n### 2.浏览器加载原理优化\nHTML页面加载渲染的过程：\n![图片描述](//img.mukewang.com/5c739e320001bc8310380478.jpg)\n\n根据上图我们来屡一下整个流程：\n1. 当浏览器从服务器接收到了HTML文档，并把HTML在内存中转换成DOM树，在转换的过程中如果发现某个节点(node)上引用了CSS或者 IMAGE，就会再发1个request去请求CSS或image,然后继续执行下面的转换，而不需要等待request的返回，当request返回 后，只需要把返回的内容放入到DOM树中对应的位置就OK。\n2. 但当引用了JS的时候，浏览器发送1个js request就会一直等待该request的返回。\n3. 因为浏览器需要1个稳定的DOM树结构，而JS中很有可能有代码直接改变了DOM树结构，浏览器为了防止出现JS修改DOM树，需要重新构建DOM树的情况，所以 就会`阻塞`其他的下载和呈现。\n那么如何解决和避免阻塞的问题呢，我们通过测试代码分别测试不同情况下引入js和css的问题如下：\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>test</title>\n      <link rel=”stylesheet” type=”text/css” href=”stylesheet.css” media=”screen”>\n      <link rel=”stylesheet” type=”text/css” href=”page-animation.css” media=”screen”>\n      <script type =”text/javascript” >\n          var f = 1;\n          f++;\n      </script >\n  </head>\n  <body>\n    <img src=”download-button.png”>\n  </body>\n</html>\n```\n测试过程省略，可以参考[这里](https://www.nihaoshijie.com.cn/index.php/archives/530/)，我们可以得到如下的结论：\n\n - 浏览器存在并发加载：资源请求是并发请求的。\n - 浏览器中可以支持并发请求，不同浏览器所支持的并发数量不同（以域名划分），以Chrome为例，并发上限为6优化点： 把CDN资源分布在多个域名下。\n - css 在head中通过link引入会阻塞页面的渲染，处于页面样式，我们必须这样放置。\n - 直接通过`<script src>`引入的外部js会阻塞后面节点的渲染，所以外部js尽量放在body底部。\n - 在head里面尽量不要引入js。\n - 如果要引入js 尽量将js内嵌。\n - 把内嵌js放在所有link引入css的前面。\n - 对于要阻塞后续内容的的外部js`<script src>`，需要增加`defer`来解决。\n\n### 3.缓存优化\n\n> *如果一个H5页面没有利用任何缓存，那么这个页面将没有任何存在的意义。*\n\n从从HTTP协议缓存，到浏览器缓存，再到APP Cache，一直在最近比较火的Service worker，我们可以选择多种的缓存方式，入门基本来说说HTTP协议缓存：\n![图片描述](//img.mukewang.com/5c73a73f0001eff709030569.jpg)\n\n#### 强缓存：Expires&Cache-Control\n当浏览器对某个资源的请求命中了强缓存时，返回的HTTP状态为200，在chrome的开发者工具的network里面 size会显示为from disk cache，这种情况下是**不用发送任何请求**，如下图![图片描述](//img.mukewang.com/5c73a9b500011ffa07890592.jpg)\n\n - Expires：指定了在浏览器上缓冲存储的页距过期还有多少时间，等同Cache-control中的max-age的效果，如果同时存在，则被Cache-Control的max-age覆盖。\n - Cache-Control：\n   - public：响应被缓存，并且在多用户间共享。\n   - private：默认值，响应只能够作为私有的缓存(e.g., 在一个浏览器中)，不能再用户间共享；\n   - no-cache：响应不会被缓存,而是实时向服务器端请求资源。\n   - max-age：数值，单位是秒，从请求时间开始到过期时间之间的秒数。基于请求时间（Date字段）的相对时间间隔，而不是绝对过期时间；\n#### 协商缓存：Last-Modified&Etag\n当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串，比如你打开京东的首页，按f12打开开发者工具，再按f5刷新页面，查看network，可以看到有不少请求就是命中了协商缓存的：\n![图片描述](//img.mukewang.com/5c73aba800012d8e08000191.jpg)\n - Last-Modified/If-Modified-Since：本地文件在服务器上的最后一次修改时间。缓存过期时把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比，如果时间一致，那么返回304，客户端就直接使用本地缓存文件。\n - Etag/If-None-Match：(EntityTags)是URL的tag，用来标示URL对象是否改变，一般为资源实体的哈希值。和Last-Modified类似，如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。Etag的优先级高于Last-Modified，Etag主要为了解决\n - Last-Modified 无法解决的一些问题。\n   - 文件也许会周期性的更改，但是他的内容并不改变，不希望客户端重新get；\n   - If-Modified-Since能检查到的粒度是s级；\n   - 某些服务器不能精确的得到文件的最后修改时间。\n### 4.懒加载与预加载\n懒加载对于移动web端，尤其是最常见的滚动加载场景是一项非常重要的优化措施。而预加载则常常应用于多tab场景的页面，让用户更快的看到打开的下一个页面。\n#### 懒加载\n - 图片进入可视区域之后请求图片资源。\n - 对于电商等图片很多，页面很长的业务场景适用。\n - 减少无效资源的加载。\n - 并发加载的资源过多会会阻塞js的加载，影响网站的正常使用。\n img src被设置之后，webkit解析到之后才去请求这个资源。所以我们希望图片到达可视区域之后，`img src`才会被设置进来，没有到达可视区域前并不现实真正的src，而是类似一个1px的占位符。\n\n\n#### 预加载\n\n - 图片等静态资源在使用之前的提前请求。\n - 资源使用到时能从缓存中加载，提升用户体验。\n - 点击操作前预先加载下一屏数据。\n\n\nok，读到这里，对于一些刚入门的前端玩家，或者是还在学习前端的同学，掌握了上面的入门级性能优化基础知识，才能算是基本的合格，真正更进一步的优化，更适合移动端web的性能点，可以参考进阶版：\n## 二，进阶篇\n### 1.资源合并与压缩\n#### 启用GZIP\ngzip是GNUzip的缩写，最早用于UNIX系统的文件压缩。HTTP协议上的gzip编码是一种用来改进web应用程序性能的技术，web服务器和客户端（浏览器）必须共同支持gzip。目前主流的浏览器，Chrome,firefox,IE等都支持该协议。常见的服务器如Apache，Nginx，IIS同样支持gzip。\n**gizp流程**：\n\n - 浏览器请求url，并在request header中设置属性accept-encoding:gzip。\n - 服务器支持gzip，response headers返回包含content-encoding:gzip。\n - 开启gzip可以达到80%的压缩率，即1MB的文件下载下来只需要200K，大大减少传输效率，是一项非常重要的资源压缩手段。\n\nNginx中开启gzip：\n![图片描述](//img.mukewang.com/5c7601e40001ea1a06000122.jpg)\n#### 升级HTTP/2.0\nHTTP/2是HTTP协议自1999年HTTP 1.1发布后的首个更新，主要基于[SPDY](https://zh.wikipedia.org/zh-hans/SPDY)协议（是Google开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验）。\n**优化原理：**\n根据上文中说的资源合并问题，浏览器可以同时建立有限个TCP连接，而每个连接都要经过`慢启动`，`三次握手`，`连接建立`，HTTP1.1为了解决这个问题推出了keep-alive，即保持连接不被释放，但是真正的这些连接下载资源是一个线性的流程：一个资源的请求响应返回后，下一个请求才能发送。这被称为[线头阻塞](https://zh.wikipedia.org/wiki/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E)，为了彻底解决此问题，HTTP2.0带来了[多路复用](https://zhuanlan.zhihu.com/p/26559480)：\n![图片描述](//img.mukewang.com/5c7622b10001789107790765.png)\nHTTP2.0的其他新特性也有助于页面的打开速度：\n\n - [二进制分帧](https://zhuanlan.zhihu.com/p/26559480)\n - [服务器推送](https://zhuanlan.zhihu.com/p/26559480)\n - [头部压缩](https://zhuanlan.zhihu.com/p/26559480)\n\n#### 合并资源 vs 并行加载资源？\n现在回过头来探讨一下上文说的资源合并问题，有了HTTP2.0之后，我们是否还需要合并资源，目前看需要遵循下面的原则：\n\n - **停止合并文件**\n在HTTP/1.1中，CSS，JavaScript被压缩到了一个文件，图片被合并到了一张雪碧图上。合并CSS、JavaScript和图片极大地减少了HTTP的请求数，在HTTP/1.1中能获得显著的性能提升。\n但是，在HTTP/2.0中合并文件不再是一个好的办法。虽然合并依然可以提高压缩率，但它带来了代价高昂的缓存失效。即使有一行代码改变了，整个文件就要重新打包压缩，浏览器也会强制重新加载新的文件。\n\n - **尽量不要在HTML里内联资源**\n非特殊的代码（rem适配代码，上报代码等）之外，尽量不要使用内联资源，在极端情况下，这确实能够减少给定网页的HTTP请求数。但是，和文件合并一样，HTTP/2优化时你不应该内联文件。内联意味着浏览器不能缓存单个的资源。如果你将所有页面使用的CSS声明嵌入了每一个HTML文件，这些文件每次都要从服务端获取。这导致用户在访问任何页面时都要传输额外的字节。\n - **合并域名**\n 拆分域名是让浏览器建立更多TCP连接的通常手段，浏览器限制了单个服务器的连接数量，但是通过将网站上的资源切分到几个域上，你可以获得额外的TCP连接，但是每个拆分的域名都会带来额外的DNS查询、握手，新连接的建立，根据HTTP2.0多路复用的原则：*HTTP2采用多路复用是指，在同一个域名下，开启一个TCP的connection，每个请求以stream的方式传输*，域名的合并可以带来更多的多路复用，如下图在chrome的Network面板中查看HTTP2.0，注意protocol和ConnectID相同则表示启用复用:\n ![图片描述](//img.mukewang.com/5c762a8e0001458821940784.png)\n\n#### 合理使用icon类图片base64化\n```html\n<img src=\"data:image/gif;base64,R0...\"/>\n```\n在页面使用的背景类图片icon类图片，不多且比较小的情况下，可以把图片转成base64编码嵌入到html页面或者CSS文件中，这样可以减少页面的HTTP请求数。需要注意的是，要保证图片较小，一般超过5kb的就不推荐base64嵌入显示了。[为什么是5kb？](https://www.zhihu.com/question/31155574)。\n同时，采用Webpack的[url-loader](https://github.com/webpack-contrib/url-loader)可以帮我们在不影响代码可读性的情况下，解决base64字符串问题。\n\n#### Icon Font\nIconFont技术起源于Web领域的Web Font技术，它是把一些简单的图标制作成字体，然后让图标变成和字体一样使用，Icon 的设计和使用在近几年的发展中，也经历了由当初的 img 方案 到现如今的 svg 方案，有以下优点：\n\n - 字体是矢量的，所以可以随意改变大小。\n - 因为它是字体，所以所有字体的css都可以使用，比如font-size，color，background，opacity等。\n - 减少图片请求数。\n - iconfont没有兼容性问题，IE6，Android2.3都能够兼容。\n\n### 2.浏览器加载原理优化\n \n \n#### 首屏资源优化\n\n - 剥离首屏资源\n 首屏的快速显示，可以大大提升用户对页面速度的感知，因此应尽量针对首屏的快速显示做优化，基于联通3G网络平均338KB/s(2.71Mb/s)，所以首屏资源不应超过1014KB，剥离首屏需要的资源，非首屏的资源单独合并，采用懒加载。这个原则适用上文的资源合并和加载中的场景。\n\n - 按需加载\n 将不影响首屏的资源和当前屏幕资源不用的资源放到用户需要时才加载，可以大大提升重要资源的显示速度和降低总体流量，对于移动web端常见的多tab页面，Webpack的[Code Splitting](https://webpack.js.org/guides/code-splitting/)帮助我们更加便捷实现按需加载。\n  - 非首屏图片Lazyload\n  不用多说，在目前流量费用还算比较高昂的情况下，帮助用户节省更多的流量可以避免用户的投诉，为了保证页面内容最小化，加速页面渲染，尽可能节省首屏网络流量，页面中的图片资源推荐使用懒加载实现，在页面滚动时动态载入图片。\n\n#### 使用CDN\nCDN是将源站内容分发至最接近用户的节点，使用户可就近取得所需内容，提高用户访问的响应速度和成功率。解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景。\n对于web页面来说，将项目的js，css等静态资源存放在CDN是一个重要的优化手段，加入所有资源统一打包放在同一个域名下，很难达到用户就近获取的优势（目前最佳实践是html页面采用一个域名，静态资源文件采用CDN域名），所谓静态资源即是可以被浏览器缓存的资源，而对于html页面，由于是js和css等链接的入口，通常不采用缓存。常用的[阿里云CDN](https://cn.aliyun.com/product/cdn)和[腾讯云CDN](https://cloud.tencent.com/product/cdn-scd)都有开放接口，开发者可以按需选择。\n\n#### 预加载\n此预加载主要分为两个部分，一种是采用原生浏览器支持的API来对页面的一些资源进行预先拉取或者加载，另一种是通过自己写逻辑来加载一些重要的资源，立即下面内容的前提是要立即目前移动web常见的hybrid架构，webview外壳+H5页面：\n![图片描述](//img.mukewang.com/5c7779240001ae7004170297.png)\n - DNS预解析（dns-prefetch）\n DNS 作为互联网的基础协议，其解析的速度似乎很容易被网站优化人员忽视。现在大多数新浏览器已经针对DNS解析进行了优化，典型的一次DNS解析需要耗费 20-120 毫秒，减少DNS解析时间和次数是个很好的优化方式。DNS Prefetching 是让具有此属性的域名不需要用户点击链接就在后台解析，而域名解析和内容载入是串行的网络操作，所以这个方式能 减少用户的等待时间，提升用户体验 。\n   ```html\n   <link rel=\"dns-prefetch\" href=\"//haitao.nos.netease.com\">\n   ```\n - Preload 和 Prefetch\n   两者都是以`<link rel=\"preload\"> 和 <link rel=\"prefetch\">`作为引入方式。\n   **Preload** 一个基本的用法是提前加载资源,告诉浏览器预先请求当前页需要的资源，从而提高这些资源的请求优先级，加载但是不运行，占用浏览器对同一个域名的并发数:\n   ```html\n   <link rel=\"preload\" href=\"a.js\" as=\"script\" onload=\"preloadLoad()\">\n   ```\n   **Prefetch** 一个一本用法是浏览器会在空闲的时候，下载资源, 并缓存起来。当有页面使用的时候，直接从缓存中读取。其实就是把决定是否和什么时间加载这个资源的决定权交给浏览器。\n      ```html\n   <link rel=\"prefetch\" href=\"a.js\">\n   ```\n  遗憾的是对于这两个接口，移动端的浏览器支持性很不好，这也是没有普遍推广开勇的原因。![图片描述](//img.mukewang.com/5c773be00001940412540467.png)\n  ![图片描述](//img.mukewang.com/5c773f550001ffa512560418.png)\n  ![图片描述](//img.mukewang.com/5c773f610001c4a412590485.png)\n  什么时候使用Preload，什么时候使用Prefetch可以总结如下：\n  *对于当前页面很有必要的资源使用 preload，对于可能在将来的页面中使用的资源使用 prefetch。*\n  关于Preload 和 Prefetch可以[参考这里](https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/),另外还有[Prerender](https://css-tricks.com/prefetching-preloading-prebrowsing/)，[subresource](https://css-tricks.com/prefetching-preloading-prebrowsing/)，[Preconnect](https://css-tricks.com/prefetching-preloading-prebrowsing/)属性，由于目前能支持到这些属性的机型太少，这里就不在赘述了。\n - 业务逻辑的预加载\n   关于业务逻辑的预加载，在这里我可以举一个微信小程序的例子。小程序主要分为渲染层和逻辑层，逻辑层有iOS或者Android的**JavaScript core**来运行，渲染层由各自的**webview**组件负责渲染。我们用户实际体验到的UI还是跑在我们的webview里面，这个和大多数H5页面的渲染用的是一个组件。但是为什么我们体验小程序会比H5页面要快很多？尤其是新开页面时？\n   ![图片描述](//img.mukewang.com/5c7747e50001ad1523561746.png)\n   *小程序在启动时，会预先加载所有页面逻辑代码进内存，在 a页面跳转至 b页面 时，可以在内存中直接运行而无需在发送资源请求，a页面的逻辑代码 Javascript 数据也不会从内存中消失。b页面甚至可以直接访问 a页面中的数据，整个坏境在一个大的上下文中。*\n   当然这里你可能会有疑问？假如用户不会进入page2，那加载page2的逻辑代码岂不是浪费？这里就会牵扯到一个用户行为预测的问题，在小程序的架构中，整个逻辑代码是统一在一个包里，微信是统一将这些文件下载并加载到内存中，这可能会涉及到一些浪费，但是对于提速来讲收益大于弊端的。当然小程序页提供出[分包策略](https://developers.weixin.qq.com/ebook?action=get_post_info&docid=000c8a2f9ac0b0ab0086aafeb5d80a)来优化这些问题。\n   借助小程序的思路，我们的移动web同样适用这种预加载优化逻辑：\n     1. **预加载资源**：在多tab的单页应用中，我们可以在用户打开首屏之后，预先加载其他tab的资源。例如用户进入时在推荐tab，这时就可以预先加载订单，我的 这两个tab的资源了，当用户点击订单时，页面的展现就会快一些。![图片描述](//img.mukewang.com/5c774c9c0001f0a302230278.png)\n     2. **预加载数据**：预加载数据的时机最好是在空闲时，什么是空闲时呢？我们分析一下打开一个H5页面的流程：![图片描述](//img.mukewang.com/5c7772200001633505590182.png)\n     从图上可以看到，利用闲时可以做的事情有很多，预加载数据是一个典型的优化手段，提前把新页面所需要的数据加载好，在新页面打开后，可以直接用数据来进行渲染，当然这里涉及到的跨页面数据通信，我们可以利用localStroage来实现。\n     3. **预加载webview**\n       我利用闲时来做更多事情的前提是闲时够长，但这本书也不是一个很好的现象，尽量的减少闲时，也是我们需要做的一项优化，例如我们来减少webview的加载时间，这就需要提前加载webview，此项优化大多是由native端来完成：\n  \n   - 在APP启动后，就提前在内存中将webview加载好，而不是等到点击进入web页面时才去加载。\n   - 创建一个webview的复用池，例如最多只存在3个webview，每次从池子里获取webview，达到复用的目的。\n### 3.合理利用缓存\n上文说了浏览器缓存的基础知识，既然是基础，那就说明必须掌握，下面来说一些进阶篇的利用缓存来优化页面：\n#### 妙用localStorage\nHTML5 LocalStorage可以看做是加强版的cookie，数据存储大小提升，有更好的弹性以及架构，可以将数据写入到本机的ROM中，还可以在关闭浏览器后再次打开时恢复数据，以减少网络流量，日常使用localStorage来优化我们的页面大概有以下几种场景：\n - 缓存一些非实时更新的变量，例如某些闪屏的标志位信息，地理位置信息等等，取用方便，即存即用。\n - 使用localStorage缓存Js和css文的，为了提升页面的打开速度，或者是页面可以离线使用，有些页面会采用将静态资源文件直接缓存在localStorage中，当页面打开时将内容读取出并运行，使用此方法确实可以减少http请求，提速页面。\n - 在一些跨webview通信的场景中，localStorage是兼容性最好的数据通信方案，例如预加载的数据可以缓存在localStorage中，来实现各个页面的webview数据共享。\n - 需要注意的是，localStorage并不是无限大的，针对每个域名，PC端浏览器给localStorage分配的容量大概4.5m-5m，移动端类似微信等等的浏览器大概容量是2.5m-3m[参考这里](http://dev-test.nemikor.com/web-storage/support-test/)。所以在使用时需要做好异常捕获，让localstorage超出容量时，是无法在进行插入并报错，如果对容量有更高的要求，可以参考使用[indexeddb](https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API)。需要注意的是indexeddb的兼容性却不是很好，android4.4之前以及iOS7以前都无法使用。\n#### 老生常谈离线包\n离线包技术可以说是并不算很新的技术了，各个业务都有在使用，也都有自己的一套hybrid离线包系统，关键点在于离线包的打包，同时对文件加密/签名，更新离线包(增量)\n，安全教研以及容错机制等等，在这里列举一些大厂的离线包方案来参考：\n - 美团：[LsLoader——通用移动端WebApp离线化方案](https://tech.meituan.com/2017/07/06/lsloader.html)。\n - 腾讯：[手Q离线包Alloykit](http://www.alloyteam.com/2013/12/web-cache-6-hybrid-app-tailored-cache/)。\n - 阿里：[极致的 Hybrid：航旅离线包再加速](https://yq.aliyun.com/articles/2939)\n\n#### Service Worker探索\n提到缓存，那就不得不提近几年比较火的Service Worker了：\n![图片描述](//img.mukewang.com/5c778bc9000139b107760495.png)\n作为一个比较新的技术，大家可以把 Service Worker 理解为一个介于客户端和服务器之间的一个代理服务器。在 Service Worker 中我们可以做很多事情，比如拦截客户端的请求、向客户端发送消息、向服务器发起请求等等，其中最重要的作用之一就是离线资源缓存。\nService Worker的主要复杂点在于不断地对缓存策略的调整，笔者在这里就不过多展开，可以参考一下淘宝[Service worker实战](http://taobaofed.org/blog/2018/08/08/workbox3/)。\n### 4.Nodejs服务端渲染（SSR）优化首屏时间\n在前后端分离之后，后端语言的模板功能被弱化，整个页面的渲染基本上都由前端 js 动态渲染，但这样对于一些应用来说是有缺陷的。比如需要 SEO 的，需要打开页面不用等待就能看到页面的，另外前端页面展示过度依赖js和css逻辑执行，在极端情况或者网络较差，手机性能低下(尤其在低端Android机型较为明显)时，白屏时间较长，这时服务端渲染便应用而生，至于为什么是Nodejs，作为一个前端，难道还要用Java么。。？\n**为什么会有服务端渲染？**\n如果你说服务端渲染和早期web框架，例如SSH，JSP servlet，PHP等等一样的话，那我只能说呵呵，目前的服务端渲染和早期的框架是有本质区别的：\n - *Web 2.0时代最大的思想革命本质不是前后端分离，而是把网页当作独立的应用程序（app）*。建立在前后端分离的基础上，后端只负责提供数据json格式，前端还是负责页面交互逻辑，大多数的服务端渲染采用Nodejs层来进行数据组装，html拼接。\n - 重点在首屏！！首屏时间的优化，移动互联网时代的爆发，用户对网页性能的要求越来越高，但毕竟基于3G，4G网络，让用户更快的看到页面就能挽留更多的潜在商机。服务端只负责首屏的页面渲染，真正过了首屏，大多数的业务逻辑，页面交互，还是需要有单独的前端来实现的。\n\n**如何实现？**\n如果你的项目用的是React或者是vue，那么下面两个现场的开源框架是不错的选择。\n - next.js: 服务器端渲染 react 组件框架，参考查看[React服务端渲染指南](https://segmentfault.com/a/1190000015578803)。\n - nuxt.js: 服务器端渲染 vue 组件框架，参考查看 https://zh.nuxtjs.org/。\n - gatsbyjs:服务端React渲染框架，目前看比较新，网上的资料还不是很多，参考查看： https://www.gatsbyjs.org/\n\n当然，你也可以自己实现一套自己的服务端渲染框架，一般需要关注这些问题：\n\n - 实现自定义的Node端的window上下文对象Cookie & Session等。\n - 远程数据的获取，一般采用Nodejs的http模块。\n - React采用ReactDOMServer调用renderToString(),Vue采用vue-server-renderer调用renderToString()。\n - Node端内存泄露和控制等问题\n\n**代码同构(isomorphic)**\n使用Nodejs的服务端渲染的一大优势就是代码同构，这使得一个项目可以分别部署成走线上正常前端渲染版本，和走服务端渲染版本，这样可以更好的做到容灾机制，当任何一种分之挂掉之后，可以直接走另一个版本，提高稳定性。这也同构的魅力所在！因为在同构直出宕掉的时候，还有前端渲染页面可以提供正常的服务。\n![图片描述](//img.mukewang.com/5c77aacc000107f406780266.png)\n\n**取舍**\n虽然说服务端渲染这类优化确实可以提升一定的页面首屏时间，但是也是需要成本的，在前端开发接管了Node作为中间层时，需要额外的机器资源部署，并且一旦接触到后端，容灾机制，内存管理等性能指标都需要关注，这对于当前的业务系统架构可能需要有一定的调整，所以还是要斟酌来使用。\n### 5.渲染优化\n终于回到我们前端的老本家了，如果说前面的优化都是在框架，逻辑层面的优化，或者是参考后端，客户端的优化思路，那么真正涉及到UI渲染的优化才是我们作为前端工程师的立身之本了。\n\n - **何为渲染优化？**\n\n  抛开首屏加速，真正让用户体验web页面的另一个很重要的部分就是用户行为交互了，这包括用户的**点击相应**，**滚动流畅度**，**动画是否卡顿**流畅度等等，这些关于用户交互性的优化在已往的PC端可能不是很被重视，因为PC浏览器的性能要远远大于手机端，但是到了移动web就不一样了，用户都希望移动web能有PC端一样的性能。\n\n - **为什么同样的页面在iPhone里总比Android流畅？**\n\n  目前主流的Android硬件配置可以说是甩iPhone几条街了，那为什么高配置却得不到好的体验呢？关键两类机型的操作系统上的优化程度，其中一个原因就是iOS操作系统采用执行率较高的Object-c语言，大部分硬件接口可以直接调用和运行，而Android则采用Java语言，因为虚拟机的存在，虽然跨平台性提升了，但是通过虚拟机在和系统硬件交互，执行效率就低了很多，当然这只是其中一个原因。那么，我们移动web主要优化的群体就是Android机型了。\n\n - ****16ms优化****\n\n  目前大多数设备的屏幕刷新频率为60次/秒，每一帧所消耗的时间约为16ms（1000 ms / 60 = 16.66ms），这16ms就是渲染帧的时长，所谓渲染帧是指浏览器一次完整绘制过程，帧之间的时间间隔是DOM视图更新的最小间隔，但实际上，浏览器还有一些整理工作要做，因此开发者所做的所有工作需要在10ms内完成。\n  如果不能完成，帧率将会下降，网页会在屏幕上抖动，也就是通常所说的卡顿，这会对用户体验产生严重的负面影响。所以如果一个页面中有动画效果或者用户正在滚动页面，那么浏览器渲染动画或页面的速率也要尽可能地与设备屏幕的刷新频率保持一致，以保证良好的用户体验。在这一个间隔内，浏览器可能需要做以下事情：\n\n   - 脚本执行（JavaScript）：脚本造成了需要重绘的改动，比如增删 DOM、请求动画等\n   - 样式计算（CSS Object Model）：级联地生成每个节点的生效样式。\n   - 布局（Layout）：计算布局，执行渲染算法\n   - 重绘（Paint）：各层分别进行绘制（比如 3D 动画）\n   - 合成（Composite）：合成各层的渲染结果\n\n - **重绘和重排**\n  在上面浏览器需要做的这些事情中，会引发不同程度的重绘和重排，而重绘和重排正式影响流畅的重要因素：\n  1. 部分渲染树（或者整个渲染树）需要重新分析并且节点尺寸需要重新计算，这被称为重排。\n\n  2. 由于节点的几何属性发生改变或者由于样式发生改变，例如改变元素背景色时，屏幕上的部分内容需要更新，这样的更新被称为重绘。\n\n  重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，但是每次重排，必然会导致重绘，而每次重绘并不一定会发生重排，我们需要在以下几种场景来减少重排的发生：\n  当页面布局和几何属性改变时就需要回流。下述情况会发生浏览器回流：\n  1. 添加或者删除可见的DOM元素。\n  2. 元素位置改变。\n  3. 元素尺寸改变——边距、填充、边框、宽度和高度。\n  4. 内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变。\n  5. 页面渲染初始化。\n  6. 浏览器窗口尺寸改变——resize事件发生时。\n\n - **使用 requestAnimationFrame**\n提升动画流畅度的另一个重要因素是让浏览器变得智能起来，好在浏览器给我们提供了这个接口requestAnimationFrame，通过这个API,可以告诉浏览器某个JavaScript代码要执行动画，浏览器收到通知后，则会运行这些代码的时候进行优化，它会确保JS尽早在每一帧的开始执行，实现流畅的效果，而不再需要开发人员烦心刷新频率的问题了：\n  ```javascript\n  function animationWidth() {\n    var div = document.getElementById('box');\n    div.style.width = parseInt(div.style.width) + 1 + 'px';\n\n    if(parseInt(div.style.width) < 200) {\n      requestAnimationFrame(animationWidth)\n    }\n  }\n  requestAnimationFrame(animationWidth);\n\n  ```\n\n - **试试requestIdleCallback**\n requestIdleCallback的出现伴随着React 16 的Fiber特性，他的使用场景是当用户在做负责交互时，不希望因为一些不重要的任务（如统计上报）导致用户感觉到卡顿的话，就应该考虑使用了，因为requestIdleCallback回调的执行的前提条件是当前浏览器处于空闲状态，但是需要注意的是不要在requestIdleCallback操作任何DOM，这违背了这个接口的设计原则。\n   ```javascript\n       requestIdelCallback(myNonEssentialWork);\n      function myNonEssentialWork (deadline) {\n      \n        // deadline.timeRemaining()可以获取到当前帧剩余时间\n        while (deadline.timeRemaining() > 0 && tasks.length > 0) {\n          doWorkIfNeeded();\n        }\n        if (tasks.length > 0){\n          requestIdleCallback(myNonEssentialWork);\n        }\n      }\n   ```\n   \n\n - **fragment元素的应用**\n   在你使用dominnerHTML方法来插入大量dom节点时，不妨试试fragment，fragment文档片段是个轻量级的document对象，它的设计初衷就是为了完成这类任务——更新和移动节点。文档片段的一个便利的语法特性是当你附加一个片断到节点时，实际上被添加的是该片断的子节点，而不是片断本身。只触发了一次重排，而且只访问了一次实时的DOM。\n\n - **列表滚动优化**\n 长列表滚动在移动端是一种非常常见的交互模式，例如feeds流，图片流等等，这些列表的滚动流畅度优化对用户体验的提升是非常重要的，基于目前的优化思路，借助dom复用的方案，类似iOS的UITableView或者Android的recyclerview原理，在列表滚动时，只保证视窗区域内的dom节点存在，在有限的dom节点内实现滚动，而不在创建新的节点，在用户不断下拉翻页的过程中，保证整个页面有限的dom元素来减少内存的消耗，原理如下图：\n ![图片描述](//img.mukewang.com/5c78e94900013bc502610519.png)\n 复用的dom：\n ![图片描述](//img.mukewang.com/5c78e95b000190de01830324.png)\n 采用这一个方案的前端是借助浏览器的onscroll事件来做逻辑处理，但是问题在于有些机型例如iOS的UIWebview下，onscroll不能实时触发，这就给优化带来了难题，由此引发出了模拟滚动:\n\n - 正常的滚动：我们平时使用的scroll，包括上面讲的滚动都属于正常滚动，利用浏览器自身提供的滚动条来实现滚动，底层是由浏览器内核控制。\n - 模拟滚动：最典型的例子就是iscroll了，原理一般有两种：\n   - 1).监听滚动元素的touchmove事件，当事件触发时修改元素的transform属性来实现元素的位移，让手指离开时触发touchend事件，然后采用requestanimationframe来在一个线型函数下不断的修改元素的transform来实现手指离开时的一段惯性滚动距离。\n   - 2).监听滚动元素的touchmove事件，当事件触发时修改元素的transform属性来实现元素的位移，让手指离开时触发touchend事件，然后给元素一个css的animation，并设置好duration和function来实现手指离开时的一段惯性距离。\n\n  结论是如果要采用模拟滚动，可以解决onscroll不实时触发的问题，从而实现长列表的复用的优化，但是带来新的问题就是模拟滚动本身也是dom的重绘，增加额外的性能消耗，达到有优化效果并不理想，好在iOS的新版WKwebview解决了onscroll问题，让开发者有了更好的选择。\n\n - **滚动函数防抖**\n当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。\n  ```javascript\n  function debounce(fn, wait) {\n      var timeout = null;\n      return function() {\n          if(timeout !== null) \n                  clearTimeout(timeout);\n          timeout = setTimeout(fn, wait);\n      }\n  }\n  // 处理函数\n  function handle() {\n      console.log(Math.random()); \n  }\n  // 滚动事件\n  window.addEventListener('scroll', debounce(handle, 1000));\n  ```\n - **合理使用GPU**\n   动画卡顿是在移动web开发时经常遇到的问题，解决这个问题一般会用到CSS3硬件加速。硬件加速这个名字感觉上很高大上，其实它做的事情可以简单概括为：通过GPU进行渲染，解放CPU，我们可以利用GPU的图形层，将负责的动画操作放在这个层，如何开启？\n   ```css\n   webkit-transform: translateZ(0);\n   ```\n   强制把需要动画的dom的对象 ，放置在GPU的layout层来缓存从而达到任何移动，大小变化都在这个层。\n通过开启GPU硬件加速虽然可以提升动画渲染性能或解决一些棘手问题，但使用仍需谨慎，使用前一定要进行严谨的测试，否则它反而会大量占用浏览网页用户的系统资源，尤其是在移动端，肆无忌惮的开启GPU硬件加速会导致大量消耗内存，千万不要`* {webkit-transform: translateZ(0);}`。\n\n### 写在最后\n本文在性能优化的基础上，将移动web的性能点逐步展开和深入，大部分属于结论性介绍内容，真正实践还是需要开发人员亲身尝试来得到优化提升，总之，\n*技术就是在于不断折腾，愿各位在踩坑的道路上一帆风顺！*\n\n\n","slug":"移动web性能优化从入门到进阶","published":1,"updated":"2019-03-03T13:53:56.000Z","comments":1,"layout":"post","link":"","_id":"ckx434q1u003z2wvjpety2a7k","content":"<p>关于前端性能优化相关的技术知识，网上随便搜一些就有很多，本文将系统性的从初级到高级的思路，总结移动前端性能优化各个方面的相关技术点，内容来自笔者以往经验的总结，希望读者可以花些时间看看。</p>\n<p>在目前大多数刚从事前端开发，或者是正在学习前端开发的同学来说，性能优化对于他们可能还比较远，但是脱颖而出，拉开差距的点，往往就在与性能优化，和理论知识不同，性能优化往往来自日常的工作经验中总结而来，也是目前大厂面试前端必问的知识点，所以重要性就不言而喻了。</p>\n<h2><span id=\"一入门篇\">一，入门篇</span></h2><p>首先，重要的事情说三遍：</p>\n<blockquote>\n<p>移动web性能优化原理知识同样适用于PCweb端！<br>移动web性能优化原理知识同样适用于PCweb端！<br>移动web性能优化原理知识同样适用于PCweb端！</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3><span id=\"1资源合并与压缩\">1.资源合并与压缩</span></h3><p><strong>为什么要压缩</strong>？</p>\n<p>不同于大部分放在服务端的后台代码，前端所有的文件程序代码都是要通过浏览器下载下来运行使用，这就牵扯到网络和请求延时，所以前端文件的精简和压缩决定了前端性能的第一步。</p>\n<p>介于目前的前端框架类库，webpack，vue-cli等等，已经可以直接将这一步操作集成到我们的系统项目中了，可以直接查看各个框架的文档来进行配置，单纯的使用原生技术，可以参考下面：</p>\n<h4><span id=\"html的压缩\">html的压缩</span></h4><p> HTML代码压缩就是压缩这些在文本文件中有意义，但是在HTML中不显示的字符，包括空格,制表符,换行符等，还有一些其他意义的字符，如HTML注释也可以被压缩。</p>\n<ul>\n<li>Nodejs的<a href=\"https://www.npmjs.com/package/html-minifier\" target=\"_blank\" rel=\"noopener\">html-minifier</a>。</li>\n<li>在线压缩工具，站长工具等等。</li>\n</ul>\n<h4><span id=\"css和javascript文件的压缩\">CSS和JavaScript文件的压缩</span></h4><p>JavaScript压缩，主要是去除多余的换行和空格等等，对于语法来说，JavaScript可以选择<a href=\"https://www.zhihu.com/question/47047191\" target=\"_blank\" rel=\"noopener\">混淆压缩</a>和非混淆压缩，无论哪种压缩都是为了减少JavaScript的文件大小，当然出于前端代码保护来看，混淆压缩会大大破坏原有的阅读逻辑，增加压缩比，从而给代码添加一层保护。<br>CSS压缩，同理是去除多余的换行和空格等等，由于CSS文件的特殊性暂时无法实现混淆压缩，压缩主要是将大量的换行去除，可以减少不少的文件大小。</p>\n<ul>\n<li>Nodejs的<a href=\"https://github.com/mishoo/UglifyJS2\" target=\"_blank\" rel=\"noopener\">uglifyjs2</a>是一个强大的JavaScript压缩库。</li>\n<li>Nodejs的<a href=\"https://www.npmjs.com/package/clean-css\" target=\"_blank\" rel=\"noopener\">clean-css</a>是一个强大的CSS压缩库。</li>\n<li>在线压缩工具，站长工具等等。</li>\n</ul>\n<h4><span id=\"图片的压缩\">图片的压缩</span></h4><p>对于常见的前端项目，关于图片的使用，主要有以下两种：</p>\n<ul>\n<li>固定图标，背景，按钮icon等等，这些图片有一个特点就是固定和用户无关，一般是放在源码包里面，由前端代码直接引入。</li>\n<li>人物头像，文章配图，内容图片等等，这些非固定图片一般由用户上传，有很强的用户性，这些图片一般放在<code>CDN</code>上，前端通过链接请求。</li>\n</ul>\n<ol>\n<li>对于<strong>固定图片</strong>，推荐<a href=\"https://tinypng.com/\" target=\"_blank\" rel=\"noopener\">https://tinypng.com/</a>在线压缩之后再进行引入，支持png，jpeg类型的图片，属于有损压缩，去除图片一些不必要的元数据，把相似像素的24bit位用8bit位来表示，肉眼很难区分，压缩率70%。<br><img src=\"//img.mukewang.com/5c738b1e0001a5a802690253.png\" alt=\"图片描述\"><ol>\n<li>采用<strong>CSS雪碧图</strong>：把你的网站用到的一些图片整合到一张单独的图片中：<br>优点：减少HTTP请求的数量(通过<code>backgroundPosition</code>定位所需图片)。<br>缺点：整合图片比较大时，加载比较慢(如果这张图片没有加载成功，整个页面会失去图片信息)。</li>\n</ol>\n</li>\n<li>对于<strong>非固定图片</strong>，常见的优化压缩主要有以下几种原则：<br>优先使用压缩率高的<code>jpeg</code>类型图片，缺点是不支持透明。<br>有条件的话使用<a href=\"https://developers.google.com/speed/webp/\" target=\"_blank\" rel=\"noopener\">webP</a>(一种Google开发的新类型)类型图片是最佳选择，相比于jpeg，有更小的文件尺寸和更高的图像质量。</li>\n</ol>\n<h4><span id=\"资源合并\">资源合并</span></h4><p>在前端编码的时候将css、js等静态资源文件合并压缩之外，我们还可以在页面中将多个css、js的请求合并为一个请求。文件的合并带来的是http请求数的减少，尤其是在移动端，每一个http请求带来的是<code>慢启动</code>，<code>三次握手</code>，<code>连接建立</code>，所以资源的合并是由为重要的，合并和不合并对比：<br><img src=\"//img.mukewang.com/5c739365000133da04800363.png\" alt=\"图片描述\"></p>\n<h3><span id=\"2浏览器加载原理优化\">2.浏览器加载原理优化</span></h3><p>HTML页面加载渲染的过程：<br><img src=\"//img.mukewang.com/5c739e320001bc8310380478.jpg\" alt=\"图片描述\"></p>\n<p>根据上图我们来屡一下整个流程：</p>\n<ol>\n<li>当浏览器从服务器接收到了HTML文档，并把HTML在内存中转换成DOM树，在转换的过程中如果发现某个节点(node)上引用了CSS或者 IMAGE，就会再发1个request去请求CSS或image,然后继续执行下面的转换，而不需要等待request的返回，当request返回 后，只需要把返回的内容放入到DOM树中对应的位置就OK。</li>\n<li>但当引用了JS的时候，浏览器发送1个js request就会一直等待该request的返回。</li>\n<li>因为浏览器需要1个稳定的DOM树结构，而JS中很有可能有代码直接改变了DOM树结构，浏览器为了防止出现JS修改DOM树，需要重新构建DOM树的情况，所以 就会<code>阻塞</code>其他的下载和呈现。<br>那么如何解决和避免阻塞的问题呢，我们通过测试代码分别测试不同情况下引入js和css的问题如下：</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">”stylesheet”</span> <span class=\"attr\">type</span>=<span class=\"string\">”text/css”</span> <span class=\"attr\">href</span>=<span class=\"string\">”stylesheet.css”</span> <span class=\"attr\">media</span>=<span class=\"string\">”screen”</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">”stylesheet”</span> <span class=\"attr\">type</span>=<span class=\"string\">”text/css”</span> <span class=\"attr\">href</span>=<span class=\"string\">”page-animation.css”</span> <span class=\"attr\">media</span>=<span class=\"string\">”screen”</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span> =<span class=\"string\">”text/javascript”</span> &gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">          <span class=\"keyword\">var</span> f = <span class=\"number\">1</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">          f++;</span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;/<span class=\"name\">script</span> &gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">”download-button.png”</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>测试过程省略，可以参考<a href=\"https://www.nihaoshijie.com.cn/index.php/archives/530/\">这里</a>，我们可以得到如下的结论：</p>\n<ul>\n<li>浏览器存在并发加载：资源请求是并发请求的。</li>\n<li>浏览器中可以支持并发请求，不同浏览器所支持的并发数量不同（以域名划分），以Chrome为例，并发上限为6优化点： 把CDN资源分布在多个域名下。</li>\n<li>css 在head中通过link引入会阻塞页面的渲染，处于页面样式，我们必须这样放置。</li>\n<li>直接通过<code>&lt;script src&gt;</code>引入的外部js会阻塞后面节点的渲染，所以外部js尽量放在body底部。</li>\n<li>在head里面尽量不要引入js。</li>\n<li>如果要引入js 尽量将js内嵌。</li>\n<li>把内嵌js放在所有link引入css的前面。</li>\n<li>对于要阻塞后续内容的的外部js<code>&lt;script src&gt;</code>，需要增加<code>defer</code>来解决。</li>\n</ul>\n<h3><span id=\"3缓存优化\">3.缓存优化</span></h3><blockquote>\n<p><em>如果一个H5页面没有利用任何缓存，那么这个页面将没有任何存在的意义。</em></p>\n</blockquote>\n<p>从从HTTP协议缓存，到浏览器缓存，再到APP Cache，一直在最近比较火的Service worker，我们可以选择多种的缓存方式，入门基本来说说HTTP协议缓存：<br><img src=\"//img.mukewang.com/5c73a73f0001eff709030569.jpg\" alt=\"图片描述\"></p>\n<h4><span id=\"强缓存expiresampcache-control\">强缓存：Expires&amp;Cache-Control</span></h4><p>当浏览器对某个资源的请求命中了强缓存时，返回的HTTP状态为200，在chrome的开发者工具的network里面 size会显示为from disk cache，这种情况下是<strong>不用发送任何请求</strong>，如下图<img src=\"//img.mukewang.com/5c73a9b500011ffa07890592.jpg\" alt=\"图片描述\"></p>\n<ul>\n<li>Expires：指定了在浏览器上缓冲存储的页距过期还有多少时间，等同Cache-control中的max-age的效果，如果同时存在，则被Cache-Control的max-age覆盖。</li>\n<li>Cache-Control：<ul>\n<li>public：响应被缓存，并且在多用户间共享。</li>\n<li>private：默认值，响应只能够作为私有的缓存(e.g., 在一个浏览器中)，不能再用户间共享；</li>\n<li>no-cache：响应不会被缓存,而是实时向服务器端请求资源。</li>\n<li>max-age：数值，单位是秒，从请求时间开始到过期时间之间的秒数。基于请求时间（Date字段）的相对时间间隔，而不是绝对过期时间；<h4><span id=\"协商缓存last-modifiedampetag\">协商缓存：Last-Modified&amp;Etag</span></h4>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串，比如你打开京东的首页，按f12打开开发者工具，再按f5刷新页面，查看network，可以看到有不少请求就是命中了协商缓存的：<br><img src=\"//img.mukewang.com/5c73aba800012d8e08000191.jpg\" alt=\"图片描述\"></li>\n</ul>\n</li>\n<li>Last-Modified/If-Modified-Since：本地文件在服务器上的最后一次修改时间。缓存过期时把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比，如果时间一致，那么返回304，客户端就直接使用本地缓存文件。</li>\n<li>Etag/If-None-Match：(EntityTags)是URL的tag，用来标示URL对象是否改变，一般为资源实体的哈希值。和Last-Modified类似，如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。Etag的优先级高于Last-Modified，Etag主要为了解决</li>\n<li>Last-Modified 无法解决的一些问题。<ul>\n<li>文件也许会周期性的更改，但是他的内容并不改变，不希望客户端重新get；</li>\n<li>If-Modified-Since能检查到的粒度是s级；</li>\n<li>某些服务器不能精确的得到文件的最后修改时间。<h3><span id=\"4懒加载与预加载\">4.懒加载与预加载</span></h3>懒加载对于移动web端，尤其是最常见的滚动加载场景是一项非常重要的优化措施。而预加载则常常应用于多tab场景的页面，让用户更快的看到打开的下一个页面。<h4><span id=\"懒加载\">懒加载</span></h4></li>\n</ul>\n</li>\n<li>图片进入可视区域之后请求图片资源。</li>\n<li>对于电商等图片很多，页面很长的业务场景适用。</li>\n<li>减少无效资源的加载。</li>\n<li>并发加载的资源过多会会阻塞js的加载，影响网站的正常使用。<br>img src被设置之后，webkit解析到之后才去请求这个资源。所以我们希望图片到达可视区域之后，<code>img src</code>才会被设置进来，没有到达可视区域前并不现实真正的src，而是类似一个1px的占位符。</li>\n</ul>\n<h4><span id=\"预加载\">预加载</span></h4><ul>\n<li>图片等静态资源在使用之前的提前请求。</li>\n<li>资源使用到时能从缓存中加载，提升用户体验。</li>\n<li>点击操作前预先加载下一屏数据。</li>\n</ul>\n<p>ok，读到这里，对于一些刚入门的前端玩家，或者是还在学习前端的同学，掌握了上面的入门级性能优化基础知识，才能算是基本的合格，真正更进一步的优化，更适合移动端web的性能点，可以参考进阶版：</p>\n<h2><span id=\"二进阶篇\">二，进阶篇</span></h2><h3><span id=\"1资源合并与压缩\">1.资源合并与压缩</span></h3><h4><span id=\"启用gzip\">启用GZIP</span></h4><p>gzip是GNUzip的缩写，最早用于UNIX系统的文件压缩。HTTP协议上的gzip编码是一种用来改进web应用程序性能的技术，web服务器和客户端（浏览器）必须共同支持gzip。目前主流的浏览器，Chrome,firefox,IE等都支持该协议。常见的服务器如Apache，Nginx，IIS同样支持gzip。<br><strong>gizp流程</strong>：</p>\n<ul>\n<li>浏览器请求url，并在request header中设置属性accept-encoding:gzip。</li>\n<li>服务器支持gzip，response headers返回包含content-encoding:gzip。</li>\n<li>开启gzip可以达到80%的压缩率，即1MB的文件下载下来只需要200K，大大减少传输效率，是一项非常重要的资源压缩手段。</li>\n</ul>\n<p>Nginx中开启gzip：<br><img src=\"//img.mukewang.com/5c7601e40001ea1a06000122.jpg\" alt=\"图片描述\"></p>\n<h4><span id=\"升级http20\">升级HTTP/2.0</span></h4><p>HTTP/2是HTTP协议自1999年HTTP 1.1发布后的首个更新，主要基于<a href=\"https://zh.wikipedia.org/zh-hans/SPDY\" target=\"_blank\" rel=\"noopener\">SPDY</a>协议（是Google开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验）。<br><strong>优化原理：</strong><br>根据上文中说的资源合并问题，浏览器可以同时建立有限个TCP连接，而每个连接都要经过<code>慢启动</code>，<code>三次握手</code>，<code>连接建立</code>，HTTP1.1为了解决这个问题推出了keep-alive，即保持连接不被释放，但是真正的这些连接下载资源是一个线性的流程：一个资源的请求响应返回后，下一个请求才能发送。这被称为<a href=\"https://zh.wikipedia.org/wiki/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E\" target=\"_blank\" rel=\"noopener\">线头阻塞</a>，为了彻底解决此问题，HTTP2.0带来了<a href=\"https://zhuanlan.zhihu.com/p/26559480\" target=\"_blank\" rel=\"noopener\">多路复用</a>：<br><img src=\"//img.mukewang.com/5c7622b10001789107790765.png\" alt=\"图片描述\"><br>HTTP2.0的其他新特性也有助于页面的打开速度：</p>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/26559480\" target=\"_blank\" rel=\"noopener\">二进制分帧</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/26559480\" target=\"_blank\" rel=\"noopener\">服务器推送</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/26559480\" target=\"_blank\" rel=\"noopener\">头部压缩</a></li>\n</ul>\n<h4><span id=\"合并资源-vs-并行加载资源\">合并资源 vs 并行加载资源？</span></h4><p>现在回过头来探讨一下上文说的资源合并问题，有了HTTP2.0之后，我们是否还需要合并资源，目前看需要遵循下面的原则：</p>\n<ul>\n<li><p><strong>停止合并文件</strong><br>在HTTP/1.1中，CSS，JavaScript被压缩到了一个文件，图片被合并到了一张雪碧图上。合并CSS、JavaScript和图片极大地减少了HTTP的请求数，在HTTP/1.1中能获得显著的性能提升。<br>但是，在HTTP/2.0中合并文件不再是一个好的办法。虽然合并依然可以提高压缩率，但它带来了代价高昂的缓存失效。即使有一行代码改变了，整个文件就要重新打包压缩，浏览器也会强制重新加载新的文件。</p>\n</li>\n<li><p><strong>尽量不要在HTML里内联资源</strong><br>非特殊的代码（rem适配代码，上报代码等）之外，尽量不要使用内联资源，在极端情况下，这确实能够减少给定网页的HTTP请求数。但是，和文件合并一样，HTTP/2优化时你不应该内联文件。内联意味着浏览器不能缓存单个的资源。如果你将所有页面使用的CSS声明嵌入了每一个HTML文件，这些文件每次都要从服务端获取。这导致用户在访问任何页面时都要传输额外的字节。</p>\n</li>\n<li><strong>合并域名</strong><br>拆分域名是让浏览器建立更多TCP连接的通常手段，浏览器限制了单个服务器的连接数量，但是通过将网站上的资源切分到几个域上，你可以获得额外的TCP连接，但是每个拆分的域名都会带来额外的DNS查询、握手，新连接的建立，根据HTTP2.0多路复用的原则：<em>HTTP2采用多路复用是指，在同一个域名下，开启一个TCP的connection，每个请求以stream的方式传输</em>，域名的合并可以带来更多的多路复用，如下图在chrome的Network面板中查看HTTP2.0，注意protocol和ConnectID相同则表示启用复用:<br><img src=\"//img.mukewang.com/5c762a8e0001458821940784.png\" alt=\"图片描述\"></li>\n</ul>\n<h4><span id=\"合理使用icon类图片base64化\">合理使用icon类图片base64化</span></h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"data:image/gif;base64,R0...\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在页面使用的背景类图片icon类图片，不多且比较小的情况下，可以把图片转成base64编码嵌入到html页面或者CSS文件中，这样可以减少页面的HTTP请求数。需要注意的是，要保证图片较小，一般超过5kb的就不推荐base64嵌入显示了。<a href=\"https://www.zhihu.com/question/31155574\" target=\"_blank\" rel=\"noopener\">为什么是5kb？</a>。<br>同时，采用Webpack的<a href=\"https://github.com/webpack-contrib/url-loader\" target=\"_blank\" rel=\"noopener\">url-loader</a>可以帮我们在不影响代码可读性的情况下，解决base64字符串问题。</p>\n<h4><span id=\"icon-font\">Icon Font</span></h4><p>IconFont技术起源于Web领域的Web Font技术，它是把一些简单的图标制作成字体，然后让图标变成和字体一样使用，Icon 的设计和使用在近几年的发展中，也经历了由当初的 img 方案 到现如今的 svg 方案，有以下优点：</p>\n<ul>\n<li>字体是矢量的，所以可以随意改变大小。</li>\n<li>因为它是字体，所以所有字体的css都可以使用，比如font-size，color，background，opacity等。</li>\n<li>减少图片请求数。</li>\n<li>iconfont没有兼容性问题，IE6，Android2.3都能够兼容。</li>\n</ul>\n<h3><span id=\"2浏览器加载原理优化\">2.浏览器加载原理优化</span></h3><h4><span id=\"首屏资源优化\">首屏资源优化</span></h4><ul>\n<li><p>剥离首屏资源<br>首屏的快速显示，可以大大提升用户对页面速度的感知，因此应尽量针对首屏的快速显示做优化，基于联通3G网络平均338KB/s(2.71Mb/s)，所以首屏资源不应超过1014KB，剥离首屏需要的资源，非首屏的资源单独合并，采用懒加载。这个原则适用上文的资源合并和加载中的场景。</p>\n</li>\n<li><p>按需加载<br>将不影响首屏的资源和当前屏幕资源不用的资源放到用户需要时才加载，可以大大提升重要资源的显示速度和降低总体流量，对于移动web端常见的多tab页面，Webpack的<a href=\"https://webpack.js.org/guides/code-splitting/\" target=\"_blank\" rel=\"noopener\">Code Splitting</a>帮助我们更加便捷实现按需加载。</p>\n<ul>\n<li>非首屏图片Lazyload<br>不用多说，在目前流量费用还算比较高昂的情况下，帮助用户节省更多的流量可以避免用户的投诉，为了保证页面内容最小化，加速页面渲染，尽可能节省首屏网络流量，页面中的图片资源推荐使用懒加载实现，在页面滚动时动态载入图片。</li>\n</ul>\n</li>\n</ul>\n<h4><span id=\"使用cdn\">使用CDN</span></h4><p>CDN是将源站内容分发至最接近用户的节点，使用户可就近取得所需内容，提高用户访问的响应速度和成功率。解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景。<br>对于web页面来说，将项目的js，css等静态资源存放在CDN是一个重要的优化手段，加入所有资源统一打包放在同一个域名下，很难达到用户就近获取的优势（目前最佳实践是html页面采用一个域名，静态资源文件采用CDN域名），所谓静态资源即是可以被浏览器缓存的资源，而对于html页面，由于是js和css等链接的入口，通常不采用缓存。常用的<a href=\"https://cn.aliyun.com/product/cdn\" target=\"_blank\" rel=\"noopener\">阿里云CDN</a>和<a href=\"https://cloud.tencent.com/product/cdn-scd\" target=\"_blank\" rel=\"noopener\">腾讯云CDN</a>都有开放接口，开发者可以按需选择。</p>\n<h4><span id=\"预加载\">预加载</span></h4><p>此预加载主要分为两个部分，一种是采用原生浏览器支持的API来对页面的一些资源进行预先拉取或者加载，另一种是通过自己写逻辑来加载一些重要的资源，立即下面内容的前提是要立即目前移动web常见的hybrid架构，webview外壳+H5页面：<br><img src=\"//img.mukewang.com/5c7779240001ae7004170297.png\" alt=\"图片描述\"></p>\n<ul>\n<li><p>DNS预解析（dns-prefetch）<br>DNS 作为互联网的基础协议，其解析的速度似乎很容易被网站优化人员忽视。现在大多数新浏览器已经针对DNS解析进行了优化，典型的一次DNS解析需要耗费 20-120 毫秒，减少DNS解析时间和次数是个很好的优化方式。DNS Prefetching 是让具有此属性的域名不需要用户点击链接就在后台解析，而域名解析和内容载入是串行的网络操作，所以这个方式能 减少用户的等待时间，提升用户体验 。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"dns-prefetch\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"//haitao.nos.netease.com\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Preload 和 Prefetch<br>两者都是以<code>&lt;link rel=&quot;preload&quot;&gt; 和 &lt;link rel=&quot;prefetch&quot;&gt;</code>作为引入方式。<br><strong>Preload</strong> 一个基本的用法是提前加载资源,告诉浏览器预先请求当前页需要的资源，从而提高这些资源的请求优先级，加载但是不运行，占用浏览器对同一个域名的并发数:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"preload\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"a.js\"</span> <span class=\"attr\">as</span>=<span class=\"string\">\"script\"</span> <span class=\"attr\">onload</span>=<span class=\"string\">\"preloadLoad()\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>Prefetch</strong> 一个一本用法是浏览器会在空闲的时候，下载资源, 并缓存起来。当有页面使用的时候，直接从缓存中读取。其实就是把决定是否和什么时间加载这个资源的决定权交给浏览器。</p>\n   <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"prefetch\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"a.js\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>遗憾的是对于这两个接口，移动端的浏览器支持性很不好，这也是没有普遍推广开勇的原因。<img src=\"//img.mukewang.com/5c773be00001940412540467.png\" alt=\"图片描述\"><br><img src=\"//img.mukewang.com/5c773f550001ffa512560418.png\" alt=\"图片描述\"><br><img src=\"//img.mukewang.com/5c773f610001c4a412590485.png\" alt=\"图片描述\"><br>什么时候使用Preload，什么时候使用Prefetch可以总结如下：<br><em>对于当前页面很有必要的资源使用 preload，对于可能在将来的页面中使用的资源使用 prefetch。</em><br>关于Preload 和 Prefetch可以<a href=\"https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/\" target=\"_blank\" rel=\"noopener\">参考这里</a>,另外还有<a href=\"https://css-tricks.com/prefetching-preloading-prebrowsing/\" target=\"_blank\" rel=\"noopener\">Prerender</a>，<a href=\"https://css-tricks.com/prefetching-preloading-prebrowsing/\" target=\"_blank\" rel=\"noopener\">subresource</a>，<a href=\"https://css-tricks.com/prefetching-preloading-prebrowsing/\" target=\"_blank\" rel=\"noopener\">Preconnect</a>属性，由于目前能支持到这些属性的机型太少，这里就不在赘述了。</p>\n</li>\n<li><p>业务逻辑的预加载<br>关于业务逻辑的预加载，在这里我可以举一个微信小程序的例子。小程序主要分为渲染层和逻辑层，逻辑层有iOS或者Android的<strong>JavaScript core</strong>来运行，渲染层由各自的<strong>webview</strong>组件负责渲染。我们用户实际体验到的UI还是跑在我们的webview里面，这个和大多数H5页面的渲染用的是一个组件。但是为什么我们体验小程序会比H5页面要快很多？尤其是新开页面时？<br><img src=\"//img.mukewang.com/5c7747e50001ad1523561746.png\" alt=\"图片描述\"><br><em>小程序在启动时，会预先加载所有页面逻辑代码进内存，在 a页面跳转至 b页面 时，可以在内存中直接运行而无需在发送资源请求，a页面的逻辑代码 Javascript 数据也不会从内存中消失。b页面甚至可以直接访问 a页面中的数据，整个坏境在一个大的上下文中。</em><br>当然这里你可能会有疑问？假如用户不会进入page2，那加载page2的逻辑代码岂不是浪费？这里就会牵扯到一个用户行为预测的问题，在小程序的架构中，整个逻辑代码是统一在一个包里，微信是统一将这些文件下载并加载到内存中，这可能会涉及到一些浪费，但是对于提速来讲收益大于弊端的。当然小程序页提供出<a href=\"https://developers.weixin.qq.com/ebook?action=get_post_info&amp;docid=000c8a2f9ac0b0ab0086aafeb5d80a\" target=\"_blank\" rel=\"noopener\">分包策略</a>来优化这些问题。<br>借助小程序的思路，我们的移动web同样适用这种预加载优化逻辑：</p>\n<ol>\n<li><strong>预加载资源</strong>：在多tab的单页应用中，我们可以在用户打开首屏之后，预先加载其他tab的资源。例如用户进入时在推荐tab，这时就可以预先加载订单，我的 这两个tab的资源了，当用户点击订单时，页面的展现就会快一些。<img src=\"//img.mukewang.com/5c774c9c0001f0a302230278.png\" alt=\"图片描述\"></li>\n<li><strong>预加载数据</strong>：预加载数据的时机最好是在空闲时，什么是空闲时呢？我们分析一下打开一个H5页面的流程：<img src=\"//img.mukewang.com/5c7772200001633505590182.png\" alt=\"图片描述\"><br>从图上可以看到，利用闲时可以做的事情有很多，预加载数据是一个典型的优化手段，提前把新页面所需要的数据加载好，在新页面打开后，可以直接用数据来进行渲染，当然这里涉及到的跨页面数据通信，我们可以利用localStroage来实现。</li>\n<li><strong>预加载webview</strong><br>我利用闲时来做更多事情的前提是闲时够长，但这本书也不是一个很好的现象，尽量的减少闲时，也是我们需要做的一项优化，例如我们来减少webview的加载时间，这就需要提前加载webview，此项优化大多是由native端来完成：</li>\n</ol>\n<ul>\n<li>在APP启动后，就提前在内存中将webview加载好，而不是等到点击进入web页面时才去加载。</li>\n<li>创建一个webview的复用池，例如最多只存在3个webview，每次从池子里获取webview，达到复用的目的。<h3><span id=\"3合理利用缓存\">3.合理利用缓存</span></h3>上文说了浏览器缓存的基础知识，既然是基础，那就说明必须掌握，下面来说一些进阶篇的利用缓存来优化页面：<h4><span id=\"妙用localstorage\">妙用localStorage</span></h4>HTML5 LocalStorage可以看做是加强版的cookie，数据存储大小提升，有更好的弹性以及架构，可以将数据写入到本机的ROM中，还可以在关闭浏览器后再次打开时恢复数据，以减少网络流量，日常使用localStorage来优化我们的页面大概有以下几种场景：</li>\n</ul>\n</li>\n<li>缓存一些非实时更新的变量，例如某些闪屏的标志位信息，地理位置信息等等，取用方便，即存即用。</li>\n<li>使用localStorage缓存Js和css文的，为了提升页面的打开速度，或者是页面可以离线使用，有些页面会采用将静态资源文件直接缓存在localStorage中，当页面打开时将内容读取出并运行，使用此方法确实可以减少http请求，提速页面。</li>\n<li>在一些跨webview通信的场景中，localStorage是兼容性最好的数据通信方案，例如预加载的数据可以缓存在localStorage中，来实现各个页面的webview数据共享。</li>\n<li>需要注意的是，localStorage并不是无限大的，针对每个域名，PC端浏览器给localStorage分配的容量大概4.5m-5m，移动端类似微信等等的浏览器大概容量是2.5m-3m<a href=\"http://dev-test.nemikor.com/web-storage/support-test/\" target=\"_blank\" rel=\"noopener\">参考这里</a>。所以在使用时需要做好异常捕获，让localstorage超出容量时，是无法在进行插入并报错，如果对容量有更高的要求，可以参考使用<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API\" target=\"_blank\" rel=\"noopener\">indexeddb</a>。需要注意的是indexeddb的兼容性却不是很好，android4.4之前以及iOS7以前都无法使用。<h4><span id=\"老生常谈离线包\">老生常谈离线包</span></h4>离线包技术可以说是并不算很新的技术了，各个业务都有在使用，也都有自己的一套hybrid离线包系统，关键点在于离线包的打包，同时对文件加密/签名，更新离线包(增量)<br>，安全教研以及容错机制等等，在这里列举一些大厂的离线包方案来参考：</li>\n<li>美团：<a href=\"https://tech.meituan.com/2017/07/06/lsloader.html\" target=\"_blank\" rel=\"noopener\">LsLoader——通用移动端WebApp离线化方案</a>。</li>\n<li>腾讯：<a href=\"http://www.alloyteam.com/2013/12/web-cache-6-hybrid-app-tailored-cache/\" target=\"_blank\" rel=\"noopener\">手Q离线包Alloykit</a>。</li>\n<li>阿里：<a href=\"https://yq.aliyun.com/articles/2939\" target=\"_blank\" rel=\"noopener\">极致的 Hybrid：航旅离线包再加速</a></li>\n</ul>\n<h4><span id=\"service-worker探索\">Service Worker探索</span></h4><p>提到缓存，那就不得不提近几年比较火的Service Worker了：<br><img src=\"//img.mukewang.com/5c778bc9000139b107760495.png\" alt=\"图片描述\"><br>作为一个比较新的技术，大家可以把 Service Worker 理解为一个介于客户端和服务器之间的一个代理服务器。在 Service Worker 中我们可以做很多事情，比如拦截客户端的请求、向客户端发送消息、向服务器发起请求等等，其中最重要的作用之一就是离线资源缓存。<br>Service Worker的主要复杂点在于不断地对缓存策略的调整，笔者在这里就不过多展开，可以参考一下淘宝<a href=\"http://taobaofed.org/blog/2018/08/08/workbox3/\" target=\"_blank\" rel=\"noopener\">Service worker实战</a>。</p>\n<h3><span id=\"4nodejs服务端渲染ssr优化首屏时间\">4.Nodejs服务端渲染（SSR）优化首屏时间</span></h3><p>在前后端分离之后，后端语言的模板功能被弱化，整个页面的渲染基本上都由前端 js 动态渲染，但这样对于一些应用来说是有缺陷的。比如需要 SEO 的，需要打开页面不用等待就能看到页面的，另外前端页面展示过度依赖js和css逻辑执行，在极端情况或者网络较差，手机性能低下(尤其在低端Android机型较为明显)时，白屏时间较长，这时服务端渲染便应用而生，至于为什么是Nodejs，作为一个前端，难道还要用Java么。。？<br><strong>为什么会有服务端渲染？</strong><br>如果你说服务端渲染和早期web框架，例如SSH，JSP servlet，PHP等等一样的话，那我只能说呵呵，目前的服务端渲染和早期的框架是有本质区别的：</p>\n<ul>\n<li><em>Web 2.0时代最大的思想革命本质不是前后端分离，而是把网页当作独立的应用程序（app）</em>。建立在前后端分离的基础上，后端只负责提供数据json格式，前端还是负责页面交互逻辑，大多数的服务端渲染采用Nodejs层来进行数据组装，html拼接。</li>\n<li>重点在首屏！！首屏时间的优化，移动互联网时代的爆发，用户对网页性能的要求越来越高，但毕竟基于3G，4G网络，让用户更快的看到页面就能挽留更多的潜在商机。服务端只负责首屏的页面渲染，真正过了首屏，大多数的业务逻辑，页面交互，还是需要有单独的前端来实现的。</li>\n</ul>\n<p><strong>如何实现？</strong><br>如果你的项目用的是React或者是vue，那么下面两个现场的开源框架是不错的选择。</p>\n<ul>\n<li>next.js: 服务器端渲染 react 组件框架，参考查看<a href=\"https://segmentfault.com/a/1190000015578803\" target=\"_blank\" rel=\"noopener\">React服务端渲染指南</a>。</li>\n<li>nuxt.js: 服务器端渲染 vue 组件框架，参考查看 <a href=\"https://zh.nuxtjs.org/。\" target=\"_blank\" rel=\"noopener\">https://zh.nuxtjs.org/。</a></li>\n<li>gatsbyjs:服务端React渲染框架，目前看比较新，网上的资料还不是很多，参考查看： <a href=\"https://www.gatsbyjs.org/\" target=\"_blank\" rel=\"noopener\">https://www.gatsbyjs.org/</a></li>\n</ul>\n<p>当然，你也可以自己实现一套自己的服务端渲染框架，一般需要关注这些问题：</p>\n<ul>\n<li>实现自定义的Node端的window上下文对象Cookie &amp; Session等。</li>\n<li>远程数据的获取，一般采用Nodejs的http模块。</li>\n<li>React采用ReactDOMServer调用renderToString(),Vue采用vue-server-renderer调用renderToString()。</li>\n<li>Node端内存泄露和控制等问题</li>\n</ul>\n<p><strong>代码同构(isomorphic)</strong><br>使用Nodejs的服务端渲染的一大优势就是代码同构，这使得一个项目可以分别部署成走线上正常前端渲染版本，和走服务端渲染版本，这样可以更好的做到容灾机制，当任何一种分之挂掉之后，可以直接走另一个版本，提高稳定性。这也同构的魅力所在！因为在同构直出宕掉的时候，还有前端渲染页面可以提供正常的服务。<br><img src=\"//img.mukewang.com/5c77aacc000107f406780266.png\" alt=\"图片描述\"></p>\n<p><strong>取舍</strong><br>虽然说服务端渲染这类优化确实可以提升一定的页面首屏时间，但是也是需要成本的，在前端开发接管了Node作为中间层时，需要额外的机器资源部署，并且一旦接触到后端，容灾机制，内存管理等性能指标都需要关注，这对于当前的业务系统架构可能需要有一定的调整，所以还是要斟酌来使用。</p>\n<h3><span id=\"5渲染优化\">5.渲染优化</span></h3><p>终于回到我们前端的老本家了，如果说前面的优化都是在框架，逻辑层面的优化，或者是参考后端，客户端的优化思路，那么真正涉及到UI渲染的优化才是我们作为前端工程师的立身之本了。</p>\n<ul>\n<li><p><strong>何为渲染优化？</strong></p>\n<p>抛开首屏加速，真正让用户体验web页面的另一个很重要的部分就是用户行为交互了，这包括用户的<strong>点击相应</strong>，<strong>滚动流畅度</strong>，<strong>动画是否卡顿</strong>流畅度等等，这些关于用户交互性的优化在已往的PC端可能不是很被重视，因为PC浏览器的性能要远远大于手机端，但是到了移动web就不一样了，用户都希望移动web能有PC端一样的性能。</p>\n</li>\n<li><p><strong>为什么同样的页面在iPhone里总比Android流畅？</strong></p>\n<p>目前主流的Android硬件配置可以说是甩iPhone几条街了，那为什么高配置却得不到好的体验呢？关键两类机型的操作系统上的优化程度，其中一个原因就是iOS操作系统采用执行率较高的Object-c语言，大部分硬件接口可以直接调用和运行，而Android则采用Java语言，因为虚拟机的存在，虽然跨平台性提升了，但是通过虚拟机在和系统硬件交互，执行效率就低了很多，当然这只是其中一个原因。那么，我们移动web主要优化的群体就是Android机型了。</p>\n</li>\n<li><p><strong><strong>16ms优化</strong></strong></p>\n<p>目前大多数设备的屏幕刷新频率为60次/秒，每一帧所消耗的时间约为16ms（1000 ms / 60 = 16.66ms），这16ms就是渲染帧的时长，所谓渲染帧是指浏览器一次完整绘制过程，帧之间的时间间隔是DOM视图更新的最小间隔，但实际上，浏览器还有一些整理工作要做，因此开发者所做的所有工作需要在10ms内完成。<br>如果不能完成，帧率将会下降，网页会在屏幕上抖动，也就是通常所说的卡顿，这会对用户体验产生严重的负面影响。所以如果一个页面中有动画效果或者用户正在滚动页面，那么浏览器渲染动画或页面的速率也要尽可能地与设备屏幕的刷新频率保持一致，以保证良好的用户体验。在这一个间隔内，浏览器可能需要做以下事情：</p>\n<ul>\n<li>脚本执行（JavaScript）：脚本造成了需要重绘的改动，比如增删 DOM、请求动画等</li>\n<li>样式计算（CSS Object Model）：级联地生成每个节点的生效样式。</li>\n<li>布局（Layout）：计算布局，执行渲染算法</li>\n<li>重绘（Paint）：各层分别进行绘制（比如 3D 动画）</li>\n<li>合成（Composite）：合成各层的渲染结果</li>\n</ul>\n</li>\n<li><p><strong>重绘和重排</strong><br>在上面浏览器需要做的这些事情中，会引发不同程度的重绘和重排，而重绘和重排正式影响流畅的重要因素：</p>\n<ol>\n<li><p>部分渲染树（或者整个渲染树）需要重新分析并且节点尺寸需要重新计算，这被称为重排。</p>\n</li>\n<li><p>由于节点的几何属性发生改变或者由于样式发生改变，例如改变元素背景色时，屏幕上的部分内容需要更新，这样的更新被称为重绘。</p>\n</li>\n</ol>\n<p>重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，但是每次重排，必然会导致重绘，而每次重绘并不一定会发生重排，我们需要在以下几种场景来减少重排的发生：<br>当页面布局和几何属性改变时就需要回流。下述情况会发生浏览器回流：</p>\n<ol>\n<li>添加或者删除可见的DOM元素。</li>\n<li>元素位置改变。</li>\n<li>元素尺寸改变——边距、填充、边框、宽度和高度。</li>\n<li>内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变。</li>\n<li>页面渲染初始化。</li>\n<li>浏览器窗口尺寸改变——resize事件发生时。</li>\n</ol>\n</li>\n<li><p><strong>使用 requestAnimationFrame</strong><br>提升动画流畅度的另一个重要因素是让浏览器变得智能起来，好在浏览器给我们提供了这个接口requestAnimationFrame，通过这个API,可以告诉浏览器某个JavaScript代码要执行动画，浏览器收到通知后，则会运行这些代码的时候进行优化，它会确保JS尽早在每一帧的开始执行，实现流畅的效果，而不再需要开发人员烦心刷新频率的问题了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">animationWidth</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> div = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'box'</span>);</span><br><span class=\"line\">  div.style.width = <span class=\"built_in\">parseInt</span>(div.style.width) + <span class=\"number\">1</span> + <span class=\"string\">'px'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">parseInt</span>(div.style.width) &lt; <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">    requestAnimationFrame(animationWidth)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">requestAnimationFrame(animationWidth);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>试试requestIdleCallback</strong><br>requestIdleCallback的出现伴随着React 16 的Fiber特性，他的使用场景是当用户在做负责交互时，不希望因为一些不重要的任务（如统计上报）导致用户感觉到卡顿的话，就应该考虑使用了，因为requestIdleCallback回调的执行的前提条件是当前浏览器处于空闲状态，但是需要注意的是不要在requestIdleCallback操作任何DOM，这违背了这个接口的设计原则。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> requestIdelCallback(myNonEssentialWork);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myNonEssentialWork</span> (<span class=\"params\">deadline</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// deadline.timeRemaining()可以获取到当前帧剩余时间</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (deadline.timeRemaining() &gt; <span class=\"number\">0</span> &amp;&amp; tasks.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    doWorkIfNeeded();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (tasks.length &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    requestIdleCallback(myNonEssentialWork);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p><strong>fragment元素的应用</strong><br>在你使用dominnerHTML方法来插入大量dom节点时，不妨试试fragment，fragment文档片段是个轻量级的document对象，它的设计初衷就是为了完成这类任务——更新和移动节点。文档片段的一个便利的语法特性是当你附加一个片断到节点时，实际上被添加的是该片断的子节点，而不是片断本身。只触发了一次重排，而且只访问了一次实时的DOM。</p>\n</li>\n<li><p><strong>列表滚动优化</strong><br>长列表滚动在移动端是一种非常常见的交互模式，例如feeds流，图片流等等，这些列表的滚动流畅度优化对用户体验的提升是非常重要的，基于目前的优化思路，借助dom复用的方案，类似iOS的UITableView或者Android的recyclerview原理，在列表滚动时，只保证视窗区域内的dom节点存在，在有限的dom节点内实现滚动，而不在创建新的节点，在用户不断下拉翻页的过程中，保证整个页面有限的dom元素来减少内存的消耗，原理如下图：<br><img src=\"//img.mukewang.com/5c78e94900013bc502610519.png\" alt=\"图片描述\"><br>复用的dom：<br><img src=\"//img.mukewang.com/5c78e95b000190de01830324.png\" alt=\"图片描述\"><br>采用这一个方案的前端是借助浏览器的onscroll事件来做逻辑处理，但是问题在于有些机型例如iOS的UIWebview下，onscroll不能实时触发，这就给优化带来了难题，由此引发出了模拟滚动:</p>\n</li>\n<li><p>正常的滚动：我们平时使用的scroll，包括上面讲的滚动都属于正常滚动，利用浏览器自身提供的滚动条来实现滚动，底层是由浏览器内核控制。</p>\n</li>\n<li><p>模拟滚动：最典型的例子就是iscroll了，原理一般有两种：</p>\n<ul>\n<li>1).监听滚动元素的touchmove事件，当事件触发时修改元素的transform属性来实现元素的位移，让手指离开时触发touchend事件，然后采用requestanimationframe来在一个线型函数下不断的修改元素的transform来实现手指离开时的一段惯性滚动距离。</li>\n<li>2).监听滚动元素的touchmove事件，当事件触发时修改元素的transform属性来实现元素的位移，让手指离开时触发touchend事件，然后给元素一个css的animation，并设置好duration和function来实现手指离开时的一段惯性距离。</li>\n</ul>\n<p>结论是如果要采用模拟滚动，可以解决onscroll不实时触发的问题，从而实现长列表的复用的优化，但是带来新的问题就是模拟滚动本身也是dom的重绘，增加额外的性能消耗，达到有优化效果并不理想，好在iOS的新版WKwebview解决了onscroll问题，让开发者有了更好的选择。</p>\n</li>\n<li><p><strong>滚动函数防抖</strong><br>当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">fn, wait</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(timeout !== <span class=\"literal\">null</span>) </span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">        timeout = setTimeout(fn, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 处理函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Math</span>.random()); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 滚动事件</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'scroll'</span>, debounce(handle, <span class=\"number\">1000</span>));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>合理使用GPU</strong><br>动画卡顿是在移动web开发时经常遇到的问题，解决这个问题一般会用到CSS3硬件加速。硬件加速这个名字感觉上很高大上，其实它做的事情可以简单概括为：通过GPU进行渲染，解放CPU，我们可以利用GPU的图形层，将负责的动画操作放在这个层，如何开启？</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">webkit-transform</span>: <span class=\"selector-tag\">translateZ</span>(0);</span><br></pre></td></tr></table></figure>\n<p>强制把需要动画的dom的对象 ，放置在GPU的layout层来缓存从而达到任何移动，大小变化都在这个层。<br>通过开启GPU硬件加速虽然可以提升动画渲染性能或解决一些棘手问题，但使用仍需谨慎，使用前一定要进行严谨的测试，否则它反而会大量占用浏览网页用户的系统资源，尤其是在移动端，肆无忌惮的开启GPU硬件加速会导致大量消耗内存，千万不要<code>* {webkit-transform: translateZ(0);}</code>。</p>\n</li>\n</ul>\n<h3><span id=\"写在最后\">写在最后</span></h3><p>本文在性能优化的基础上，将移动web的性能点逐步展开和深入，大部分属于结论性介绍内容，真正实践还是需要开发人员亲身尝试来得到优化提升，总之，<br><em>技术就是在于不断折腾，愿各位在踩坑的道路上一帆风顺！</em></p>\n","site":{"data":{}},"excerpt":"<p>关于前端性能优化相关的技术知识，网上随便搜一些就有很多，本文将系统性的从初级到高级的思路，总结移动前端性能优化各个方面的相关技术点，内容来自笔者以往经验的总结，希望读者可以花些时间看看。</p>\n<p>在目前大多数刚从事前端开发，或者是正在学习前端开发的同学来说，性能优化对于他们可能还比较远，但是脱颖而出，拉开差距的点，往往就在与性能优化，和理论知识不同，性能优化往往来自日常的工作经验中总结而来，也是目前大厂面试前端必问的知识点，所以重要性就不言而喻了。</p>\n<h2 id=\"一，入门篇\"><a href=\"#一，入门篇\" class=\"headerlink\" title=\"一，入门篇\"></a>一，入门篇</h2><p>首先，重要的事情说三遍：</p>\n<blockquote>\n<p>移动web性能优化原理知识同样适用于PCweb端！<br>移动web性能优化原理知识同样适用于PCweb端！<br>移动web性能优化原理知识同样适用于PCweb端！</p>\n</blockquote>","more":"<h3 id=\"1-资源合并与压缩\"><a href=\"#1-资源合并与压缩\" class=\"headerlink\" title=\"1.资源合并与压缩\"></a>1.资源合并与压缩</h3><p><strong>为什么要压缩</strong>？</p>\n<p>不同于大部分放在服务端的后台代码，前端所有的文件程序代码都是要通过浏览器下载下来运行使用，这就牵扯到网络和请求延时，所以前端文件的精简和压缩决定了前端性能的第一步。</p>\n<p>介于目前的前端框架类库，webpack，vue-cli等等，已经可以直接将这一步操作集成到我们的系统项目中了，可以直接查看各个框架的文档来进行配置，单纯的使用原生技术，可以参考下面：</p>\n<h4 id=\"html的压缩\"><a href=\"#html的压缩\" class=\"headerlink\" title=\"html的压缩\"></a>html的压缩</h4><p> HTML代码压缩就是压缩这些在文本文件中有意义，但是在HTML中不显示的字符，包括空格,制表符,换行符等，还有一些其他意义的字符，如HTML注释也可以被压缩。</p>\n<ul>\n<li>Nodejs的<a href=\"https://www.npmjs.com/package/html-minifier\" target=\"_blank\" rel=\"noopener\">html-minifier</a>。</li>\n<li>在线压缩工具，站长工具等等。</li>\n</ul>\n<h4 id=\"CSS和JavaScript文件的压缩\"><a href=\"#CSS和JavaScript文件的压缩\" class=\"headerlink\" title=\"CSS和JavaScript文件的压缩\"></a>CSS和JavaScript文件的压缩</h4><p>JavaScript压缩，主要是去除多余的换行和空格等等，对于语法来说，JavaScript可以选择<a href=\"https://www.zhihu.com/question/47047191\" target=\"_blank\" rel=\"noopener\">混淆压缩</a>和非混淆压缩，无论哪种压缩都是为了减少JavaScript的文件大小，当然出于前端代码保护来看，混淆压缩会大大破坏原有的阅读逻辑，增加压缩比，从而给代码添加一层保护。<br>CSS压缩，同理是去除多余的换行和空格等等，由于CSS文件的特殊性暂时无法实现混淆压缩，压缩主要是将大量的换行去除，可以减少不少的文件大小。</p>\n<ul>\n<li>Nodejs的<a href=\"https://github.com/mishoo/UglifyJS2\" target=\"_blank\" rel=\"noopener\">uglifyjs2</a>是一个强大的JavaScript压缩库。</li>\n<li>Nodejs的<a href=\"https://www.npmjs.com/package/clean-css\" target=\"_blank\" rel=\"noopener\">clean-css</a>是一个强大的CSS压缩库。</li>\n<li>在线压缩工具，站长工具等等。</li>\n</ul>\n<h4 id=\"图片的压缩\"><a href=\"#图片的压缩\" class=\"headerlink\" title=\"图片的压缩\"></a>图片的压缩</h4><p>对于常见的前端项目，关于图片的使用，主要有以下两种：</p>\n<ul>\n<li>固定图标，背景，按钮icon等等，这些图片有一个特点就是固定和用户无关，一般是放在源码包里面，由前端代码直接引入。</li>\n<li>人物头像，文章配图，内容图片等等，这些非固定图片一般由用户上传，有很强的用户性，这些图片一般放在<code>CDN</code>上，前端通过链接请求。</li>\n</ul>\n<ol>\n<li>对于<strong>固定图片</strong>，推荐<a href=\"https://tinypng.com/\" target=\"_blank\" rel=\"noopener\">https://tinypng.com/</a>在线压缩之后再进行引入，支持png，jpeg类型的图片，属于有损压缩，去除图片一些不必要的元数据，把相似像素的24bit位用8bit位来表示，肉眼很难区分，压缩率70%。<br><img src=\"//img.mukewang.com/5c738b1e0001a5a802690253.png\" alt=\"图片描述\"><ol>\n<li>采用<strong>CSS雪碧图</strong>：把你的网站用到的一些图片整合到一张单独的图片中：<br>优点：减少HTTP请求的数量(通过<code>backgroundPosition</code>定位所需图片)。<br>缺点：整合图片比较大时，加载比较慢(如果这张图片没有加载成功，整个页面会失去图片信息)。</li>\n</ol>\n</li>\n<li>对于<strong>非固定图片</strong>，常见的优化压缩主要有以下几种原则：<br>优先使用压缩率高的<code>jpeg</code>类型图片，缺点是不支持透明。<br>有条件的话使用<a href=\"https://developers.google.com/speed/webp/\" target=\"_blank\" rel=\"noopener\">webP</a>(一种Google开发的新类型)类型图片是最佳选择，相比于jpeg，有更小的文件尺寸和更高的图像质量。</li>\n</ol>\n<h4 id=\"资源合并\"><a href=\"#资源合并\" class=\"headerlink\" title=\"资源合并\"></a>资源合并</h4><p>在前端编码的时候将css、js等静态资源文件合并压缩之外，我们还可以在页面中将多个css、js的请求合并为一个请求。文件的合并带来的是http请求数的减少，尤其是在移动端，每一个http请求带来的是<code>慢启动</code>，<code>三次握手</code>，<code>连接建立</code>，所以资源的合并是由为重要的，合并和不合并对比：<br><img src=\"//img.mukewang.com/5c739365000133da04800363.png\" alt=\"图片描述\"></p>\n<h3 id=\"2-浏览器加载原理优化\"><a href=\"#2-浏览器加载原理优化\" class=\"headerlink\" title=\"2.浏览器加载原理优化\"></a>2.浏览器加载原理优化</h3><p>HTML页面加载渲染的过程：<br><img src=\"//img.mukewang.com/5c739e320001bc8310380478.jpg\" alt=\"图片描述\"></p>\n<p>根据上图我们来屡一下整个流程：</p>\n<ol>\n<li>当浏览器从服务器接收到了HTML文档，并把HTML在内存中转换成DOM树，在转换的过程中如果发现某个节点(node)上引用了CSS或者 IMAGE，就会再发1个request去请求CSS或image,然后继续执行下面的转换，而不需要等待request的返回，当request返回 后，只需要把返回的内容放入到DOM树中对应的位置就OK。</li>\n<li>但当引用了JS的时候，浏览器发送1个js request就会一直等待该request的返回。</li>\n<li>因为浏览器需要1个稳定的DOM树结构，而JS中很有可能有代码直接改变了DOM树结构，浏览器为了防止出现JS修改DOM树，需要重新构建DOM树的情况，所以 就会<code>阻塞</code>其他的下载和呈现。<br>那么如何解决和避免阻塞的问题呢，我们通过测试代码分别测试不同情况下引入js和css的问题如下：</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">”stylesheet”</span> <span class=\"attr\">type</span>=<span class=\"string\">”text/css”</span> <span class=\"attr\">href</span>=<span class=\"string\">”stylesheet.css”</span> <span class=\"attr\">media</span>=<span class=\"string\">”screen”</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">”stylesheet”</span> <span class=\"attr\">type</span>=<span class=\"string\">”text/css”</span> <span class=\"attr\">href</span>=<span class=\"string\">”page-animation.css”</span> <span class=\"attr\">media</span>=<span class=\"string\">”screen”</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span> =<span class=\"string\">”text/javascript”</span> &gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">          <span class=\"keyword\">var</span> f = <span class=\"number\">1</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">          f++;</span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;/<span class=\"name\">script</span> &gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">”download-button.png”</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>测试过程省略，可以参考<a href=\"https://www.nihaoshijie.com.cn/index.php/archives/530/\">这里</a>，我们可以得到如下的结论：</p>\n<ul>\n<li>浏览器存在并发加载：资源请求是并发请求的。</li>\n<li>浏览器中可以支持并发请求，不同浏览器所支持的并发数量不同（以域名划分），以Chrome为例，并发上限为6优化点： 把CDN资源分布在多个域名下。</li>\n<li>css 在head中通过link引入会阻塞页面的渲染，处于页面样式，我们必须这样放置。</li>\n<li>直接通过<code>&lt;script src&gt;</code>引入的外部js会阻塞后面节点的渲染，所以外部js尽量放在body底部。</li>\n<li>在head里面尽量不要引入js。</li>\n<li>如果要引入js 尽量将js内嵌。</li>\n<li>把内嵌js放在所有link引入css的前面。</li>\n<li>对于要阻塞后续内容的的外部js<code>&lt;script src&gt;</code>，需要增加<code>defer</code>来解决。</li>\n</ul>\n<h3 id=\"3-缓存优化\"><a href=\"#3-缓存优化\" class=\"headerlink\" title=\"3.缓存优化\"></a>3.缓存优化</h3><blockquote>\n<p><em>如果一个H5页面没有利用任何缓存，那么这个页面将没有任何存在的意义。</em></p>\n</blockquote>\n<p>从从HTTP协议缓存，到浏览器缓存，再到APP Cache，一直在最近比较火的Service worker，我们可以选择多种的缓存方式，入门基本来说说HTTP协议缓存：<br><img src=\"//img.mukewang.com/5c73a73f0001eff709030569.jpg\" alt=\"图片描述\"></p>\n<h4 id=\"强缓存：Expires-amp-Cache-Control\"><a href=\"#强缓存：Expires-amp-Cache-Control\" class=\"headerlink\" title=\"强缓存：Expires&amp;Cache-Control\"></a>强缓存：Expires&amp;Cache-Control</h4><p>当浏览器对某个资源的请求命中了强缓存时，返回的HTTP状态为200，在chrome的开发者工具的network里面 size会显示为from disk cache，这种情况下是<strong>不用发送任何请求</strong>，如下图<img src=\"//img.mukewang.com/5c73a9b500011ffa07890592.jpg\" alt=\"图片描述\"></p>\n<ul>\n<li>Expires：指定了在浏览器上缓冲存储的页距过期还有多少时间，等同Cache-control中的max-age的效果，如果同时存在，则被Cache-Control的max-age覆盖。</li>\n<li>Cache-Control：<ul>\n<li>public：响应被缓存，并且在多用户间共享。</li>\n<li>private：默认值，响应只能够作为私有的缓存(e.g., 在一个浏览器中)，不能再用户间共享；</li>\n<li>no-cache：响应不会被缓存,而是实时向服务器端请求资源。</li>\n<li>max-age：数值，单位是秒，从请求时间开始到过期时间之间的秒数。基于请求时间（Date字段）的相对时间间隔，而不是绝对过期时间；<h4 id=\"协商缓存：Last-Modified-amp-Etag\"><a href=\"#协商缓存：Last-Modified-amp-Etag\" class=\"headerlink\" title=\"协商缓存：Last-Modified&amp;Etag\"></a>协商缓存：Last-Modified&amp;Etag</h4>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串，比如你打开京东的首页，按f12打开开发者工具，再按f5刷新页面，查看network，可以看到有不少请求就是命中了协商缓存的：<br><img src=\"//img.mukewang.com/5c73aba800012d8e08000191.jpg\" alt=\"图片描述\"></li>\n</ul>\n</li>\n<li>Last-Modified/If-Modified-Since：本地文件在服务器上的最后一次修改时间。缓存过期时把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比，如果时间一致，那么返回304，客户端就直接使用本地缓存文件。</li>\n<li>Etag/If-None-Match：(EntityTags)是URL的tag，用来标示URL对象是否改变，一般为资源实体的哈希值。和Last-Modified类似，如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。Etag的优先级高于Last-Modified，Etag主要为了解决</li>\n<li>Last-Modified 无法解决的一些问题。<ul>\n<li>文件也许会周期性的更改，但是他的内容并不改变，不希望客户端重新get；</li>\n<li>If-Modified-Since能检查到的粒度是s级；</li>\n<li>某些服务器不能精确的得到文件的最后修改时间。<h3 id=\"4-懒加载与预加载\"><a href=\"#4-懒加载与预加载\" class=\"headerlink\" title=\"4.懒加载与预加载\"></a>4.懒加载与预加载</h3>懒加载对于移动web端，尤其是最常见的滚动加载场景是一项非常重要的优化措施。而预加载则常常应用于多tab场景的页面，让用户更快的看到打开的下一个页面。<h4 id=\"懒加载\"><a href=\"#懒加载\" class=\"headerlink\" title=\"懒加载\"></a>懒加载</h4></li>\n</ul>\n</li>\n<li>图片进入可视区域之后请求图片资源。</li>\n<li>对于电商等图片很多，页面很长的业务场景适用。</li>\n<li>减少无效资源的加载。</li>\n<li>并发加载的资源过多会会阻塞js的加载，影响网站的正常使用。<br>img src被设置之后，webkit解析到之后才去请求这个资源。所以我们希望图片到达可视区域之后，<code>img src</code>才会被设置进来，没有到达可视区域前并不现实真正的src，而是类似一个1px的占位符。</li>\n</ul>\n<h4 id=\"预加载\"><a href=\"#预加载\" class=\"headerlink\" title=\"预加载\"></a>预加载</h4><ul>\n<li>图片等静态资源在使用之前的提前请求。</li>\n<li>资源使用到时能从缓存中加载，提升用户体验。</li>\n<li>点击操作前预先加载下一屏数据。</li>\n</ul>\n<p>ok，读到这里，对于一些刚入门的前端玩家，或者是还在学习前端的同学，掌握了上面的入门级性能优化基础知识，才能算是基本的合格，真正更进一步的优化，更适合移动端web的性能点，可以参考进阶版：</p>\n<h2 id=\"二，进阶篇\"><a href=\"#二，进阶篇\" class=\"headerlink\" title=\"二，进阶篇\"></a>二，进阶篇</h2><h3 id=\"1-资源合并与压缩-1\"><a href=\"#1-资源合并与压缩-1\" class=\"headerlink\" title=\"1.资源合并与压缩\"></a>1.资源合并与压缩</h3><h4 id=\"启用GZIP\"><a href=\"#启用GZIP\" class=\"headerlink\" title=\"启用GZIP\"></a>启用GZIP</h4><p>gzip是GNUzip的缩写，最早用于UNIX系统的文件压缩。HTTP协议上的gzip编码是一种用来改进web应用程序性能的技术，web服务器和客户端（浏览器）必须共同支持gzip。目前主流的浏览器，Chrome,firefox,IE等都支持该协议。常见的服务器如Apache，Nginx，IIS同样支持gzip。<br><strong>gizp流程</strong>：</p>\n<ul>\n<li>浏览器请求url，并在request header中设置属性accept-encoding:gzip。</li>\n<li>服务器支持gzip，response headers返回包含content-encoding:gzip。</li>\n<li>开启gzip可以达到80%的压缩率，即1MB的文件下载下来只需要200K，大大减少传输效率，是一项非常重要的资源压缩手段。</li>\n</ul>\n<p>Nginx中开启gzip：<br><img src=\"//img.mukewang.com/5c7601e40001ea1a06000122.jpg\" alt=\"图片描述\"></p>\n<h4 id=\"升级HTTP-2-0\"><a href=\"#升级HTTP-2-0\" class=\"headerlink\" title=\"升级HTTP/2.0\"></a>升级HTTP/2.0</h4><p>HTTP/2是HTTP协议自1999年HTTP 1.1发布后的首个更新，主要基于<a href=\"https://zh.wikipedia.org/zh-hans/SPDY\" target=\"_blank\" rel=\"noopener\">SPDY</a>协议（是Google开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验）。<br><strong>优化原理：</strong><br>根据上文中说的资源合并问题，浏览器可以同时建立有限个TCP连接，而每个连接都要经过<code>慢启动</code>，<code>三次握手</code>，<code>连接建立</code>，HTTP1.1为了解决这个问题推出了keep-alive，即保持连接不被释放，但是真正的这些连接下载资源是一个线性的流程：一个资源的请求响应返回后，下一个请求才能发送。这被称为<a href=\"https://zh.wikipedia.org/wiki/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E\" target=\"_blank\" rel=\"noopener\">线头阻塞</a>，为了彻底解决此问题，HTTP2.0带来了<a href=\"https://zhuanlan.zhihu.com/p/26559480\" target=\"_blank\" rel=\"noopener\">多路复用</a>：<br><img src=\"//img.mukewang.com/5c7622b10001789107790765.png\" alt=\"图片描述\"><br>HTTP2.0的其他新特性也有助于页面的打开速度：</p>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/26559480\" target=\"_blank\" rel=\"noopener\">二进制分帧</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/26559480\" target=\"_blank\" rel=\"noopener\">服务器推送</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/26559480\" target=\"_blank\" rel=\"noopener\">头部压缩</a></li>\n</ul>\n<h4 id=\"合并资源-vs-并行加载资源？\"><a href=\"#合并资源-vs-并行加载资源？\" class=\"headerlink\" title=\"合并资源 vs 并行加载资源？\"></a>合并资源 vs 并行加载资源？</h4><p>现在回过头来探讨一下上文说的资源合并问题，有了HTTP2.0之后，我们是否还需要合并资源，目前看需要遵循下面的原则：</p>\n<ul>\n<li><p><strong>停止合并文件</strong><br>在HTTP/1.1中，CSS，JavaScript被压缩到了一个文件，图片被合并到了一张雪碧图上。合并CSS、JavaScript和图片极大地减少了HTTP的请求数，在HTTP/1.1中能获得显著的性能提升。<br>但是，在HTTP/2.0中合并文件不再是一个好的办法。虽然合并依然可以提高压缩率，但它带来了代价高昂的缓存失效。即使有一行代码改变了，整个文件就要重新打包压缩，浏览器也会强制重新加载新的文件。</p>\n</li>\n<li><p><strong>尽量不要在HTML里内联资源</strong><br>非特殊的代码（rem适配代码，上报代码等）之外，尽量不要使用内联资源，在极端情况下，这确实能够减少给定网页的HTTP请求数。但是，和文件合并一样，HTTP/2优化时你不应该内联文件。内联意味着浏览器不能缓存单个的资源。如果你将所有页面使用的CSS声明嵌入了每一个HTML文件，这些文件每次都要从服务端获取。这导致用户在访问任何页面时都要传输额外的字节。</p>\n</li>\n<li><strong>合并域名</strong><br>拆分域名是让浏览器建立更多TCP连接的通常手段，浏览器限制了单个服务器的连接数量，但是通过将网站上的资源切分到几个域上，你可以获得额外的TCP连接，但是每个拆分的域名都会带来额外的DNS查询、握手，新连接的建立，根据HTTP2.0多路复用的原则：<em>HTTP2采用多路复用是指，在同一个域名下，开启一个TCP的connection，每个请求以stream的方式传输</em>，域名的合并可以带来更多的多路复用，如下图在chrome的Network面板中查看HTTP2.0，注意protocol和ConnectID相同则表示启用复用:<br><img src=\"//img.mukewang.com/5c762a8e0001458821940784.png\" alt=\"图片描述\"></li>\n</ul>\n<h4 id=\"合理使用icon类图片base64化\"><a href=\"#合理使用icon类图片base64化\" class=\"headerlink\" title=\"合理使用icon类图片base64化\"></a>合理使用icon类图片base64化</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"data:image/gif;base64,R0...\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在页面使用的背景类图片icon类图片，不多且比较小的情况下，可以把图片转成base64编码嵌入到html页面或者CSS文件中，这样可以减少页面的HTTP请求数。需要注意的是，要保证图片较小，一般超过5kb的就不推荐base64嵌入显示了。<a href=\"https://www.zhihu.com/question/31155574\" target=\"_blank\" rel=\"noopener\">为什么是5kb？</a>。<br>同时，采用Webpack的<a href=\"https://github.com/webpack-contrib/url-loader\" target=\"_blank\" rel=\"noopener\">url-loader</a>可以帮我们在不影响代码可读性的情况下，解决base64字符串问题。</p>\n<h4 id=\"Icon-Font\"><a href=\"#Icon-Font\" class=\"headerlink\" title=\"Icon Font\"></a>Icon Font</h4><p>IconFont技术起源于Web领域的Web Font技术，它是把一些简单的图标制作成字体，然后让图标变成和字体一样使用，Icon 的设计和使用在近几年的发展中，也经历了由当初的 img 方案 到现如今的 svg 方案，有以下优点：</p>\n<ul>\n<li>字体是矢量的，所以可以随意改变大小。</li>\n<li>因为它是字体，所以所有字体的css都可以使用，比如font-size，color，background，opacity等。</li>\n<li>减少图片请求数。</li>\n<li>iconfont没有兼容性问题，IE6，Android2.3都能够兼容。</li>\n</ul>\n<h3 id=\"2-浏览器加载原理优化-1\"><a href=\"#2-浏览器加载原理优化-1\" class=\"headerlink\" title=\"2.浏览器加载原理优化\"></a>2.浏览器加载原理优化</h3><h4 id=\"首屏资源优化\"><a href=\"#首屏资源优化\" class=\"headerlink\" title=\"首屏资源优化\"></a>首屏资源优化</h4><ul>\n<li><p>剥离首屏资源<br>首屏的快速显示，可以大大提升用户对页面速度的感知，因此应尽量针对首屏的快速显示做优化，基于联通3G网络平均338KB/s(2.71Mb/s)，所以首屏资源不应超过1014KB，剥离首屏需要的资源，非首屏的资源单独合并，采用懒加载。这个原则适用上文的资源合并和加载中的场景。</p>\n</li>\n<li><p>按需加载<br>将不影响首屏的资源和当前屏幕资源不用的资源放到用户需要时才加载，可以大大提升重要资源的显示速度和降低总体流量，对于移动web端常见的多tab页面，Webpack的<a href=\"https://webpack.js.org/guides/code-splitting/\" target=\"_blank\" rel=\"noopener\">Code Splitting</a>帮助我们更加便捷实现按需加载。</p>\n<ul>\n<li>非首屏图片Lazyload<br>不用多说，在目前流量费用还算比较高昂的情况下，帮助用户节省更多的流量可以避免用户的投诉，为了保证页面内容最小化，加速页面渲染，尽可能节省首屏网络流量，页面中的图片资源推荐使用懒加载实现，在页面滚动时动态载入图片。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"使用CDN\"><a href=\"#使用CDN\" class=\"headerlink\" title=\"使用CDN\"></a>使用CDN</h4><p>CDN是将源站内容分发至最接近用户的节点，使用户可就近取得所需内容，提高用户访问的响应速度和成功率。解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景。<br>对于web页面来说，将项目的js，css等静态资源存放在CDN是一个重要的优化手段，加入所有资源统一打包放在同一个域名下，很难达到用户就近获取的优势（目前最佳实践是html页面采用一个域名，静态资源文件采用CDN域名），所谓静态资源即是可以被浏览器缓存的资源，而对于html页面，由于是js和css等链接的入口，通常不采用缓存。常用的<a href=\"https://cn.aliyun.com/product/cdn\" target=\"_blank\" rel=\"noopener\">阿里云CDN</a>和<a href=\"https://cloud.tencent.com/product/cdn-scd\" target=\"_blank\" rel=\"noopener\">腾讯云CDN</a>都有开放接口，开发者可以按需选择。</p>\n<h4 id=\"预加载-1\"><a href=\"#预加载-1\" class=\"headerlink\" title=\"预加载\"></a>预加载</h4><p>此预加载主要分为两个部分，一种是采用原生浏览器支持的API来对页面的一些资源进行预先拉取或者加载，另一种是通过自己写逻辑来加载一些重要的资源，立即下面内容的前提是要立即目前移动web常见的hybrid架构，webview外壳+H5页面：<br><img src=\"//img.mukewang.com/5c7779240001ae7004170297.png\" alt=\"图片描述\"></p>\n<ul>\n<li><p>DNS预解析（dns-prefetch）<br>DNS 作为互联网的基础协议，其解析的速度似乎很容易被网站优化人员忽视。现在大多数新浏览器已经针对DNS解析进行了优化，典型的一次DNS解析需要耗费 20-120 毫秒，减少DNS解析时间和次数是个很好的优化方式。DNS Prefetching 是让具有此属性的域名不需要用户点击链接就在后台解析，而域名解析和内容载入是串行的网络操作，所以这个方式能 减少用户的等待时间，提升用户体验 。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"dns-prefetch\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"//haitao.nos.netease.com\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Preload 和 Prefetch<br>两者都是以<code>&lt;link rel=&quot;preload&quot;&gt; 和 &lt;link rel=&quot;prefetch&quot;&gt;</code>作为引入方式。<br><strong>Preload</strong> 一个基本的用法是提前加载资源,告诉浏览器预先请求当前页需要的资源，从而提高这些资源的请求优先级，加载但是不运行，占用浏览器对同一个域名的并发数:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"preload\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"a.js\"</span> <span class=\"attr\">as</span>=<span class=\"string\">\"script\"</span> <span class=\"attr\">onload</span>=<span class=\"string\">\"preloadLoad()\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>Prefetch</strong> 一个一本用法是浏览器会在空闲的时候，下载资源, 并缓存起来。当有页面使用的时候，直接从缓存中读取。其实就是把决定是否和什么时间加载这个资源的决定权交给浏览器。</p>\n   <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"prefetch\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"a.js\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>遗憾的是对于这两个接口，移动端的浏览器支持性很不好，这也是没有普遍推广开勇的原因。<img src=\"//img.mukewang.com/5c773be00001940412540467.png\" alt=\"图片描述\"><br><img src=\"//img.mukewang.com/5c773f550001ffa512560418.png\" alt=\"图片描述\"><br><img src=\"//img.mukewang.com/5c773f610001c4a412590485.png\" alt=\"图片描述\"><br>什么时候使用Preload，什么时候使用Prefetch可以总结如下：<br><em>对于当前页面很有必要的资源使用 preload，对于可能在将来的页面中使用的资源使用 prefetch。</em><br>关于Preload 和 Prefetch可以<a href=\"https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/\" target=\"_blank\" rel=\"noopener\">参考这里</a>,另外还有<a href=\"https://css-tricks.com/prefetching-preloading-prebrowsing/\" target=\"_blank\" rel=\"noopener\">Prerender</a>，<a href=\"https://css-tricks.com/prefetching-preloading-prebrowsing/\" target=\"_blank\" rel=\"noopener\">subresource</a>，<a href=\"https://css-tricks.com/prefetching-preloading-prebrowsing/\" target=\"_blank\" rel=\"noopener\">Preconnect</a>属性，由于目前能支持到这些属性的机型太少，这里就不在赘述了。</p>\n</li>\n<li><p>业务逻辑的预加载<br>关于业务逻辑的预加载，在这里我可以举一个微信小程序的例子。小程序主要分为渲染层和逻辑层，逻辑层有iOS或者Android的<strong>JavaScript core</strong>来运行，渲染层由各自的<strong>webview</strong>组件负责渲染。我们用户实际体验到的UI还是跑在我们的webview里面，这个和大多数H5页面的渲染用的是一个组件。但是为什么我们体验小程序会比H5页面要快很多？尤其是新开页面时？<br><img src=\"//img.mukewang.com/5c7747e50001ad1523561746.png\" alt=\"图片描述\"><br><em>小程序在启动时，会预先加载所有页面逻辑代码进内存，在 a页面跳转至 b页面 时，可以在内存中直接运行而无需在发送资源请求，a页面的逻辑代码 Javascript 数据也不会从内存中消失。b页面甚至可以直接访问 a页面中的数据，整个坏境在一个大的上下文中。</em><br>当然这里你可能会有疑问？假如用户不会进入page2，那加载page2的逻辑代码岂不是浪费？这里就会牵扯到一个用户行为预测的问题，在小程序的架构中，整个逻辑代码是统一在一个包里，微信是统一将这些文件下载并加载到内存中，这可能会涉及到一些浪费，但是对于提速来讲收益大于弊端的。当然小程序页提供出<a href=\"https://developers.weixin.qq.com/ebook?action=get_post_info&amp;docid=000c8a2f9ac0b0ab0086aafeb5d80a\" target=\"_blank\" rel=\"noopener\">分包策略</a>来优化这些问题。<br>借助小程序的思路，我们的移动web同样适用这种预加载优化逻辑：</p>\n<ol>\n<li><strong>预加载资源</strong>：在多tab的单页应用中，我们可以在用户打开首屏之后，预先加载其他tab的资源。例如用户进入时在推荐tab，这时就可以预先加载订单，我的 这两个tab的资源了，当用户点击订单时，页面的展现就会快一些。<img src=\"//img.mukewang.com/5c774c9c0001f0a302230278.png\" alt=\"图片描述\"></li>\n<li><strong>预加载数据</strong>：预加载数据的时机最好是在空闲时，什么是空闲时呢？我们分析一下打开一个H5页面的流程：<img src=\"//img.mukewang.com/5c7772200001633505590182.png\" alt=\"图片描述\"><br>从图上可以看到，利用闲时可以做的事情有很多，预加载数据是一个典型的优化手段，提前把新页面所需要的数据加载好，在新页面打开后，可以直接用数据来进行渲染，当然这里涉及到的跨页面数据通信，我们可以利用localStroage来实现。</li>\n<li><strong>预加载webview</strong><br>我利用闲时来做更多事情的前提是闲时够长，但这本书也不是一个很好的现象，尽量的减少闲时，也是我们需要做的一项优化，例如我们来减少webview的加载时间，这就需要提前加载webview，此项优化大多是由native端来完成：</li>\n</ol>\n<ul>\n<li>在APP启动后，就提前在内存中将webview加载好，而不是等到点击进入web页面时才去加载。</li>\n<li>创建一个webview的复用池，例如最多只存在3个webview，每次从池子里获取webview，达到复用的目的。<h3 id=\"3-合理利用缓存\"><a href=\"#3-合理利用缓存\" class=\"headerlink\" title=\"3.合理利用缓存\"></a>3.合理利用缓存</h3>上文说了浏览器缓存的基础知识，既然是基础，那就说明必须掌握，下面来说一些进阶篇的利用缓存来优化页面：<h4 id=\"妙用localStorage\"><a href=\"#妙用localStorage\" class=\"headerlink\" title=\"妙用localStorage\"></a>妙用localStorage</h4>HTML5 LocalStorage可以看做是加强版的cookie，数据存储大小提升，有更好的弹性以及架构，可以将数据写入到本机的ROM中，还可以在关闭浏览器后再次打开时恢复数据，以减少网络流量，日常使用localStorage来优化我们的页面大概有以下几种场景：</li>\n</ul>\n</li>\n<li>缓存一些非实时更新的变量，例如某些闪屏的标志位信息，地理位置信息等等，取用方便，即存即用。</li>\n<li>使用localStorage缓存Js和css文的，为了提升页面的打开速度，或者是页面可以离线使用，有些页面会采用将静态资源文件直接缓存在localStorage中，当页面打开时将内容读取出并运行，使用此方法确实可以减少http请求，提速页面。</li>\n<li>在一些跨webview通信的场景中，localStorage是兼容性最好的数据通信方案，例如预加载的数据可以缓存在localStorage中，来实现各个页面的webview数据共享。</li>\n<li>需要注意的是，localStorage并不是无限大的，针对每个域名，PC端浏览器给localStorage分配的容量大概4.5m-5m，移动端类似微信等等的浏览器大概容量是2.5m-3m<a href=\"http://dev-test.nemikor.com/web-storage/support-test/\" target=\"_blank\" rel=\"noopener\">参考这里</a>。所以在使用时需要做好异常捕获，让localstorage超出容量时，是无法在进行插入并报错，如果对容量有更高的要求，可以参考使用<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API\" target=\"_blank\" rel=\"noopener\">indexeddb</a>。需要注意的是indexeddb的兼容性却不是很好，android4.4之前以及iOS7以前都无法使用。<h4 id=\"老生常谈离线包\"><a href=\"#老生常谈离线包\" class=\"headerlink\" title=\"老生常谈离线包\"></a>老生常谈离线包</h4>离线包技术可以说是并不算很新的技术了，各个业务都有在使用，也都有自己的一套hybrid离线包系统，关键点在于离线包的打包，同时对文件加密/签名，更新离线包(增量)<br>，安全教研以及容错机制等等，在这里列举一些大厂的离线包方案来参考：</li>\n<li>美团：<a href=\"https://tech.meituan.com/2017/07/06/lsloader.html\" target=\"_blank\" rel=\"noopener\">LsLoader——通用移动端WebApp离线化方案</a>。</li>\n<li>腾讯：<a href=\"http://www.alloyteam.com/2013/12/web-cache-6-hybrid-app-tailored-cache/\" target=\"_blank\" rel=\"noopener\">手Q离线包Alloykit</a>。</li>\n<li>阿里：<a href=\"https://yq.aliyun.com/articles/2939\" target=\"_blank\" rel=\"noopener\">极致的 Hybrid：航旅离线包再加速</a></li>\n</ul>\n<h4 id=\"Service-Worker探索\"><a href=\"#Service-Worker探索\" class=\"headerlink\" title=\"Service Worker探索\"></a>Service Worker探索</h4><p>提到缓存，那就不得不提近几年比较火的Service Worker了：<br><img src=\"//img.mukewang.com/5c778bc9000139b107760495.png\" alt=\"图片描述\"><br>作为一个比较新的技术，大家可以把 Service Worker 理解为一个介于客户端和服务器之间的一个代理服务器。在 Service Worker 中我们可以做很多事情，比如拦截客户端的请求、向客户端发送消息、向服务器发起请求等等，其中最重要的作用之一就是离线资源缓存。<br>Service Worker的主要复杂点在于不断地对缓存策略的调整，笔者在这里就不过多展开，可以参考一下淘宝<a href=\"http://taobaofed.org/blog/2018/08/08/workbox3/\" target=\"_blank\" rel=\"noopener\">Service worker实战</a>。</p>\n<h3 id=\"4-Nodejs服务端渲染（SSR）优化首屏时间\"><a href=\"#4-Nodejs服务端渲染（SSR）优化首屏时间\" class=\"headerlink\" title=\"4.Nodejs服务端渲染（SSR）优化首屏时间\"></a>4.Nodejs服务端渲染（SSR）优化首屏时间</h3><p>在前后端分离之后，后端语言的模板功能被弱化，整个页面的渲染基本上都由前端 js 动态渲染，但这样对于一些应用来说是有缺陷的。比如需要 SEO 的，需要打开页面不用等待就能看到页面的，另外前端页面展示过度依赖js和css逻辑执行，在极端情况或者网络较差，手机性能低下(尤其在低端Android机型较为明显)时，白屏时间较长，这时服务端渲染便应用而生，至于为什么是Nodejs，作为一个前端，难道还要用Java么。。？<br><strong>为什么会有服务端渲染？</strong><br>如果你说服务端渲染和早期web框架，例如SSH，JSP servlet，PHP等等一样的话，那我只能说呵呵，目前的服务端渲染和早期的框架是有本质区别的：</p>\n<ul>\n<li><em>Web 2.0时代最大的思想革命本质不是前后端分离，而是把网页当作独立的应用程序（app）</em>。建立在前后端分离的基础上，后端只负责提供数据json格式，前端还是负责页面交互逻辑，大多数的服务端渲染采用Nodejs层来进行数据组装，html拼接。</li>\n<li>重点在首屏！！首屏时间的优化，移动互联网时代的爆发，用户对网页性能的要求越来越高，但毕竟基于3G，4G网络，让用户更快的看到页面就能挽留更多的潜在商机。服务端只负责首屏的页面渲染，真正过了首屏，大多数的业务逻辑，页面交互，还是需要有单独的前端来实现的。</li>\n</ul>\n<p><strong>如何实现？</strong><br>如果你的项目用的是React或者是vue，那么下面两个现场的开源框架是不错的选择。</p>\n<ul>\n<li>next.js: 服务器端渲染 react 组件框架，参考查看<a href=\"https://segmentfault.com/a/1190000015578803\" target=\"_blank\" rel=\"noopener\">React服务端渲染指南</a>。</li>\n<li>nuxt.js: 服务器端渲染 vue 组件框架，参考查看 <a href=\"https://zh.nuxtjs.org/。\" target=\"_blank\" rel=\"noopener\">https://zh.nuxtjs.org/。</a></li>\n<li>gatsbyjs:服务端React渲染框架，目前看比较新，网上的资料还不是很多，参考查看： <a href=\"https://www.gatsbyjs.org/\" target=\"_blank\" rel=\"noopener\">https://www.gatsbyjs.org/</a></li>\n</ul>\n<p>当然，你也可以自己实现一套自己的服务端渲染框架，一般需要关注这些问题：</p>\n<ul>\n<li>实现自定义的Node端的window上下文对象Cookie &amp; Session等。</li>\n<li>远程数据的获取，一般采用Nodejs的http模块。</li>\n<li>React采用ReactDOMServer调用renderToString(),Vue采用vue-server-renderer调用renderToString()。</li>\n<li>Node端内存泄露和控制等问题</li>\n</ul>\n<p><strong>代码同构(isomorphic)</strong><br>使用Nodejs的服务端渲染的一大优势就是代码同构，这使得一个项目可以分别部署成走线上正常前端渲染版本，和走服务端渲染版本，这样可以更好的做到容灾机制，当任何一种分之挂掉之后，可以直接走另一个版本，提高稳定性。这也同构的魅力所在！因为在同构直出宕掉的时候，还有前端渲染页面可以提供正常的服务。<br><img src=\"//img.mukewang.com/5c77aacc000107f406780266.png\" alt=\"图片描述\"></p>\n<p><strong>取舍</strong><br>虽然说服务端渲染这类优化确实可以提升一定的页面首屏时间，但是也是需要成本的，在前端开发接管了Node作为中间层时，需要额外的机器资源部署，并且一旦接触到后端，容灾机制，内存管理等性能指标都需要关注，这对于当前的业务系统架构可能需要有一定的调整，所以还是要斟酌来使用。</p>\n<h3 id=\"5-渲染优化\"><a href=\"#5-渲染优化\" class=\"headerlink\" title=\"5.渲染优化\"></a>5.渲染优化</h3><p>终于回到我们前端的老本家了，如果说前面的优化都是在框架，逻辑层面的优化，或者是参考后端，客户端的优化思路，那么真正涉及到UI渲染的优化才是我们作为前端工程师的立身之本了。</p>\n<ul>\n<li><p><strong>何为渲染优化？</strong></p>\n<p>抛开首屏加速，真正让用户体验web页面的另一个很重要的部分就是用户行为交互了，这包括用户的<strong>点击相应</strong>，<strong>滚动流畅度</strong>，<strong>动画是否卡顿</strong>流畅度等等，这些关于用户交互性的优化在已往的PC端可能不是很被重视，因为PC浏览器的性能要远远大于手机端，但是到了移动web就不一样了，用户都希望移动web能有PC端一样的性能。</p>\n</li>\n<li><p><strong>为什么同样的页面在iPhone里总比Android流畅？</strong></p>\n<p>目前主流的Android硬件配置可以说是甩iPhone几条街了，那为什么高配置却得不到好的体验呢？关键两类机型的操作系统上的优化程度，其中一个原因就是iOS操作系统采用执行率较高的Object-c语言，大部分硬件接口可以直接调用和运行，而Android则采用Java语言，因为虚拟机的存在，虽然跨平台性提升了，但是通过虚拟机在和系统硬件交互，执行效率就低了很多，当然这只是其中一个原因。那么，我们移动web主要优化的群体就是Android机型了。</p>\n</li>\n<li><p><strong><strong>16ms优化</strong></strong></p>\n<p>目前大多数设备的屏幕刷新频率为60次/秒，每一帧所消耗的时间约为16ms（1000 ms / 60 = 16.66ms），这16ms就是渲染帧的时长，所谓渲染帧是指浏览器一次完整绘制过程，帧之间的时间间隔是DOM视图更新的最小间隔，但实际上，浏览器还有一些整理工作要做，因此开发者所做的所有工作需要在10ms内完成。<br>如果不能完成，帧率将会下降，网页会在屏幕上抖动，也就是通常所说的卡顿，这会对用户体验产生严重的负面影响。所以如果一个页面中有动画效果或者用户正在滚动页面，那么浏览器渲染动画或页面的速率也要尽可能地与设备屏幕的刷新频率保持一致，以保证良好的用户体验。在这一个间隔内，浏览器可能需要做以下事情：</p>\n<ul>\n<li>脚本执行（JavaScript）：脚本造成了需要重绘的改动，比如增删 DOM、请求动画等</li>\n<li>样式计算（CSS Object Model）：级联地生成每个节点的生效样式。</li>\n<li>布局（Layout）：计算布局，执行渲染算法</li>\n<li>重绘（Paint）：各层分别进行绘制（比如 3D 动画）</li>\n<li>合成（Composite）：合成各层的渲染结果</li>\n</ul>\n</li>\n<li><p><strong>重绘和重排</strong><br>在上面浏览器需要做的这些事情中，会引发不同程度的重绘和重排，而重绘和重排正式影响流畅的重要因素：</p>\n<ol>\n<li><p>部分渲染树（或者整个渲染树）需要重新分析并且节点尺寸需要重新计算，这被称为重排。</p>\n</li>\n<li><p>由于节点的几何属性发生改变或者由于样式发生改变，例如改变元素背景色时，屏幕上的部分内容需要更新，这样的更新被称为重绘。</p>\n</li>\n</ol>\n<p>重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，但是每次重排，必然会导致重绘，而每次重绘并不一定会发生重排，我们需要在以下几种场景来减少重排的发生：<br>当页面布局和几何属性改变时就需要回流。下述情况会发生浏览器回流：</p>\n<ol>\n<li>添加或者删除可见的DOM元素。</li>\n<li>元素位置改变。</li>\n<li>元素尺寸改变——边距、填充、边框、宽度和高度。</li>\n<li>内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变。</li>\n<li>页面渲染初始化。</li>\n<li>浏览器窗口尺寸改变——resize事件发生时。</li>\n</ol>\n</li>\n<li><p><strong>使用 requestAnimationFrame</strong><br>提升动画流畅度的另一个重要因素是让浏览器变得智能起来，好在浏览器给我们提供了这个接口requestAnimationFrame，通过这个API,可以告诉浏览器某个JavaScript代码要执行动画，浏览器收到通知后，则会运行这些代码的时候进行优化，它会确保JS尽早在每一帧的开始执行，实现流畅的效果，而不再需要开发人员烦心刷新频率的问题了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">animationWidth</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> div = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'box'</span>);</span><br><span class=\"line\">  div.style.width = <span class=\"built_in\">parseInt</span>(div.style.width) + <span class=\"number\">1</span> + <span class=\"string\">'px'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">parseInt</span>(div.style.width) &lt; <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">    requestAnimationFrame(animationWidth)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">requestAnimationFrame(animationWidth);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>试试requestIdleCallback</strong><br>requestIdleCallback的出现伴随着React 16 的Fiber特性，他的使用场景是当用户在做负责交互时，不希望因为一些不重要的任务（如统计上报）导致用户感觉到卡顿的话，就应该考虑使用了，因为requestIdleCallback回调的执行的前提条件是当前浏览器处于空闲状态，但是需要注意的是不要在requestIdleCallback操作任何DOM，这违背了这个接口的设计原则。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> requestIdelCallback(myNonEssentialWork);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myNonEssentialWork</span> (<span class=\"params\">deadline</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// deadline.timeRemaining()可以获取到当前帧剩余时间</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (deadline.timeRemaining() &gt; <span class=\"number\">0</span> &amp;&amp; tasks.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    doWorkIfNeeded();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (tasks.length &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    requestIdleCallback(myNonEssentialWork);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p><strong>fragment元素的应用</strong><br>在你使用dominnerHTML方法来插入大量dom节点时，不妨试试fragment，fragment文档片段是个轻量级的document对象，它的设计初衷就是为了完成这类任务——更新和移动节点。文档片段的一个便利的语法特性是当你附加一个片断到节点时，实际上被添加的是该片断的子节点，而不是片断本身。只触发了一次重排，而且只访问了一次实时的DOM。</p>\n</li>\n<li><p><strong>列表滚动优化</strong><br>长列表滚动在移动端是一种非常常见的交互模式，例如feeds流，图片流等等，这些列表的滚动流畅度优化对用户体验的提升是非常重要的，基于目前的优化思路，借助dom复用的方案，类似iOS的UITableView或者Android的recyclerview原理，在列表滚动时，只保证视窗区域内的dom节点存在，在有限的dom节点内实现滚动，而不在创建新的节点，在用户不断下拉翻页的过程中，保证整个页面有限的dom元素来减少内存的消耗，原理如下图：<br><img src=\"//img.mukewang.com/5c78e94900013bc502610519.png\" alt=\"图片描述\"><br>复用的dom：<br><img src=\"//img.mukewang.com/5c78e95b000190de01830324.png\" alt=\"图片描述\"><br>采用这一个方案的前端是借助浏览器的onscroll事件来做逻辑处理，但是问题在于有些机型例如iOS的UIWebview下，onscroll不能实时触发，这就给优化带来了难题，由此引发出了模拟滚动:</p>\n</li>\n<li><p>正常的滚动：我们平时使用的scroll，包括上面讲的滚动都属于正常滚动，利用浏览器自身提供的滚动条来实现滚动，底层是由浏览器内核控制。</p>\n</li>\n<li><p>模拟滚动：最典型的例子就是iscroll了，原理一般有两种：</p>\n<ul>\n<li>1).监听滚动元素的touchmove事件，当事件触发时修改元素的transform属性来实现元素的位移，让手指离开时触发touchend事件，然后采用requestanimationframe来在一个线型函数下不断的修改元素的transform来实现手指离开时的一段惯性滚动距离。</li>\n<li>2).监听滚动元素的touchmove事件，当事件触发时修改元素的transform属性来实现元素的位移，让手指离开时触发touchend事件，然后给元素一个css的animation，并设置好duration和function来实现手指离开时的一段惯性距离。</li>\n</ul>\n<p>结论是如果要采用模拟滚动，可以解决onscroll不实时触发的问题，从而实现长列表的复用的优化，但是带来新的问题就是模拟滚动本身也是dom的重绘，增加额外的性能消耗，达到有优化效果并不理想，好在iOS的新版WKwebview解决了onscroll问题，让开发者有了更好的选择。</p>\n</li>\n<li><p><strong>滚动函数防抖</strong><br>当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">fn, wait</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(timeout !== <span class=\"literal\">null</span>) </span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">        timeout = setTimeout(fn, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 处理函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Math</span>.random()); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 滚动事件</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'scroll'</span>, debounce(handle, <span class=\"number\">1000</span>));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>合理使用GPU</strong><br>动画卡顿是在移动web开发时经常遇到的问题，解决这个问题一般会用到CSS3硬件加速。硬件加速这个名字感觉上很高大上，其实它做的事情可以简单概括为：通过GPU进行渲染，解放CPU，我们可以利用GPU的图形层，将负责的动画操作放在这个层，如何开启？</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">webkit-transform</span>: <span class=\"selector-tag\">translateZ</span>(0);</span><br></pre></td></tr></table></figure>\n<p>强制把需要动画的dom的对象 ，放置在GPU的layout层来缓存从而达到任何移动，大小变化都在这个层。<br>通过开启GPU硬件加速虽然可以提升动画渲染性能或解决一些棘手问题，但使用仍需谨慎，使用前一定要进行严谨的测试，否则它反而会大量占用浏览网页用户的系统资源，尤其是在移动端，肆无忌惮的开启GPU硬件加速会导致大量消耗内存，千万不要<code>* {webkit-transform: translateZ(0);}</code>。</p>\n</li>\n</ul>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>本文在性能优化的基础上，将移动web的性能点逐步展开和深入，大部分属于结论性介绍内容，真正实践还是需要开发人员亲身尝试来得到优化提升，总之，<br><em>技术就是在于不断折腾，愿各位在踩坑的道路上一帆风顺！</em></p>"},{"title":"线条之美，玩转SVG线条动画","date":"2017-02-20T12:23:10.000Z","photos":["https://qiniu.nihaoshijie.com.cn/ilu2.gif"],"_content":"通常来说web前端实现动画效果主要通过下面几种方案：\n<ul>\n \t<li>css动画；利用css3的样式效果可以将dom元素做出动画的效果来。</li>\n \t<li>canvas动画；利用canvas提供的API，然后利用清除-渲染这样一帧一帧的做出动画效果。</li>\n \t<li>svg动画；同样svg也提供了不少的API来实现动画效果，并且兼容性也不差，本文主要讲解一下如何制作svg线条动画。</li>\n</ul>\n<!--more-->\n先来看几个效果：\n\n<a href=\"https://qiniu.nihaoshijie.com.cn/blog/buluofuza.gif\"><img class=\"alignnone size-full wp-image-670\" src=\"https://qiniu.nihaoshijie.com.cn/blog/buluofuza.gif\" alt=\"\" width=\"279\" height=\"237\" /></a><a href=\"https://www.nihaoshijie.com.cn/mypro/svg/buluofuza.html\" target=\"_blank\">demo</a>\n\n<a href=\"https://qiniu.nihaoshijie.com.cn/blog/daojishi1.gif\"><img class=\"alignnone size-full wp-image-671\" src=\"https://qiniu.nihaoshijie.com.cn/blog/daojishi1.gif\" alt=\"\" width=\"298\" height=\"148\" /></a><a href=\"https://www.nihaoshijie.com.cn/mypro/svg/daojishi.html\" target=\"_blank\">demo</a>\n\n<a href=\"https://qiniu.nihaoshijie.com.cn/alloyteam.gif\"><img class=\"alignnone size-full wp-image-672\" src=\"https://qiniu.nihaoshijie.com.cn/alloyteam.gif\" alt=\"\" width=\"785\" height=\"592\" /></a><a href=\"https://www.nihaoshijie.com.cn/mypro/svg/alloyteam.html\" target=\"_blank\">demo</a>\n\n以上这些效果都是利用SVG线条动画实现的，只用了css3和svg，没有使用一行javascript代码，这一点和canvas比起来要容易一些，下面就说明一下实现这些效果的原理。\n\n关于SVG的基础知识，我这里就不再叙述了，大家可以直接在文档中查看相关的API，这里只说一下实现线条动画主要用到的：path （路径）\n<h2 style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; border: 0px; font-weight: bold; font-family: 微软雅黑; font-size: 14px; color: #000000; background-color: #f9f9f9;\">&lt;path&gt; 标签命令</h2>\n<ul style=\"margin-top: 10px; margin-bottom: 0px; margin-left: 35px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; border: 0px; color: #000000; font-family: Verdana, Arial, 宋体; font-size: 12px; background-color: #f9f9f9;\">\n \t<li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">M = moveto</li>\n \t<li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">L = lineto</li>\n \t<li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">H = horizontal lineto</li>\n \t<li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">V = vertical lineto</li>\n \t<li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">C = curveto</li>\n \t<li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">S = smooth curveto</li>\n \t<li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">Q = quadratic Belzier curve</li>\n \t<li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">T = smooth quadratic Belzier curveto</li>\n \t<li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">A = elliptical Arc</li>\n \t<li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">Z = closepath</li>\n</ul>\n利用path的这些命令我们可以实现我们想要的任何线条组合，以一段简单的线条为例:\n```html\n<path id=\"path\" fill=\"none\" stroke=\"#000\" stroke-width=\"1px\" d=\"M452,293c0,0,0-61,72-44c0,0-47,117,81,57\n    s5-110,10-67s-51,77.979-50,33.989\"/>\n```\n效果：\n\n<a href=\"https://qiniu.nihaoshijie.com.cn/blog/simple.png\"><img class=\"alignnone size-full wp-image-673\" src=\"https://qiniu.nihaoshijie.com.cn/blog/simple.png\" alt=\"\" width=\"255\" height=\"157\" /></a>\n\n呵呵，看起来很简单，但是，如何让这个线条动起来呢？这里就要明白到SVG里的path的一些主要属性：\n<ol style=\"transition: all 0.3s; margin-top: 0px; margin-bottom: 0px; margin-left: 30px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; list-style-position: initial; list-style-image: initial; color: #333333; font-family: 'lucida grande', 'lucida sans unicode', lucida, helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;\">\n \t<li style=\"transition: all 0.3s; margin: 0px; padding: 0px; list-style-position: inside; list-style-image: initial;\">stroke：标识路径的颜色；</li>\n \t<li style=\"transition: all 0.3s; margin: 0px; padding: 0px; list-style-position: inside; list-style-image: initial;\">d：标识路径命令的集合，这个属性主要决定了线条的形状。</li>\n \t<li style=\"transition: all 0.3s; margin: 0px; padding: 0px; list-style-position: inside; list-style-image: initial;\"><span style=\"color: #333333; font-family: 'lucida grande', 'lucida sans unicode', lucida, helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;\">stroke-width：标识路径的宽度，单位是px；</span></li>\n \t<li style=\"transition: all 0.3s; margin: 0px; padding: 0px; list-style-position: inside; list-style-image: initial;\">stroke-dasharray：它是一个&lt;length&gt;和&lt;percentage&gt;数列，数与数之间用逗号或者空白隔开，指定短划线和缺口的长度。如果提供了奇数个值，则这个值的数列重复一次，从而变成偶数个值。因此，5,3,2等同于5,3,2,5,3,2；</li>\n \t<li style=\"transition: all 0.3s; margin: 0px; padding: 0px; list-style-position: inside; list-style-image: initial;\"><span style=\"color: #333333; font-family: 'lucida grande', 'lucida sans unicode', lucida, helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;\">stroke-dashoffset：标识的是整个路径的偏移值；</span></li>\n</ol>\n<span style=\"color: #333333;\">以一张图来解释stroke-dasharray和stroke-dashoffset更容易理解一些：</span>\n\n<a href=\"https://qiniu.nihaoshijie.com.cn/blog/array.png\"><img class=\"alignnone size-full wp-image-674\" src=\"https://qiniu.nihaoshijie.com.cn/blog/array.png\" alt=\"\" width=\"484\" height=\"242\" /></a>\n\n<span style=\"color: #333333;\">因此，我们之前的路径就会变成这个样子：</span>\n```css\n#path {\n        stroke-dasharray: 3px, 1px;\n        stroke-dasharray: 0;\n}\n```\n效果：\n\n<a href=\"https://qiniu.nihaoshijie.com.cn/%E8%99%9A%E7%BA%BF.png\"><img class=\"alignnone size-full wp-image-675\" src=\"https://qiniu.nihaoshijie.com.cn/%E8%99%9A%E7%BA%BF.png\" alt=\"\" width=\"278\" height=\"171\" /></a>\n\n理解了stroke-dasharray的作用之后，下面我们就可以使用css3的animation来让这个路径动起来。\n```css\n#path {\n    animation: move 3s linear forwards;\n}\n\n@keyframes move {\n      0%{\n          stroke-dasharray: 0, 511px;\n      }\n      100%{\n          stroke-dasharray: 511px, 511px;\n      }\n}\n```\n&nbsp;\n\n效果：\n\n<a href=\"https://qiniu.nihaoshijie.com.cn/blog/dong2.gif\"><img class=\"alignnone size-full wp-image-676\" src=\"https://qiniu.nihaoshijie.com.cn/blog/dong2.gif\" alt=\"\" width=\"384\" height=\"154\" /></a>\n\n511这个值是整个路径的长度，可以用js的document.getElementById('path').getTotalLength()得到\n\nstroke-dasharray: 0, 511; 表示实线和空隙的长度分别为 0 和 511，所以一开始整个路径都是空隙，所以是空的。\n然后过渡到 stroke-dasharray: 511, 511; 因为整个线条的长度就是 511，而实线的长度也慢慢变成511，所以整个线条就出现了。\n\n同样利用stroke-dashoffset也可以实现这个效果，原理就是最初线条分为511实线，和511空隙，但是由于设置了offset使线条偏移不可见了，当不断修改offset后，线条慢慢出现。\n```css\n#path {\n    animation: move 3s linear forwards;\n    stroke-dasharray: 511px,511px;\n}\n\n@keyframes move {\n  0%{\n      stroke-dashoffset: 511px;\n  }\n  100%{\n      stroke-dashoffset: 0;\n  }\n}\n```\n效果：\n\n<a href=\"https://qiniu.nihaoshijie.com.cn/blog/dong2-1.gif\"><img class=\"alignnone size-full wp-image-677\" src=\"https://qiniu.nihaoshijie.com.cn/blog/dong2-1.gif\" alt=\"\" width=\"384\" height=\"154\" /></a>\n\n当我们掌握了上述的方法后，整个利用SVG实现线条动画的原理就已经清楚了，我们需要的就是一个SVG路径了，但是总画一些简单的线条还是不美啊，那我们如何才能得到复杂的svg路径呢？\n<ol>\n \t<li>找UI设计师要一个。</li>\n \t<li>自己利用PS和AI做一个，只需要简单的2步。</li>\n</ol>\n<a href=\"https://qiniu.nihaoshijie.com.cn/blog/psai.png\"><img class=\"alignnone size-full wp-image-678\" src=\"https://qiniu.nihaoshijie.com.cn/blog/psai.png\" alt=\"\" width=\"119\" height=\"31\" /></a>\n\n以部落LOGO为例：\n\n1，得到部落LOGO的png图片。\n\n2，右键图层，然后点击从选区生成工作路径，我们就可以得到：\n\n<a href=\"https://qiniu.nihaoshijie.com.cn/blog/buluopng.png\"><img class=\"alignnone size-full wp-image-679\" src=\"https://qiniu.nihaoshijie.com.cn/blog/buluopng.png\" alt=\"\" width=\"260\" height=\"210\" /></a>\n\n3，文件--导出--路径到AI，将路径导出在AI里面打开。\n\n<a href=\"https://qiniu.nihaoshijie.com.cn/buluolujing.png\"><img class=\"alignnone size-full wp-image-680\" src=\"https://qiniu.nihaoshijie.com.cn/buluolujing.png\" alt=\"\" width=\"294\" height=\"230\" /></a>\n\n4，在AI里面选择保存成svg格式的文件，然后用sublime打开svg文件，将path的d拷贝出来即可。\n\n5，利用上文介绍的实现动画的方法，我们就可以轻松的得到了下面这个效果。\n\n<a href=\"https://qiniu.nihaoshijie.com.cn/blog/buluo.gif\"><img class=\"alignnone size-full wp-image-681\" src=\"https://qiniu.nihaoshijie.com.cn/blog/buluo.gif\" alt=\"\" width=\"312\" height=\"173\" /></a>\n\n线条动画进阶：\n\n可以看到上面的动画效果和文章最初显示的动画效果还是有区别的，要想实现文章最初的动画效果，需要用到SVG的&lt;symbol&gt; 和 &lt;use&gt;来实现，读者可以在网上查一下这两个标签的用法。\n\n```html\n<symbol id=\"pathSymbol\">\n    <path  class=\"path\" stroke=\"#00adef\"  d=\"M281.221,261.806c0,2.756-2.166,4.922-4.922,4.922l0,0h-33.964c-11.715-24.119-31.503-59.855-47.156-68.026\n  c-15.751,7.974-35.637,43.907-47.451,68.026h-33.865l0,0c-2.756,0-4.922-2.166-4.922-4.922l0,0l0,0c0-0.295,0-0.689,0.098-0.984\n  c0,0,14.078-69.109,79.15-129.161c-2.953-2.56-5.907-5.119-8.959-7.58c-1.87-1.575-2.166-4.233-0.591-6.104\n  c1.575-1.772,4.43-2.166,6.497-0.689c3.347,2.461,6.694,5.218,9.746,8.073c3.15-2.953,6.497-5.71,10.041-8.368\n  c2.067-1.378,4.922-1.083,6.497,0.689c1.575,1.87,1.28,4.529-0.591,6.104c-3.052,2.56-6.104,5.218-9.155,7.876\n  c65.27,59.953,79.446,129.161,79.446,129.161C281.221,261.117,281.221,261.412,281.221,261.806L281.221,261.806L281.221,261.806z\"/>\n    <path  class=\"path\" stroke=\"#00adef\"  d=\"M194.589,212.583h0.984l0,0c19.886,28.451,31.503,54.145,31.503,54.145h-63.99C163.086,266.728,174.703,241.034,194.589,212.583\nL194.589,212.583z\"/>\n</symbol>\n<g>\n  <use xlink:href=\"#pathSymbol\"\n    id=\"path1\"></use>\n    <use xlink:href=\"#pathSymbol\"\n      id=\"path2\"></use>\n</g>\n```\n```css\n#path1 {\n\n    stroke-dashoffset: 7% 7%;\n    stroke-dasharray: 0 35%;\n    animation: animation 3s linear forwards;\n  }\n\n  @keyframes animation {\n      100% {\n        stroke-dasharray: 7% 7%;\n        stroke-dashoffset: 7%;\n\n      }\n  }\n\n  #path2 {\n\n    stroke-dashoffset: 7% 7%;\n    stroke-dasharray: 0 35%;\n    animation: animation2 3s linear forwards;\n  }\n\n  @keyframes animation2 {\n      100% {\n          stroke-dasharray: 7% 7%;\n          stroke-dashoffset: 14%;\n\n      }\n }\n ```\n思路就是：\n\n1，将原来只有一条path的路径替换成两条，并且这两条的路径是完全重合的。\n\n2，分别设置两条路径的stroke-dasharray和stroke-dashoffset的css3的animation动画，注意两条路径的动画不能完全一样要有差值。\n\n3，设置成功之后就可以利用animation动画触发的时机和改变程度来实现多条动画效果。\n\n效果：\n\n<a href=\"https://qiniu.nihaoshijie.com.cn/blog/buluofuza.gif\"><img class=\"alignnone size-full wp-image-670\" src=\"https://qiniu.nihaoshijie.com.cn/blog/buluofuza.gif\" alt=\"\" width=\"279\" height=\"237\" /></a>\n\n那么如何实现alloyteam的文字动画呢，其实原理也是利用了stroke-dasharray和stroke-dashoffset，这两个属性不仅可以作用在&lt;path&gt;上，同样可以作用在&lt;text&gt;上。\n```html\n<symbol id=\"text\">\n    <text x=\"30%\" y=\"35%\" class=\"text\">QQ</text>\n  </symbol>\n\n  <g>\n    <use xlink:href=\"#text\"\n      class=\"use-text\"></use>\n      <use xlink:href=\"#text\"\n        class=\"use-text\"></use>\n        <use xlink:href=\"#text\"\n          class=\"use-text\"></use>\n          <use xlink:href=\"#text\"\n            class=\"use-text\"></use>\n            <use xlink:href=\"#text\"\n              class=\"use-text\"></use>\n  </g>\n```\n```css\n.use-text:nth-child(1) {\n      stroke: #360745;\n      animation: animation1 8s infinite ease-in-out forwards;\n\n}\n          \n.use-text:nth-child(2) {\n      stroke: #D61C59;\n      animation: animation2 8s infinite ease-in-out forwards;\n\n}\n          \n.use-text:nth-child(3) {\n       stroke: #E7D84B;\n       animation: animation3 8s infinite ease-in-out forwards;\n\n}\n\n.use-text:nth-child(4) {\n       stroke: #EFEAC5;\n       animation: animation4 8s infinite ease-in-out forwards;\n\n}\n\n.use-text:nth-child(5) {\n      stroke: #1B8798;\n      animation: animation5 8s infinite ease-in-out forwards;\n}\n\n@keyframes animation1 {\n       50%{\n            stroke-dasharray: 7% 28%;\n            stroke-dashoffset: 7%;\n       }\n       70%{\n             stroke-dasharray: 7% 28%;\n             stroke-dashoffset: 7%;\n       }\n}\n@keyframes animation2 {\n       50%{\n           stroke-dasharray: 7% 28%;\n           stroke-dashoffset: 14%;\n       }\n       70%{\n            stroke-dasharray: 7% 28%;\n            stroke-dashoffset: 14%;\n       }\n}\n@keyframes animation3 {\n     50%{\n         stroke-dasharray: 7% 28%;\n         stroke-dashoffset: 21%;\n    }\n    70%{\n         stroke-dasharray: 7% 28%;\n         stroke-dashoffset: 21%;\n    }\n}\n@keyframes animation4 {\n       50%{\n            stroke-dasharray: 7% 28%;\n            stroke-dashoffset: 28%;\n       }\n       70%{\n            stroke-dasharray: 7% 28%;\n            stroke-dashoffset: 28%;\n       }\n}\n@keyframes animation5 {\n      50%{\n           stroke-dasharray: 7% 28%;\n           stroke-dashoffset: 35%;\n      }\n      70%{\n           stroke-dasharray: 7% 28%;\n           stroke-dashoffset: 35%;\n      }\n}\n```\n这里用了5条完全重合的路径，并且每个路径的颜色和动画效果都不一样。\n\n效果：\n\n<a href=\"https://qiniu.nihaoshijie.com.cn/qq.gif\"><img class=\"alignnone size-full wp-image-682\" src=\"https://qiniu.nihaoshijie.com.cn/qq.gif\" alt=\"\" width=\"529\" height=\"338\" /></a>","source":"_posts/线条之美，玩转SVG线条动画.md","raw":"---\ntitle: 线条之美，玩转SVG线条动画\ndate: 2017-02-20 20:23:10\ntags:\n- svg\ncategories:\n- 667\nphotos: https://qiniu.nihaoshijie.com.cn/ilu2.gif\n---\n通常来说web前端实现动画效果主要通过下面几种方案：\n<ul>\n \t<li>css动画；利用css3的样式效果可以将dom元素做出动画的效果来。</li>\n \t<li>canvas动画；利用canvas提供的API，然后利用清除-渲染这样一帧一帧的做出动画效果。</li>\n \t<li>svg动画；同样svg也提供了不少的API来实现动画效果，并且兼容性也不差，本文主要讲解一下如何制作svg线条动画。</li>\n</ul>\n<!--more-->\n先来看几个效果：\n\n<a href=\"https://qiniu.nihaoshijie.com.cn/blog/buluofuza.gif\"><img class=\"alignnone size-full wp-image-670\" src=\"https://qiniu.nihaoshijie.com.cn/blog/buluofuza.gif\" alt=\"\" width=\"279\" height=\"237\" /></a><a href=\"https://www.nihaoshijie.com.cn/mypro/svg/buluofuza.html\" target=\"_blank\">demo</a>\n\n<a href=\"https://qiniu.nihaoshijie.com.cn/blog/daojishi1.gif\"><img class=\"alignnone size-full wp-image-671\" src=\"https://qiniu.nihaoshijie.com.cn/blog/daojishi1.gif\" alt=\"\" width=\"298\" height=\"148\" /></a><a href=\"https://www.nihaoshijie.com.cn/mypro/svg/daojishi.html\" target=\"_blank\">demo</a>\n\n<a href=\"https://qiniu.nihaoshijie.com.cn/alloyteam.gif\"><img class=\"alignnone size-full wp-image-672\" src=\"https://qiniu.nihaoshijie.com.cn/alloyteam.gif\" alt=\"\" width=\"785\" height=\"592\" /></a><a href=\"https://www.nihaoshijie.com.cn/mypro/svg/alloyteam.html\" target=\"_blank\">demo</a>\n\n以上这些效果都是利用SVG线条动画实现的，只用了css3和svg，没有使用一行javascript代码，这一点和canvas比起来要容易一些，下面就说明一下实现这些效果的原理。\n\n关于SVG的基础知识，我这里就不再叙述了，大家可以直接在文档中查看相关的API，这里只说一下实现线条动画主要用到的：path （路径）\n<h2 style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; border: 0px; font-weight: bold; font-family: 微软雅黑; font-size: 14px; color: #000000; background-color: #f9f9f9;\">&lt;path&gt; 标签命令</h2>\n<ul style=\"margin-top: 10px; margin-bottom: 0px; margin-left: 35px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; border: 0px; color: #000000; font-family: Verdana, Arial, 宋体; font-size: 12px; background-color: #f9f9f9;\">\n \t<li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">M = moveto</li>\n \t<li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">L = lineto</li>\n \t<li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">H = horizontal lineto</li>\n \t<li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">V = vertical lineto</li>\n \t<li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">C = curveto</li>\n \t<li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">S = smooth curveto</li>\n \t<li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">Q = quadratic Belzier curve</li>\n \t<li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">T = smooth quadratic Belzier curveto</li>\n \t<li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">A = elliptical Arc</li>\n \t<li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">Z = closepath</li>\n</ul>\n利用path的这些命令我们可以实现我们想要的任何线条组合，以一段简单的线条为例:\n```html\n<path id=\"path\" fill=\"none\" stroke=\"#000\" stroke-width=\"1px\" d=\"M452,293c0,0,0-61,72-44c0,0-47,117,81,57\n    s5-110,10-67s-51,77.979-50,33.989\"/>\n```\n效果：\n\n<a href=\"https://qiniu.nihaoshijie.com.cn/blog/simple.png\"><img class=\"alignnone size-full wp-image-673\" src=\"https://qiniu.nihaoshijie.com.cn/blog/simple.png\" alt=\"\" width=\"255\" height=\"157\" /></a>\n\n呵呵，看起来很简单，但是，如何让这个线条动起来呢？这里就要明白到SVG里的path的一些主要属性：\n<ol style=\"transition: all 0.3s; margin-top: 0px; margin-bottom: 0px; margin-left: 30px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; list-style-position: initial; list-style-image: initial; color: #333333; font-family: 'lucida grande', 'lucida sans unicode', lucida, helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;\">\n \t<li style=\"transition: all 0.3s; margin: 0px; padding: 0px; list-style-position: inside; list-style-image: initial;\">stroke：标识路径的颜色；</li>\n \t<li style=\"transition: all 0.3s; margin: 0px; padding: 0px; list-style-position: inside; list-style-image: initial;\">d：标识路径命令的集合，这个属性主要决定了线条的形状。</li>\n \t<li style=\"transition: all 0.3s; margin: 0px; padding: 0px; list-style-position: inside; list-style-image: initial;\"><span style=\"color: #333333; font-family: 'lucida grande', 'lucida sans unicode', lucida, helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;\">stroke-width：标识路径的宽度，单位是px；</span></li>\n \t<li style=\"transition: all 0.3s; margin: 0px; padding: 0px; list-style-position: inside; list-style-image: initial;\">stroke-dasharray：它是一个&lt;length&gt;和&lt;percentage&gt;数列，数与数之间用逗号或者空白隔开，指定短划线和缺口的长度。如果提供了奇数个值，则这个值的数列重复一次，从而变成偶数个值。因此，5,3,2等同于5,3,2,5,3,2；</li>\n \t<li style=\"transition: all 0.3s; margin: 0px; padding: 0px; list-style-position: inside; list-style-image: initial;\"><span style=\"color: #333333; font-family: 'lucida grande', 'lucida sans unicode', lucida, helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;\">stroke-dashoffset：标识的是整个路径的偏移值；</span></li>\n</ol>\n<span style=\"color: #333333;\">以一张图来解释stroke-dasharray和stroke-dashoffset更容易理解一些：</span>\n\n<a href=\"https://qiniu.nihaoshijie.com.cn/blog/array.png\"><img class=\"alignnone size-full wp-image-674\" src=\"https://qiniu.nihaoshijie.com.cn/blog/array.png\" alt=\"\" width=\"484\" height=\"242\" /></a>\n\n<span style=\"color: #333333;\">因此，我们之前的路径就会变成这个样子：</span>\n```css\n#path {\n        stroke-dasharray: 3px, 1px;\n        stroke-dasharray: 0;\n}\n```\n效果：\n\n<a href=\"https://qiniu.nihaoshijie.com.cn/%E8%99%9A%E7%BA%BF.png\"><img class=\"alignnone size-full wp-image-675\" src=\"https://qiniu.nihaoshijie.com.cn/%E8%99%9A%E7%BA%BF.png\" alt=\"\" width=\"278\" height=\"171\" /></a>\n\n理解了stroke-dasharray的作用之后，下面我们就可以使用css3的animation来让这个路径动起来。\n```css\n#path {\n    animation: move 3s linear forwards;\n}\n\n@keyframes move {\n      0%{\n          stroke-dasharray: 0, 511px;\n      }\n      100%{\n          stroke-dasharray: 511px, 511px;\n      }\n}\n```\n&nbsp;\n\n效果：\n\n<a href=\"https://qiniu.nihaoshijie.com.cn/blog/dong2.gif\"><img class=\"alignnone size-full wp-image-676\" src=\"https://qiniu.nihaoshijie.com.cn/blog/dong2.gif\" alt=\"\" width=\"384\" height=\"154\" /></a>\n\n511这个值是整个路径的长度，可以用js的document.getElementById('path').getTotalLength()得到\n\nstroke-dasharray: 0, 511; 表示实线和空隙的长度分别为 0 和 511，所以一开始整个路径都是空隙，所以是空的。\n然后过渡到 stroke-dasharray: 511, 511; 因为整个线条的长度就是 511，而实线的长度也慢慢变成511，所以整个线条就出现了。\n\n同样利用stroke-dashoffset也可以实现这个效果，原理就是最初线条分为511实线，和511空隙，但是由于设置了offset使线条偏移不可见了，当不断修改offset后，线条慢慢出现。\n```css\n#path {\n    animation: move 3s linear forwards;\n    stroke-dasharray: 511px,511px;\n}\n\n@keyframes move {\n  0%{\n      stroke-dashoffset: 511px;\n  }\n  100%{\n      stroke-dashoffset: 0;\n  }\n}\n```\n效果：\n\n<a href=\"https://qiniu.nihaoshijie.com.cn/blog/dong2-1.gif\"><img class=\"alignnone size-full wp-image-677\" src=\"https://qiniu.nihaoshijie.com.cn/blog/dong2-1.gif\" alt=\"\" width=\"384\" height=\"154\" /></a>\n\n当我们掌握了上述的方法后，整个利用SVG实现线条动画的原理就已经清楚了，我们需要的就是一个SVG路径了，但是总画一些简单的线条还是不美啊，那我们如何才能得到复杂的svg路径呢？\n<ol>\n \t<li>找UI设计师要一个。</li>\n \t<li>自己利用PS和AI做一个，只需要简单的2步。</li>\n</ol>\n<a href=\"https://qiniu.nihaoshijie.com.cn/blog/psai.png\"><img class=\"alignnone size-full wp-image-678\" src=\"https://qiniu.nihaoshijie.com.cn/blog/psai.png\" alt=\"\" width=\"119\" height=\"31\" /></a>\n\n以部落LOGO为例：\n\n1，得到部落LOGO的png图片。\n\n2，右键图层，然后点击从选区生成工作路径，我们就可以得到：\n\n<a href=\"https://qiniu.nihaoshijie.com.cn/blog/buluopng.png\"><img class=\"alignnone size-full wp-image-679\" src=\"https://qiniu.nihaoshijie.com.cn/blog/buluopng.png\" alt=\"\" width=\"260\" height=\"210\" /></a>\n\n3，文件--导出--路径到AI，将路径导出在AI里面打开。\n\n<a href=\"https://qiniu.nihaoshijie.com.cn/buluolujing.png\"><img class=\"alignnone size-full wp-image-680\" src=\"https://qiniu.nihaoshijie.com.cn/buluolujing.png\" alt=\"\" width=\"294\" height=\"230\" /></a>\n\n4，在AI里面选择保存成svg格式的文件，然后用sublime打开svg文件，将path的d拷贝出来即可。\n\n5，利用上文介绍的实现动画的方法，我们就可以轻松的得到了下面这个效果。\n\n<a href=\"https://qiniu.nihaoshijie.com.cn/blog/buluo.gif\"><img class=\"alignnone size-full wp-image-681\" src=\"https://qiniu.nihaoshijie.com.cn/blog/buluo.gif\" alt=\"\" width=\"312\" height=\"173\" /></a>\n\n线条动画进阶：\n\n可以看到上面的动画效果和文章最初显示的动画效果还是有区别的，要想实现文章最初的动画效果，需要用到SVG的&lt;symbol&gt; 和 &lt;use&gt;来实现，读者可以在网上查一下这两个标签的用法。\n\n```html\n<symbol id=\"pathSymbol\">\n    <path  class=\"path\" stroke=\"#00adef\"  d=\"M281.221,261.806c0,2.756-2.166,4.922-4.922,4.922l0,0h-33.964c-11.715-24.119-31.503-59.855-47.156-68.026\n  c-15.751,7.974-35.637,43.907-47.451,68.026h-33.865l0,0c-2.756,0-4.922-2.166-4.922-4.922l0,0l0,0c0-0.295,0-0.689,0.098-0.984\n  c0,0,14.078-69.109,79.15-129.161c-2.953-2.56-5.907-5.119-8.959-7.58c-1.87-1.575-2.166-4.233-0.591-6.104\n  c1.575-1.772,4.43-2.166,6.497-0.689c3.347,2.461,6.694,5.218,9.746,8.073c3.15-2.953,6.497-5.71,10.041-8.368\n  c2.067-1.378,4.922-1.083,6.497,0.689c1.575,1.87,1.28,4.529-0.591,6.104c-3.052,2.56-6.104,5.218-9.155,7.876\n  c65.27,59.953,79.446,129.161,79.446,129.161C281.221,261.117,281.221,261.412,281.221,261.806L281.221,261.806L281.221,261.806z\"/>\n    <path  class=\"path\" stroke=\"#00adef\"  d=\"M194.589,212.583h0.984l0,0c19.886,28.451,31.503,54.145,31.503,54.145h-63.99C163.086,266.728,174.703,241.034,194.589,212.583\nL194.589,212.583z\"/>\n</symbol>\n<g>\n  <use xlink:href=\"#pathSymbol\"\n    id=\"path1\"></use>\n    <use xlink:href=\"#pathSymbol\"\n      id=\"path2\"></use>\n</g>\n```\n```css\n#path1 {\n\n    stroke-dashoffset: 7% 7%;\n    stroke-dasharray: 0 35%;\n    animation: animation 3s linear forwards;\n  }\n\n  @keyframes animation {\n      100% {\n        stroke-dasharray: 7% 7%;\n        stroke-dashoffset: 7%;\n\n      }\n  }\n\n  #path2 {\n\n    stroke-dashoffset: 7% 7%;\n    stroke-dasharray: 0 35%;\n    animation: animation2 3s linear forwards;\n  }\n\n  @keyframes animation2 {\n      100% {\n          stroke-dasharray: 7% 7%;\n          stroke-dashoffset: 14%;\n\n      }\n }\n ```\n思路就是：\n\n1，将原来只有一条path的路径替换成两条，并且这两条的路径是完全重合的。\n\n2，分别设置两条路径的stroke-dasharray和stroke-dashoffset的css3的animation动画，注意两条路径的动画不能完全一样要有差值。\n\n3，设置成功之后就可以利用animation动画触发的时机和改变程度来实现多条动画效果。\n\n效果：\n\n<a href=\"https://qiniu.nihaoshijie.com.cn/blog/buluofuza.gif\"><img class=\"alignnone size-full wp-image-670\" src=\"https://qiniu.nihaoshijie.com.cn/blog/buluofuza.gif\" alt=\"\" width=\"279\" height=\"237\" /></a>\n\n那么如何实现alloyteam的文字动画呢，其实原理也是利用了stroke-dasharray和stroke-dashoffset，这两个属性不仅可以作用在&lt;path&gt;上，同样可以作用在&lt;text&gt;上。\n```html\n<symbol id=\"text\">\n    <text x=\"30%\" y=\"35%\" class=\"text\">QQ</text>\n  </symbol>\n\n  <g>\n    <use xlink:href=\"#text\"\n      class=\"use-text\"></use>\n      <use xlink:href=\"#text\"\n        class=\"use-text\"></use>\n        <use xlink:href=\"#text\"\n          class=\"use-text\"></use>\n          <use xlink:href=\"#text\"\n            class=\"use-text\"></use>\n            <use xlink:href=\"#text\"\n              class=\"use-text\"></use>\n  </g>\n```\n```css\n.use-text:nth-child(1) {\n      stroke: #360745;\n      animation: animation1 8s infinite ease-in-out forwards;\n\n}\n          \n.use-text:nth-child(2) {\n      stroke: #D61C59;\n      animation: animation2 8s infinite ease-in-out forwards;\n\n}\n          \n.use-text:nth-child(3) {\n       stroke: #E7D84B;\n       animation: animation3 8s infinite ease-in-out forwards;\n\n}\n\n.use-text:nth-child(4) {\n       stroke: #EFEAC5;\n       animation: animation4 8s infinite ease-in-out forwards;\n\n}\n\n.use-text:nth-child(5) {\n      stroke: #1B8798;\n      animation: animation5 8s infinite ease-in-out forwards;\n}\n\n@keyframes animation1 {\n       50%{\n            stroke-dasharray: 7% 28%;\n            stroke-dashoffset: 7%;\n       }\n       70%{\n             stroke-dasharray: 7% 28%;\n             stroke-dashoffset: 7%;\n       }\n}\n@keyframes animation2 {\n       50%{\n           stroke-dasharray: 7% 28%;\n           stroke-dashoffset: 14%;\n       }\n       70%{\n            stroke-dasharray: 7% 28%;\n            stroke-dashoffset: 14%;\n       }\n}\n@keyframes animation3 {\n     50%{\n         stroke-dasharray: 7% 28%;\n         stroke-dashoffset: 21%;\n    }\n    70%{\n         stroke-dasharray: 7% 28%;\n         stroke-dashoffset: 21%;\n    }\n}\n@keyframes animation4 {\n       50%{\n            stroke-dasharray: 7% 28%;\n            stroke-dashoffset: 28%;\n       }\n       70%{\n            stroke-dasharray: 7% 28%;\n            stroke-dashoffset: 28%;\n       }\n}\n@keyframes animation5 {\n      50%{\n           stroke-dasharray: 7% 28%;\n           stroke-dashoffset: 35%;\n      }\n      70%{\n           stroke-dasharray: 7% 28%;\n           stroke-dashoffset: 35%;\n      }\n}\n```\n这里用了5条完全重合的路径，并且每个路径的颜色和动画效果都不一样。\n\n效果：\n\n<a href=\"https://qiniu.nihaoshijie.com.cn/qq.gif\"><img class=\"alignnone size-full wp-image-682\" src=\"https://qiniu.nihaoshijie.com.cn/qq.gif\" alt=\"\" width=\"529\" height=\"338\" /></a>","slug":"线条之美，玩转SVG线条动画","published":1,"updated":"2019-04-02T16:49:22.000Z","comments":1,"layout":"post","link":"","_id":"ckx434q1w00432wvjhq6fkkhs","content":"<p>通常来说web前端实现动画效果主要通过下面几种方案：</p>\n<p><ul><br>     <li>css动画；利用css3的样式效果可以将dom元素做出动画的效果来。</li><br>     <li>canvas动画；利用canvas提供的API，然后利用清除-渲染这样一帧一帧的做出动画效果。</li><br>     <li>svg动画；同样svg也提供了不少的API来实现动画效果，并且兼容性也不差，本文主要讲解一下如何制作svg线条动画。</li><br></ul><br><a id=\"more\"></a><br>先来看几个效果：</p>\n<p><a href=\"https://qiniu.nihaoshijie.com.cn/blog/buluofuza.gif\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-670\" src=\"https://qiniu.nihaoshijie.com.cn/blog/buluofuza.gif\" alt width=\"279\" height=\"237\"></a><a href=\"https://www.nihaoshijie.com.cn/mypro/svg/buluofuza.html\" target=\"_blank\">demo</a></p>\n<p><a href=\"https://qiniu.nihaoshijie.com.cn/blog/daojishi1.gif\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-671\" src=\"https://qiniu.nihaoshijie.com.cn/blog/daojishi1.gif\" alt width=\"298\" height=\"148\"></a><a href=\"https://www.nihaoshijie.com.cn/mypro/svg/daojishi.html\" target=\"_blank\">demo</a></p>\n<p><a href=\"https://qiniu.nihaoshijie.com.cn/alloyteam.gif\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-672\" src=\"https://qiniu.nihaoshijie.com.cn/alloyteam.gif\" alt width=\"785\" height=\"592\"></a><a href=\"https://www.nihaoshijie.com.cn/mypro/svg/alloyteam.html\" target=\"_blank\">demo</a></p>\n<p>以上这些效果都是利用SVG线条动画实现的，只用了css3和svg，没有使用一行javascript代码，这一点和canvas比起来要容易一些，下面就说明一下实现这些效果的原理。</p>\n<p>关于SVG的基础知识，我这里就不再叙述了，大家可以直接在文档中查看相关的API，这里只说一下实现线条动画主要用到的：path （路径）</p>\n<p></p><h2 style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; border: 0px; font-weight: bold; font-family: 微软雅黑; font-size: 14px; color: #000000; background-color: #f9f9f9;\"><span id=\"ltpathgt-标签命令\">&lt;path&gt; 标签命令</span></h2><p></p>\n<p><ul style=\"margin-top: 10px; margin-bottom: 0px; margin-left: 35px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; border: 0px; color: #000000; font-family: Verdana, Arial, 宋体; font-size: 12px; background-color: #f9f9f9;\"><br>     <li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">M = moveto</li><br>     <li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">L = lineto</li><br>     <li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">H = horizontal lineto</li><br>     <li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">V = vertical lineto</li><br>     <li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">C = curveto</li><br>     <li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">S = smooth curveto</li><br>     <li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">Q = quadratic Belzier curve</li><br>     <li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">T = smooth quadratic Belzier curveto</li><br>     <li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">A = elliptical Arc</li><br>     <li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">Z = closepath</li><br></ul><br>利用path的这些命令我们可以实现我们想要的任何线条组合，以一段简单的线条为例:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">id</span>=<span class=\"string\">\"path\"</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"none\"</span> <span class=\"attr\">stroke</span>=<span class=\"string\">\"#000\"</span> <span class=\"attr\">stroke-width</span>=<span class=\"string\">\"1px\"</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M452,293c0,0,0-61,72-44c0,0-47,117,81,57</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">    s5-110,10-67s-51,77.979-50,33.989\"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>效果：</p>\n<p><a href=\"https://qiniu.nihaoshijie.com.cn/blog/simple.png\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-673\" src=\"https://qiniu.nihaoshijie.com.cn/blog/simple.png\" alt width=\"255\" height=\"157\"></a></p>\n<p>呵呵，看起来很简单，但是，如何让这个线条动起来呢？这里就要明白到SVG里的path的一些主要属性：</p>\n<p><ol style=\"transition: all 0.3s; margin-top: 0px; margin-bottom: 0px; margin-left: 30px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; list-style-position: initial; list-style-image: initial; color: #333333; font-family: 'lucida grande', 'lucida sans unicode', lucida, helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;\"><br>     <li style=\"transition: all 0.3s; margin: 0px; padding: 0px; list-style-position: inside; list-style-image: initial;\">stroke：标识路径的颜色；</li><br>     <li style=\"transition: all 0.3s; margin: 0px; padding: 0px; list-style-position: inside; list-style-image: initial;\">d：标识路径命令的集合，这个属性主要决定了线条的形状。</li><br>     <li style=\"transition: all 0.3s; margin: 0px; padding: 0px; list-style-position: inside; list-style-image: initial;\"><span style=\"color: #333333; font-family: 'lucida grande', 'lucida sans unicode', lucida, helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;\">stroke-width：标识路径的宽度，单位是px；</span></li><br>     <li style=\"transition: all 0.3s; margin: 0px; padding: 0px; list-style-position: inside; list-style-image: initial;\">stroke-dasharray：它是一个&lt;length&gt;和&lt;percentage&gt;数列，数与数之间用逗号或者空白隔开，指定短划线和缺口的长度。如果提供了奇数个值，则这个值的数列重复一次，从而变成偶数个值。因此，5,3,2等同于5,3,2,5,3,2；</li><br>     <li style=\"transition: all 0.3s; margin: 0px; padding: 0px; list-style-position: inside; list-style-image: initial;\"><span style=\"color: #333333; font-family: 'lucida grande', 'lucida sans unicode', lucida, helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;\">stroke-dashoffset：标识的是整个路径的偏移值；</span></li><br></ol><br><span style=\"color: #333333;\">以一张图来解释stroke-dasharray和stroke-dashoffset更容易理解一些：</span></p>\n<p><a href=\"https://qiniu.nihaoshijie.com.cn/blog/array.png\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-674\" src=\"https://qiniu.nihaoshijie.com.cn/blog/array.png\" alt width=\"484\" height=\"242\"></a></p>\n<p><span style=\"color: #333333;\">因此，我们之前的路径就会变成这个样子：</span><br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#path</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">3px</span>, <span class=\"number\">1px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>效果：</p>\n<p><a href=\"https://qiniu.nihaoshijie.com.cn/%E8%99%9A%E7%BA%BF.png\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-675\" src=\"https://qiniu.nihaoshijie.com.cn/%E8%99%9A%E7%BA%BF.png\" alt width=\"278\" height=\"171\"></a></p>\n<p>理解了stroke-dasharray的作用之后，下面我们就可以使用css3的animation来让这个路径动起来。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#path</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: move <span class=\"number\">3s</span> linear forwards;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@<span class=\"keyword\">keyframes</span> move &#123;</span><br><span class=\"line\">      0%&#123;</span><br><span class=\"line\">          <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">0</span>, <span class=\"number\">511px</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      100%&#123;</span><br><span class=\"line\">          <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">511px</span>, <span class=\"number\">511px</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;</p>\n<p>效果：</p>\n<p><a href=\"https://qiniu.nihaoshijie.com.cn/blog/dong2.gif\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-676\" src=\"https://qiniu.nihaoshijie.com.cn/blog/dong2.gif\" alt width=\"384\" height=\"154\"></a></p>\n<p>511这个值是整个路径的长度，可以用js的document.getElementById(‘path’).getTotalLength()得到</p>\n<p>stroke-dasharray: 0, 511; 表示实线和空隙的长度分别为 0 和 511，所以一开始整个路径都是空隙，所以是空的。<br>然后过渡到 stroke-dasharray: 511, 511; 因为整个线条的长度就是 511，而实线的长度也慢慢变成511，所以整个线条就出现了。</p>\n<p>同样利用stroke-dashoffset也可以实现这个效果，原理就是最初线条分为511实线，和511空隙，但是由于设置了offset使线条偏移不可见了，当不断修改offset后，线条慢慢出现。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#path</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: move <span class=\"number\">3s</span> linear forwards;</span><br><span class=\"line\">    <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">511px</span>,<span class=\"number\">511px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@<span class=\"keyword\">keyframes</span> move &#123;</span><br><span class=\"line\">  0%&#123;</span><br><span class=\"line\">      <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">511px</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  100%&#123;</span><br><span class=\"line\">      <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>效果：</p>\n<p><a href=\"https://qiniu.nihaoshijie.com.cn/blog/dong2-1.gif\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-677\" src=\"https://qiniu.nihaoshijie.com.cn/blog/dong2-1.gif\" alt width=\"384\" height=\"154\"></a></p>\n<p>当我们掌握了上述的方法后，整个利用SVG实现线条动画的原理就已经清楚了，我们需要的就是一个SVG路径了，但是总画一些简单的线条还是不美啊，那我们如何才能得到复杂的svg路径呢？</p>\n<p><ol><br>     <li>找UI设计师要一个。</li><br>     <li>自己利用PS和AI做一个，只需要简单的2步。</li><br></ol><br><a href=\"https://qiniu.nihaoshijie.com.cn/blog/psai.png\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-678\" src=\"https://qiniu.nihaoshijie.com.cn/blog/psai.png\" alt width=\"119\" height=\"31\"></a></p>\n<p>以部落LOGO为例：</p>\n<p>1，得到部落LOGO的png图片。</p>\n<p>2，右键图层，然后点击从选区生成工作路径，我们就可以得到：</p>\n<p><a href=\"https://qiniu.nihaoshijie.com.cn/blog/buluopng.png\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-679\" src=\"https://qiniu.nihaoshijie.com.cn/blog/buluopng.png\" alt width=\"260\" height=\"210\"></a></p>\n<p>3，文件–导出–路径到AI，将路径导出在AI里面打开。</p>\n<p><a href=\"https://qiniu.nihaoshijie.com.cn/buluolujing.png\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-680\" src=\"https://qiniu.nihaoshijie.com.cn/buluolujing.png\" alt width=\"294\" height=\"230\"></a></p>\n<p>4，在AI里面选择保存成svg格式的文件，然后用sublime打开svg文件，将path的d拷贝出来即可。</p>\n<p>5，利用上文介绍的实现动画的方法，我们就可以轻松的得到了下面这个效果。</p>\n<p><a href=\"https://qiniu.nihaoshijie.com.cn/blog/buluo.gif\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-681\" src=\"https://qiniu.nihaoshijie.com.cn/blog/buluo.gif\" alt width=\"312\" height=\"173\"></a></p>\n<p>线条动画进阶：</p>\n<p>可以看到上面的动画效果和文章最初显示的动画效果还是有区别的，要想实现文章最初的动画效果，需要用到SVG的&lt;symbol&gt; 和 &lt;use&gt;来实现，读者可以在网上查一下这两个标签的用法。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">symbol</span> <span class=\"attr\">id</span>=<span class=\"string\">\"pathSymbol\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">path</span>  <span class=\"attr\">class</span>=<span class=\"string\">\"path\"</span> <span class=\"attr\">stroke</span>=<span class=\"string\">\"#00adef\"</span>  <span class=\"attr\">d</span>=<span class=\"string\">\"M281.221,261.806c0,2.756-2.166,4.922-4.922,4.922l0,0h-33.964c-11.715-24.119-31.503-59.855-47.156-68.026</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">  c-15.751,7.974-35.637,43.907-47.451,68.026h-33.865l0,0c-2.756,0-4.922-2.166-4.922-4.922l0,0l0,0c0-0.295,0-0.689,0.098-0.984</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">  c0,0,14.078-69.109,79.15-129.161c-2.953-2.56-5.907-5.119-8.959-7.58c-1.87-1.575-2.166-4.233-0.591-6.104</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">  c1.575-1.772,4.43-2.166,6.497-0.689c3.347,2.461,6.694,5.218,9.746,8.073c3.15-2.953,6.497-5.71,10.041-8.368</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">  c2.067-1.378,4.922-1.083,6.497,0.689c1.575,1.87,1.28,4.529-0.591,6.104c-3.052,2.56-6.104,5.218-9.155,7.876</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">  c65.27,59.953,79.446,129.161,79.446,129.161C281.221,261.117,281.221,261.412,281.221,261.806L281.221,261.806L281.221,261.806z\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">path</span>  <span class=\"attr\">class</span>=<span class=\"string\">\"path\"</span> <span class=\"attr\">stroke</span>=<span class=\"string\">\"#00adef\"</span>  <span class=\"attr\">d</span>=<span class=\"string\">\"M194.589,212.583h0.984l0,0c19.886,28.451,31.503,54.145,31.503,54.145h-63.99C163.086,266.728,174.703,241.034,194.589,212.583</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">L194.589,212.583z\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">symbol</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">g</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xlink:href</span>=<span class=\"string\">\"#pathSymbol\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">id</span>=<span class=\"string\">\"path1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">use</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xlink:href</span>=<span class=\"string\">\"#pathSymbol\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">id</span>=<span class=\"string\">\"path2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">use</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">g</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#path1</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">7%</span> <span class=\"number\">7%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">0</span> <span class=\"number\">35%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: animation <span class=\"number\">3s</span> linear forwards;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  @<span class=\"keyword\">keyframes</span> animation &#123;</span><br><span class=\"line\">      100% &#123;</span><br><span class=\"line\">        <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">7%</span> <span class=\"number\">7%</span>;</span><br><span class=\"line\">        <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">7%</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"selector-id\">#path2</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">7%</span> <span class=\"number\">7%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">0</span> <span class=\"number\">35%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: animation2 <span class=\"number\">3s</span> linear forwards;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  @<span class=\"keyword\">keyframes</span> animation2 &#123;</span><br><span class=\"line\">      100% &#123;</span><br><span class=\"line\">          <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">7%</span> <span class=\"number\">7%</span>;</span><br><span class=\"line\">          <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">14%</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>思路就是：</p>\n<p>1，将原来只有一条path的路径替换成两条，并且这两条的路径是完全重合的。</p>\n<p>2，分别设置两条路径的stroke-dasharray和stroke-dashoffset的css3的animation动画，注意两条路径的动画不能完全一样要有差值。</p>\n<p>3，设置成功之后就可以利用animation动画触发的时机和改变程度来实现多条动画效果。</p>\n<p>效果：</p>\n<p><a href=\"https://qiniu.nihaoshijie.com.cn/blog/buluofuza.gif\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-670\" src=\"https://qiniu.nihaoshijie.com.cn/blog/buluofuza.gif\" alt width=\"279\" height=\"237\"></a></p>\n<p>那么如何实现alloyteam的文字动画呢，其实原理也是利用了stroke-dasharray和stroke-dashoffset，这两个属性不仅可以作用在&lt;path&gt;上，同样可以作用在&lt;text&gt;上。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">symbol</span> <span class=\"attr\">id</span>=<span class=\"string\">\"text\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">text</span> <span class=\"attr\">x</span>=<span class=\"string\">\"30%\"</span> <span class=\"attr\">y</span>=<span class=\"string\">\"35%\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text\"</span>&gt;</span>QQ<span class=\"tag\">&lt;/<span class=\"name\">text</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">symbol</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">g</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xlink:href</span>=<span class=\"string\">\"#text\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">class</span>=<span class=\"string\">\"use-text\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">use</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xlink:href</span>=<span class=\"string\">\"#text\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">class</span>=<span class=\"string\">\"use-text\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">use</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xlink:href</span>=<span class=\"string\">\"#text\"</span></span></span><br><span class=\"line\"><span class=\"tag\">          <span class=\"attr\">class</span>=<span class=\"string\">\"use-text\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">use</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xlink:href</span>=<span class=\"string\">\"#text\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">class</span>=<span class=\"string\">\"use-text\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">use</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xlink:href</span>=<span class=\"string\">\"#text\"</span></span></span><br><span class=\"line\"><span class=\"tag\">              <span class=\"attr\">class</span>=<span class=\"string\">\"use-text\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">use</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">g</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.use-text</span><span class=\"selector-pseudo\">:nth-child(1)</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">stroke</span>: <span class=\"number\">#360745</span>;</span><br><span class=\"line\">      <span class=\"attribute\">animation</span>: animation1 <span class=\"number\">8s</span> infinite ease-in-out forwards;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">          </span><br><span class=\"line\"><span class=\"selector-class\">.use-text</span><span class=\"selector-pseudo\">:nth-child(2)</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">stroke</span>: <span class=\"number\">#D61C59</span>;</span><br><span class=\"line\">      <span class=\"attribute\">animation</span>: animation2 <span class=\"number\">8s</span> infinite ease-in-out forwards;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">          </span><br><span class=\"line\"><span class=\"selector-class\">.use-text</span><span class=\"selector-pseudo\">:nth-child(3)</span> &#123;</span><br><span class=\"line\">       <span class=\"attribute\">stroke</span>: <span class=\"number\">#E7D84B</span>;</span><br><span class=\"line\">       <span class=\"attribute\">animation</span>: animation3 <span class=\"number\">8s</span> infinite ease-in-out forwards;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.use-text</span><span class=\"selector-pseudo\">:nth-child(4)</span> &#123;</span><br><span class=\"line\">       <span class=\"attribute\">stroke</span>: <span class=\"number\">#EFEAC5</span>;</span><br><span class=\"line\">       <span class=\"attribute\">animation</span>: animation4 <span class=\"number\">8s</span> infinite ease-in-out forwards;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.use-text</span><span class=\"selector-pseudo\">:nth-child(5)</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">stroke</span>: <span class=\"number\">#1B8798</span>;</span><br><span class=\"line\">      <span class=\"attribute\">animation</span>: animation5 <span class=\"number\">8s</span> infinite ease-in-out forwards;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@<span class=\"keyword\">keyframes</span> animation1 &#123;</span><br><span class=\"line\">       50%&#123;</span><br><span class=\"line\">            <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">7%</span> <span class=\"number\">28%</span>;</span><br><span class=\"line\">            <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">7%</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       70%&#123;</span><br><span class=\"line\">             <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">7%</span> <span class=\"number\">28%</span>;</span><br><span class=\"line\">             <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">7%</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@<span class=\"keyword\">keyframes</span> animation2 &#123;</span><br><span class=\"line\">       50%&#123;</span><br><span class=\"line\">           <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">7%</span> <span class=\"number\">28%</span>;</span><br><span class=\"line\">           <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">14%</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       70%&#123;</span><br><span class=\"line\">            <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">7%</span> <span class=\"number\">28%</span>;</span><br><span class=\"line\">            <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">14%</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@<span class=\"keyword\">keyframes</span> animation3 &#123;</span><br><span class=\"line\">     50%&#123;</span><br><span class=\"line\">         <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">7%</span> <span class=\"number\">28%</span>;</span><br><span class=\"line\">         <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">21%</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    70%&#123;</span><br><span class=\"line\">         <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">7%</span> <span class=\"number\">28%</span>;</span><br><span class=\"line\">         <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">21%</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@<span class=\"keyword\">keyframes</span> animation4 &#123;</span><br><span class=\"line\">       50%&#123;</span><br><span class=\"line\">            <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">7%</span> <span class=\"number\">28%</span>;</span><br><span class=\"line\">            <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">28%</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       70%&#123;</span><br><span class=\"line\">            <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">7%</span> <span class=\"number\">28%</span>;</span><br><span class=\"line\">            <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">28%</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@<span class=\"keyword\">keyframes</span> animation5 &#123;</span><br><span class=\"line\">      50%&#123;</span><br><span class=\"line\">           <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">7%</span> <span class=\"number\">28%</span>;</span><br><span class=\"line\">           <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">35%</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      70%&#123;</span><br><span class=\"line\">           <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">7%</span> <span class=\"number\">28%</span>;</span><br><span class=\"line\">           <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">35%</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里用了5条完全重合的路径，并且每个路径的颜色和动画效果都不一样。</p>\n<p>效果：</p>\n<p><a href=\"https://qiniu.nihaoshijie.com.cn/qq.gif\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-682\" src=\"https://qiniu.nihaoshijie.com.cn/qq.gif\" alt width=\"529\" height=\"338\"></a></p>\n","site":{"data":{}},"excerpt":"<p>通常来说web前端实现动画效果主要通过下面几种方案：</p>\n<p><ul><br>     <li>css动画；利用css3的样式效果可以将dom元素做出动画的效果来。</li><br>     <li>canvas动画；利用canvas提供的API，然后利用清除-渲染这样一帧一帧的做出动画效果。</li><br>     <li>svg动画；同样svg也提供了不少的API来实现动画效果，并且兼容性也不差，本文主要讲解一下如何制作svg线条动画。</li><br></ul><br>","more":"<br>先来看几个效果：</p>\n<p><a href=\"https://qiniu.nihaoshijie.com.cn/blog/buluofuza.gif\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-670\" src=\"https://qiniu.nihaoshijie.com.cn/blog/buluofuza.gif\" alt=\"\" width=\"279\" height=\"237\"></a><a href=\"https://www.nihaoshijie.com.cn/mypro/svg/buluofuza.html\" target=\"_blank\">demo</a></p>\n<p><a href=\"https://qiniu.nihaoshijie.com.cn/blog/daojishi1.gif\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-671\" src=\"https://qiniu.nihaoshijie.com.cn/blog/daojishi1.gif\" alt=\"\" width=\"298\" height=\"148\"></a><a href=\"https://www.nihaoshijie.com.cn/mypro/svg/daojishi.html\" target=\"_blank\">demo</a></p>\n<p><a href=\"https://qiniu.nihaoshijie.com.cn/alloyteam.gif\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-672\" src=\"https://qiniu.nihaoshijie.com.cn/alloyteam.gif\" alt=\"\" width=\"785\" height=\"592\"></a><a href=\"https://www.nihaoshijie.com.cn/mypro/svg/alloyteam.html\" target=\"_blank\">demo</a></p>\n<p>以上这些效果都是利用SVG线条动画实现的，只用了css3和svg，没有使用一行javascript代码，这一点和canvas比起来要容易一些，下面就说明一下实现这些效果的原理。</p>\n<p>关于SVG的基础知识，我这里就不再叙述了，大家可以直接在文档中查看相关的API，这里只说一下实现线条动画主要用到的：path （路径）</p>\n<p></p><h2 style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; border: 0px; font-weight: bold; font-family: 微软雅黑; font-size: 14px; color: #000000; background-color: #f9f9f9;\">&lt;path&gt; 标签命令</h2><p></p>\n<p><ul style=\"margin-top: 10px; margin-bottom: 0px; margin-left: 35px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; border: 0px; color: #000000; font-family: Verdana, Arial, 宋体; font-size: 12px; background-color: #f9f9f9;\"><br>     <li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">M = moveto</li><br>     <li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">L = lineto</li><br>     <li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">H = horizontal lineto</li><br>     <li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">V = vertical lineto</li><br>     <li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">C = curveto</li><br>     <li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">S = smooth curveto</li><br>     <li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">Q = quadratic Belzier curve</li><br>     <li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">T = smooth quadratic Belzier curveto</li><br>     <li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">A = elliptical Arc</li><br>     <li style=\"margin: 3px 0px 0px; padding: 0px; border: 0px;\">Z = closepath</li><br></ul><br>利用path的这些命令我们可以实现我们想要的任何线条组合，以一段简单的线条为例:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">id</span>=<span class=\"string\">\"path\"</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"none\"</span> <span class=\"attr\">stroke</span>=<span class=\"string\">\"#000\"</span> <span class=\"attr\">stroke-width</span>=<span class=\"string\">\"1px\"</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M452,293c0,0,0-61,72-44c0,0-47,117,81,57</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">    s5-110,10-67s-51,77.979-50,33.989\"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>效果：</p>\n<p><a href=\"https://qiniu.nihaoshijie.com.cn/blog/simple.png\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-673\" src=\"https://qiniu.nihaoshijie.com.cn/blog/simple.png\" alt=\"\" width=\"255\" height=\"157\"></a></p>\n<p>呵呵，看起来很简单，但是，如何让这个线条动起来呢？这里就要明白到SVG里的path的一些主要属性：</p>\n<p><ol style=\"transition: all 0.3s; margin-top: 0px; margin-bottom: 0px; margin-left: 30px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; list-style-position: initial; list-style-image: initial; color: #333333; font-family: 'lucida grande', 'lucida sans unicode', lucida, helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;\"><br>     <li style=\"transition: all 0.3s; margin: 0px; padding: 0px; list-style-position: inside; list-style-image: initial;\">stroke：标识路径的颜色；</li><br>     <li style=\"transition: all 0.3s; margin: 0px; padding: 0px; list-style-position: inside; list-style-image: initial;\">d：标识路径命令的集合，这个属性主要决定了线条的形状。</li><br>     <li style=\"transition: all 0.3s; margin: 0px; padding: 0px; list-style-position: inside; list-style-image: initial;\"><span style=\"color: #333333; font-family: 'lucida grande', 'lucida sans unicode', lucida, helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;\">stroke-width：标识路径的宽度，单位是px；</span></li><br>     <li style=\"transition: all 0.3s; margin: 0px; padding: 0px; list-style-position: inside; list-style-image: initial;\">stroke-dasharray：它是一个&lt;length&gt;和&lt;percentage&gt;数列，数与数之间用逗号或者空白隔开，指定短划线和缺口的长度。如果提供了奇数个值，则这个值的数列重复一次，从而变成偶数个值。因此，5,3,2等同于5,3,2,5,3,2；</li><br>     <li style=\"transition: all 0.3s; margin: 0px; padding: 0px; list-style-position: inside; list-style-image: initial;\"><span style=\"color: #333333; font-family: 'lucida grande', 'lucida sans unicode', lucida, helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;\">stroke-dashoffset：标识的是整个路径的偏移值；</span></li><br></ol><br><span style=\"color: #333333;\">以一张图来解释stroke-dasharray和stroke-dashoffset更容易理解一些：</span></p>\n<p><a href=\"https://qiniu.nihaoshijie.com.cn/blog/array.png\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-674\" src=\"https://qiniu.nihaoshijie.com.cn/blog/array.png\" alt=\"\" width=\"484\" height=\"242\"></a></p>\n<p><span style=\"color: #333333;\">因此，我们之前的路径就会变成这个样子：</span><br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#path</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">3px</span>, <span class=\"number\">1px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>效果：</p>\n<p><a href=\"https://qiniu.nihaoshijie.com.cn/%E8%99%9A%E7%BA%BF.png\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-675\" src=\"https://qiniu.nihaoshijie.com.cn/%E8%99%9A%E7%BA%BF.png\" alt=\"\" width=\"278\" height=\"171\"></a></p>\n<p>理解了stroke-dasharray的作用之后，下面我们就可以使用css3的animation来让这个路径动起来。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#path</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: move <span class=\"number\">3s</span> linear forwards;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@<span class=\"keyword\">keyframes</span> move &#123;</span><br><span class=\"line\">      0%&#123;</span><br><span class=\"line\">          <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">0</span>, <span class=\"number\">511px</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      100%&#123;</span><br><span class=\"line\">          <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">511px</span>, <span class=\"number\">511px</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;</p>\n<p>效果：</p>\n<p><a href=\"https://qiniu.nihaoshijie.com.cn/blog/dong2.gif\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-676\" src=\"https://qiniu.nihaoshijie.com.cn/blog/dong2.gif\" alt=\"\" width=\"384\" height=\"154\"></a></p>\n<p>511这个值是整个路径的长度，可以用js的document.getElementById(‘path’).getTotalLength()得到</p>\n<p>stroke-dasharray: 0, 511; 表示实线和空隙的长度分别为 0 和 511，所以一开始整个路径都是空隙，所以是空的。<br>然后过渡到 stroke-dasharray: 511, 511; 因为整个线条的长度就是 511，而实线的长度也慢慢变成511，所以整个线条就出现了。</p>\n<p>同样利用stroke-dashoffset也可以实现这个效果，原理就是最初线条分为511实线，和511空隙，但是由于设置了offset使线条偏移不可见了，当不断修改offset后，线条慢慢出现。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#path</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: move <span class=\"number\">3s</span> linear forwards;</span><br><span class=\"line\">    <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">511px</span>,<span class=\"number\">511px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@<span class=\"keyword\">keyframes</span> move &#123;</span><br><span class=\"line\">  0%&#123;</span><br><span class=\"line\">      <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">511px</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  100%&#123;</span><br><span class=\"line\">      <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>效果：</p>\n<p><a href=\"https://qiniu.nihaoshijie.com.cn/blog/dong2-1.gif\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-677\" src=\"https://qiniu.nihaoshijie.com.cn/blog/dong2-1.gif\" alt=\"\" width=\"384\" height=\"154\"></a></p>\n<p>当我们掌握了上述的方法后，整个利用SVG实现线条动画的原理就已经清楚了，我们需要的就是一个SVG路径了，但是总画一些简单的线条还是不美啊，那我们如何才能得到复杂的svg路径呢？</p>\n<p><ol><br>     <li>找UI设计师要一个。</li><br>     <li>自己利用PS和AI做一个，只需要简单的2步。</li><br></ol><br><a href=\"https://qiniu.nihaoshijie.com.cn/blog/psai.png\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-678\" src=\"https://qiniu.nihaoshijie.com.cn/blog/psai.png\" alt=\"\" width=\"119\" height=\"31\"></a></p>\n<p>以部落LOGO为例：</p>\n<p>1，得到部落LOGO的png图片。</p>\n<p>2，右键图层，然后点击从选区生成工作路径，我们就可以得到：</p>\n<p><a href=\"https://qiniu.nihaoshijie.com.cn/blog/buluopng.png\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-679\" src=\"https://qiniu.nihaoshijie.com.cn/blog/buluopng.png\" alt=\"\" width=\"260\" height=\"210\"></a></p>\n<p>3，文件–导出–路径到AI，将路径导出在AI里面打开。</p>\n<p><a href=\"https://qiniu.nihaoshijie.com.cn/buluolujing.png\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-680\" src=\"https://qiniu.nihaoshijie.com.cn/buluolujing.png\" alt=\"\" width=\"294\" height=\"230\"></a></p>\n<p>4，在AI里面选择保存成svg格式的文件，然后用sublime打开svg文件，将path的d拷贝出来即可。</p>\n<p>5，利用上文介绍的实现动画的方法，我们就可以轻松的得到了下面这个效果。</p>\n<p><a href=\"https://qiniu.nihaoshijie.com.cn/blog/buluo.gif\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-681\" src=\"https://qiniu.nihaoshijie.com.cn/blog/buluo.gif\" alt=\"\" width=\"312\" height=\"173\"></a></p>\n<p>线条动画进阶：</p>\n<p>可以看到上面的动画效果和文章最初显示的动画效果还是有区别的，要想实现文章最初的动画效果，需要用到SVG的&lt;symbol&gt; 和 &lt;use&gt;来实现，读者可以在网上查一下这两个标签的用法。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">symbol</span> <span class=\"attr\">id</span>=<span class=\"string\">\"pathSymbol\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">path</span>  <span class=\"attr\">class</span>=<span class=\"string\">\"path\"</span> <span class=\"attr\">stroke</span>=<span class=\"string\">\"#00adef\"</span>  <span class=\"attr\">d</span>=<span class=\"string\">\"M281.221,261.806c0,2.756-2.166,4.922-4.922,4.922l0,0h-33.964c-11.715-24.119-31.503-59.855-47.156-68.026</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">  c-15.751,7.974-35.637,43.907-47.451,68.026h-33.865l0,0c-2.756,0-4.922-2.166-4.922-4.922l0,0l0,0c0-0.295,0-0.689,0.098-0.984</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">  c0,0,14.078-69.109,79.15-129.161c-2.953-2.56-5.907-5.119-8.959-7.58c-1.87-1.575-2.166-4.233-0.591-6.104</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">  c1.575-1.772,4.43-2.166,6.497-0.689c3.347,2.461,6.694,5.218,9.746,8.073c3.15-2.953,6.497-5.71,10.041-8.368</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">  c2.067-1.378,4.922-1.083,6.497,0.689c1.575,1.87,1.28,4.529-0.591,6.104c-3.052,2.56-6.104,5.218-9.155,7.876</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">  c65.27,59.953,79.446,129.161,79.446,129.161C281.221,261.117,281.221,261.412,281.221,261.806L281.221,261.806L281.221,261.806z\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">path</span>  <span class=\"attr\">class</span>=<span class=\"string\">\"path\"</span> <span class=\"attr\">stroke</span>=<span class=\"string\">\"#00adef\"</span>  <span class=\"attr\">d</span>=<span class=\"string\">\"M194.589,212.583h0.984l0,0c19.886,28.451,31.503,54.145,31.503,54.145h-63.99C163.086,266.728,174.703,241.034,194.589,212.583</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">L194.589,212.583z\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">symbol</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">g</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xlink:href</span>=<span class=\"string\">\"#pathSymbol\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">id</span>=<span class=\"string\">\"path1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">use</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xlink:href</span>=<span class=\"string\">\"#pathSymbol\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">id</span>=<span class=\"string\">\"path2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">use</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">g</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#path1</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">7%</span> <span class=\"number\">7%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">0</span> <span class=\"number\">35%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: animation <span class=\"number\">3s</span> linear forwards;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  @<span class=\"keyword\">keyframes</span> animation &#123;</span><br><span class=\"line\">      100% &#123;</span><br><span class=\"line\">        <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">7%</span> <span class=\"number\">7%</span>;</span><br><span class=\"line\">        <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">7%</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"selector-id\">#path2</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">7%</span> <span class=\"number\">7%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">0</span> <span class=\"number\">35%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: animation2 <span class=\"number\">3s</span> linear forwards;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  @<span class=\"keyword\">keyframes</span> animation2 &#123;</span><br><span class=\"line\">      100% &#123;</span><br><span class=\"line\">          <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">7%</span> <span class=\"number\">7%</span>;</span><br><span class=\"line\">          <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">14%</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>思路就是：</p>\n<p>1，将原来只有一条path的路径替换成两条，并且这两条的路径是完全重合的。</p>\n<p>2，分别设置两条路径的stroke-dasharray和stroke-dashoffset的css3的animation动画，注意两条路径的动画不能完全一样要有差值。</p>\n<p>3，设置成功之后就可以利用animation动画触发的时机和改变程度来实现多条动画效果。</p>\n<p>效果：</p>\n<p><a href=\"https://qiniu.nihaoshijie.com.cn/blog/buluofuza.gif\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-670\" src=\"https://qiniu.nihaoshijie.com.cn/blog/buluofuza.gif\" alt=\"\" width=\"279\" height=\"237\"></a></p>\n<p>那么如何实现alloyteam的文字动画呢，其实原理也是利用了stroke-dasharray和stroke-dashoffset，这两个属性不仅可以作用在&lt;path&gt;上，同样可以作用在&lt;text&gt;上。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">symbol</span> <span class=\"attr\">id</span>=<span class=\"string\">\"text\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">text</span> <span class=\"attr\">x</span>=<span class=\"string\">\"30%\"</span> <span class=\"attr\">y</span>=<span class=\"string\">\"35%\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text\"</span>&gt;</span>QQ<span class=\"tag\">&lt;/<span class=\"name\">text</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">symbol</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">g</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xlink:href</span>=<span class=\"string\">\"#text\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">class</span>=<span class=\"string\">\"use-text\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">use</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xlink:href</span>=<span class=\"string\">\"#text\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">class</span>=<span class=\"string\">\"use-text\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">use</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xlink:href</span>=<span class=\"string\">\"#text\"</span></span></span><br><span class=\"line\"><span class=\"tag\">          <span class=\"attr\">class</span>=<span class=\"string\">\"use-text\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">use</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xlink:href</span>=<span class=\"string\">\"#text\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">class</span>=<span class=\"string\">\"use-text\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">use</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xlink:href</span>=<span class=\"string\">\"#text\"</span></span></span><br><span class=\"line\"><span class=\"tag\">              <span class=\"attr\">class</span>=<span class=\"string\">\"use-text\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">use</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">g</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.use-text</span><span class=\"selector-pseudo\">:nth-child(1)</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">stroke</span>: <span class=\"number\">#360745</span>;</span><br><span class=\"line\">      <span class=\"attribute\">animation</span>: animation1 <span class=\"number\">8s</span> infinite ease-in-out forwards;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">          </span><br><span class=\"line\"><span class=\"selector-class\">.use-text</span><span class=\"selector-pseudo\">:nth-child(2)</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">stroke</span>: <span class=\"number\">#D61C59</span>;</span><br><span class=\"line\">      <span class=\"attribute\">animation</span>: animation2 <span class=\"number\">8s</span> infinite ease-in-out forwards;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">          </span><br><span class=\"line\"><span class=\"selector-class\">.use-text</span><span class=\"selector-pseudo\">:nth-child(3)</span> &#123;</span><br><span class=\"line\">       <span class=\"attribute\">stroke</span>: <span class=\"number\">#E7D84B</span>;</span><br><span class=\"line\">       <span class=\"attribute\">animation</span>: animation3 <span class=\"number\">8s</span> infinite ease-in-out forwards;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.use-text</span><span class=\"selector-pseudo\">:nth-child(4)</span> &#123;</span><br><span class=\"line\">       <span class=\"attribute\">stroke</span>: <span class=\"number\">#EFEAC5</span>;</span><br><span class=\"line\">       <span class=\"attribute\">animation</span>: animation4 <span class=\"number\">8s</span> infinite ease-in-out forwards;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.use-text</span><span class=\"selector-pseudo\">:nth-child(5)</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">stroke</span>: <span class=\"number\">#1B8798</span>;</span><br><span class=\"line\">      <span class=\"attribute\">animation</span>: animation5 <span class=\"number\">8s</span> infinite ease-in-out forwards;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@<span class=\"keyword\">keyframes</span> animation1 &#123;</span><br><span class=\"line\">       50%&#123;</span><br><span class=\"line\">            <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">7%</span> <span class=\"number\">28%</span>;</span><br><span class=\"line\">            <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">7%</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       70%&#123;</span><br><span class=\"line\">             <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">7%</span> <span class=\"number\">28%</span>;</span><br><span class=\"line\">             <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">7%</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@<span class=\"keyword\">keyframes</span> animation2 &#123;</span><br><span class=\"line\">       50%&#123;</span><br><span class=\"line\">           <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">7%</span> <span class=\"number\">28%</span>;</span><br><span class=\"line\">           <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">14%</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       70%&#123;</span><br><span class=\"line\">            <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">7%</span> <span class=\"number\">28%</span>;</span><br><span class=\"line\">            <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">14%</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@<span class=\"keyword\">keyframes</span> animation3 &#123;</span><br><span class=\"line\">     50%&#123;</span><br><span class=\"line\">         <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">7%</span> <span class=\"number\">28%</span>;</span><br><span class=\"line\">         <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">21%</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    70%&#123;</span><br><span class=\"line\">         <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">7%</span> <span class=\"number\">28%</span>;</span><br><span class=\"line\">         <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">21%</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@<span class=\"keyword\">keyframes</span> animation4 &#123;</span><br><span class=\"line\">       50%&#123;</span><br><span class=\"line\">            <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">7%</span> <span class=\"number\">28%</span>;</span><br><span class=\"line\">            <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">28%</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       70%&#123;</span><br><span class=\"line\">            <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">7%</span> <span class=\"number\">28%</span>;</span><br><span class=\"line\">            <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">28%</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@<span class=\"keyword\">keyframes</span> animation5 &#123;</span><br><span class=\"line\">      50%&#123;</span><br><span class=\"line\">           <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">7%</span> <span class=\"number\">28%</span>;</span><br><span class=\"line\">           <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">35%</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      70%&#123;</span><br><span class=\"line\">           <span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">7%</span> <span class=\"number\">28%</span>;</span><br><span class=\"line\">           <span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">35%</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里用了5条完全重合的路径，并且每个路径的颜色和动画效果都不一样。</p>\n<p>效果：</p>\n<p><a href=\"https://qiniu.nihaoshijie.com.cn/qq.gif\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone size-full wp-image-682\" src=\"https://qiniu.nihaoshijie.com.cn/qq.gif\" alt=\"\" width=\"529\" height=\"338\"></a></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckx434pz300022wvjgpkjc70l","category_id":"ckx434pzc00062wvjq78xnvxh","_id":"ckx434pzq000g2wvjdfkraepk"},{"post_id":"ckx434pza00042wvjmjyg4krh","category_id":"ckx434pzk000b2wvjnviir5qh","_id":"ckx434pzu000m2wvjazagi7v3"},{"post_id":"ckx434pzf00082wvjen46uibo","category_id":"ckx434pzq000h2wvjeahh6g6j","_id":"ckx434pzy000r2wvjn92sqk8a"},{"post_id":"ckx434pzh00092wvjwb4zfqdv","category_id":"ckx434pzu000n2wvjduf44mor","_id":"ckx434q01000y2wvj4qo7d5qc"},{"post_id":"ckx434pzj000a2wvjgybmp15v","category_id":"ckx434pzy000s2wvjgcu8usje","_id":"ckx434q0500152wvju6metrfy"},{"post_id":"ckx434pzl000e2wvjeporgsya","category_id":"ckx434q0200102wvjh1uuywhy","_id":"ckx434q08001a2wvjjb5icqb9"},{"post_id":"ckx434pzp000f2wvj6o1ptt5f","category_id":"ckx434q0500162wvjpiic6vfz","_id":"ckx434q0b001h2wvjeheoy9ea"},{"post_id":"ckx434pzr000j2wvjaoxnevkx","category_id":"ckx434q08001b2wvj7q7ygyje","_id":"ckx434q0g001n2wvjb83kduzd"},{"post_id":"ckx434pzt000l2wvjok0mto2h","category_id":"ckx434q0b001i2wvj2fetaoz0","_id":"ckx434q0k001v2wvjzmghk1rs"},{"post_id":"ckx434pzv000p2wvj4inb4d3y","category_id":"ckx434q0h001q2wvjfjxc685o","_id":"ckx434q0n00212wvj025wgen2"},{"post_id":"ckx434pzx000q2wvjme4ood7a","category_id":"ckx434q0l001x2wvj0zwhy0hj","_id":"ckx434q0q00282wvj48334ll3"},{"post_id":"ckx434pzy000u2wvj47jofst0","category_id":"ckx434q0n00222wvj5p2suucp","_id":"ckx434q0t002d2wvjbl3inea9"},{"post_id":"ckx434q00000w2wvjxgpu292e","category_id":"ckx434q0q00292wvjktyfkdon","_id":"ckx434q0y002l2wvjwdctfy6p"},{"post_id":"ckx434q01000z2wvjl7hclgzm","category_id":"ckx434q0v002f2wvj15rodmh4","_id":"ckx434q11002r2wvjkhpdd9sn"},{"post_id":"ckx434q0300132wvj8g4f2apl","category_id":"ckx434q0y002m2wvjw2dc3um3","_id":"ckx434q13002x2wvjikimb7tm"},{"post_id":"ckx434q0400142wvj6tb0zszd","category_id":"ckx434q11002t2wvjleg1f5z3","_id":"ckx434q1600322wvjwqrivrpz"},{"post_id":"ckx434q0600182wvjmrg4wlz4","category_id":"ckx434q14002y2wvjv9kv9iec","_id":"ckx434q1c003b2wvj6ntaocxj"},{"post_id":"ckx434q0700192wvj3orp030v","category_id":"ckx434q1800352wvjh65vp6bh","_id":"ckx434q1f003g2wvjx4k6jwfh"},{"post_id":"ckx434q08001d2wvjux4387b4","category_id":"ckx434q1d003c2wvja2xhuhyf","_id":"ckx434q1i003n2wvjsu7byapt"},{"post_id":"ckx434q0a001f2wvjnjr6344m","category_id":"ckx434q1g003i2wvj4ywoxett","_id":"ckx434q1m003s2wvjzinn6a0b"},{"post_id":"ckx434q0c001k2wvjef5rrzv5","category_id":"ckx434q1j003o2wvjbnsm797o","_id":"ckx434q1v00402wvj3gfuec9u"},{"post_id":"ckx434q0f001m2wvjlbolvkng","category_id":"ckx434q1p003v2wvj4b4puxzc","_id":"ckx434q1y00452wvjodebfquk"},{"post_id":"ckx434q0g001p2wvjiojle814","category_id":"ckx434q1w00422wvjku664b2f","_id":"ckx434q1z00482wvjg3w57fj7"},{"post_id":"ckx434q0i001s2wvj3l2k6acm","category_id":"ckx434q1y00462wvjjx0wek6c","_id":"ckx434q20004e2wvjj2vte7hj"},{"post_id":"ckx434q0j001u2wvjkdpq9dcc","category_id":"ckx434q1z004a2wvjez72xxip","_id":"ckx434q21004h2wvj8sc6aczv"},{"post_id":"ckx434q0l001y2wvjng4ofx4a","category_id":"ckx434q20004f2wvjgtr0omq3","_id":"ckx434q22004l2wvjcc9sppxh"},{"post_id":"ckx434q0m001z2wvjjh28d2fy","category_id":"ckx434q21004i2wvjw4wcc11c","_id":"ckx434q23004p2wvj9okv61h6"},{"post_id":"ckx434q0o00242wvjnexjspv9","category_id":"ckx434q22004m2wvjeolw2k8g","_id":"ckx434q24004t2wvjo8nno9kv"},{"post_id":"ckx434q0p00262wvjadzse5kt","category_id":"ckx434q23004q2wvjj7ak79pt","_id":"ckx434q26004x2wvjwpfmibi2"},{"post_id":"ckx434q0r002a2wvjty9c4v1e","category_id":"ckx434q24004u2wvjo5nbd4mv","_id":"ckx434q2800512wvj31jhxyeu"},{"post_id":"ckx434q0s002b2wvjmdl85e6d","category_id":"ckx434q26004y2wvj7fvii35i","_id":"ckx434q2a00552wvjl6ql20q7"},{"post_id":"ckx434q0u002e2wvjwswk0vbb","category_id":"ckx434q2800522wvjnbm67y52","_id":"ckx434q2c00592wvjis18llxm"},{"post_id":"ckx434q0w002h2wvjzrf1pls4","category_id":"ckx434q2a00562wvj8pl5dbit","_id":"ckx434q2d005d2wvjkxd85fn3"},{"post_id":"ckx434q0x002k2wvj1bh5otoe","category_id":"ckx434q2c005b2wvji2pcl5ol","_id":"ckx434q2f005i2wvj6sw29hev"},{"post_id":"ckx434q0z002o2wvj9rvg8nmz","category_id":"ckx434q2d005e2wvjsl0pdrzg","_id":"ckx434q2k005m2wvj1of1n81s"},{"post_id":"ckx434q10002q2wvjcwza8vbr","category_id":"ckx434q2g005k2wvj0ze97qwq","_id":"ckx434q2p005r2wvjt3p68i7g"},{"post_id":"ckx434q11002u2wvjo86cuif1","category_id":"ckx434q2l005n2wvjb8twq255","_id":"ckx434q2q005u2wvjiv70r0ka"},{"post_id":"ckx434q13002w2wvjv8au5890","category_id":"ckx434q2p005s2wvjar6vbrbx","_id":"ckx434q2r005z2wvjkz5be34z"},{"post_id":"ckx434q14002z2wvjjjw2nqhz","category_id":"ckx434q2q005w2wvj4078ah5q","_id":"ckx434q2s00622wvjqaqpq0qo"},{"post_id":"ckx434q1500302wvjejg73dv3","category_id":"ckx434q2r00602wvjzel7uuti","_id":"ckx434q2t00672wvjcqy82rdt"},{"post_id":"ckx434q1700342wvj7d6prm6y","category_id":"ckx434q2s00642wvj5dn41ltw","_id":"ckx434q2u006a2wvj07z09ew9"},{"post_id":"ckx434q1800372wvj0h9uginj","category_id":"ckx434q2t00682wvj0hlkxwo3","_id":"ckx434q2v006f2wvjekyjw88u"},{"post_id":"ckx434q1b003a2wvj8eo2nm2c","category_id":"ckx434q2u006c2wvjq93jf5p2","_id":"ckx434q2w006j2wvjh36wv9ew"},{"post_id":"ckx434q1d003d2wvju43p6xwh","category_id":"ckx434q2v006h2wvj0f7c4495","_id":"ckx434q2x006o2wvj6dbu0yb7"},{"post_id":"ckx434q1f003f2wvj1g13n4og","category_id":"ckx434q2w006l2wvjkooa9ozl","_id":"ckx434q2y006r2wvjerb0xjdg"},{"post_id":"ckx434q1g003j2wvjw2f37bm8","category_id":"ckx434q2x006p2wvjgxt18mt9","_id":"ckx434q2z006v2wvjmoc2t38y"},{"post_id":"ckx434q1i003m2wvjnvyc7wuc","category_id":"ckx434q2y006s2wvjlnx8eqaq","_id":"ckx434q30006z2wvjnb385lzs"},{"post_id":"ckx434q1j003p2wvjuy38qt3l","category_id":"ckx434q2z006w2wvjutq86kzi","_id":"ckx434q3000732wvjg8wey9wv"},{"post_id":"ckx434q1k003q2wvjeenb2989","category_id":"ckx434q3000702wvjj10ljb6w","_id":"ckx434q3100782wvjn24jjye8"},{"post_id":"ckx434q1n003u2wvjdauh9oxg","category_id":"ckx434q3100742wvjptd9obpm","_id":"ckx434q32007b2wvj6w6g0bqu"},{"post_id":"ckx434q1s003x2wvjx13gxby8","category_id":"ckx434q3200792wvj8re9kohm","_id":"ckx434q33007f2wvjrsdoials"},{"post_id":"ckx434q1u003z2wvjpety2a7k","category_id":"ckx434q32007c2wvjp6me0zi3","_id":"ckx434q35007j2wvjt4num7vg"},{"post_id":"ckx434q1w00432wvjhq6fkkhs","category_id":"ckx434q33007g2wvj5rwlm02j","_id":"ckx434q36007m2wvj139nqv1w"}],"PostTag":[{"post_id":"ckx434pz300022wvjgpkjc70l","tag_id":"ckx434pze00072wvj1ppo96jq","_id":"ckx434pzl000d2wvjl24wxffv"},{"post_id":"ckx434pza00042wvjmjyg4krh","tag_id":"ckx434pzk000c2wvjfjn6drbd","_id":"ckx434pzt000k2wvjdunb9r4z"},{"post_id":"ckx434pzf00082wvjen46uibo","tag_id":"ckx434pzq000i2wvjdgbdjh32","_id":"ckx434pzz000v2wvjng5c0bap"},{"post_id":"ckx434pzf00082wvjen46uibo","tag_id":"ckx434pzv000o2wvjdkf7hkof","_id":"ckx434q01000x2wvjb30uo2sg"},{"post_id":"ckx434pzh00092wvjwb4zfqdv","tag_id":"ckx434pzy000t2wvj18goq9x2","_id":"ckx434q0300122wvjv31p1se5"},{"post_id":"ckx434pzj000a2wvjgybmp15v","tag_id":"ckx434q0200112wvjrvrhatmg","_id":"ckx434q09001e2wvjj9kb91mw"},{"post_id":"ckx434pzj000a2wvjgybmp15v","tag_id":"ckx434q0500172wvjycomb2o8","_id":"ckx434q0b001g2wvjfxcvkywe"},{"post_id":"ckx434q0700192wvj3orp030v","tag_id":"ckx434pzy000t2wvj18goq9x2","_id":"ckx434q0f001l2wvj4i9zaecb"},{"post_id":"ckx434pzl000e2wvjeporgsya","tag_id":"ckx434q08001c2wvjpcc8wm7u","_id":"ckx434q0i001r2wvj6spnm4gc"},{"post_id":"ckx434pzl000e2wvjeporgsya","tag_id":"ckx434q0500172wvjycomb2o8","_id":"ckx434q0j001t2wvj7vjspfw8"},{"post_id":"ckx434pzp000f2wvj6o1ptt5f","tag_id":"ckx434q0g001o2wvjtgjndh9j","_id":"ckx434q0o00232wvjihhe3y5z"},{"post_id":"ckx434pzp000f2wvj6o1ptt5f","tag_id":"ckx434q0500172wvjycomb2o8","_id":"ckx434q0p00252wvjhl34zbn0"},{"post_id":"ckx434pzr000j2wvjaoxnevkx","tag_id":"ckx434q0n00202wvjuu5i1p84","_id":"ckx434q0v002g2wvjwka02390"},{"post_id":"ckx434pzr000j2wvjaoxnevkx","tag_id":"ckx434q0q00272wvjtu6dvv4y","_id":"ckx434q0w002i2wvjagrw0o11"},{"post_id":"ckx434pzt000l2wvjok0mto2h","tag_id":"ckx434q0n00202wvjuu5i1p84","_id":"ckx434q0y002n2wvjpxzc9dq4"},{"post_id":"ckx434pzv000p2wvj4inb4d3y","tag_id":"ckx434q0n00202wvjuu5i1p84","_id":"ckx434q11002s2wvj8dnbr4je"},{"post_id":"ckx434pzx000q2wvjme4ood7a","tag_id":"ckx434q10002p2wvjcjo09w9d","_id":"ckx434q1600332wvjhuw1sa4x"},{"post_id":"ckx434pzx000q2wvjme4ood7a","tag_id":"ckx434q12002v2wvjnh8akzk4","_id":"ckx434q1800362wvjwkz3cwp6"},{"post_id":"ckx434q1500302wvjejg73dv3","tag_id":"ckx434q0q00272wvjtu6dvv4y","_id":"ckx434q1b00392wvjs2sjnivu"},{"post_id":"ckx434pzy000u2wvj47jofst0","tag_id":"ckx434q1600312wvj2vn8o9gc","_id":"ckx434q1g003h2wvjqqihzkyd"},{"post_id":"ckx434pzy000u2wvj47jofst0","tag_id":"ckx434q1a00382wvjtihhbgj0","_id":"ckx434q1h003k2wvj8p9p7ejx"},{"post_id":"ckx434q00000w2wvjxgpu292e","tag_id":"ckx434q1e003e2wvjz7fdp70j","_id":"ckx434q1n003t2wvjs0tq50vw"},{"post_id":"ckx434q00000w2wvjxgpu292e","tag_id":"ckx434q1h003l2wvjszw8e9ep","_id":"ckx434q1r003w2wvjx5zsb9bm"},{"post_id":"ckx434q01000z2wvjl7hclgzm","tag_id":"ckx434q1l003r2wvjq7n19ebl","_id":"ckx434q1v00412wvjjxhntsjl"},{"post_id":"ckx434q0300132wvj8g4f2apl","tag_id":"ckx434q1u003y2wvjlm3of0j1","_id":"ckx434q1z00492wvjp4ora9wd"},{"post_id":"ckx434q0300132wvj8g4f2apl","tag_id":"ckx434q1x00442wvjwe3dbu69","_id":"ckx434q1z004b2wvj5xw6wyiv"},{"post_id":"ckx434q0400142wvj6tb0zszd","tag_id":"ckx434q1u003y2wvjlm3of0j1","_id":"ckx434q20004d2wvjy46brzdv"},{"post_id":"ckx434q0600182wvjmrg4wlz4","tag_id":"ckx434q1u003y2wvjlm3of0j1","_id":"ckx434q22004k2wvjuzzxyeu6"},{"post_id":"ckx434q0600182wvjmrg4wlz4","tag_id":"ckx434q21004g2wvjin27nr7f","_id":"ckx434q22004n2wvj7lo0dsi4"},{"post_id":"ckx434q08001d2wvjux4387b4","tag_id":"ckx434q21004j2wvj8alphfbh","_id":"ckx434q24004s2wvjfdxbqsds"},{"post_id":"ckx434q08001d2wvjux4387b4","tag_id":"ckx434q23004o2wvj8lfiq42n","_id":"ckx434q24004v2wvj5tugof0a"},{"post_id":"ckx434q0a001f2wvjnjr6344m","tag_id":"ckx434q23004r2wvj7lwdd2ar","_id":"ckx434q2700502wvj15scdemk"},{"post_id":"ckx434q0a001f2wvjnjr6344m","tag_id":"ckx434q25004w2wvjucfn4276","_id":"ckx434q2900532wvjafx4qpmi"},{"post_id":"ckx434q0c001k2wvjef5rrzv5","tag_id":"ckx434q1e003e2wvjz7fdp70j","_id":"ckx434q2b00582wvj4hd9ln9n"},{"post_id":"ckx434q0c001k2wvjef5rrzv5","tag_id":"ckx434q1h003l2wvjszw8e9ep","_id":"ckx434q2c005a2wvj6jsz62nk"},{"post_id":"ckx434q0f001m2wvjlbolvkng","tag_id":"ckx434q1e003e2wvjz7fdp70j","_id":"ckx434q2e005g2wvj7kqkho6g"},{"post_id":"ckx434q0f001m2wvjlbolvkng","tag_id":"ckx434q2c005c2wvj2j5yhads","_id":"ckx434q2f005h2wvjzl4r8mmn"},{"post_id":"ckx434q0g001p2wvjiojle814","tag_id":"ckx434q1e003e2wvjz7fdp70j","_id":"ckx434q2m005o2wvj3lrke44t"},{"post_id":"ckx434q0g001p2wvjiojle814","tag_id":"ckx434q2c005c2wvj2j5yhads","_id":"ckx434q2m005p2wvjujwugjla"},{"post_id":"ckx434q0i001s2wvj3l2k6acm","tag_id":"ckx434q1e003e2wvjz7fdp70j","_id":"ckx434q2q005v2wvjjb7llmlp"},{"post_id":"ckx434q0i001s2wvj3l2k6acm","tag_id":"ckx434q2c005c2wvj2j5yhads","_id":"ckx434q2r005x2wvj4c894be7"},{"post_id":"ckx434q0j001u2wvjkdpq9dcc","tag_id":"ckx434q2q005t2wvjmgjyn40a","_id":"ckx434q2s00632wvjjdya3dzi"},{"post_id":"ckx434q0j001u2wvjkdpq9dcc","tag_id":"ckx434q2r005y2wvjqj7gdrw8","_id":"ckx434q2t00652wvjb7r6kdck"},{"post_id":"ckx434q0l001y2wvjng4ofx4a","tag_id":"ckx434q2s00612wvj2grnrnud","_id":"ckx434q2u006b2wvjl2udv56o"},{"post_id":"ckx434q0l001y2wvjng4ofx4a","tag_id":"ckx434q2t00662wvj58h364eu","_id":"ckx434q2u006d2wvjd0edi3q2"},{"post_id":"ckx434q0m001z2wvjjh28d2fy","tag_id":"ckx434q2u00692wvj3cwn7okm","_id":"ckx434q2v006g2wvjsr6jt5hu"},{"post_id":"ckx434q0o00242wvjnexjspv9","tag_id":"ckx434q2v006e2wvjh64q1ifx","_id":"ckx434q2w006k2wvja7dah4tz"},{"post_id":"ckx434q0p00262wvjadzse5kt","tag_id":"ckx434q2v006e2wvjh64q1ifx","_id":"ckx434q2x006n2wvjdt4c5on6"},{"post_id":"ckx434q0r002a2wvjty9c4v1e","tag_id":"ckx434q2x006m2wvjjkifou2q","_id":"ckx434q2z006u2wvjej7kpg7f"},{"post_id":"ckx434q0r002a2wvjty9c4v1e","tag_id":"ckx434q2y006q2wvjvm9mbpv7","_id":"ckx434q2z006x2wvjgpgoulwf"},{"post_id":"ckx434q0s002b2wvjmdl85e6d","tag_id":"ckx434q2y006t2wvjila14sya","_id":"ckx434q3000722wvjd0qx2o5u"},{"post_id":"ckx434q0s002b2wvjmdl85e6d","tag_id":"ckx434q2z006y2wvj7lpp8nws","_id":"ckx434q3100752wvjqd3ingt0"},{"post_id":"ckx434q0u002e2wvjwswk0vbb","tag_id":"ckx434q3000712wvjbv2sfmus","_id":"ckx434q3100772wvjobj8zxzg"},{"post_id":"ckx434q0w002h2wvjzrf1pls4","tag_id":"ckx434q3100762wvjrf71voyg","_id":"ckx434q33007e2wvj07487qt6"},{"post_id":"ckx434q0w002h2wvjzrf1pls4","tag_id":"ckx434q1a00382wvjtihhbgj0","_id":"ckx434q34007h2wvj6iwcbjqn"},{"post_id":"ckx434q0x002k2wvj1bh5otoe","tag_id":"ckx434q33007d2wvj7olvfe9t","_id":"ckx434q36007l2wvj5ba5m8ts"},{"post_id":"ckx434q0x002k2wvj1bh5otoe","tag_id":"ckx434q34007i2wvjb84nur7w","_id":"ckx434q36007n2wvj28jpt305"},{"post_id":"ckx434q0z002o2wvj9rvg8nmz","tag_id":"ckx434q33007d2wvj7olvfe9t","_id":"ckx434q38007q2wvjrg6vjkgs"},{"post_id":"ckx434q0z002o2wvj9rvg8nmz","tag_id":"ckx434q37007o2wvjrliu88u0","_id":"ckx434q38007r2wvjwvliin2u"},{"post_id":"ckx434q10002q2wvjcwza8vbr","tag_id":"ckx434q33007d2wvj7olvfe9t","_id":"ckx434q39007u2wvj30c2lmlt"},{"post_id":"ckx434q10002q2wvjcwza8vbr","tag_id":"ckx434q38007s2wvjp789hiy1","_id":"ckx434q39007v2wvj09qdnk6g"},{"post_id":"ckx434q11002u2wvjo86cuif1","tag_id":"ckx434q33007d2wvj7olvfe9t","_id":"ckx434q3a007y2wvja7848fe7"},{"post_id":"ckx434q11002u2wvjo86cuif1","tag_id":"ckx434q39007w2wvjxtnqtg1x","_id":"ckx434q3a007z2wvjqdiwqtqs"},{"post_id":"ckx434q13002w2wvjv8au5890","tag_id":"ckx434q33007d2wvj7olvfe9t","_id":"ckx434q3b00822wvjigew07w9"},{"post_id":"ckx434q13002w2wvjv8au5890","tag_id":"ckx434q3a00802wvjfec730vc","_id":"ckx434q3b00832wvjzhkvojja"},{"post_id":"ckx434q14002z2wvjjjw2nqhz","tag_id":"ckx434q3a00812wvjm5q8z0l9","_id":"ckx434q3b00852wvjww1vov7b"},{"post_id":"ckx434q1700342wvj7d6prm6y","tag_id":"ckx434q3b00842wvjql7pdesu","_id":"ckx434q3i00892wvjsr89njda"},{"post_id":"ckx434q1700342wvj7d6prm6y","tag_id":"ckx434q3b00862wvjmor4ohfp","_id":"ckx434q3i008a2wvjqryqdvxt"},{"post_id":"ckx434q1700342wvj7d6prm6y","tag_id":"ckx434q3c00872wvjhnnus23r","_id":"ckx434q3j008c2wvjqb8r3ysk"},{"post_id":"ckx434q1800372wvj0h9uginj","tag_id":"ckx434q3c00882wvjn7p9kv8l","_id":"ckx434q3j008d2wvj0jmrtvti"},{"post_id":"ckx434q1b003a2wvj8eo2nm2c","tag_id":"ckx434q3i008b2wvj6yi9wx08","_id":"ckx434q3k008f2wvjv5ibg71c"},{"post_id":"ckx434q1d003d2wvju43p6xwh","tag_id":"ckx434q3b00862wvjmor4ohfp","_id":"ckx434q3m008i2wvjckbpovne"},{"post_id":"ckx434q1d003d2wvju43p6xwh","tag_id":"ckx434q3k008g2wvj8rwps33m","_id":"ckx434q3m008j2wvjt6zmivtl"},{"post_id":"ckx434q1f003f2wvj1g13n4og","tag_id":"ckx434q3l008h2wvj4gc358wd","_id":"ckx434q3o008n2wvjoa3jwd4u"},{"post_id":"ckx434q1f003f2wvj1g13n4og","tag_id":"ckx434q3m008k2wvj1jc5lzvx","_id":"ckx434q3p008o2wvjju0ixb1x"},{"post_id":"ckx434q1f003f2wvj1g13n4og","tag_id":"ckx434q3n008l2wvjthqdbkhl","_id":"ckx434q3p008q2wvjwfbq8bwt"},{"post_id":"ckx434q1g003j2wvjw2f37bm8","tag_id":"ckx434q2y006t2wvjila14sya","_id":"ckx434q3q008s2wvjbkow87nq"},{"post_id":"ckx434q1g003j2wvjw2f37bm8","tag_id":"ckx434q3p008p2wvjdyg47a1r","_id":"ckx434q3q008t2wvjk7t22lkr"},{"post_id":"ckx434q1i003m2wvjnvyc7wuc","tag_id":"ckx434q2y006t2wvjila14sya","_id":"ckx434q3s008w2wvjuawpvabt"},{"post_id":"ckx434q1i003m2wvjnvyc7wuc","tag_id":"ckx434q3q008u2wvj9nxb81qr","_id":"ckx434q3s008x2wvj8rp3s80g"},{"post_id":"ckx434q1j003p2wvjuy38qt3l","tag_id":"ckx434q3s008v2wvjk7rti70b","_id":"ckx434q3t008z2wvjge89k4vr"},{"post_id":"ckx434q1k003q2wvjeenb2989","tag_id":"ckx434q3t008y2wvjiaykvm23","_id":"ckx434q3u00922wvjg5n6ftgl"},{"post_id":"ckx434q1k003q2wvjeenb2989","tag_id":"ckx434q3t00902wvjtgwtuxvp","_id":"ckx434q3u00932wvjgc8zoh57"},{"post_id":"ckx434q1n003u2wvjdauh9oxg","tag_id":"ckx434q2y006t2wvjila14sya","_id":"ckx434q3v00962wvj82q66t5b"},{"post_id":"ckx434q1n003u2wvjdauh9oxg","tag_id":"ckx434q3u00942wvj5diedchx","_id":"ckx434q3w00972wvjzydbda3e"},{"post_id":"ckx434q1s003x2wvjx13gxby8","tag_id":"ckx434q2y006t2wvjila14sya","_id":"ckx434q3w00992wvjeksnqkyn"},{"post_id":"ckx434q1s003x2wvjx13gxby8","tag_id":"ckx434q0500172wvjycomb2o8","_id":"ckx434q3w009a2wvj712apogc"},{"post_id":"ckx434q1u003z2wvjpety2a7k","tag_id":"ckx434q2y006t2wvjila14sya","_id":"ckx434q3x009d2wvjisme7jai"},{"post_id":"ckx434q1u003z2wvjpety2a7k","tag_id":"ckx434q2z006y2wvj7lpp8nws","_id":"ckx434q3y009e2wvjf88bivzb"},{"post_id":"ckx434q1w00432wvjhq6fkkhs","tag_id":"ckx434q3x009c2wvjy3ptzsdj","_id":"ckx434q3y009f2wvjpvfsijc8"}],"Tag":[{"name":"Angular","_id":"ckx434pze00072wvj1ppo96jq"},{"name":"HTML5游戏","_id":"ckx434pzk000c2wvjfjn6drbd"},{"name":"canvas","_id":"ckx434pzq000i2wvjdgbdjh32"},{"name":"点赞","_id":"ckx434pzv000o2wvjdkf7hkof"},{"name":"chrome插件","_id":"ckx434pzy000t2wvj18goq9x2"},{"name":"手势解锁","_id":"ckx434q0200112wvjrvrhatmg"},{"name":"HTML5","_id":"ckx434q0500172wvjycomb2o8"},{"name":"视频直播","_id":"ckx434q08001c2wvjpcc8wm7u"},{"name":"离线存储","_id":"ckx434q0g001o2wvjtgjndh9j"},{"name":"http2","_id":"ckx434q0n00202wvjuu5i1p84"},{"name":"https","_id":"ckx434q0q00272wvjtu6dvv4y"},{"name":"javascript","_id":"ckx434q10002p2wvjcjo09w9d"},{"name":"面试","_id":"ckx434q12002v2wvjnh8akzk4"},{"name":"PWA","_id":"ckx434q1600312wvj2vn8o9gc"},{"name":"前端","_id":"ckx434q1a00382wvjtihhbgj0"},{"name":"Vue3","_id":"ckx434q1e003e2wvjz7fdp70j"},{"name":"Vue.js","_id":"ckx434q1h003l2wvjszw8e9ep"},{"name":"react16 升级","_id":"ckx434q1l003r2wvjq7n19ebl"},{"name":"React Native","_id":"ckx434q1u003y2wvjlm3of0j1"},{"name":"android","_id":"ckx434q1x00442wvjwe3dbu69"},{"name":"下拉刷新","_id":"ckx434q21004g2wvjin27nr7f"},{"name":"vue3","_id":"ckx434q21004j2wvj8alphfbh"},{"name":"Composition API","_id":"ckx434q23004o2wvj8lfiq42n"},{"name":"Vite","_id":"ckx434q23004r2wvj7lwdd2ar"},{"name":"Vue Cli","_id":"ckx434q25004w2wvjucfn4276"},{"name":"源码解析","_id":"ckx434q2c005c2wvj2j5yhads"},{"name":"Vue","_id":"ckx434q2q005t2wvjmgjyn40a"},{"name":"B端系统","_id":"ckx434q2r005y2wvjqj7gdrw8"},{"name":"webpack2","_id":"ckx434q2s00612wvj2grnrnud"},{"name":"升级","_id":"ckx434q2t00662wvj58h364eu"},{"name":"ios","_id":"ckx434q2u00692wvj3cwn7okm"},{"name":"requirejs","_id":"ckx434q2v006e2wvjh64q1ifx"},{"name":"css动画","_id":"ckx434q2x006m2wvjjkifou2q"},{"name":"全屏滚动","_id":"ckx434q2y006q2wvjvm9mbpv7"},{"name":"移动web","_id":"ckx434q2y006t2wvjila14sya"},{"name":"性能优化","_id":"ckx434q2z006y2wvj7lpp8nws"},{"name":"浏览器","_id":"ckx434q3000712wvjbv2sfmus"},{"name":"架构师","_id":"ckx434q3100762wvjrf71voyg"},{"name":"算法","_id":"ckx434q33007d2wvj7olvfe9t"},{"name":"二叉树遍历","_id":"ckx434q34007i2wvjb84nur7w"},{"name":"回文串","_id":"ckx434q37007o2wvjrliu88u0"},{"name":"滑动窗口","_id":"ckx434q38007s2wvjp789hiy1"},{"name":"背包问题","_id":"ckx434q39007w2wvjxtnqtg1x"},{"name":"迷宫问题","_id":"ckx434q3a00802wvjfec730vc"},{"name":"专栏","_id":"ckx434q3a00812wvjm5q8z0l9"},{"name":"博客搬家","_id":"ckx434q3b00842wvjql7pdesu"},{"name":"hexo","_id":"ckx434q3b00862wvjmor4ohfp"},{"name":"wordpress","_id":"ckx434q3c00872wvjhnnus23r"},{"name":"微前端","_id":"ckx434q3c00882wvjn7p9kv8l"},{"name":"数据结构","_id":"ckx434q3i008b2wvj6yi9wx08"},{"name":"bdshare","_id":"ckx434q3k008g2wvj8rwps33m"},{"name":"react","_id":"ckx434q3l008h2wvj4gc358wd"},{"name":"react全家桶","_id":"ckx434q3m008k2wvj1jc5lzvx"},{"name":"配置指南","_id":"ckx434q3n008l2wvjthqdbkhl"},{"name":"滚动","_id":"ckx434q3p008p2wvjdyg47a1r"},{"name":"React全家桶","_id":"ckx434q3q008u2wvj9nxb81qr"},{"name":"工具","_id":"ckx434q3s008v2wvjk7rti70b"},{"name":"移动web适配","_id":"ckx434q3t008y2wvjiaykvm23"},{"name":"vmin","_id":"ckx434q3t00902wvjtgwtuxvp"},{"name":"rem","_id":"ckx434q3u00942wvj5diedchx"},{"name":"svg","_id":"ckx434q3x009c2wvjy3ptzsdj"}]}}